Index: include/iup.h
===================================================================
--- include/iup.h	(revision 5971)
+++ include/iup.h	(working copy)
@@ -256,6 +256,8 @@
 IUP_API Ihandle*  IupMultiLine  (const char* action);
 IUP_API Ihandle*  IupToggle     (const char* title, const char* action);
 IUP_API Ihandle*  IupTimer      (void);
+IUP_API Ihandle*  IupTray       (void);
+IUP_API Ihandle*  IupNotify     (void);
 IUP_API Ihandle*  IupClipboard  (void);
 IUP_API Ihandle*  IupProgressBar(void);
 IUP_API Ihandle*  IupVal        (const char *type);
@@ -266,10 +268,12 @@
 IUP_API Ihandle*  IupFlatTabs   (Ihandle* first, ...);
 IUP_API Ihandle*  IupFlatTabsv  (Ihandle* *children);
 IUP_API Ihandle*  IupTree       (void);
+IUP_API Ihandle*  IupTable      (void);
 IUP_API Ihandle*  IupLink       (const char* url, const char* title);
 IUP_API Ihandle*  IupAnimatedLabel(Ihandle* animation);
 IUP_API Ihandle*  IupDatePick   (void);
 IUP_API Ihandle*  IupCalendar   (void);
+IUP_API Ihandle*  IupPopover    (Ihandle* child);
 IUP_API Ihandle*  IupColorbar   (void);
 IUP_API Ihandle*  IupGauge      (void);
 IUP_API Ihandle*  IupDial       (const char* type);
Index: include/iup_varg.h
===================================================================
--- include/iup_varg.h	(revision 5971)
+++ include/iup_varg.h	(working copy)
@@ -48,5 +48,8 @@
 IUP_GLCONTROLS_API Ihandle*  IupGLCanvasBoxV(Ihandle* child, va_list arglist);
 #endif
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif
Index: include/iupcbs.h
===================================================================
--- include/iupcbs.h	(revision 5971)
+++ include/iupcbs.h	(working copy)
@@ -47,6 +47,7 @@
 typedef int (*IFnis)(Ihandle*, int, char *);  /* text_action, multiline_action, edit_cb, rename_cb */
 typedef int (*IFnsii)(Ihandle*, char*, int, int);  /* list_action */
 typedef int (*IFniis)(Ihandle*, int, int, char*);  /* motion_cb, click_cb, value_edit_cb */
+typedef int (*IFniisi)(Ihandle*, int, int, char*, int);  /* editend_cb */
 typedef int (*IFniiis)(Ihandle*, int, int, int, char*);  /* touch_cb, dblclick_cb */
 typedef int (*IFniiiis)(Ihandle*, int, int, int, int, char*);  /* button_cb, matrix_action, mousemotion_cb */
 typedef int (*IFniiiiiis)(Ihandle*, int, int, int, int, int, int, char*);  /* mouseclick_cb */
Index: include/iupdraw.h
===================================================================
--- include/iupdraw.h	(revision 5971)
+++ include/iupdraw.h	(working copy)
@@ -19,6 +19,7 @@
 /* all functions can be called only between calls to Begin and End */
 
 IUP_API void IupDrawSetClipRect(Ihandle* ih, int x1, int y1, int x2, int y2);
+IUP_API void IupDrawSetClipRoundedRect(Ihandle* ih, int x1, int y1, int x2, int y2, int corner_radius);
 IUP_API void IupDrawGetClipRect(Ihandle* ih, int *x1, int *y1, int *x2, int *y2);
 IUP_API void IupDrawResetClip(Ihandle* ih);
 
@@ -28,8 +29,18 @@
 IUP_API void IupDrawParentBackground(Ihandle* ih);
 IUP_API void IupDrawLine(Ihandle* ih, int x1, int y1, int x2, int y2);
 IUP_API void IupDrawRectangle(Ihandle* ih, int x1, int y1, int x2, int y2);
+IUP_API void IupDrawRoundedRectangle(Ihandle* ih, int x1, int y1, int x2, int y2, int corner_radius);
 IUP_API void IupDrawArc(Ihandle* ih, int x1, int y1, int x2, int y2, double a1, double a2);
+IUP_API void IupDrawEllipse(Ihandle* ih, int x1, int y1, int x2, int y2);
 IUP_API void IupDrawPolygon(Ihandle* ih, int* points, int count);
+IUP_API void IupDrawPixel(Ihandle* ih, int x, int y);
+IUP_API void IupDrawBezier(Ihandle* ih, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
+IUP_API void IupDrawQuadraticBezier(Ihandle* ih, int x1, int y1, int x2, int y2, int x3, int y3);
+
+/* gradient colors are passed as parameters (not controlled by DRAWCOLOR) */
+IUP_API void IupDrawLinearGradient(Ihandle* ih, int x1, int y1, int x2, int y2, float angle, const char* color1, const char* color2);
+IUP_API void IupDrawRadialGradient(Ihandle* ih, int cx, int cy, int radius, const char* colorCenter, const char* colorEdge);
+
 IUP_API void IupDrawText(Ihandle* ih, const char* text, int len, int x, int y, int w, int h);
 IUP_API void IupDrawImage(Ihandle* ih, const char* name, int x, int y, int w, int h);
 IUP_API void IupDrawSelectRect(Ihandle* ih, int x1, int y1, int x2, int y2);
Index: src/cocoa/IupCocoaTreeToggleTableCellView.h
===================================================================
--- src/cocoa/IupCocoaTreeToggleTableCellView.h	(revision 5971)
+++ src/cocoa/IupCocoaTreeToggleTableCellView.h	(working copy)
@@ -3,11 +3,9 @@
 
 #import <Cocoa/Cocoa.h>
 
+
 @interface IupCocoaTreeToggleTableCellView : NSTableCellView
-
-@property(assign, nonatomic) IBOutlet NSButton* checkBox;
-
+@property(retain, nonatomic) IBOutlet NSButton* checkBox;
 @end
 
-#endif
-
+#endif
\ No newline at end of file
Index: src/cocoa/IupCocoaTreeToggleTableCellView.m
===================================================================
--- src/cocoa/IupCocoaTreeToggleTableCellView.m	(revision 5971)
+++ src/cocoa/IupCocoaTreeToggleTableCellView.m	(working copy)
@@ -1,11 +1,85 @@
-
 #import <Cocoa/Cocoa.h>
-
 #import "IupCocoaTreeToggleTableCellView.h"
 
+
 @implementation IupCocoaTreeToggleTableCellView
 
+@synthesize checkBox = _checkBox;
 
-@end
+- (instancetype)initWithFrame:(NSRect)frameRect
+{
+  self = [super initWithFrame:frameRect];
+  if (self)
+  {
+    /* Create the checkbox. */
+    /* We use the setter to ensure it is properly retained. */
+    self.checkBox = [[[NSButton alloc] initWithFrame:NSZeroRect] autorelease];
+    [self.checkBox setButtonType:NSButtonTypeSwitch];
+    [self.checkBox setTitle:@""]; /* A checkbox shouldn't have a title of its own */
+    [self.checkBox setTranslatesAutoresizingMaskIntoConstraints:NO];
+    [self addSubview:self.checkBox];
 
+    /* The superclass (NSTableCellView) has imageView and textField properties. */
+    /* We must create them ourselves when not using a XIB. */
+    self.imageView = [[[NSImageView alloc] initWithFrame:NSZeroRect] autorelease];
+    [self.imageView setTranslatesAutoresizingMaskIntoConstraints:NO];
+    [self addSubview:self.imageView];
 
+    self.textField = [[[NSTextField alloc] initWithFrame:NSZeroRect] autorelease];
+    [self.textField setTranslatesAutoresizingMaskIntoConstraints:NO];
+    [self.textField setBezeled:NO];
+    [self.textField setDrawsBackground:NO];
+    [self.textField setEditable:NO];
+    [self.textField setSelectable:NO];
+    [self addSubview:self.textField];
+
+    /* Set up Auto Layout constraints */
+    NSDictionary* views = @{
+      @"checkBox": self.checkBox,
+     @"imageView": self.imageView,
+     @"textField": self.textField
+    };
+
+         /* Horizontal constraints: Arrange checkbox, image, and text from left to right. */
+         [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-2-[checkBox]-5-[imageView]-5-[textField]-2-|"
+                      options:0
+                      metrics:nil
+                        views:views]];
+
+             /* Vertical constraints: Center all subviews vertically within the cell. */
+             [self addConstraint:[NSLayoutConstraint constraintWithItem:self.checkBox
+                       attribute:NSLayoutAttributeCenterY
+                       relatedBy:NSLayoutRelationEqual
+                          toItem:self
+                       attribute:NSLayoutAttributeCenterY
+                      multiplier:1.0
+                        constant:0]];
+
+             [self addConstraint:[NSLayoutConstraint constraintWithItem:self.imageView
+                       attribute:NSLayoutAttributeCenterY
+                       relatedBy:NSLayoutRelationEqual
+                          toItem:self
+                       attribute:NSLayoutAttributeCenterY
+                      multiplier:1.0
+                        constant:0]];
+
+             [self addConstraint:[NSLayoutConstraint constraintWithItem:self.textField
+                       attribute:NSLayoutAttributeCenterY
+                       relatedBy:NSLayoutRelationEqual
+                          toItem:self
+                       attribute:NSLayoutAttributeCenterY
+                      multiplier:1.0
+                        constant:0]];
+  }
+  return self;
+}
+
+- (void)dealloc
+{
+  /* Release the retained checkBox property */
+  [_checkBox release];
+  _checkBox = nil;
+  [super dealloc];
+}
+
+@end
Index: src/cocoa/iupcocoa_button.m
===================================================================
--- src/cocoa/iupcocoa_button.m	(revision 5971)
+++ src/cocoa/iupcocoa_button.m	(working copy)
@@ -28,368 +28,995 @@
 #include "iup_key.h"
 
 #include "iupcocoa_drv.h"
+#include "iupcocoa_keycodes.h"
 
-static const CGFloat kIupCocoaDefaultWidthNSButton = 1.0;
-static const CGFloat kIupCocoaDefaultHeightNSButton = 32.0;
+static const void* IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY = @"IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY";
 
-// the point of this is we have a unique memory address for an identifier
-static const void* IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY = "IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY";
+@interface IupCocoaFlatButton : NSButton
+@property (nonatomic, assign) BOOL isFlat;
+@property (nonatomic, assign) BOOL isHovering;
+@end
 
+@implementation IupCocoaFlatButton
 
-@interface IupCocoaButtonReceiver : NSObject
-- (IBAction) myButtonClickAction:(id)the_sender;
-@end
+- (void)updateTrackingAreas
+{
+  [super updateTrackingAreas];
 
-@implementation IupCocoaButtonReceiver
+  for (NSTrackingArea *area in [self trackingAreas])
+  {
+    [self removeTrackingArea:area];
+  }
 
-/*
-- (void) dealloc
+  NSTrackingArea *trackingArea = [[NSTrackingArea alloc]
+    initWithRect:[self bounds]
+         options:(NSTrackingMouseEnteredAndExited | NSTrackingMouseMoved |
+                  NSTrackingActiveInKeyWindow | NSTrackingInVisibleRect)
+           owner:self
+        userInfo:nil];
+
+  [self addTrackingArea:trackingArea];
+  [trackingArea release];
+}
+
+- (void)mouseEntered:(NSEvent *)event
 {
-	[super dealloc];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
+
+  if (self.isFlat && !self.isHovering && [self isEnabled])
+  {
+    self.isHovering = YES;
+    [self setBordered:YES];
+    [self setNeedsDisplay:YES];
+  }
+
+  IFn cb = (IFn)IupGetCallback(ih, "ENTERWINDOW_CB");
+  if (cb)
+  {
+    if (cb(ih) == IUP_CLOSE)
+      IupExitLoop();
+  }
 }
-*/
 
+- (void)mouseExited:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
-- (IBAction) myButtonClickAction:(id)the_sender;
+  if (self.isFlat && self.isHovering)
+  {
+    self.isHovering = NO;
+    [self setBordered:NO];
+    [self setNeedsDisplay:YES];
+  }
+
+  IFn cb = (IFn)IupGetCallback(ih, "LEAVEWINDOW_CB");
+  if (cb)
+  {
+    if (cb(ih) == IUP_CLOSE)
+      IupExitLoop();
+  }
+}
+
+- (void)mouseMoved:(NSEvent *)event
 {
-	Icallback callback_function;
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+  [super mouseMoved:event];
 
-	// CONFLICT: Cocoa buttons don't normally do anything for non-primary click. (Second click is supposed to trigger the contextual menu.)
-	// Also Cocoa doesn't normall give callbacks for both down and up
-	/*
-	callback_function = IupGetCallback(ih, "BUTTON_CB");
-	if(callback_function)
-	{
-		if(callback_function(ih) == IUP_CLOSE)
-		{
-			IupExitLoop();
-		}
-		
-	}
-	 */
-	
-	callback_function = IupGetCallback(ih, "ACTION");
-	if(callback_function)
-	{
-		if(callback_function(ih) == IUP_CLOSE)
-		{
-			IupExitLoop();
-		}
-	}
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaCommonBaseHandleMouseMotionCallback(ih, event, self);
 }
 
+- (void)mouseDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaCommonBaseHandleMouseButtonCallback(ih, event, self, true);
+
+  [self highlight:YES];
+
+  BOOL keepTracking = YES;
+  BOOL mouseIsInside = YES;
+  NSPoint currentLocation;
+
+  while (keepTracking)
+  {
+    NSEvent* nextEvent = [[self window] nextEventMatchingMask:(NSEventMaskLeftMouseUp | NSEventMaskLeftMouseDragged)];
+
+    switch ([nextEvent type])
+    {
+      case NSEventTypeLeftMouseDragged:
+        currentLocation = [self convertPoint:[nextEvent locationInWindow] fromView:nil];
+        mouseIsInside = [self mouse:currentLocation inRect:[self bounds]];
+        [self highlight:mouseIsInside];
+        break;
+
+      case NSEventTypeLeftMouseUp:
+        currentLocation = [self convertPoint:[nextEvent locationInWindow] fromView:nil];
+        mouseIsInside = [self mouse:currentLocation inRect:[self bounds]];
+
+        [self highlight:NO];
+
+        if (ih)
+          iupcocoaCommonBaseHandleMouseButtonCallback(ih, nextEvent, self, false);
+
+        if (mouseIsInside)
+          [self performClick:self];
+
+        keepTracking = NO;
+        break;
+
+      default:
+        break;
+    }
+  }
+}
+
+- (void)mouseUp:(NSEvent *)event
+{
+  /* This method is kept for right and other mouse buttons which don't use custom tracking */
+  [super mouseUp:event];
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaCommonBaseHandleMouseButtonCallback(ih, event, self, false);
+}
+
+- (void)rightMouseDown:(NSEvent *)event
+{
+  [super rightMouseDown:event];
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaCommonBaseHandleMouseButtonCallback(ih, event, self, true);
+}
+
+- (void)rightMouseUp:(NSEvent *)event
+{
+  [super rightMouseUp:event];
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaCommonBaseHandleMouseButtonCallback(ih, event, self, false);
+}
+
+- (void)otherMouseDown:(NSEvent *)event
+{
+  [super otherMouseDown:event];
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaCommonBaseHandleMouseButtonCallback(ih, event, self, true);
+}
+
+- (void)otherMouseUp:(NSEvent *)event
+{
+  [super otherMouseUp:event];
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaCommonBaseHandleMouseButtonCallback(ih, event, self, false);
+}
+
+- (void)scrollWheel:(NSEvent *)event
+{
+  [super scrollWheel:event];
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    if (!iupcocoaCommonBaseScrollWheelCallback(ih, event, self))
+      [super scrollWheel:event];
+  }
+}
+
+- (void)keyDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+
+    /* Enter activates the button when it has focus */
+    if (mac_key_code == kVK_Return)
+    {
+      [self performClick:nil];
+      return;
+    }
+
+    if (!iupcocoaKeyEvent(ih, event, mac_key_code, true))
+      [super keyDown:event];
+  }
+  else
+    [super keyDown:event];
+}
+
+- (void)keyUp:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaKeyEvent(ih, event, mac_key_code, false))
+      [super keyUp:event];
+  }
+  else
+    [super keyUp:event];
+}
+
+- (void)flagsChanged:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaModifierEvent(ih, event, mac_key_code))
+      [super flagsChanged:event];
+  }
+  else
+    [super flagsChanged:event];
+}
+
+- (BOOL)becomeFirstResponder
+{
+  BOOL result = [super becomeFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusIn(ih);
+  }
+  return result;
+}
+
+- (BOOL)resignFirstResponder
+{
+  BOOL result = [super resignFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusOut(ih);
+  }
+  return result;
+}
+
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    if (iupAttribGet(ih, "_IUPCOCOA_CANFOCUS"))
+      return iupAttribGetBoolean(ih, "_IUPCOCOA_CANFOCUS");
+    return iupAttribGetBoolean(ih, "CANFOCUS");
+  }
+  return [super acceptsFirstResponder];
+}
+
+- (BOOL) needsPanelToBecomeKey
+{
+  return YES;
+}
+
 @end
 
 
+@interface IupCocoaButtonReceiver : NSObject
+   - (IBAction)myButtonClickAction:(id)the_sender;
+   @end
 
+   @implementation IupCocoaButtonReceiver
+
+   - (IBAction)myButtonClickAction:(id)the_sender
+{
+  Icallback callback_function;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  callback_function = IupGetCallback(ih, "ACTION");
+  if(callback_function)
+  {
+    if(callback_function(ih) == IUP_CLOSE)
+    {
+      IupExitLoop();
+    }
+  }
+}
+@end
+
+static void cocoaButtonMeasureBorders(Ihandle* ih, int has_image, int has_text, int img_position, int *border_x, int *border_y)
+{
+  NSButton* temp_button = [[NSButton alloc] initWithFrame:NSZeroRect];
+  [temp_button setBezelStyle:NSBezelStyleRegularSquare];
+  [temp_button setFont:[NSFont systemFontOfSize:0]];
+  [temp_button setBordered:YES];
+
+  if (has_image)
+  {
+    NSImage* temp_image = [[NSImage alloc] initWithSize:NSMakeSize(16, 16)];
+
+    if (has_text)
+    {
+      [temp_button setTitle:@"Test"];
+      [temp_button setImage:temp_image];
+
+      NSCellImagePosition position;
+      switch(img_position)
+      {
+        case IUP_IMGPOS_TOP:
+          position = NSImageAbove;
+          break;
+        case IUP_IMGPOS_BOTTOM:
+          position = NSImageBelow;
+          break;
+        case IUP_IMGPOS_RIGHT:
+          position = NSImageRight;
+          break;
+        case IUP_IMGPOS_LEFT:
+        default:
+          position = NSImageLeft;
+          break;
+      }
+      [temp_button setImagePosition:position];
+    }
+    else
+    {
+      [temp_button setImage:temp_image];
+      [temp_button setImagePosition:NSImageOnly];
+    }
+
+    [temp_image release];
+  }
+  else
+  {
+    [temp_button setTitle:@"WWWWWWWWWW"];
+    [temp_button setImagePosition:NSNoImage];
+  }
+
+  NSSize fitting_size = [temp_button fittingSize];
+  NSSize intrinsic_size = [temp_button intrinsicContentSize];
+
+  *border_x = (int)(fitting_size.width - intrinsic_size.width);
+  *border_y = (int)(fitting_size.height - intrinsic_size.height);
+
+  /* When intrinsic == fitting, calculate border using known content size */
+  if (*border_x == 0 && *border_y == 0)
+  {
+    if (has_image && has_text)
+    {
+      int iup_text_w = iupdrvFontGetStringWidth(ih, "Test");
+      int iup_text_h;
+      iupdrvFontGetCharSize(ih, NULL, &iup_text_h);
+      int content_w = 16 + 2 + iup_text_w;  /* image + spacing + text */
+      int content_h = (16 > iup_text_h) ? 16 : iup_text_h;
+
+      *border_x = (int)fitting_size.width - content_w;
+      *border_y = (int)fitting_size.height - content_h;
+    }
+    else if (!has_image)
+    {
+      int iup_text_w = iupdrvFontGetStringWidth(ih, "WWWWWWWWWW");
+      int iup_text_h;
+      iupdrvFontGetCharSize(ih, NULL, &iup_text_h);
+
+      *border_x = (int)fitting_size.width - iup_text_w;
+      *border_y = (int)fitting_size.height - iup_text_h;
+    }
+  }
+
+  if (*border_x < 0) *border_x = 0;
+  if (*border_y < 0) *border_y = 0;
+
+  [temp_button release];
+}
+
 void iupdrvButtonAddBorders(Ihandle* ih, int *x, int *y)
 {
-//	NSLog(@"iupdrvButtonAddBorders in <%d, %d>", *x, *y);
-	
-	
-	if(*y < (int)kIupCocoaDefaultHeightNSButton)
-	{
-		*y = (int)kIupCocoaDefaultHeightNSButton;
-//		*y = (int)22;
+  static int text_border_x = -1, text_border_y = -1;
+  static int image_border_x = -1, image_border_y = -1;
+  static int image_text_border_x = -1, image_text_border_y = -1;
 
-	}
-//	*x += 4; // a regular label seems to get 2 padding on each size
-//	*x += 36; // the difference between a label and push button is 36 in Interface Builder
+  int border_x = 0, border_y = 0;
+  int has_image = 0;
+  int has_text = 0;
+  int has_bgcolor = 0;
+  int img_position = IUP_IMGPOS_LEFT;
 
-	*x += 27;
-	
-	/*
-	NSView* the_view = (NSView*)ih->handle;
-	NSRect view_frame = [the_view frame];
-	*x = view_frame.size.width;
-	*y = view_frame.size.height;
-	
-	*/
-//	NSLog(@"iupdrvButtonAddBorders frame <%d, %d>", *x, *y);
+  if (ih)
+  {
+    char* image = iupAttribGet(ih, "IMAGE");
+    char* title = iupAttribGet(ih, "TITLE");
+    char* bgcolor = iupAttribGet(ih, "BGCOLOR");
+    has_image = (image != NULL);
+    has_text = (title != NULL && *title != 0);
+    has_bgcolor = (!has_image && !has_text && bgcolor != NULL);
+    img_position = ih->data->img_position;
+  }
 
+  if (has_bgcolor)
+  {
+    if (text_border_x == -1)
+      cocoaButtonMeasureBorders(ih, 0, 1, IUP_IMGPOS_LEFT, &text_border_x, &text_border_y);
+
+    border_x = text_border_x;
+    border_y = text_border_y;
+  }
+  else if (has_image && has_text)
+  {
+    if (image_text_border_x == -1)
+      cocoaButtonMeasureBorders(ih, 1, 1, img_position, &image_text_border_x, &image_text_border_y);
+
+    border_x = image_text_border_x;
+    border_y = image_text_border_y;
+  }
+  else if (has_image)
+  {
+    if (image_border_x == -1)
+      cocoaButtonMeasureBorders(ih, 1, 0, IUP_IMGPOS_LEFT, &image_border_x, &image_border_y);
+
+    border_x = image_border_x;
+    border_y = image_border_y;
+  }
+  else
+  {
+    if (text_border_x == -1)
+      cocoaButtonMeasureBorders(ih, 0, 1, IUP_IMGPOS_LEFT, &text_border_x, &text_border_y);
+
+    border_x = text_border_x;
+    border_y = text_border_y;
+  }
+
+  *x += border_x;
+  *y += border_y;
 }
 
 static int cocoaButtonSetTitleAttrib(Ihandle* ih, const char* value)
 {
-	id the_button = ih->handle;
+  NSButton* the_button = ih->handle;
 
-	if (ih->data->type & IUP_BUTTON_TEXT)  /* text or both */
-	{
-		if(value && *value!=0)
-		{
-			char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);   /* remove & */
-			
-			// This will return nil if the string can't be converted.
-			NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
-			
-			if(stripped_str && stripped_str != value)
-			{
-				free(stripped_str);
-			}
-			
-			[the_button setTitle:ns_string];
-			
-			if(ih->data->type & IUP_BUTTON_IMAGE)
-			{
-				// TODO: FEATURE: Cocoa allows text to be placed in different positions
-				// https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Button/Tasks/SettingButtonImage.html
-				[the_button setImagePosition:NSImageLeft];
-			}
-			else
-			{
-				//			[the_button setImagePosition:NSNoImage];
-				
-			}
-			
-			return 1;
-		}
-	}
-	
-	return 0;
+  if (ih->data->type & IUP_BUTTON_TEXT)
+  {
+    if(value && *value!=0)
+    {
+      char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);
+      NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
+
+      if(stripped_str && stripped_str != value)
+      {
+        free(stripped_str);
+      }
+
+      char* fgcolor = iupAttribGet(ih, "FGCOLOR");
+      unsigned char r, g, b;
+      if (fgcolor && iupStrToRGB(fgcolor, &r, &g, &b))
+      {
+        NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+        NSMutableAttributedString* attributed_title = [[NSMutableAttributedString alloc] initWithString:ns_string];
+        NSRange range = NSMakeRange(0, [attributed_title length]);
+        [attributed_title addAttribute:NSForegroundColorAttributeName value:color range:range];
+        [the_button setAttributedTitle:attributed_title];
+        [attributed_title release];
+      }
+      else
+      {
+        [the_button setTitle:ns_string];
+      }
+
+      /* Prevent text wrapping */
+      [[the_button cell] setLineBreakMode:NSLineBreakByClipping];
+
+      if(ih->data->type & IUP_BUTTON_IMAGE)
+      {
+        NSCellImagePosition position;
+        switch(ih->data->img_position)
+        {
+          case IUP_IMGPOS_TOP:
+            position = NSImageAbove;
+            break;
+          case IUP_IMGPOS_BOTTOM:
+            position = NSImageBelow;
+            break;
+          case IUP_IMGPOS_RIGHT:
+            position = NSImageRight;
+            break;
+          case IUP_IMGPOS_LEFT:
+          default:
+            position = NSImageLeft;
+            break;
+        }
+        [the_button setImagePosition:position];
+      }
+
+      if(ih->handle)
+      {
+        IupRefresh(ih);
+      }
+      return 1;
+    }
+  }
+
+  return 0;
 }
 
+static int cocoaButtonSetFontAttrib(Ihandle* ih, const char* value)
+{
+  if (!value)
+    return 0;
 
-// The reason we need a custom layout is because the button is being positioned too high compared to other widgets.
-// I think the reason is because the NSButton has both a lot of invisible padding (officially 32 high, but only about 22 visible)
-// and I think some of that padding is not completely centered.
-// So when putting a button next to a label or textfield, the button looks too high up compared to standard Cocoa/IB layout.
+  NSButton* the_button = ih->handle;
+  IupCocoaFont* font = iupcocoaFindFont(value);
+
+  if (font && font.nativeFont)
+  {
+    [the_button setFont:font.nativeFont];
+
+    if (ih->handle)
+      IupRefresh(ih);
+
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaButtonSetAlignmentAttrib(Ihandle* ih, const char* value)
+{
+  NSButton* the_button = ih->handle;
+  char value1[30], value2[30];
+  NSTextAlignment alignment = NSTextAlignmentCenter;
+
+  iupStrToStrStr(value, value1, value2, ':');
+
+  if (iupStrEqualNoCase(value1, "ARIGHT"))
+  {
+    alignment = NSTextAlignmentRight;
+    ih->data->horiz_alignment = IUP_ALIGN_ARIGHT;
+  }
+  else if (iupStrEqualNoCase(value1, "ALEFT"))
+  {
+    alignment = NSTextAlignmentLeft;
+    ih->data->horiz_alignment = IUP_ALIGN_ALEFT;
+  }
+  else /* ACENTER (default) */
+  {
+    alignment = NSTextAlignmentCenter;
+    ih->data->horiz_alignment = IUP_ALIGN_ACENTER;
+  }
+
+  [[the_button cell] setAlignment:alignment];
+
+  if (iupStrEqualNoCase(value2, "ABOTTOM"))
+    ih->data->vert_alignment = IUP_ALIGN_ABOTTOM;
+  else if (iupStrEqualNoCase(value2, "ATOP"))
+    ih->data->vert_alignment = IUP_ALIGN_ATOP;
+  else /* ACENTER (default) */
+    ih->data->vert_alignment = IUP_ALIGN_ACENTER;
+
+  return 1;
+}
+
+static char* cocoaButtonGetAlignmentAttrib(Ihandle* ih)
+{
+  char* horiz_align2str[3] = {"ALEFT", "ACENTER", "ARIGHT"};
+  char* vert_align2str[3] = {"ATOP", "ACENTER", "ABOTTOM"};
+
+  int horiz = ih->data->horiz_alignment;
+  int vert = ih->data->vert_alignment;
+
+  if (horiz < IUP_ALIGN_ALEFT || horiz > IUP_ALIGN_ARIGHT)
+    horiz = IUP_ALIGN_ACENTER;
+  if (vert < IUP_ALIGN_ATOP || vert > IUP_ALIGN_ABOTTOM)
+    vert = IUP_ALIGN_ACENTER;
+
+  return iupStrReturnStrf("%s:%s", horiz_align2str[horiz], vert_align2str[vert]);
+}
+
+static int cocoaButtonSetPaddingAttrib(Ihandle* ih, const char* value)
+{
+  NSButton* the_button = ih->handle;
+
+  if (iupStrEqual(value, "DEFAULTBUTTONPADDING"))
+    value = IupGetGlobal("DEFAULTBUTTONPADDING");
+
+  iupStrToIntInt(value, &ih->data->horiz_padding, &ih->data->vert_padding, 'x');
+
+  if (ih->handle)
+  {
+    /* Apply content insets if available (macOS 11.0+) */
+    if ([the_button respondsToSelector:@selector(setContentInsets:)])
+    {
+      NSEdgeInsets insets = NSEdgeInsetsMake(
+        ih->data->vert_padding,
+        ih->data->horiz_padding,
+        ih->data->vert_padding,
+        ih->data->horiz_padding
+      );
+
+      NSMethodSignature *signature = [NSButton instanceMethodSignatureForSelector:@selector(setContentInsets:)];
+      NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
+      [invocation setSelector:@selector(setContentInsets:)];
+      [invocation setTarget:the_button];
+      [invocation setArgument:&insets atIndex:2];
+      [invocation invoke];
+    }
+
+    IupRefresh(ih);
+    return 0;
+  }
+
+  return 1;
+}
+
+static int cocoaButtonSetBgColorAttrib(Ihandle* ih, const char* value)
+{
+  NSButton* the_button = ih->handle;
+  unsigned char r, g, b;
+
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
+
+  [the_button setWantsLayer:YES];
+  [[the_button layer] setBackgroundColor:[[NSColor colorWithCalibratedRed:r/255.0
+                                   green:g/255.0
+                                    blue:b/255.0
+                                   alpha:1.0] CGColor]];
+
+  return 1;
+}
+
+static int cocoaButtonSetFgColorAttrib(Ihandle* ih, const char* value)
+{
+  NSButton* the_button = ih->handle;
+  unsigned char r, g, b;
+
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
+
+  NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+  NSString* title = [the_button title];
+
+  if (title && [title length] > 0)
+  {
+    NSMutableAttributedString* attributed_title = [[NSMutableAttributedString alloc] initWithString:title];
+    NSRange range = NSMakeRange(0, [attributed_title length]);
+    [attributed_title addAttribute:NSForegroundColorAttributeName value:color range:range];
+    [the_button setAttributedTitle:attributed_title];
+    [attributed_title release];
+  }
+
+  return 1;
+}
+
+static int cocoaButtonSetImageAttrib(Ihandle* ih, const char* value)
+{
+  NSButton* the_button = ih->handle;
+
+  if (ih->data->type & IUP_BUTTON_IMAGE)
+  {
+    NSImage* the_bitmap;
+    int make_inactive = 0;
+
+    if (!iupAttribGetBoolean(ih, "ACTIVE"))
+      make_inactive = 1;
+
+    the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
+    [the_button setImage:the_bitmap];
+
+    if (ih->handle)
+    {
+      IupRefresh(ih);
+    }
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaButtonSetImInactiveAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->type & IUP_BUTTON_IMAGE)
+  {
+    if (!iupAttribGetBoolean(ih, "ACTIVE"))
+    {
+      NSButton* the_button = ih->handle;
+      NSImage* the_bitmap = iupImageGetImage(value, ih, 0, NULL);
+      [the_button setImage:the_bitmap];
+    }
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaButtonSetImpressAttrib(Ihandle* ih, const char* value)
+{
+  NSButton* the_button = ih->handle;
+
+  if (ih->data->type & IUP_BUTTON_IMAGE)
+  {
+    if (value && *value != 0)
+    {
+      int make_inactive = 0;
+      if (!iupAttribGetBoolean(ih, "ACTIVE"))
+        make_inactive = 1;
+
+      NSImage* the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
+      [the_button setAlternateImage:the_bitmap];
+    }
+    else
+    {
+      [the_button setAlternateImage:nil];
+    }
+
+    if (ih->handle)
+    {
+      IupRefresh(ih);
+    }
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaButtonSetActiveAttrib(Ihandle* ih, const char* value)
+{
+  NSButton* the_button = ih->handle;
+  int active = iupStrBoolean(value);
+
+  [the_button setEnabled:active];
+
+  if (ih->data->type & IUP_BUTTON_IMAGE)
+  {
+    char* image_name = iupAttribGet(ih, active ? "IMAGE" : "IMINACTIVE");
+    if (!image_name && !active)
+      image_name = iupAttribGet(ih, "IMAGE");
+
+    if (image_name)
+    {
+      int make_inactive = !active && !iupAttribGet(ih, "IMINACTIVE");
+      NSImage* the_bitmap = iupImageGetImage(image_name, ih, make_inactive, NULL);
+      [the_button setImage:the_bitmap];
+    }
+
+    char* impress_name = iupAttribGet(ih, "IMPRESS");
+    if (impress_name)
+    {
+      int make_inactive = !active;
+      NSImage* the_bitmap = iupImageGetImage(impress_name, ih, make_inactive, NULL);
+      [the_button setAlternateImage:the_bitmap];
+    }
+  }
+
+  return iupBaseSetActiveAttrib(ih, value);
+}
+
 void cocoaButtonLayoutUpdateMethod(Ihandle *ih)
 {
-	
-	NSView* parent_view = nil;
-	NSView* child_view = nil;
-	
-	parent_view = iupCocoaCommonBaseLayoutGetParentView(ih);
-	child_view = iupCocoaCommonBaseLayoutGetChildView(ih);
-	
-	NSRect parent_rect = [parent_view frame];
-	
-	NSRect child_rect = iupCocoaCommonBaseLayoutComputeChildFrameRectFromParentRect(ih, parent_rect);
+  NSView* parent_view = iupcocoaCommonBaseLayoutGetParentView(ih);
+  NSView* child_view = iupcocoaCommonBaseLayoutGetChildView(ih);
 
-	
-	// Experimentally, it looks like I just need to shift 1 pixel down to make it look right.
-	child_rect.origin.y = child_rect.origin.y - 1.0;
-	
-	
-	[child_view setFrame:child_rect];
-	
-	
-	
+  if (!parent_view || !child_view)
+  {
+    return;
+  }
+
+  NSRect parent_rect = [parent_view frame];
+  NSRect child_rect;
+
+  if ([parent_view isFlipped])
+  {
+    child_rect = NSMakeRect(
+        ih->x,
+        ih->y,
+        ih->currentwidth,
+        ih->currentheight
+    );
+  }
+  else
+  {
+    child_rect = NSMakeRect(
+        ih->x,
+        parent_rect.size.height - ih->y - ih->currentheight,
+        ih->currentwidth,
+        ih->currentheight
+    );
+  }
+
+  (void)child_view;
+
+  [child_view setFrame:NSIntegralRect(child_rect)];
 }
 
-
 static int cocoaButtonMapMethod(Ihandle* ih)
 {
-	char* value;
+  char* value;
+  NSButton* the_button;
+  int has_border = 1;
+  BOOL is_flat = iupAttribGetBoolean(ih, "FLAT");
 
-	/*
-	static int woffset = 0;
-	static int hoffset = 0;
-	
-	woffset += 30;
-	hoffset += 30;
-//	ih->data->type = 0;
-	
-	 NSButton* the_button = [[NSButton alloc] initWithFrame:NSMakeRect(woffset, hoffset, 0, 0)];
-	*/
-	NSButton* the_button = [[NSButton alloc] initWithFrame:NSZeroRect];
-	// I seem to be getting a default "Button" title for image button.
-	[the_button setTitle:@""];
-	
+  the_button = [[IupCocoaFlatButton alloc] initWithFrame:NSZeroRect];
+  [(IupCocoaFlatButton*)the_button setIsFlat:is_flat];
+  [(IupCocoaFlatButton*)the_button setIsHovering:NO];
 
-	value = iupAttribGet(ih, "IMAGE");
-	if(value)
-	{
-		ih->data->type = IUP_BUTTON_IMAGE;
-		
-		const char* title = iupAttribGet(ih, "TITLE");
-		if (title && *title!=0)
-		{
-			ih->data->type |= IUP_BUTTON_TEXT;
-			
-			
-			char* stripped_str = iupStrProcessMnemonic(title, NULL, 0);   /* remove & */
-			
-			// This will return nil if the string can't be converted.
-			NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
-			
-			if(stripped_str && stripped_str != title)
-			{
-				free(stripped_str);
-			}
-			
-			[the_button setTitle:ns_string];
+  [the_button setTitle:@""];
+  [the_button setBezelStyle:NSBezelStyleRegularSquare];
+  [the_button setButtonType:NSButtonTypeMomentaryPushIn];
 
-			// TODO: FEATURE: Cocoa allows text to be placed in different positions
-			// https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Button/Tasks/SettingButtonImage.html
-			[the_button setImagePosition:NSImageLeft];
+  value = iupAttribGet(ih, "IMAGE");
+  if(value)
+  {
+    ih->data->type = IUP_BUTTON_IMAGE;
 
-		}
-		else
-		{
-			// Explicitly set to NSImageOnly, otherwise expanding the image button does it in a off-centered way.
-			[the_button setImagePosition:NSImageOnly];
-		}
-		
-		
-		[the_button setButtonType:NSMomentaryChangeButton];
+    const char* title = iupAttribGet(ih, "TITLE");
+    if (title && *title!=0)
+    {
+      ih->data->type |= IUP_BUTTON_TEXT;
 
-		// I don't know what the style should be for images
-		// https://mackuba.eu/2014/10/06/a-guide-to-nsbutton-styles/
-//		[the_button setBezelStyle:NSRoundedBezelStyle];
-		[the_button setBezelStyle:NSThickSquareBezelStyle];
-//		[the_button setBezelStyle:NSShadowlessSquareBezelStyle];
-//		[the_button setBezelStyle:NSTexturedSquareBezelStyle];
-//		[the_button setBezelStyle:NSThickerSquareBezelStyle];
+      char* stripped_str = iupStrProcessMnemonic(title, NULL, 0);
+      NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
 
-		
-		NSImage* the_bitmap;
-		int make_inactive = 0;
-		
+      if(stripped_str && stripped_str != title)
+        free(stripped_str);
 
-		if(iupAttribGet(ih, "IMINACTIVE"))
-		{
-			make_inactive = 1;
-		}
+      [the_button setTitle:ns_string];
 
-		the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
-		[the_button setImage:the_bitmap];
-		
-		
-		value = iupAttribGet(ih, "IMPRESS");
-		if(value && *value!=0)
-		{
-			the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
-			[the_button setAlternateImage:the_bitmap];
-		}
-		
-	}
-	else
-	{
-		[the_button setButtonType:NSMomentaryLightButton];
-		[the_button setBezelStyle:NSRoundedBezelStyle];
-		
-		ih->data->type = IUP_BUTTON_TEXT;
+      NSCellImagePosition position;
+      switch(ih->data->img_position)
+      {
+        case IUP_IMGPOS_TOP:
+          position = NSImageAbove;
+          break;
+        case IUP_IMGPOS_BOTTOM:
+          position = NSImageBelow;
+          break;
+        case IUP_IMGPOS_RIGHT:
+          position = NSImageRight;
+          break;
+        case IUP_IMGPOS_LEFT:
+        default:
+          position = NSImageLeft;
+          break;
+      }
+      [the_button setImagePosition:position];
+    }
+    else
+    {
+      [the_button setImagePosition:NSImageOnly];
+    }
 
-		
+    if (iupAttribGet(ih, "IMPRESS") && !iupAttribGetBoolean(ih, "IMPRESSBORDER"))
+    {
+      has_border = 0;
+      [the_button setButtonType:NSButtonTypeMomentaryChange];
+      [the_button setBordered:NO];
+    }
 
-	}
-	
-	// Interface builder defaults to 13pt, but programmatic is smaller (12?). Setting the font fixes that difference.
-	[the_button setFont:[NSFont systemFontOfSize:0]];
+    NSImage* the_bitmap;
+    int make_inactive = 0;
 
-//	[the_button setButtonType:NSMomentaryLightButton];
+    if(iupAttribGet(ih, "IMINACTIVE") && !iupAttribGetBoolean(ih, "ACTIVE"))
+    {
+      value = iupAttribGet(ih, "IMINACTIVE");
+    }
+    else if(!iupAttribGetBoolean(ih, "ACTIVE"))
+    {
+      make_inactive = 1;
+    }
 
+    the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
+    [the_button setImage:the_bitmap];
 
-	
-//	[the_button sizeToFit];
-	
-	
-	
-	ih->handle = the_button;
-	iupCocoaSetAssociatedViews(ih, the_button, the_button);
+    value = iupAttribGet(ih, "IMPRESS");
+    if(value && *value!=0)
+    {
+      the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
+      [the_button setAlternateImage:the_bitmap];
+    }
+  }
+  else
+  {
+    ih->data->type = IUP_BUTTON_TEXT;
+  }
 
-	// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-	objc_setAssociatedObject(the_button, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-	// I also need to track the memory of the buttion action receiver.
-	// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-	// So with only one pointer to deal with, this means we need our button to hold a reference to the receiver object.
-	// This is generally not good Cocoa as buttons don't retain their receivers, but this seems like the best option.
-	// Be careful of retain cycles.
-	IupCocoaButtonReceiver* button_receiver = [[IupCocoaButtonReceiver alloc] init];
-	[the_button setTarget:button_receiver];
-	[the_button setAction:@selector(myButtonClickAction:)];
-	// I *think* is we use RETAIN, the object will be released automatically when the button is freed.
-	// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)
-	// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.
-	objc_setAssociatedObject(the_button, IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY, (id)button_receiver, OBJC_ASSOCIATION_ASSIGN);
+  [the_button setFont:[NSFont systemFontOfSize:0]];
+  [[the_button cell] setLineBreakMode:NSLineBreakByClipping];
 
-	
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
+  /* Apply initial padding if set and API is available */
+  if ((ih->data->horiz_padding != 0 || ih->data->vert_padding != 0) &&
+      [the_button respondsToSelector:@selector(setContentInsets:)])
+  {
+    NSEdgeInsets insets = NSEdgeInsetsMake(
+      ih->data->vert_padding,
+      ih->data->horiz_padding,
+      ih->data->vert_padding,
+      ih->data->horiz_padding
+    );
 
-	
-	
-	
+    NSMethodSignature *signature = [NSButton instanceMethodSignatureForSelector:@selector(setContentInsets:)];
+    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
+    [invocation setSelector:@selector(setContentInsets:)];
+    [invocation setTarget:the_button];
+    [invocation setArgument:&insets atIndex:2];
+    [invocation invoke];
+  }
 
-	
-	
-//	gtk_widget_realize(ih->handle);
-	
-	/* update a mnemonic in a label if necessary */
-//	iupgtkUpdateMnemonic(ih);
-	
-	return IUP_NOERROR;
+  ih->handle = the_button;
+  iupcocoaSetAssociatedViews(ih, the_button, the_button);
+
+  objc_setAssociatedObject(the_button, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+
+  IupCocoaButtonReceiver* button_receiver = [[IupCocoaButtonReceiver alloc] init];
+  [the_button setTarget:button_receiver];
+  [the_button setAction:@selector(myButtonClickAction:)];
+  objc_setAssociatedObject(the_button, IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY, (id)button_receiver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+
+  iupcocoaAddToParent(ih);
+
+  if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+  {
+    [the_button setRefusesFirstResponder:YES];
+    iupcocoaSetCanFocus(ih, 0);
+  }
+  else
+  {
+    iupcocoaSetCanFocus(ih, 1);
+  }
+
+  if (is_flat && has_border)
+  {
+    [the_button setBordered:NO];
+    [the_button updateTrackingAreas];
+  }
+
+  if (!iupAttribGetBoolean(ih, "ACTIVE"))
+    [the_button setEnabled:NO];
+
+  return IUP_NOERROR;
 }
 
 static void cocoaButtonUnMapMethod(Ihandle* ih)
 {
-	id the_button = ih->handle;
+  id the_button = ih->handle;
 
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-	
-	id butten_receiver = objc_getAssociatedObject(the_button, IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY);
-	objc_setAssociatedObject(the_button, IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
-	[butten_receiver release];
-	
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
+  Ihandle* context_menu_ih = (Ihandle*)iupcocoaCommonBaseGetContextMenuAttrib(ih);
+  if(context_menu_ih)
+  {
+    IupDestroy(context_menu_ih);
+    iupcocoaCommonBaseSetContextMenuAttrib(ih, NULL);
+  }
 
-	[the_button release];
-	ih->handle = NULL;
-	
+  [the_button setTarget:nil];
+  id button_receiver = objc_getAssociatedObject(the_button, IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY);
+  objc_setAssociatedObject(the_button, IUP_COCOA_BUTTON_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  [button_receiver release];
+
+  iupcocoaRemoveFromParent(ih);
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+
+  [the_button release];
+  ih->handle = NULL;
 }
 
-
 void iupdrvButtonInitClass(Iclass* ic)
 {
-	/* Driver Dependent Class functions */
-	ic->Map = cocoaButtonMapMethod;
-	ic->UnMap = cocoaButtonUnMapMethod;
-	
+  ic->Map = cocoaButtonMapMethod;
+  ic->UnMap = cocoaButtonUnMapMethod;
+  ic->LayoutUpdate = cocoaButtonLayoutUpdateMethod;
 
-	ic->LayoutUpdate = cocoaButtonLayoutUpdateMethod;
-#if 0
-	
-	/* Driver Dependent Attribute functions */
-	
-	/* Overwrite Common */
-	iupClassRegisterAttribute(ic, "STANDARDFONT", NULL, gtkButtonSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);
-	
-	/* Overwrite Visual */
-	iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, gtkButtonSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-	
-	/* Visual */
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, gtkButtonSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-	
-	/* Special */
-	iupClassRegisterAttribute(ic, "FGCOLOR", NULL, gtkButtonSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
-#endif
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, cocoaButtonSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaButtonSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, cocoaButtonSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FONT", NULL, cocoaButtonSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
 
-	iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaButtonSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaButtonSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ALIGNMENT", cocoaButtonGetAlignmentAttrib, cocoaButtonSetAlignmentAttrib, "ACENTER:ACENTER", NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMAGE", NULL, cocoaButtonSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMINACTIVE", NULL, cocoaButtonSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMPRESS", NULL, cocoaButtonSetImpressAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMPRESSBORDER", NULL, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "PADDING", iupButtonGetPaddingAttrib, cocoaButtonSetPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED);
 
-#if 0
-	/* IupButton only */
-	iupClassRegisterAttribute(ic, "ALIGNMENT", NULL, gtkButtonSetAlignmentAttrib, "ACENTER:ACENTER", NULL, IUPAF_NO_INHERIT);  /* force new default value */
-	iupClassRegisterAttribute(ic, "IMAGE", NULL, gtkButtonSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "IMINACTIVE", NULL, gtkButtonSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "IMPRESS", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	
-	iupClassRegisterAttribute(ic, "PADDING", iupButtonGetPaddingAttrib, gtkButtonSetPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED);
-	iupClassRegisterAttribute(ic, "MARKUP", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);
-#endif
+  iupClassRegisterAttribute(ic, "MARKUP", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, iupCocoaCommonBaseSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupCocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
-
+  iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupcocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
 }
Index: src/cocoa/iupcocoa_calendar.m
===================================================================
--- src/cocoa/iupcocoa_calendar.m	(revision 5971)
+++ src/cocoa/iupcocoa_calendar.m	(working copy)
@@ -29,147 +29,230 @@
 
 static const void* IUP_COCOA_CALENDAR_DELEGATE_OBJ_KEY = "IUP_COCOA_CALENDAR_DELEGATE_OBJ_KEY";
 
-
 @interface IupCocoaCalendarDelegate : NSObject
 @end
 
 @implementation IupCocoaCalendarDelegate
-//	The user interacted with the date picker control so update the date/time examples.
-- (IBAction) myDatePickerAction:(id)the_sender
+
+- (IBAction)myDatePickerAction:(id)the_sender
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
-	iupBaseCallValueChangedCb(ih);
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+  iupBaseCallValueChangedCb(ih);
 }
+
 @end
 
-
-
 static int cocoaCalendarSetValueAttrib(Ihandle* ih, const char* value)
 {
-	NSDatePicker* date_picker = (NSDatePicker*)ih->handle;
+  NSDatePicker* date_picker = (NSDatePicker*)ih->handle;
 
-	if(iupStrEqualNoCase(value, "TODAY"))
-	{
-		[date_picker setDateValue:[NSDate date]];
-	}
-	else
-	{
-		NSDateFormatter* date_formatter = [[NSDateFormatter alloc] init];
-		[date_formatter setDateFormat:@"YYYY/MM/dd"];
-		if(value && (value[0] != '\0'))
-		{
-			NSString* date_string = [NSString stringWithUTF8String:value];
-			NSDate* parsed_date = [date_formatter dateFromString:date_string];
-			[date_picker setDateValue:parsed_date];
-		}
-	}
-	return 0; /* do not store value in hash table */
+  if (iupStrEqualNoCase(value, "TODAY"))
+  {
+    [date_picker setDateValue:[NSDate date]];
+  }
+  else if (value)
+  {
+    int year, month, day;
+    if (sscanf(value, "%d/%d/%d", &year, &month, &day) == 3)
+    {
+      if (month < 1) month = 1;
+      if (month > 12) month = 12;
+      if (day < 1) day = 1;
+      if (day > 31) day = 31;
+
+      NSDateComponents* components = [[NSDateComponents alloc] init];
+      [components setYear:year];
+      [components setMonth:month];
+      [components setDay:day];
+
+      NSCalendar* calendar = [NSCalendar currentCalendar];
+      NSDate* parsed_date = [calendar dateFromComponents:components];
+      [components release];
+
+      if (parsed_date)
+      {
+        [date_picker setDateValue:parsed_date];
+      }
+    }
+  }
+
+  return 0;
 }
 
 static char* cocoaCalendarGetIupStrFromDate(NSDate* the_date)
 {
-	NSDateFormatter* date_formatter = [[NSDateFormatter alloc] init];
-	[date_formatter setDateFormat:@"YYYY/MM/dd"];
-	
-	NSString* date_string = [date_formatter stringFromDate:the_date];
-	
-	char* c_date_string = iupStrReturnStr([date_string UTF8String]);
-	[date_formatter release];
-	
-	return c_date_string;
+  NSDateComponents* components = [[NSCalendar currentCalendar] components:NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay
+                                                                 fromDate:the_date];
+
+  char* result = iupStrReturnStrf("%ld/%ld/%ld",
+      (long)[components year],
+      (long)[components month],
+      (long)[components day]);
+
+  return result;
 }
 
 static char* cocoaCalendarGetValueAttrib(Ihandle* ih)
 {
-	NSDatePicker* date_picker = (NSDatePicker*)ih->handle;
-	NSDate* the_date = [date_picker dateValue];
-	return cocoaCalendarGetIupStrFromDate(the_date);
+  NSDatePicker* date_picker = (NSDatePicker*)ih->handle;
+  NSDate* the_date = [date_picker dateValue];
+  return cocoaCalendarGetIupStrFromDate(the_date);
 }
 
 static char* cocoaCalendarGetTodayAttrib(Ihandle* ih)
 {
-	NSDate* today_date = [NSDate date];
-	return cocoaCalendarGetIupStrFromDate(today_date);
+  (void)ih;
+  NSDate* today_date = [NSDate date];
+  return cocoaCalendarGetIupStrFromDate(today_date);
 }
 
+static int cocoaCalendarSetWeekNumbersAttrib(Ihandle* ih, const char* value)
+{
+  /* NSDatePicker does not support week numbers on macOS */
+  (void)ih;
+  (void)value;
+  return 0;
+}
 
+static void cocoaCalendarLayoutUpdateMethod(Ihandle* ih)
+{
+  NSDatePicker* date_picker = (NSDatePicker*)ih->handle;
+  if (!date_picker) return;
 
+  NSView* parent_view = [date_picker superview];
+  if (!parent_view) return;
 
+  NSRect parent_bounds = [parent_view bounds];
+  NSSize intrinsic_size = [date_picker intrinsicContentSize];
+  NSRect child_rect;
+
+  /* Check if parent is a popover - if so, center the calendar */
+  Ihandle* ih_parent = ih->parent;
+  int is_in_popover = (ih_parent && ih_parent->iclass &&
+                       ih_parent->iclass->name &&
+                       strcmp(ih_parent->iclass->name, "popover") == 0);
+
+  if (is_in_popover)
+  {
+    /* Center the date picker within the popover */
+    CGFloat x = (parent_bounds.size.width - intrinsic_size.width) / 2;
+    CGFloat y = (parent_bounds.size.height - intrinsic_size.height) / 2;
+    child_rect = NSMakeRect(x, y, intrinsic_size.width, intrinsic_size.height);
+    [date_picker setFrame:child_rect];
+    [date_picker setBoundsSize:intrinsic_size];
+  }
+  else
+  {
+    /* Normal layout, use IUP computed position and size */
+    if ([parent_view isFlipped])
+    {
+      child_rect = NSMakeRect(ih->x, ih->y, ih->currentwidth, ih->currentheight);
+    }
+    else
+    {
+      child_rect = NSMakeRect(ih->x, parent_bounds.size.height - ih->y - ih->currentheight, ih->currentwidth, ih->currentheight);
+    }
+
+    [date_picker setFrame:child_rect];
+
+    /* If frame is larger than intrinsic size, scale content */
+    if (child_rect.size.width > intrinsic_size.width || child_rect.size.height > intrinsic_size.height)
+    {
+      [date_picker setBoundsSize:intrinsic_size];
+    }
+    else
+    {
+      [date_picker setBoundsSize:child_rect.size];
+    }
+  }
+}
+
 static void cocoaCalendarComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)
 {
-	(void)children_expand; /* unset if not a container */
+  (void)children_expand;
 
-	if(ih->handle)
-	{
-		NSDatePicker* date_picker = (NSDatePicker*)ih->handle;
-		NSRect frame_rect = [date_picker frame];
-		*w = frame_rect.size.width;
-		*h = frame_rect.size.height;
-	}
-	else
-	{
-		// These are what I always get on 10.12
-		*w = 139;
-		*h = 148;
-	}
+  if (ih->handle)
+  {
+    NSDatePicker* date_picker = (NSDatePicker*)ih->handle;
+    NSSize intrinsic_size = [date_picker intrinsicContentSize];
+    *w = iupROUND(intrinsic_size.width);
+    *h = iupROUND(intrinsic_size.height);
+  }
+  else
+  {
+    static int calendar_w = -1;
+    static int calendar_h = -1;
+
+    if (calendar_w < 0)
+    {
+      NSDatePicker* temp_picker = [[NSDatePicker alloc] initWithFrame:NSZeroRect];
+      [temp_picker setDatePickerStyle:NSDatePickerStyleClockAndCalendar];
+      [temp_picker setDatePickerElements:NSDatePickerElementFlagYearMonthDay];
+      [temp_picker setBezeled:YES];
+
+      NSSize intrinsic_size = [temp_picker intrinsicContentSize];
+      calendar_w = iupROUND(intrinsic_size.width);
+      calendar_h = iupROUND(intrinsic_size.height);
+
+      [temp_picker release];
+    }
+
+    *w = calendar_w;
+    *h = calendar_h;
+  }
 }
 
 static int cocoaCalendarMapMethod(Ihandle* ih)
 {
-//	NSRect frame = NSMakeRect(0, 0, 139, 148);
-//	NSDatePicker* date_picker = [[NSDatePicker alloc] initWithFrame:frame];
-	NSDatePicker* date_picker = [[NSDatePicker alloc] initWithFrame:NSZeroRect];
-	[date_picker setDatePickerStyle:NSClockAndCalendarDatePickerStyle];	// set our desired picker style
-	[date_picker setDatePickerElements:NSYearMonthDayDatePickerElementFlag];
-	// always set the date/time to TODAY
-	// note that our delete override might block this...
-	[date_picker setDateValue:[NSDate date]];
+  NSDatePicker* date_picker = [[NSDatePicker alloc] initWithFrame:NSZeroRect];
 
-	
-	IupCocoaCalendarDelegate* calendar_delegate = [[IupCocoaCalendarDelegate alloc] init];
-//	[date_picker setDelegate:calendar_delegate];
-	[date_picker setTarget:calendar_delegate];
-	[date_picker setAction:@selector(myDatePickerAction:)];
-	objc_setAssociatedObject(date_picker, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-	objc_setAssociatedObject(date_picker, IUP_COCOA_CALENDAR_DELEGATE_OBJ_KEY, calendar_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
-	[calendar_delegate release];
-	
-	
-	[date_picker sizeToFit];
-//	NSRect fit_frame = [date_picker frame];
-//	NSLog(@"size %@", NSStringFromRect(fit_frame));
-	
-	
-	
-	ih->handle = date_picker;
-	iupCocoaSetAssociatedViews(ih, date_picker, date_picker);
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
+  [date_picker setDatePickerStyle:NSDatePickerStyleClockAndCalendar];
 
-	
-	return IUP_NOERROR;
+  [date_picker setDatePickerElements:NSDatePickerElementFlagYearMonthDay];
+  [date_picker setDateValue:[NSDate date]];
+  [date_picker setBezeled:YES];
+  [date_picker setBordered:YES];
+
+  IupCocoaCalendarDelegate* calendar_delegate = [[IupCocoaCalendarDelegate alloc] init];
+  [date_picker setTarget:calendar_delegate];
+  [date_picker setAction:@selector(myDatePickerAction:)];
+
+  objc_setAssociatedObject(date_picker, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+  objc_setAssociatedObject(date_picker, IUP_COCOA_CALENDAR_DELEGATE_OBJ_KEY, calendar_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  [calendar_delegate release];
+
+  [date_picker sizeToFit];
+
+  ih->handle = date_picker;
+  iupcocoaSetAssociatedViews(ih, date_picker, date_picker);
+
+  iupcocoaAddToParent(ih);
+
+  if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+  {
+    [date_picker setRefusesFirstResponder:YES];
+    iupcocoaSetCanFocus(ih, 0);
+  }
+  else
+  {
+    iupcocoaSetCanFocus(ih, 1);
+  }
+
+  return IUP_NOERROR;
 }
 
 static void cocoaCalendarUnMapMethod(Ihandle* ih)
 {
-	id date_picker = ih->handle;
-	
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-	
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
+  if (!ih->handle)
+    return;
 
-	[date_picker release];
-	ih->handle = NULL;
-	
+  id date_picker = ih->handle;
+
+  [date_picker setTarget:nil];
+  objc_setAssociatedObject(date_picker, IUP_COCOA_CALENDAR_DELEGATE_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  objc_setAssociatedObject(date_picker, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+
+  iupdrvBaseUnMapMethod(ih);
 }
 
 Iclass* iupCalendarNewClass(void)
@@ -177,46 +260,32 @@
   Iclass* ic = iupClassNew(NULL);
 
   ic->name = "calendar";
-  ic->format = NULL; /* none */
+  ic->format = NULL;
   ic->nativetype = IUP_TYPECONTROL;
   ic->childtype = IUP_CHILDNONE;
   ic->is_interactive = 1;
 
-  /* Class functions */
   ic->New = iupCalendarNewClass;
+  ic->Map = cocoaCalendarMapMethod;
+  ic->UnMap = cocoaCalendarUnMapMethod;
+  ic->ComputeNaturalSize = cocoaCalendarComputeNaturalSizeMethod;
+  ic->LayoutUpdate = cocoaCalendarLayoutUpdateMethod;
 
-	ic->Map = cocoaCalendarMapMethod;
-	ic->UnMap = cocoaCalendarUnMapMethod;
-	ic->ComputeNaturalSize = cocoaCalendarComputeNaturalSizeMethod;
-	ic->LayoutUpdate = iupdrvBaseLayoutUpdateMethod;
-
-
-  /* Callbacks */
   iupClassRegisterCallback(ic, "VALUECHANGED_CB", "");
 
-  /* Common Callbacks */
   iupBaseRegisterCommonCallbacks(ic);
-
-  /* Common */
   iupBaseRegisterCommonAttrib(ic);
-
-  /* Visual */
   iupBaseRegisterVisualAttrib(ic);
 
-  /* IupCalendar only */
   iupClassRegisterAttribute(ic, "VALUE", cocoaCalendarGetValueAttrib, cocoaCalendarSetValueAttrib, NULL, "TODAY", IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
-//  iupClassRegisterAttribute(ic, "WEEKNUMBERS", NULL, gtkCalendarSetWeekNumbersAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TODAY", cocoaCalendarGetTodayAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "WEEKNUMBERS", NULL, cocoaCalendarSetWeekNumbersAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TODAY", cocoaCalendarGetTodayAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_READONLY | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupcocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
 
-	/* New API for view specific contextual menus (Mac only) */
-	// Hmmmm. Context menus don't seem to work on NSDatePicker.
-//	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, iupCocoaCommonBaseSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupCocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
-
   return ic;
 }
 
-Ihandle *IupCalendar(void)
+Ihandle* IupCalendar(void)
 {
   return IupCreate("calendar");
 }
Index: src/cocoa/iupcocoa_canvas.m
===================================================================
--- src/cocoa/iupcocoa_canvas.m	(revision 5971)
+++ src/cocoa/iupcocoa_canvas.m	(working copy)
@@ -1,5 +1,5 @@
 /** \file
- * \brief Canvas Control
+ * \brief Canvas Control for Cocoa
  *
  * See Copyright Notice in "iup.h"
  */
@@ -12,7 +12,7 @@
 #include <string.h>
 #include <memory.h>
 #include <stdarg.h>
-#include <limits.h>
+#include <math.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -27,1396 +27,1564 @@
 #include "iup_drvfont.h"
 #include "iup_canvas.h"
 #include "iup_key.h"
-#include "iup_class.h" // needed for iup_classbase.h
-#include "iup_classbase.h" // iupROUND
+#include "iup_class.h"
 #include "iup_focus.h"
 
-#include "iupcocoa_draw.h" // struct _IdrawCanvas
-#import "iupcocoa_canvas.h"
+#include "iupcocoa_draw.h"
 #include "iupcocoa_drv.h"
-#import "iupcocoa_dragdrop.h"
+#include "iupcocoa_dragdrop.h"
 
 
-@implementation IupCocoaCanvasView
-@synthesize ih = _ih;
-@synthesize dc = _dc;
-@synthesize currentKeyWindow = _isCurrentKeyWindow;
-@synthesize currentFirstResponder = _isCurrentFirstResponder;
-@synthesize startedDrag = _startedDrag;
+/* Forward declarations */
+static int cocoaCanvasSetBeginDragAttrib(Ihandle* ih, const char* value);
+static void cocoaCanvasLayoutUpdateMethod(Ihandle *ih);
+static int cocoaCanvasSetDXAttrib(Ihandle* ih, const char* value);
+static int cocoaCanvasSetDYAttrib(Ihandle* ih, const char* value);
+static void cocoaCanvasComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *expand);
 
-- (instancetype) initWithFrame:(NSRect)frame_rect ih:(Ihandle*)ih
+/**
+ * @brief Custom NSControl subclass for IupCanvas.
+ *
+ * This view serves as the core drawing and event-handling surface for the IupCanvas element.
+ *
+ * This view is designed to be used either standalone or as the `documentView` within an NSScrollView to support scrolling.
+ * When used with an NSScrollView, it relies on NSViewBoundsDidChangeNotification from the parent NSClipView
+ * to update IUP's scroll position attributes and trigger the SCROLL_CB callback.
+ */
+@interface IupCocoaCanvasView : NSControl
+
+@property(nonatomic, assign) Ihandle* ih;
+
+@property(nonatomic, assign, getter=isCurrentKeyWindow) bool currentKeyWindow;
+@property(nonatomic, assign, getter=isCurrentFirstResponder) bool currentFirstResponder;
+
+@property(nonatomic, assign) bool startedDrag;
+
+@property(nonatomic, assign) CGSize previousSize;
+
+@property(nonatomic, copy) NSColor* backgroundColor;
+
+@property(nonatomic, assign) bool useNativeFocusRing;
+
+- (instancetype) initWithFrame:(NSRect)frame_rect ih:(Ihandle*)ih;
+
+/**
+ * @brief Triggers the GETFOCUS_CB or KILLFOCUS_CB callback based on the view's focus state.
+ */
+- (void) updateFocus;
+
+@end
+
+
+/**
+ * @brief Custom NSView subclass for absolute positioning of child views.
+ *
+ * This view is flipped (origin at top-left, like IUP's coordinate system)
+ * and allows child views to be positioned with setFrameOrigin/setFrame.
+ * Used as _IUP_EXTRAPARENT for canvas controls.
+ */
+@interface IupCocoaFixedView : NSView
+@end
+
+@implementation IupCocoaFixedView
+
+- (BOOL) isFlipped
 {
-	self = [super initWithFrame:frame_rect];
-	if(self)
-	{
-		_ih = ih;
-		_dc = NULL;
+  return YES;
+}
 
-//		iupAttribSetDouble(ih, "_IUPAPPLE_CGWIDTH", frame_rect.size.width);
-//		iupAttribSetDouble(ih, "_IUPAPPLE_CGHEIGHT", frame_rect.size.height);
-		// Enabling layer backed views works around drawing corruption caused by native focus rings, but has all the consequences of using layer-backed views.
-		// Apple Bug ID: 44545497
-//		[self setWantsLayer:YES];
-#if 1
-		[self setPostsBoundsChangedNotifications:YES];
+@end
 
-		// Surprisingly, NSView doesn't have a built in method for resize events, but instead we muse use NSNotificationCenter
-		NSNotificationCenter* notification_center = [NSNotificationCenter defaultCenter];
-		[notification_center addObserver:self
-			selector:@selector(frameDidChangeNotification:)
-			name:NSViewFrameDidChangeNotification
-			object:self
-		];
-		[notification_center addObserver:self
-			selector:@selector(windowDidBecomeKeyNotification:)
-			name:NSWindowDidBecomeKeyNotification
-			object:[self window]
-		];
-		[notification_center addObserver:self
-			selector:@selector(windowDidResignKeyNotification:)
-			name:NSWindowDidResignKeyNotification
-			object:[self window]
-		];
 
-		[self setEnabled:YES];
-#endif
-		
-		[self setBackgroundColor:[NSColor whiteColor]];
+@interface IupLogicalScrollClipView : NSClipView
+@end
 
-	}
-	return self;
+@implementation IupLogicalScrollClipView
+
+- (void) setBoundsOrigin:(NSPoint)newOrigin
+{
+  /* Prevent NSScrollView from physically moving the clip view.
+   * Always keep bounds origin at (0,0) so the document view never moves.
+   * Scrolling is handled logically through POSX/POSY and redrawing. */
+  [super setBoundsOrigin:NSZeroPoint];
 }
 
+- (NSRect) constrainBoundsRect:(NSRect)proposedBounds
+{
+  /* Always constrain to origin (0,0) */
+  NSRect constrained = proposedBounds;
+  constrained.origin = NSZeroPoint;
+  return constrained;
+}
+
+@end
+
+@implementation IupCocoaCanvasView
+
+- (instancetype) initWithFrame:(NSRect)frame_rect ih:(Ihandle*)ih
+{
+  self = [super initWithFrame:frame_rect];
+  if(self)
+  {
+    _ih = ih;
+    [self setEnabled:YES];
+  }
+  return self;
+}
+
 - (void) dealloc
 {
-	NSNotificationCenter* notification_center = [NSNotificationCenter defaultCenter];
-	[notification_center removeObserver:self];
-	[self setBackgroundColor:nil];
-	[super dealloc];
+  NSNotificationCenter* notification_center = [NSNotificationCenter defaultCenter];
+  [notification_center removeObserver:self];
+  [self setBackgroundColor:nil];
+
+  [super dealloc];
 }
 
-- (NSGraphicsContext*) graphicsContext
+- (BOOL) isFlipped
 {
-	return [NSGraphicsContext currentContext];
+  if (iupAttribGet(_ih, "_IUP_GLCONTROLDATA"))
+    return NO;  /* OpenGL: bottom-left origin */
+  return YES;   /* Regular canvas: top-left origin */
 }
 
-- (CGContextRef) CGContext
+- (BOOL) isOpaque
 {
-	return [[NSGraphicsContext currentContext] CGContext];
+  /* OpenGL canvases are opaque and will draw their entire bounds */
+  if (iupAttribGet(_ih, "_IUP_GLCONTROLDATA"))
+    return YES;
+  return NO;
 }
 
-- (void) drawRect:(NSRect)the_rect
+- (void) viewWillMoveToWindow:(NSWindow*)newWindow
 {
-	Ihandle* ih = _ih;
+  [super viewWillMoveToWindow:newWindow];
 
-	[self lockFocus];
+  /* Remove observers from the old window before moving to a new one (or to nil). */
+  NSNotificationCenter* notification_center = [NSNotificationCenter defaultCenter];
+  if([self window])
+  {
+    [notification_center removeObserver:self name:NSWindowDidBecomeKeyNotification object:[self window]];
+    [notification_center removeObserver:self name:NSWindowDidResignKeyNotification object:[self window]];
+  }
+}
 
-	// Obtain the Quartz context from the current NSGraphicsContext at the time the view's
-	// drawRect method is called. This context is only appropriate for drawing in this invocation
-	// of the drawRect method.
-	// Interesting: graphicsPort is deprecated in 10.10
-	// CGContextRef cg_context = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
-	// Use [[NSGraphicsContext currentContext] CGContext] in 10.10+
-	CGContextRef cg_context = [[NSGraphicsContext currentContext] CGContext];
-	
-	
-	CGContextSaveGState(cg_context);
+- (void) viewDidMoveToWindow
+{
+  [super viewDidMoveToWindow];
 
-	// IUP has inverted y-coordinates compared to Cocoa (which uses Cartesian like OpenGL and your math books)
-	// If we are clever, we can invert the transform matrix so that the rest of the drawing code doesn't need to care.
-	{
-		// just inverting the y-scale causes the rendered area to flip off-screen. So we need to shift the canvas so it is centered before inverting it.
-		CGFloat translate_y = the_rect.size.height * 0.5;
-		CGContextTranslateCTM(cg_context, 0.0, +translate_y);
-		CGContextScaleCTM(cg_context, 1.0,  -1.0);
-		CGContextTranslateCTM(cg_context, 0.0, -translate_y);
-	}
-	
-	[[self backgroundColor] set];
-    NSRectFill(the_rect);
-	
-	IFnff call_back = (IFnff)IupGetCallback(ih, "ACTION");
-	if(call_back)
-	{
-		call_back(ih, ih->data->posx, ih->data->posy);
-	}
-	CGContextRestoreGState(cg_context);
+  /* Add observers to the new window. */
+  NSNotificationCenter* notification_center = [NSNotificationCenter defaultCenter];
+  if([self window])
+  {
+    [notification_center addObserver:self
+                            selector:@selector(windowDidBecomeKeyNotification:)
+                                name:NSWindowDidBecomeKeyNotification
+                              object:[self window]
+    ];
+    [notification_center addObserver:self
+                            selector:@selector(windowDidResignKeyNotification:)
+                                name:NSWindowDidResignKeyNotification
+                              object:[self window]
+    ];
 
-	[self unlockFocus];
+    /* Trigger initial tracking area setup when view is added to window.
+       updateTrackingAreas is not called automatically until frame changes,
+       so we need to ensure the tracking area is set up for hover events. */
+    [self updateTrackingAreas];
+  }
 }
 
+- (void) drawRect:(NSRect)dirty_rect
+{
+  /* For OpenGL canvases, use clearDrawable + setView pattern before calling ACTION */
+  if (iupAttribGet(_ih, "_IUP_GLCONTROLDATA"))
+  {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    NSOpenGLContext* gl_context = (NSOpenGLContext*)iupAttribGet(_ih, "CONTEXT");
+    if (gl_context)
+    {
+      [gl_context clearDrawable];
+      [gl_context setView:self];
+      [gl_context update];
+    }
+#pragma clang diagnostic pop
 
+    IFn cb = (IFn)IupGetCallback(_ih, "ACTION");
+    if (cb && !(_ih->data->inside_resize))
+    {
+      /* Set CLIPRECT for the damaged area */
+      iupAttribSetStrf(_ih, "CLIPRECT", "%.0f %.0f %.0f %.0f",
+                       dirty_rect.origin.x, dirty_rect.origin.y,
+                       dirty_rect.origin.x + dirty_rect.size.width - 1,
+                       dirty_rect.origin.y + dirty_rect.size.height - 1);
+      cb(_ih);
+      iupAttribSet(_ih, "CLIPRECT", NULL);
+    }
+    return;
+  }
 
-// Note: This also triggers when the view is moved, not just resize.
+  /* Check if there's a persistent buffer from SCROLL_CB or other drawing outside ACTION */
+  if (iupAttribGet(_ih, "_IUPCOCOA_BUFFER_DIRTY"))
+  {
+    NSBitmapImageRep* buffer = (NSBitmapImageRep*)iupAttribGet(_ih, "_IUPCOCOA_CANVAS_BUFFER");
+
+    if (buffer)
+    {
+      NSRect bounds = [self bounds];
+
+      /* If buffer exists and matches size, use it instead of calling ACTION */
+      if ([buffer pixelsWide] == (NSInteger)bounds.size.width &&
+          [buffer pixelsHigh] == (NSInteger)bounds.size.height)
+      {
+        /* Draw buffer contents to screen */
+        NSGraphicsContext* context = [NSGraphicsContext currentContext];
+        [context saveGraphicsState];
+
+        /* Draw bitmap respecting flipped view - this prevents Y-axis inversion */
+        [buffer drawInRect:bounds
+                  fromRect:NSMakeRect(0, 0, bounds.size.width, bounds.size.height)
+                 operation:NSCompositingOperationCopy
+                  fraction:1.0
+            respectFlipped:YES
+                     hints:nil];
+
+        [context restoreGraphicsState];
+
+        /* Keep dirty flag set - continue using buffer until ACTION is called */
+        return;  /* Don't call ACTION callback */
+      }
+    }
+  }
+
+  IFn call_back = (IFn)IupGetCallback(_ih, "ACTION");
+
+  if (call_back)
+  {
+    /* Clear dirty flag since ACTION is being called */
+    iupAttribSet(_ih, "_IUPCOCOA_BUFFER_DIRTY", NULL);
+
+    NSGraphicsContext* context = [NSGraphicsContext currentContext];
+    [context saveGraphicsState];
+
+    /* Get the scroll offset (top-left visible coordinate in virtual space).
+       We use the stored IUP POSX/POSY, which are synchronized with the visible rect. */
+    double xmin = iupAttribGetDouble(_ih, "XMIN");
+    double ymin = iupAttribGetDouble(_ih, "YMIN");
+    double offsetX = _ih->data->posx - xmin;
+    double offsetY = _ih->data->posy - ymin;
+
+    /* Apply the translation: T(x_app) = x_virt = x_app + OffsetX. */
+    CGContextRef cgContext = [context CGContext];
+    CGContextTranslateCTM(cgContext, offsetX, offsetY);
+
+    /* Set the CLIPRECT attribute, relative to the visible area (0,0).
+       The dirty_rect is in virtual coordinates, so we translate it back. */
+    NSRect clip_rect = dirty_rect;
+    clip_rect.origin.x -= offsetX;
+    clip_rect.origin.y -= offsetY;
+
+    /* IUP CLIPRECT definition: If the rectangle is empty, the attribute returns NULL. */
+    if (clip_rect.size.width <= 0 || clip_rect.size.height <= 0)
+    {
+      iupAttribSet(_ih, "CLIPRECT", NULL);
+    }
+    else
+    {
+      /* IUP uses inclusive integer coordinates for the end point (x2, y2).
+         We use floor/ceil to ensure we cover the pixel area correctly and subtract 1 for inclusive end coordinate. */
+      double x1 = floor(clip_rect.origin.x);
+      double y1 = floor(clip_rect.origin.y);
+      double x2 = ceil(clip_rect.origin.x + clip_rect.size.width) - 1;
+      double y2 = ceil(clip_rect.origin.y + clip_rect.size.height) - 1;
+
+      if (x2 < x1) x2 = x1;
+      if (y2 < y1) y2 = y1;
+
+      iupAttribSetStrf(_ih, "CLIPRECT", "%.0f %.0f %.0f %.0f", x1, y1, x2, y2);
+    }
+
+    /* The view is flipped, so the graphics context's coordinate system is
+       already top-down, matching IUP. The ACTION callback receives posx/posy to handle scrolling offsets. */
+    call_back(_ih);
+
+    iupAttribSet(_ih, "CLIPRECT", NULL);
+    [context restoreGraphicsState];
+  }
+  else
+  {
+    /* If there is no ACTION callback, we are responsible for drawing the background.
+       Clip to bounds to avoid drawing outside the view. */
+    if ([self backgroundColor])
+    {
+      NSRect fill_rect = NSIntersectionRect(dirty_rect, [self bounds]);
+      if (!NSIsEmptyRect(fill_rect))
+      {
+        [[self backgroundColor] set];
+        NSRectFill(fill_rect);
+      }
+    }
+  }
+}
+
 - (void) frameDidChangeNotification:(NSNotification*)the_notification
 {
-// This Notification does not provide a userInfo dictionary according to the docs
-	NSRect view_frame = [self frame];
-	Ihandle* ih = _ih;
+  NSRect view_rect = NSZeroRect;
+  id notification_object = [the_notification object];
 
-//	struct _IdrawCanvas* dc = [self dc];
-	CGSize previous_size = [self previousSize];
-	
-	CGFloat old_width = previous_size.width;
-	CGFloat old_height = previous_size.height;
+  /* The RESIZE_CB should report the size of the visible area.
+     The notification object is either the IupCocoaCanvasView itself (standalone)
+     or the NSClipView (when inside an NSScrollView), as configured in cocoaCanvasMapMethod. */
 
-	if((old_width == view_frame.size.width) && (old_height == view_frame.size.height))
-	{
-		// Means we were moved, but not resized.
-		return;
-	}
+  if ([notification_object isKindOfClass:[NSView class]])
+  {
+    /* When inside a scroll view (observing NSClipView), we must use its bounds size,
+       as it correctly represents the visible area regardless of scrollbar presence (tiling). */
+    if ([notification_object isKindOfClass:[NSClipView class]])
+    {
+      view_rect.size = [(NSClipView*)notification_object bounds].size;
+    }
+    else
+    {
+      /* Standalone canvas, use the frame size. */
+      view_rect = [(NSView*)notification_object frame];
+    }
+  }
+  else
+  {
+    NSLog(@"frameDidChangeNotification: unexpected notification object.");
+    return;
+  }
 
-	[self setPreviousSize:view_frame.size];
-	
-	IFnii call_back = (IFnii)IupGetCallback(ih, "RESIZE_CB");
-	if(call_back)
-	{
-		call_back(ih, view_frame.size.width, view_frame.size.height);
-	}
-	
+  CGSize previous_size = [self previousSize];
 
+  if(CGSizeEqualToSize(previous_size, view_rect.size))
+  {
+    /* The view was moved, but not resized, OR the resize was already handled synchronously by cocoaCanvasLayoutUpdateMethod. */
+    return;
+  }
+
+  [self setPreviousSize:view_rect.size];
+
+  /* For GL canvases, attach view to context on first resize (before any user callbacks) */
+  if (iupAttribGet(_ih, "_IUP_GLCONTROLDATA") && !iupAttribGet(_ih, "_IUPCOCOA_GL_VIEW_ATTACHED"))
+  {
+    if (view_rect.size.width > 0 && view_rect.size.height > 0)
+    {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+      NSOpenGLContext* gl_context = (NSOpenGLContext*)iupAttribGet(_ih, "CONTEXT");
+      if (gl_context)
+      {
+        if ([NSThread isMainThread])
+          [gl_context setView:self];
+        else
+          dispatch_sync(dispatch_get_main_queue(), ^{ [gl_context setView:self]; });
+        iupAttribSet(_ih, "_IUPCOCOA_GL_VIEW_ATTACHED", "1");
+      }
+#pragma clang diagnostic pop
+    }
+  }
+
+  IFnii call_back = (IFnii)IupGetCallback(_ih, "RESIZE_CB");
+  if(call_back && !_ih->data->inside_resize)
+  {
+    _ih->data->inside_resize = 1;
+
+    int width, height;
+    /* For GL canvases, pass actual drawable size in pixels, not view size in points */
+    if (iupAttribGet(_ih, "_IUP_GLCONTROLDATA"))
+    {
+      NSRect backing_bounds = [self convertRectToBacking:[self bounds]];
+      width = iupROUND(backing_bounds.size.width);
+      height = iupROUND(backing_bounds.size.height);
+    }
+    else
+    {
+      /* Regular canvas, use view size in points */
+      width = iupROUND(view_rect.size.width);
+      height = iupROUND(view_rect.size.height);
+    }
+
+    call_back(_ih, width, height);
+
+    _ih->data->inside_resize = 0;
+  }
 }
 
+- (void) globalFrameDidChangeNotification:(NSNotification*)the_notification
+{
+  if (_ih && iupAttribGet(_ih, "_IUP_GLCONTROLDATA"))
+  {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    NSOpenGLContext* gl_context = (NSOpenGLContext*)iupAttribGet(_ih, "CONTEXT");
+    if (gl_context)
+    {
+      [gl_context makeCurrentContext];
+      [gl_context update];
+    }
+#pragma clang diagnostic pop
+  }
+}
 
 - (void) windowDidBecomeKeyNotification:(NSNotification*)the_notification
 {
-//		NSLog(@"Window became key: %@", [[self window] title]);
-//	NSLog(@"window became key");
-	[self setCurrentKeyWindow:true];
-	[self updateFocus];
+  [self setCurrentKeyWindow:true];
+  [self updateFocus];
+}
 
-}
 - (void) windowDidResignKeyNotification:(NSNotification*)the_notification
 {
-//		NSLog(@"Window resign key: %@", [[self window] title]);
-//	NSLog(@"window resigned");
-	[self setCurrentKeyWindow:false];
-	[self updateFocus];
+  [self setCurrentKeyWindow:false];
+  [self updateFocus];
 }
 
-
-//////// Keyboard stuff
-
 - (BOOL) acceptsFirstResponder
 {
-//	BOOL ret_flag = [super acceptsFirstResponder];
-#if 1
-	if([self isEnabled])
-	{
-//NSLog(@"acceptsFirstResponder:YES");
-		return YES;
-	}
-	else
-	{
-//NSLog(@"acceptsFirstResponder:NO");
-		return NO;
-	}
-#else
-	return YES;
-#endif
+  return [self isEnabled];
 }
 
-/*
-Apple doc:
-The default value of this property is NO.
-Subclasses can override this property and use their implementation to determine if the view requires its panel
-to become the key window so that it can handle keyboard input and navigation.
-Such a subclass should also override acceptsFirstResponder to return YES.
-This property is also used in keyboard navigation.
-It determines if a mouse click should give focus to a viewthat is, make it the first responder).
-Some views (for example, text fields) want to receive the keyboard focus when you click in them.
-Other views (for example, buttons) receive focus only when you tab to them.
-You wouldn't want focus to shift from a textfield that has editing in progress simply because you clicked on a check box.
-
-Sooo... since IUP uses this mostly for buttons and not text entry, it seems like we should return NO.
-But this means that the widgets will never get the focus ring.
-*/
 - (BOOL) needsPanelToBecomeKey
 {
-	// Should we also test [[NSApplication sharedApplication] isFullKeyboardAccessEnabled]?
-//	BOOL ret_flag = [super needsPanelToBecomeKey];
-//	return YES;
-
-	// TODO: We should create a new ATTRIBUTE to distinguish different behavior modes, e.g.
-	// FOCUSMODE=
-	// BUTTON - returns no here so if the user is typing in another field and clicks this "button", the focus won't change
-	// TEXTFIELD - text entry things are handled, but things like TAB to switch focus are passed up the responder chain
-	// ALL - all entry is handled by the user
-
-	Ihandle* ih = _ih;
-
-	// FOR NOW: Hardcode/hack until I sort this out
-/*
-	if(IupClassMatch(ih, "flatbutton")
-		|| IupClassMatch(ih, "flatseparator")
-		|| IupClassMatch(ih, "dropbutton")
-		|| IupClassMatch(ih, "flattoggle")
-		|| IupClassMatch(ih, "flatlabel")
-		|| IupClassMatch(ih, "colorbar")
-		|| IupClassMatch(ih, "colorbrowser")
-		|| IupClassMatch(ih, "dial")
-		|| IupClassMatch(ih, "flatseparator")
-		|| IupClassMatch(ih, "flatscrollbox")
-		|| IupClassMatch(ih, "gauge")
-		|| IupClassMatch(ih, "flatseparator")
-		|| IupClassMatch(ih, "flatframe")
-		|| IupClassMatch(ih, "flattabs")
-	)
-	{
-		return NO;
-	}
-	else
-	{
-		return YES;
-	}
-*/
-	if(IupClassMatch(ih, "canvas"))
-	{
-		return YES;
-	}
-	else
-	{
-		return NO;
-	}
-
+  return YES;
 }
 
 - (BOOL) canBecomeKeyView
 {
-//	BOOL ret_flag = [super canBecomeKeyView];
-#if 1
-	// Should we also test [[NSApplication sharedApplication] isFullKeyboardAccessEnabled]?
-	//
-	if([self isEnabled] && [[NSApplication sharedApplication] isFullKeyboardAccessEnabled])
-	{
-//NSLog(@"canBecomeKeyView:YES");
-		return YES;
-	}
-	else
-	{
-//NSLog(@"canBecomeKeyView:NO");
-		return NO;
-	}
-#else
-	return YES;
-#endif
+  return [self isEnabled];
 }
 
 - (BOOL) becomeFirstResponder
 {
-//NSLog(@"becomeFirstResponder");
-#if 0
+  if (![self isEnabled])
+  {
+    [self setCurrentFirstResponder:false];
+    [self updateFocus];
+    return NO;
+  }
 
-	BOOL ret_val = [super becomeFirstResponder];
-	[self setCurrentFirstResponder:ret_val];
-	[self updateFocus];
-	return ret_val;
-#else
-	if([self isEnabled] && [[NSApplication sharedApplication] isFullKeyboardAccessEnabled])
-	{
-//NSLog(@"canBecomeKeyView:YES");
-		[self setCurrentFirstResponder:true];
-		[self updateFocus];
-		return YES;
-	}
-	else
-	{
-		[self setCurrentFirstResponder:false];
-		[self updateFocus];
-		return NO;
-	}
-#endif
+  BOOL accepted = [super becomeFirstResponder];
+  if(accepted)
+  {
+    [self setCurrentFirstResponder:true];
+    [self updateFocus];
+  }
+  return accepted;
 }
 
 - (BOOL) resignFirstResponder
 {
-//NSLog(@"resignFirstResponder");
-#if 1
-	BOOL ret_val = [super resignFirstResponder];
-	[self setCurrentFirstResponder:!ret_val];
-	[self updateFocus];
-	return ret_val;
-
-#else
-	[self setCurrentFirstResponder:false];
-
-	[self updateFocus];
-	return YES;
-#endif
-
-
-
+  BOOL ret_val = [super resignFirstResponder];
+  if(ret_val)
+  {
+    [self setCurrentFirstResponder:false];
+    [self updateFocus];
+  }
+  return ret_val;
 }
 
-// 10.7 API for native focus ring
 - (void) drawFocusRingMask
 {
-	bool should_use_native = [self useNativeFocusRing];
-	if(!should_use_native)
-	{
-//		NSRectFill([self bounds]);
-		NSRectFill(NSZeroRect);
-		return;
-	}
-//	[self lockFocus];
-//	[NSGraphicsContext currentContext];
-	
+  if([self useNativeFocusRing])
+  {
     NSRectFill([self bounds]);
-//	[self unlockFocus];
-//	[[self window] setViewsNeedDisplay:YES];
+  }
+  else
+  {
+    NSRectFill(NSZeroRect);
+  }
 }
 
-// 10.7 API for native focus ring
 - (NSRect) focusRingMaskBounds
 {
-	bool should_use_native = [self useNativeFocusRing];
-	if(!should_use_native)
-	{
-	    //return [self bounds];
-	    return NSZeroRect;
-	}
-
+  if([self useNativeFocusRing])
+  {
     return [self bounds];
+  }
+  return NSZeroRect;
 }
 
-// helper API to notify IUP of focus state change
 - (void) updateFocus
 {
-	Ihandle* ih = _ih;
-	// BUG: I used to set my own variable in the key window notification callback.
-	// But Apple was giving me multiple becomeKey callbacks or multiple resignKey callbacks, and I wasn't getting the counterparts.
-	// So it appeared that I had multiple key windows and IUP focus rings were drawn in multiple windows.
-	// I also tried the Main window callback, but got the same thing.
-	// So instead, I query the keyWindow directly and that seems to solve the problem.
-	
-	
-//	if([self isCurrentKeyWindow] && [self isCurrentFirstResponder])
-//	if([self isCurrentKeyWindow] && [self isCurrentFirstResponder] && [self isCurrentMainWindowStatus])
-	if([self isCurrentFirstResponder] && [[self window] isKeyWindow])
-	{
-//		NSLog(@"GetFocus ih:0x%p for View: %@ in Window: %@", ih, self, [self window]);
-//		NSLog(@"GrabFocus ih:0x%p for View: %@ in Window: %@", ih, self, [[self window] title]);
-
-		iupCallGetFocusCb(ih);
-	}
-	else
-	{
-//		NSLog(@"KillFocus ih:0x%p for View: %@ in Window: %@", ih, self, [[self window] title]);
-		iupCallKillFocusCb(ih);
-
-	}
-	// Because IUP draws fake widgets, they may need to redraw to change focus rings or active-state theming
-	[self setNeedsDisplay:YES]; // Cocoa seems to redraw without this. But it probably doesn't hurt.
+  if([self isCurrentFirstResponder] && [[self window] isKeyWindow])
+  {
+    iupCallGetFocusCb(_ih);
+  }
+  else
+  {
+    iupCallKillFocusCb(_ih);
+  }
+  [self setNeedsDisplay:YES];
 }
 
 - (BOOL) acceptsFirstMouse:(NSEvent *)theEvent
 {
-	return YES;
+  return YES;
 }
-#if 1
-- (void) flagsChanged:(NSEvent*)the_event
+
+- (void) updateTrackingAreas
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
+  [super updateTrackingAreas];
 
-//	NSLog(@"flagsChanged: %@", the_event);
-//	NSLog(@"modifierFlags: 0x%X", [the_event modifierFlags]);
-/*
-    NSEventModifierFlagCapsLock           = 1 << 16, // Set if Caps Lock key is pressed.
-    NSEventModifierFlagShift              = 1 << 17, // Set if Shift key is pressed.
-    NSEventModifierFlagControl            = 1 << 18, // Set if Control key is pressed.
-    NSEventModifierFlagOption             = 1 << 19, // Set if Option or Alternate key is pressed.
-    NSEventModifierFlagCommand            = 1 << 20, // Set if Command key is pressed.
-    NSEventModifierFlagNumericPad         = 1 << 21, // Set if any key in the numeric keypad is pressed.
-    NSEventModifierFlagHelp               = 1 << 22, // Set if the Help key is pressed.
-    NSEventModifierFlagFunction           = 1 << 23, // Set if any function key is pressed.
-*/
-	Ihandle* ih = [self ih];
-    unsigned short mac_key_code = [the_event keyCode];
-//    NSLog(@"mac_key_code : %d", mac_key_code);
-	bool should_not_propagate = iupCocoaModifierEvent(ih, the_event, (int)mac_key_code);
-	if(!should_not_propagate)
-	{
-		[super flagsChanged:the_event];
-	}
+  for (NSTrackingArea* area in [self trackingAreas])
+  {
+    if ([area owner] == self)
+    {
+      [self removeTrackingArea:area];
+    }
+  }
+
+  NSTrackingAreaOptions options = NSTrackingMouseEnteredAndExited |
+                                  NSTrackingMouseMoved |
+                                  NSTrackingActiveInKeyWindow |
+                                  NSTrackingInVisibleRect;
+  NSTrackingArea* tracking_area = [[NSTrackingArea alloc] initWithRect:[self bounds]
+                                                               options:options
+                                                                 owner:self
+                                                              userInfo:nil];
+  [self addTrackingArea:tracking_area];
+  [tracking_area release];
 }
 
+- (void) mouseEntered:(NSEvent*)the_event
+{
+  if (![self isEnabled]) return;
 
-//  Should we call this,
-// [self setNeedsDisplay:YES];
-// or force the user to call something if they need it?
-- (void) keyDown:(NSEvent*)the_event
+  IFn cb = (IFn)IupGetCallback(_ih, "ENTERWINDOW_CB");
+  if (cb)
+  {
+    if (cb(_ih) == IUP_CLOSE)
+      IupExitLoop();
+  }
+}
+
+- (void) mouseExited:(NSEvent*)the_event
 {
- 	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	   // gets ihandle
-    Ihandle* ih = [self ih];
-//	NSLog(@"keyDown: %@", the_event);
-    unsigned short mac_key_code = [the_event keyCode];
-//    NSLog(@"keydown string: %d", mac_key_code);
+  if (![self isEnabled]) return;
 
-	bool should_not_propagate = iupCocoaKeyEvent(ih, the_event, (int)mac_key_code, true);
-	if(!should_not_propagate)
-	{
-		[super keyDown:the_event];
-	}
+  IFn cb = (IFn)IupGetCallback(_ih, "LEAVEWINDOW_CB");
+  if (cb)
+  {
+    if (cb(_ih) == IUP_CLOSE)
+      IupExitLoop();
+  }
 }
 
-- (void) keyUp:(NSEvent*)the_event
+- (void) flagsChanged:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = [self ih];
-    unsigned short mac_key_code = [the_event keyCode];
-	bool should_not_propagate = iupCocoaKeyEvent(ih, the_event, (int)mac_key_code, false);
-	if(!should_not_propagate)
-	{
-		[super keyUp:the_event];
-	}
+  if(![self isEnabled]) return;
+
+  unsigned short mac_key_code = [the_event keyCode];
+  if(!iupcocoaModifierEvent(_ih, the_event, (int)mac_key_code))
+  {
+    [super flagsChanged:the_event];
+  }
 }
-#endif
 
-//////// Mouse stuff
+- (void) keyDown:(NSEvent*)the_event
+{
+  if(![self isEnabled]) return;
 
-- (void) mouseDown:(NSEvent*)the_event
-{
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseButtonCallback(ih, the_event, self, true);
-	if(!should_not_propagate)
-	{
-		[super mouseDown:the_event];
-	}
+  unsigned short mac_key_code = [the_event keyCode];
+  if(!iupcocoaKeyEvent(_ih, the_event, (int)mac_key_code, true))
+  {
+    [super keyDown:the_event];
+  }
 }
 
-// WARNING: This may be unsupportable.
-// The currentEvent may not be the right kind ad will throw an exception when our code tries to call invalid methods for the wrong type.
-// The one reason I think this may work is If-and-only-if the user calls this in the mouseDragged: callback (mouseDown: might also work),
-// then the currentEvent should (I hope) be the event passed to mouseDragged:.
-// If that is true, this should work.
-// But calling anywhere else will probably not work.
-static int cocoaCanvasSetBeginDragAttrib(Ihandle* ih, const char* value)
+- (void) keyUp:(NSEvent*)the_event
 {
-	IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
+  if(![self isEnabled]) return;
 
-	if([drag_source_data isDragSourceEnabled])
-	{
-		NSDraggingItem* dragging_item = [drag_source_data defaultDraggingItem];
+  unsigned short mac_key_code = [the_event keyCode];
+  if(!iupcocoaKeyEvent(_ih, the_event, (int)mac_key_code, false))
+  {
+    [super keyUp:the_event];
+  }
+}
 
-		NSView* main_view = [drag_source_data mainView];
-		
-		
-		// Special case for Canvas. We want the default file promise action to write a png file of the snapshot.
-		if([drag_source_data usesFilePromise] && ![drag_source_data hasFilePromiseCallback])
-		{
-			NSFilePromiseProvider* file_promise = (NSFilePromiseProvider*)[dragging_item item];
-			// If the auto-generate drag setting was enabled, we already created an NSImage. So try reusing that.
-			// This may also capture the manual drag image if the user set it.
-			NSArray* images_array = [dragging_item imageComponents];
-			if(images_array && ([images_array count] > 0))
-			{
-				NSDraggingImageComponent* image_component = [images_array objectAtIndex:0];
-				id image_data = [image_component contents];
-				[file_promise setUserInfo:image_data];
-			}
-			else
-			{
-				NSRect bounds_rect = [main_view bounds];
-				NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
-				NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
-				[image_data autorelease];
-				[file_promise setUserInfo:image_data];
-			}
-		} // end special case
-		
-		
-		NSEvent* the_event = [[NSApplication sharedApplication] currentEvent];
-		[main_view beginDraggingSessionWithItems:@[dragging_item] event:the_event source:drag_source_data];
-	}
+- (void) mouseDown:(NSEvent*)the_event
+{
+  if(![self isEnabled]) return;
 
-	return 0;
+  if(!iupcocoaCommonBaseHandleMouseButtonCallback(_ih, the_event, self, true))
+  {
+    [super mouseDown:the_event];
+  }
 }
 
 - (void) mouseDragged:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseMotionCallback(ih, the_event, self);
-	if(!should_not_propagate)
-	{
-		[super mouseDragged:the_event];
-	}
-	
-	// Should this be before or after the user callback? Or should this only fire if super is allowed?
-	// (The super reasoning is that other more complex widgets will invoke the drag in their super implementation.)
-	// And if after, should we consider their return value?
-	// Maybe the better thing to do is let the user directly invoke the drag?
-	if(([the_event associatedEventsMask] & NSLeftMouseDragged) && ![self startedDrag])
-	{
-	
-		IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
-		
-		if([drag_source_data isDragSourceEnabled] && [drag_source_data useAutoBeginDrag])
-		{
-#if 0
-			NSDraggingItem* dragging_item = [drag_source_data defaultDraggingItem];
-			if(nil != dragging_item)
-			{
-				// Special case for Canvas. We want the default file promise action to write a png file of the snapshot.
-				if([drag_source_data usesFilePromise] && ![drag_source_data hasFilePromiseCallback])
-				{
-					NSFilePromiseProvider* file_promise = (NSFilePromiseProvider*)[dragging_item item];
-					// If the auto-generate drag setting was enabled, we already created an NSImage. So try reusing that.
-					// This may also capture the manual drag image if the user set it.
-					NSArray* images_array = [dragging_item imageComponents];
-					if(images_array && ([images_array count] > 0))
-					{
-						NSDraggingImageComponent* image_component = [images_array objectAtIndex:0];
-						id image_data = [image_component contents];
-						[file_promise setUserInfo:image_data];
-					}
-					else
-					{
-						NSRect bounds_rect = [self bounds];
-						NSData* pdf_data = [self dataWithPDFInsideRect:bounds_rect];
-						NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
-						[image_data autorelease];
-						[file_promise setUserInfo:image_data];
-					}
-				} // end special case
+  if(![self isEnabled]) return;
 
+  if(!iupcocoaCommonBaseHandleMouseMotionCallback(_ih, the_event, self))
+  {
+    [super mouseDragged:the_event];
+  }
 
-				[self beginDraggingSessionWithItems:@[dragging_item] event:the_event source:drag_source_data];
-				[self setStartedDrag:true];
-			}
-#else
-			cocoaCanvasSetBeginDragAttrib(ih, NULL);
-#endif
-		}
-
-	}
-	
+  if(([the_event associatedEventsMask] & NSEventMaskLeftMouseDragged) && ![self startedDrag])
+  {
+    IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(_ih);
+    if([drag_source_data isDragSourceEnabled] && iupAttribGetBoolean(_ih, "AUTOBEGINDRAG"))
+    {
+      cocoaCanvasSetBeginDragAttrib(_ih, NULL);
+    }
+  }
 }
 
 - (void) mouseUp:(NSEvent*)the_event
 {
-	[self setStartedDrag:false];
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseButtonCallback(ih, the_event, self, false);
-	if(!should_not_propagate)
-	{
-		[super mouseUp:the_event];
-	}
+  [self setStartedDrag:false];
+  if(![self isEnabled]) return;
+
+  if(!iupcocoaCommonBaseHandleMouseButtonCallback(_ih, the_event, self, false))
+  {
+    [super mouseUp:the_event];
+  }
 }
 
-// I learned that if I don't call super, the context menu doesn't activate.
 - (void) rightMouseDown:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseButtonCallback(ih, the_event, self, true);
-	if(!should_not_propagate)
-	{
-		[super rightMouseDown:the_event];
-	}
+  if(![self isEnabled]) return;
+
+  if(!iupcocoaCommonBaseHandleMouseButtonCallback(_ih, the_event, self, true))
+  {
+    [super rightMouseDown:the_event];
+  }
 }
 
 - (void) rightMouseDragged:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseMotionCallback(ih, the_event, self);
-	if(!should_not_propagate)
-	{
-		[super rightMouseDragged:the_event];
-	}
+  if(![self isEnabled]) return;
+
+  if(!iupcocoaCommonBaseHandleMouseMotionCallback(_ih, the_event, self))
+  {
+    [super rightMouseDragged:the_event];
+  }
 }
 
 - (void) rightMouseUp:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseButtonCallback(ih, the_event, self, false);
-	if(!should_not_propagate)
-	{
-		[super rightMouseUp:the_event];
-	}
+  if(![self isEnabled]) return;
+
+  if(!iupcocoaCommonBaseHandleMouseButtonCallback(_ih, the_event, self, false))
+  {
+    [super rightMouseUp:the_event];
+  }
 }
 
 - (void) otherMouseDown:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseButtonCallback(ih, the_event, self, true);
-	if(!should_not_propagate)
-	{
-		[super otherMouseDown:the_event];
-	}
+  if(![self isEnabled]) return;
+
+  if(!iupcocoaCommonBaseHandleMouseButtonCallback(_ih, the_event, self, true))
+  {
+    [super otherMouseDown:the_event];
+  }
 }
 
 - (void) otherMouseDragged:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseMotionCallback(ih, the_event, self);
-	if(!should_not_propagate)
-	{
-		[super otherMouseDragged:the_event];
-	}
+  if(![self isEnabled]) return;
+
+  if(!iupcocoaCommonBaseHandleMouseMotionCallback(_ih, the_event, self))
+  {
+    [super otherMouseDragged:the_event];
+  }
 }
 
 - (void) otherMouseUp:(NSEvent*)the_event
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseHandleMouseButtonCallback(ih, the_event, self, false);
-	if(!should_not_propagate)
-	{
-		[super otherMouseUp:the_event];
-	}
+  if(![self isEnabled]) return;
+
+  if(!iupcocoaCommonBaseHandleMouseButtonCallback(_ih, the_event, self, false))
+  {
+    [super otherMouseUp:the_event];
+  }
 }
 
-// WARNING: IUP WHEEL_CB does not support delta y-axis
-- (void) scrollWheel:(NSEvent*)the_event
+- (void) _updateIupScrollState
 {
-	// Don't respond if the control is inactive
-	if(![self isEnabled])
-	{
-		return;
-	}
-	
-	Ihandle* ih = _ih;
-	bool should_not_propagate = iupCocoaCommonBaseScrollWheelCallback(ih, the_event, self);
-	if(!should_not_propagate)
-	{
-		[super scrollWheel:the_event];
-	}
-}
+  if (!_ih) return;
 
+  /* Calculate POSX/POSY from scroller doubleValue */
+  NSScrollView* scroll_view = [self enclosingScrollView];
+  if (![scroll_view isKindOfClass:[NSScrollView class]]) return;
 
+  /* Skip if we're setting the position programmatically */
+  if (iupAttribGet(_ih, "_IUPCOCOA_UPDATING_SCROLL_POS"))
+  {
+    return;
+  }
 
-/******* Begin Drag & Drop ************/
+  double old_posx = _ih->data->posx;
+  double old_posy = _ih->data->posy;
 
-/*
-- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender;
-- (NSDragOperation)draggingUpdated:(id <NSDraggingInfo>)sender; // if the destination responded to draggingEntered: but not to draggingUpdated: the return value from draggingEntered: is used
-- (void)draggingExited:(nullable id <NSDraggingInfo>)sender;
-- (BOOL)prepareForDragOperation:(id <NSDraggingInfo>)sender;
-- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender;
-- (void)concludeDragOperation:(nullable id <NSDraggingInfo>)sender;
-// draggingEnded: is implemented as of Mac OS 10.5
-- (void)draggingEnded:(id<NSDraggingInfo>)sender;
-*/
+  double xmin = iupAttribGetDouble(_ih, "XMIN");
+  double xmax = iupAttribGetDouble(_ih, "XMAX");
+  double dx = iupAttribGetDouble(_ih, "DX");
 
+  double ymin = iupAttribGetDouble(_ih, "YMIN");
+  double ymax = iupAttribGetDouble(_ih, "YMAX");
+  double dy = iupAttribGetDouble(_ih, "DY");
 
-- (NSDragOperation) draggingEntered:(id<NSDraggingInfo>)the_sender
+  double content_width = xmax - xmin;
+  double content_height = ymax - ymin;
+
+  double new_posx = old_posx;
+  double new_posy = old_posy;
+
+  /* Calculate POSX from horizontal scroller */
+  if (_ih->data->sb & IUP_SB_HORIZ)
+  {
+    NSScroller* h_scroller = [scroll_view horizontalScroller];
+    if (h_scroller && content_width > dx)
+    {
+      CGFloat double_value = [h_scroller doubleValue];
+      double scrollable_range = content_width - dx;
+      new_posx = xmin + (double_value * scrollable_range);
+
+      double max_posx = xmax - dx;
+      if (max_posx < xmin) max_posx = xmin;
+      if (new_posx < xmin) new_posx = xmin;
+      if (new_posx > max_posx) new_posx = max_posx;
+    }
+  }
+
+  /* Calculate POSY from vertical scroller */
+  if (_ih->data->sb & IUP_SB_VERT)
+  {
+    NSScroller* v_scroller = [scroll_view verticalScroller];
+    if (v_scroller && content_height > dy)
+    {
+      CGFloat double_value = [v_scroller doubleValue];
+      double scrollable_range = content_height - dy;
+      new_posy = ymin + (double_value * scrollable_range);
+
+      double max_posy = ymax - dy;
+      if (max_posy < ymin) max_posy = ymin;
+      if (new_posy < ymin) new_posy = ymin;
+      if (new_posy > max_posy) new_posy = max_posy;
+    }
+  }
+
+  double delta_x = new_posx - old_posx;
+  double delta_y = new_posy - old_posy;
+
+  if (fabs(delta_x) < 1e-6 && fabs(delta_y) < 1e-6)
+  {
+    return;
+  }
+
+  _ih->data->posx = new_posx;
+  _ih->data->posy = new_posy;
+
+  IFniff scroll_cb = (IFniff)IupGetCallback(_ih, "SCROLL_CB");
+  if (scroll_cb)
+  {
+    int op = (fabs(delta_y) >= fabs(delta_x)) ? IUP_SBPOSV : IUP_SBPOSH;
+    scroll_cb(_ih, op, (float)_ih->data->posx, (float)_ih->data->posy);
+  }
+  else
+  {
+    IFn action_cb = (IFn)IupGetCallback(_ih, "ACTION");
+    if (action_cb)
+    {
+      iupdrvRedrawNow(_ih);
+    }
+  }
+}
+
+- (void) scrollWheel:(NSEvent*)the_event
 {
-//	NSLog(@"%@, %@", NSStringFromSelector(_cmd), the_sender);
-	
-	Ihandle* ih = [self ih];
-	IupTargetDropAssociatedData* target_drop_data = cocoaTargetDropGetAssociatedData(ih);
-	NSArray* supported_types = [target_drop_data dropRegisteredTypes];
+  if (![self isEnabled])
+  {
+    [super scrollWheel:the_event];
+    return;
+  }
 
-	NSPasteboard* paste_board = [the_sender draggingPasteboard];
-//	NSString* available_type = [paste_board availableTypeFromArray:@[NSPasteboardTypeTIFF, NSPasteboardTypePNG, NSFilenamesPboardType]];
-	NSString* available_type = [paste_board availableTypeFromArray:supported_types];
-	if(available_type)
-	{
-	
-		IFniis call_back = (IFniis)IupGetCallback(ih, "DROPMOTION_CB");
-		if(NULL != call_back)
-		{
-			NSPoint window_point = [the_sender draggingLocation];
-			NSPoint view_point = [self convertPoint:window_point fromView:nil];
-			NSRect view_frame = [self frame];
-			CGFloat inverted_y = view_frame.size.height - view_point.y;
-			view_point.y = inverted_y;
-	
-			char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
-			// We can't support this. The currentEvent may not be the right kind and will throw an exception when our code tries to call invalid methods for the wrong type.
-//			NSEvent* the_event = [[NSApplication sharedApplication] currentEvent];
-//			iupcocoaButtonKeySetStatus(the_event, mod_status);
-			call_back(ih, view_point.x, view_point.y, mod_status);
-		}
-	
-//		[self setNeedDisplay:YES];
+  if (iupAttribGetBoolean(_ih, "WHEELDROPFOCUS"))
+  {
+    Ihandle* ih_focus = IupGetFocus();
+    if (iupObjectCheck(ih_focus))
+      iupAttribSetClassObject(ih_focus, "SHOWDROPDOWN", "NO");
+  }
 
+  IFnfiis wheel_cb = (IFnfiis)IupGetCallback(_ih, "WHEEL_CB");
+  if (wheel_cb)
+  {
+    iupcocoaCommonBaseScrollWheelCallback(_ih, the_event, self);
+    return;
+  }
 
-		bool is_move = iupAttribGetBoolean(ih, "DRAGSOURCEMOVE");
-		if(is_move)
-		{
-			return NSDragOperationMove;
-		}
-		else
-		{
-			return NSDragOperationCopy;
-		}
-	}
-	return NSDragOperationNone;
+  CGFloat deltaY = [the_event deltaY];
+  CGFloat deltaX = [the_event deltaX];
+  IFniff scroll_cb = (IFniff)IupGetCallback(_ih, "SCROLL_CB");
+
+  if (fabs(deltaY) > 0.0)
+  {
+    double dy = iupAttribGetDouble(_ih, "DY");
+    if (dy > 0.0)
+    {
+      double posy = _ih->data->posy;
+      posy -= deltaY * dy / 10.0;
+      IupSetDouble(_ih, "POSY", posy);
+
+      if (scroll_cb)
+      {
+        int op = (deltaY > 0) ? IUP_SBUP : IUP_SBDN;
+        scroll_cb(_ih, op, (float)_ih->data->posx, (float)_ih->data->posy);
+      }
+      else
+      {
+        IFn action_cb = (IFn)IupGetCallback(_ih, "ACTION");
+        if (action_cb)
+          iupdrvRedrawNow(_ih);
+      }
+    }
+    else
+    {
+      [super scrollWheel:the_event];
+    }
+  }
+  else if (fabs(deltaX) > 0.0)
+  {
+    double dx = iupAttribGetDouble(_ih, "DX");
+    if (dx > 0.0)
+    {
+      double posx = _ih->data->posx;
+      posx += deltaX * dx / 10.0;
+      IupSetDouble(_ih, "POSX", posx);
+
+      if (scroll_cb)
+      {
+        int op = (deltaX > 0) ? IUP_SBRIGHT : IUP_SBLEFT;
+        scroll_cb(_ih, op, (float)_ih->data->posx, (float)_ih->data->posy);
+      }
+      else
+      {
+        IFn action_cb = (IFn)IupGetCallback(_ih, "ACTION");
+        if (action_cb)
+          iupdrvRedrawNow(_ih);
+      }
+    }
+    else
+    {
+      [super scrollWheel:the_event];
+    }
+  }
+  else
+  {
+    [super scrollWheel:the_event];
+  }
 }
 
-/*
-- (NSDragOperation) draggingUpdated:(id<NSDraggingInfo>)the_sender
+- (NSDragOperation) draggingEntered:(id<NSDraggingInfo>)the_sender
 {
-//	NSLog(@"%@, %@", NSStringFromSelector(_cmd), the_sender);
-	Ihandle* ih = [self ih];
-	IupTargetDropAssociatedData* target_drop_data = cocoaTargetDropGetAssociatedData(ih);
-	NSArray* supported_types = [target_drop_data dropRegisteredTypes];
-	
-	NSPasteboard* paste_board = [the_sender draggingPasteboard];
-//	NSString* available_type = [paste_board availableTypeFromArray:@[NSPasteboardTypeTIFF, NSPasteboardTypePNG, NSFilenamesPboardType]];
-	NSString* available_type = [paste_board availableTypeFromArray:supported_types];
-	if(available_type)
-	{
-//		[self setNeedDisplay:YES];
-		return NSDragOperationCopy;
-	}
-	return NSDragOperationNone;
+  IupTargetDropAssociatedData* target_drop_data = cocoaTargetDropGetAssociatedData(_ih);
+  NSArray* supported_types = [target_drop_data dropRegisteredTypes];
+  NSPasteboard* paste_board = [the_sender draggingPasteboard];
+
+  if([paste_board availableTypeFromArray:supported_types])
+  {
+    IFniis call_back = (IFniis)IupGetCallback(_ih, "DROPMOTION_CB");
+    if(call_back)
+    {
+      NSPoint window_point = [the_sender draggingLocation];
+      NSPoint view_point = [self convertPoint:window_point fromView:nil];
+
+      char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+      call_back(_ih, (int)view_point.x, (int)view_point.y, mod_status);
+    }
+
+    return iupAttribGetBoolean(_ih, "DRAGSOURCEMOVE") ? NSDragOperationMove : NSDragOperationCopy;
+  }
+  return NSDragOperationNone;
 }
-*/
 
 - (BOOL) performDragOperation:(id<NSDraggingInfo>)the_sender
 {
-//	NSLog(@"%@, %@", NSStringFromSelector(_cmd), the_sender);
-	
-	NSPasteboard* paste_board = [the_sender draggingPasteboard];
-	NSPoint drop_point = [the_sender draggingLocation];
-	NSPoint converted_point = [self convertPoint:drop_point fromView:nil];
-	NSRect view_frame = [self frame];
-	CGFloat inverted_y = view_frame.size.height - converted_point.y;
-	converted_point.y = inverted_y;
+  NSPasteboard* paste_board = [the_sender draggingPasteboard];
+  NSPoint drop_point = [self convertPoint:[the_sender draggingLocation] fromView:nil];
 
-	Ihandle* ih = [self ih];
-	cocoaTargetDropBasePerformDropCallback(ih, the_sender, paste_board, converted_point);
+  cocoaTargetDropBasePerformDropCallback(_ih, the_sender, paste_board, drop_point);
+  return YES;
+}
 
-	return YES;
+- (void) boundsDidChangeNotification:(NSNotification*)notification
+{
+  [self _updateIupScrollState];
 }
 
-/*
-- (BOOL) prepareForDragOperation:(id<NSDraggingInfo>)the_sender
+- (void) scrollerAction:(id)sender
 {
-	NSLog(@"%@, %@", NSStringFromSelector(_cmd), the_sender);
-	[the_sender setAnimatesToDestination:YES];
-	return YES;
+  /* Handle user dragging the scroller thumb */
+  [self _updateIupScrollState];
 }
-*/
-/*
-- (void) concludeDragOperation:(id<NSDraggingInfo>)the_sender
+
+@end
+
+
+static NSScrollView* cocoaCanvasGetScrollView(Ihandle* ih)
 {
-	NSLog(@"%@, %@", NSStringFromSelector(_cmd), the_sender);
+  if(iupAttribGetBoolean(ih, "_IUPCOCOA_CANVAS_HAS_SCROLLBAR"))
+  {
+    NSScrollView* scroll_view = (NSScrollView*)iupAttribGet(ih, "_IUPCOCOA_CANVAS_ROOT");
+    NSCAssert([scroll_view isKindOfClass:[NSScrollView class]], @"Expected NSScrollView");
+    return scroll_view;
+  }
+  return nil;
 }
 
-- (void) draggingEnded:(id<NSDraggingInfo>)the_sender
+static IupCocoaCanvasView* cocoaCanvasGetCanvasView(Ihandle* ih)
 {
-	NSLog(@"%@, %@", NSStringFromSelector(_cmd), the_sender);
+  IupCocoaCanvasView* canvas_view = (IupCocoaCanvasView*)iupAttribGet(ih, "_IUPCOCOA_CANVAS_VIEW");
+  NSCAssert([canvas_view isKindOfClass:[IupCocoaCanvasView class]], @"Expected IupCocoaCanvasView");
+  return canvas_view;
 }
-*/
-//- (void)updateDraggingItemsForDrag:(nullable id <NSDraggingInfo>)sender NS_AVAILABLE_MAC(10_7);
 
-/*
-- (NSDragOperation)draggingSession:(NSDraggingSession *)session sourceOperationMaskForDraggingContext:(NSDraggingContext)context
+static int cocoaCanvasSetBgColorAttrib(Ihandle* ih, const char* value)
 {
-    if (context == NSDraggingContextOutsideApplication) {
-        return NSDragOperationCopy;
-    }
-	
-    return NSDragOperationNone;
+  IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+  unsigned char r, g, b;
+  if (iupStrToRGB(value, &r, &g, &b))
+  {
+    NSColor* the_color = [NSColor colorWithCalibratedRed:(CGFloat)r/255.0 green:(CGFloat)g/255.0 blue:(CGFloat)b/255.0 alpha:1.0];
+    [canvas_view setBackgroundColor:the_color];
+    [canvas_view setNeedsDisplay:YES];
+  }
+  return 1;
 }
-*/
-/*
-- (NSDraggingSession*) beginDraggingSessionWithItems:(NSArray<NSDraggingItem*>*)items_array event:(NSEvent*)the_event source:(id<NSDraggingSource>)dragging_source
+
+static int cocoaCanvasSetDXAttrib(Ihandle* ih, const char* value)
 {
-	NSLog(@"beginDraggingSessionWithItems:%@, event:%@, source:%@", items_array, the_event, dragging_source);
-	NSDraggingSession* dragging_session = [super beginDraggingSessionWithItems:items_array event:the_event source:dragging_source];
-	NSLog(@"dragging_session:%@", dragging_session);
-	return dragging_session;
+  if (ih->data->sb & IUP_SB_HORIZ)
+  {
+    NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
+    if (!scroll_view) return 0;
+
+    double dx;
+    if (value) iupStrToDouble(value, &dx);
+    else dx = iupAttribGetDouble(ih, "DX");
+
+    double xmin = iupAttribGetDouble(ih, "XMIN");
+    double xmax = iupAttribGetDouble(ih, "XMAX");
+    double content_width = xmax - xmin;
+
+    if (dx >= content_width)
+    {
+      if (iupAttribGetBoolean(ih, "XAUTOHIDE"))
+      {
+        [scroll_view setHasHorizontalScroller:NO];
+        iupAttribSet(ih, "SB_RESIZE", "YES");
+      }
+      else
+      {
+        [scroll_view setHasHorizontalScroller:YES];
+        [[scroll_view horizontalScroller] setEnabled:NO];
+      }
+      iupAttribSet(ih, "XHIDDEN", "YES");
+      if (ih->data->posx != xmin) IupSetDouble(ih, "POSX", xmin);
+    }
+    else
+    {
+      [scroll_view setHasHorizontalScroller:YES];
+      [[scroll_view horizontalScroller] setEnabled:YES];
+      iupAttribSet(ih, "SB_RESIZE", "YES");
+      iupAttribSet(ih, "XHIDDEN", "NO");
+
+      NSScroller* scroller = [scroll_view horizontalScroller];
+      if (scroller && content_width > 0)
+      {
+        CGFloat knob_proportion = (CGFloat)(dx / content_width);
+        [scroller setKnobProportion:knob_proportion];
+      }
+    }
+
+    [scroll_view tile];
+    [scroll_view setNeedsDisplay:YES];
+  }
+  return 1;
 }
-*/
-//@protocol NSDraggingSource <NSObject>
-/* Methods implemented by an object that initiates a drag session. The source application is sent these messages during dragging.  The first must be implemented, the others are sent if the source responds to them.
-*/
 
-//@required
-/* Declares what types of operations the source allows to be performed. Apple may provide more specific "within" values in the future. To account for this, for unrecongized localities, return the operation mask for the most specific context that you are concerned with. For example:
-    switch(context) {
-        case NSDraggingContextOutsideApplication:
-            return ...
-            break;
+static int cocoaCanvasSetDYAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->sb & IUP_SB_VERT)
+  {
+    NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
+    if (!scroll_view) return 0;
 
-        case NSDraggingContextWithinApplication:
-        default:
-            return ...
-            break;
+    double dy;
+    if (value) iupStrToDouble(value, &dy);
+    else dy = iupAttribGetDouble(ih, "DY");
+
+    double ymin = iupAttribGetDouble(ih, "YMIN");
+    double ymax = iupAttribGetDouble(ih, "YMAX");
+    double content_height = ymax - ymin;
+
+    if (dy >= content_height)
+    {
+      if (iupAttribGetBoolean(ih, "YAUTOHIDE"))
+      {
+        [scroll_view setHasVerticalScroller:NO];
+        iupAttribSet(ih, "SB_RESIZE", "YES");
+      }
+      else
+      {
+        [scroll_view setHasVerticalScroller:YES];
+        [[scroll_view verticalScroller] setEnabled:NO];
+      }
+      iupAttribSet(ih, "YHIDDEN", "YES");
+      if (ih->data->posy != ymin) IupSetDouble(ih, "POSY", ymin);
     }
-*/
+    else
+    {
+      [scroll_view setHasVerticalScroller:YES];
+      [[scroll_view verticalScroller] setEnabled:YES];
+      iupAttribSet(ih, "SB_RESIZE", "YES");
+      iupAttribSet(ih, "YHIDDEN", "NO");
 
+      NSScroller* scroller = [scroll_view verticalScroller];
+      if (scroller && content_height > 0)
+      {
+        CGFloat knob_proportion = (CGFloat)(dy / content_height);
+        [scroller setKnobProportion:knob_proportion];
+      }
+    }
 
-/******* End Drag & Drop ************/
+    [scroll_view tile];
+    [scroll_view setNeedsDisplay:YES];
+  }
+  return 1;
+}
 
-/*
-TODO: Menu Items / Responder Chain for Undo, Redo, Cut, Copy, Paste (and any other menu items)
+static int cocoaCanvasSetPosXAttrib(Ihandle* ih, const char* value)
+{
+  if (!(ih->data->sb & IUP_SB_HORIZ)) return 1;
 
-I would like to allow our custom (Canvas) Views to respond to the standard menu items.
-This means graying/not graying out, and being able to respond to the actions.
+  NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
+  if (!scroll_view) return 0;
 
-While I think it would be cool to provide direct integration with NSUndoManager for undo/redo,
-I worry the semantics won't fit well with a cross-platform program in that the user will have to
-write a lot more code to keep the undo manager aprised of the application state.
-And this code will not be easily reusable with the other platforms, so nobody will want to write it.
-(TODO: Re-evaluate other platforms and see if the modern APIs look closer to NSUndoManager.)
+  double posx;
+  if (!iupStrToDouble(value, &posx)) return 1;
 
-So instead of direct NSUndoManager integration, let's presume the user wrote their own
-cross-platform manual undo system, with typical custom functions like myundo() and myredo().
-(See 7GUI #6)
+  double xmin = iupAttribGetDouble(ih, "XMIN");
+  double xmax = iupAttribGetDouble(ih, "XMAX");
+  double dx = iupAttribGetDouble(ih, "DX");
 
-So instead, let's just override this View's responder to forward the menu events to the user's cross-platform
-custom undo/redo system.
+  double content_width = xmax - xmin;
+  double max_posx = xmax - dx;
 
-This will allow the user to reuse all their own code, and only require a little bit of additional code
-to hook into it for Cocoa.
+  if (dx >= content_width)
+  {
+    posx = xmin;
+  }
 
+  if (posx < xmin) posx = xmin;
+  if (posx > max_posx)
+  {
+    if (max_posx < xmin) max_posx = xmin;
+    posx = max_posx;
+  }
 
-We can extend this idea to cut, copy, paste as well.
+  ih->data->posx = posx;
 
-*/
+  NSScroller* scroller = [scroll_view horizontalScroller];
+  if (scroller && content_width > dx && dx > 0)
+  {
+    /* Calculate scroller position: doubleValue ranges from 0.0 to 1.0
+       0.0 = at XMIN, 1.0 = at XMAX-DX */
+    double scrollable_range = content_width - dx;
+    CGFloat double_value = (CGFloat)((posx - xmin) / scrollable_range);
 
-/*
-static BOOL iupCocoaValidateMenuItemFromActionCallback(Ihandle* ih, const char* callback_name, bool default_for_continue)
-{
-	Icallback action_callback = (Icallback)IupGetCallback(ih, callback_name);
-	if(NULL != action_callback)
-	{
-		return YES;
-	}
-	return default_for_continue;
+    if (double_value < 0.0) double_value = 0.0;
+    if (double_value > 1.0) double_value = 1.0;
+
+    iupAttribSet(ih, "_IUPCOCOA_UPDATING_SCROLL_POS", "1");
+    [scroller setDoubleValue:double_value];
+    iupAttribSet(ih, "_IUPCOCOA_UPDATING_SCROLL_POS", NULL);
+
+    /* Mark canvas as dirty to trigger redraw */
+    IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+    [canvas_view setNeedsDisplay:YES];
+  }
+
+  return 1;
 }
-*/
 
-static bool iupCocoaHelperHasCallback(Ihandle* ih, const char* callback_name)
+static int cocoaCanvasSetPosYAttrib(Ihandle* ih, const char* value)
 {
-	Icallback action_callback = (Icallback)IupGetCallback(ih, callback_name);
-	if(NULL != action_callback)
-	{
-		return true;
-	}
-	else
-	{
-		return false;
-	}
+  if (!(ih->data->sb & IUP_SB_VERT)) return 1;
+
+  NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
+  if (!scroll_view) return 0;
+
+  double posy;
+  if (!iupStrToDouble(value, &posy)) return 1;
+
+  double ymin = iupAttribGetDouble(ih, "YMIN");
+  double ymax = iupAttribGetDouble(ih, "YMAX");
+  double dy = iupAttribGetDouble(ih, "DY");
+
+  double content_height = ymax - ymin;
+  double max_posy = ymax - dy;
+
+  if (dy >= content_height)
+  {
+    posy = ymin;
+  }
+
+  if (posy < ymin) posy = ymin;
+  if (posy > max_posy)
+  {
+    if (max_posy < ymin) max_posy = ymin;
+    posy = max_posy;
+  }
+
+  ih->data->posy = posy;
+
+  NSScroller* scroller = [scroll_view verticalScroller];
+  if (scroller && content_height > dy && dy > 0)
+  {
+    /* Calculate scroller position: doubleValue ranges from 0.0 to 1.0
+       0.0 = at YMIN, 1.0 = at YMAX-DY */
+    double scrollable_range = content_height - dy;
+    CGFloat double_value = (CGFloat)((posy - ymin) / scrollable_range);
+
+    if (double_value < 0.0) double_value = 0.0;
+    if (double_value > 1.0) double_value = 1.0;
+
+    iupAttribSet(ih, "_IUPCOCOA_UPDATING_SCROLL_POS", "1");
+    [scroller setDoubleValue:double_value];
+    iupAttribSet(ih, "_IUPCOCOA_UPDATING_SCROLL_POS", NULL);
+
+    /* Mark canvas as dirty to trigger redraw */
+    IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+    [canvas_view setNeedsDisplay:YES];
+  }
+
+  return 1;
 }
 
-- (BOOL) validateMenuItem:(NSMenuItem*)menu_item
+static int cocoaCanvasSetBeginDragAttrib(Ihandle* ih, const char* value)
 {
-	// Instead of this, check for user callback, e.g. VALIDATEMENU_CB.
-	// User should return YES/NO (I can't seem to call super.)
-	// They should implement for all titles they need to support (Undo, Redo, Cut Copy Paste)
-	// Not sure how to handle localized strings
-	Ihandle* ih = _ih;
-	NSString* menu_item_title = [menu_item title];
-	const char* c_menu_item_title = [menu_item_title UTF8String];
-	
-	IFns validate_menu_callback = (IFns)IupGetCallback(ih, "VALIDATEMENU_CB");
-	int ret_val = IUP_CONTINUE;
-	if(NULL != validate_menu_callback)
-	{
-		ret_val = validate_menu_callback(ih, (char*)c_menu_item_title);
-	}
-	if(1 == ret_val)
-	{
-		return YES;
-	}
-	else if(0 == ret_val)
-	{
-		return NO;
-	}
-	else if(IUP_CONTINUE == ret_val)
-	{
-		if([menu_item_title isEqualTo:NSLocalizedString(@"Undo", @"Undo")])
-		{
-			return iupCocoaHelperHasCallback(ih, "UNDO_CB");
-		}
-		else if([menu_item_title isEqualTo:NSLocalizedString(@"Redo", @"Redo")])
-		{
-			return iupCocoaHelperHasCallback(ih, "REDO_CB");
-		}
-		else if([menu_item_title isEqualTo:NSLocalizedString(@"Cut", @"Cut")])
-		{
-		   	bool is_move = iupAttribGetBoolean(ih, "DRAGSOURCEMOVE");
-			if(is_move)
-			{
-				IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
-				NSArray* registered_types = [drag_source_data dragRegisteredTypes];
-				if((registered_types != nil) && ([registered_types count] > 0))
-				{
-					return YES;
-				}
-			}
-			return iupCocoaHelperHasCallback(ih, "CUT_CB");
-		}
-		else if([menu_item_title isEqualTo:NSLocalizedString(@"Copy", @"Copy")])
-		{
-		   	bool is_move = iupAttribGetBoolean(ih, "DRAGSOURCEMOVE");
-			if(!is_move)
-			{
-				IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
-				NSArray* registered_types = [drag_source_data dragRegisteredTypes];
-				if((registered_types != nil) && ([registered_types count] > 0))
-				{
-					return YES;
-				}
-			}
-			return iupCocoaHelperHasCallback(ih, "COPY_CB");
-		}
-		else if([menu_item_title isEqualTo:NSLocalizedString(@"Paste", @"Paste")])
-		{
-			IupTargetDropAssociatedData* target_drop_data = cocoaTargetDropGetAssociatedData(ih);
-			NSArray* registered_types = [target_drop_data dropRegisteredTypes];
-			if((registered_types != nil) && ([registered_types count] > 0))
-			{
-				return YES;
-			}
-			return iupCocoaHelperHasCallback(ih, "PASTE_CB");
-		}
-		else if([menu_item_title isEqualTo:NSLocalizedString(@"Paste and Match Style", @"Paste and Match Style")])
-		{
-			/*
-			IupTargetDropAssociatedData* target_drop_data = cocoaTargetDropGetAssociatedData(ih);
-			NSArray* registered_types = [target_drop_data dropRegisteredTypes];
-			if((registered_types != nil) && ([registered_types count] > 0))
-			{
-				return YES;
-			}
-			*/
-			return iupCocoaHelperHasCallback(ih, "PASTESTYLE_CB");
-		}
-		else
-		{
-			return NO;
-		}
-	}
-	else
-	{
-		return NO;
-	}
-	
+  IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
+  if(![drag_source_data isDragSourceEnabled]) return 1;
 
-	return NO;
+  NSDraggingItem* dragging_item = [drag_source_data defaultDraggingItem];
+  NSView* main_view = [drag_source_data mainView];
+
+  /* For file promises, ensure the user info (image representation) is set. */
+  if([drag_source_data usesFilePromise] && ![drag_source_data hasFilePromiseCallback])
+  {
+    NSFilePromiseProvider* file_promise = (NSFilePromiseProvider*)[dragging_item item];
+    NSDraggingImageComponent* image_component = [[dragging_item imageComponents] firstObject];
+    if(image_component)
+    {
+      [file_promise setUserInfo:[image_component contents]];
+    }
+    else /* Fallback to a PDF representation of the view */
+    {
+      NSData* pdf_data = [main_view dataWithPDFInsideRect:[main_view bounds]];
+      NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
+      [file_promise setUserInfo:image_data];
+      [image_data release];
+    }
+  }
+
+  NSEvent* the_event = [[NSApplication sharedApplication] currentEvent];
+  [main_view beginDraggingSessionWithItems:@[dragging_item] event:the_event source:drag_source_data];
+
+  (void)value;
+  return 1;
 }
 
-static int iupCocoaRunMenuItemActionFromCallback(Ihandle* ih, const char* callback_name)
+static char* cocoaCanvasGetCGContextAttrib(Ihandle* ih)
 {
-	Icallback action_callback = (Icallback)IupGetCallback(ih, callback_name);
-	int ret_val = IUP_CONTINUE;
-	if(NULL != action_callback)
-	{
-		ret_val = action_callback(ih);
-	}
-	return ret_val;
+  (void)ih;
+  CGContextRef cg_context = [[NSGraphicsContext currentContext] CGContext];
+  return (char*)cg_context;
 }
 
-- (void) undo:(id)the_sender
+static char* cocoaCanvasGetDrawableAttrib(Ihandle* ih)
 {
-//	NSLog(@"Undo");
- 	// Provide a new callback, e.g. MENU_CB or MENUACTION_CB or MENUITEM_CB
- 	// We can provide pre-canned strings like "UNDO", "REDO", "CUT", "COPY", "PASTE"
- 	// telling them which action they need to handle.
-	Ihandle* ih = _ih;
-	int ret_val = iupCocoaRunMenuItemActionFromCallback(ih, "UNDO_CB");
-	if(IUP_CONTINUE == ret_val)
-	{
-	}
+  return (char*)cocoaCanvasGetCGContextAttrib(ih);
 }
-- (void) redo:(id)the_sender
+
+static char* cocoaCanvasGetNSViewAttrib(Ihandle* ih)
 {
-	Ihandle* ih = _ih;
-	int ret_val = iupCocoaRunMenuItemActionFromCallback(ih, "REDO_CB");
-	if(IUP_CONTINUE == ret_val)
-	{
-	}
+  /* Return the canvas view (IupCocoaCanvasView) - needed by GLCanvas */
+  IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+  return (char*)canvas_view;
 }
-- (void) cut:(id)the_sender
+
+static char* cocoaCanvasGetDrawSizeAttrib(Ihandle *ih)
 {
-	Ihandle* ih = _ih;
-	int ret_val = iupCocoaRunMenuItemActionFromCallback(ih, "CUT_CB");
-	if(IUP_CONTINUE == ret_val)
-	{
-	}
+  IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+  NSRect the_frame = [canvas_view bounds];
+  int w = iupROUND(the_frame.size.width);
+  int h = iupROUND(the_frame.size.height);
+  return iupStrReturnIntInt(w, h, 'x');
 }
-- (void) copy:(id)the_sender
-{
-	Ihandle* ih = _ih;
-	int ret_val = iupCocoaRunMenuItemActionFromCallback(ih, "COPY_CB");
-	if(IUP_CONTINUE == ret_val)
-	{
-		IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
-		
-		NSPasteboardItem* pasteboard_item = [drag_source_data defaultPasteboardItem];
-		NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
 
-		[paste_board clearContents];
-		[paste_board writeObjects:@[pasteboard_item]];
-	}
-}
-- (void) paste:(id)the_sender
+static char* cocoaCanvasGetNativeFocusRingAttrib(Ihandle* ih)
 {
-	Ihandle* ih = _ih;
-	int ret_val = iupCocoaRunMenuItemActionFromCallback(ih, "PASTE_CB");
-	if(IUP_CONTINUE == ret_val)
-	{
-		NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
-		// TODO: Provide user a way to change the drop point value for paste (so they can differentiate from a drop if needed)
-		NSPoint drop_point = {0, 0};
-		cocoaTargetDropBasePerformDropCallback(ih, the_sender, paste_board, drop_point);
-	}
+  IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+  return iupStrReturnBoolean([canvas_view useNativeFocusRing]);
 }
 
-- (void) pasteAsPlainText:(id)the_sender
+static char* cocoaCanvasGetScrollVisibleAttrib(Ihandle* ih)
 {
-	Ihandle* ih = _ih;
-	int ret_val = iupCocoaRunMenuItemActionFromCallback(ih, "PASTESTYLE_CB");
-	if(IUP_CONTINUE == ret_val)
-	{
+  NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
+  if (!scroll_view)
+    return "NO";
 
-	}
-}
+  int scroll_visible = 0;
 
+  NSScroller* horiz_scroller = [scroll_view horizontalScroller];
+  NSScroller* vert_scroller = [scroll_view verticalScroller];
 
+  if (horiz_scroller && ![horiz_scroller isHidden])
+    scroll_visible |= 1;
+  if (vert_scroller && ![vert_scroller isHidden])
+    scroll_visible |= 2;
 
-@end
-
-
-static NSView* cocoaCanvasGetRootView(Ihandle* ih)
-{
-	NSView* root_container_view = (NSView*)ih->handle;
-	NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
-	return root_container_view;
+  if (scroll_visible == 3)
+    return "YES";
+  else if (scroll_visible == 1)
+    return "HORIZONTAL";
+  else if (scroll_visible == 2)
+    return "VERTICAL";
+  else
+    return "NO";
 }
 
-static NSScrollView* cocoaCanvasGetScrollView(Ihandle* ih)
+static int cocoaCanvasSetNativeFocusRingAttrib(Ihandle* ih, const char* value)
 {
-	if(iupAttribGetBoolean(ih, "_IUPCOCOA_CANVAS_HAS_SCROLLBAR"))
-	{
-		NSScrollView* scroll_view = (NSScrollView*)ih->handle;
-		NSCAssert([scroll_view isKindOfClass:[NSScrollView class]], @"Expected NSScrollView");
-		return scroll_view;
-	}
-	else
-	{
-		return nil;
-	}
+  IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+  [canvas_view setUseNativeFocusRing:(bool)iupStrBoolean(value)];
+  return 1;
 }
 
-static IupCocoaCanvasView* cocoaCanvasGetCanvasView(Ihandle* ih)
+static int cocoaCanvasSetContextMenuAttrib(Ihandle* ih, const char* value)
 {
-	if(iupAttribGetBoolean(ih, "_IUPCOCOA_CANVAS_HAS_SCROLLBAR"))
-	{
-		NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
-		IupCocoaCanvasView* canvas_view = (IupCocoaCanvasView*)[scroll_view documentView];
-		NSCAssert([canvas_view isKindOfClass:[IupCocoaCanvasView class]], @"Expected IupCocoaCanvasView");
-		return canvas_view;
-	}
-	else
-	{
-		IupCocoaCanvasView* canvas_view = (IupCocoaCanvasView*)ih->handle;
-		return canvas_view;
-	}
+  Ihandle* menu_ih = (Ihandle*)value;
+  IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+  iupcocoaCommonBaseSetContextMenuForWidget(ih, canvas_view, menu_ih);
+  return 1;
 }
 
-static char* cocoaCanvasGetCGContextAttrib(Ihandle* ih)
+static int cocoaCanvasMapMethod(Ihandle* ih)
 {
-	IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
-	CGContextRef cg_context = NULL;
-//	[canvas_view lockFocus];
-	// Interesting: graphicsPort is deprecated in 10.10
-	// cg_context = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
-	// Use [[NSGraphicsContext currentContext] CGContext] in 10.10+
-	cg_context = [[NSGraphicsContext currentContext] CGContext];
-//	[canvas_view unlockFocus];
-	
-	return (char*)cg_context;
-}
+  /* Create extra parent for absolute positioning of IUP children */
+  IupCocoaFixedView* extra_parent = [[IupCocoaFixedView alloc] initWithFrame:NSZeroRect];
 
-static char* cocoaCanvasGetDrawableAttrib(Ihandle* ih)
-{
-	return (char*)cocoaCanvasGetCGContextAttrib(ih);
-}
+  NSView* root_view = nil;
+  IupCocoaCanvasView* canvas_view = [[IupCocoaCanvasView alloc] initWithFrame:NSZeroRect ih:ih];
+  iupAttribSet(ih, "_IUPCOCOA_CANVAS_VIEW", (char*)canvas_view);
 
-static char* cocoaCanvasGetDrawSizeAttrib(Ihandle *ih)
-{
-	int w, h;
+  ih->data->sb = iupBaseGetScrollbar(ih);
 
-	// scrollview or canvas view?
-	IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+  NSNotificationCenter* notification_center = [NSNotificationCenter defaultCenter];
 
-	NSRect the_frame = [canvas_view frame];
-	w = iupROUND(the_frame.size.width);
-	h = iupROUND(the_frame.size.height);
-	
-	return iupStrReturnIntInt(w, h, 'x');
-}
+  if (ih->data->sb)
+  {
+    NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
 
-static char* cocoaCanvasGetNativeFocusRingAttrib(Ihandle* ih)
-{
-	IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
-	bool should_use_native = [canvas_view useNativeFocusRing];
-/*
-	struct _IdrawCanvas* dc = [canvas_view dc];
-	if(dc)
-	{
-		should_use_native = dc->useNativeFocusRing;
-	}
-*/
-	return iupStrReturnBoolean(should_use_native);
-}
+    /* Replace default NSClipView with our custom one that prevents physical scrolling */
+    IupLogicalScrollClipView* clip_view = [[IupLogicalScrollClipView alloc] initWithFrame:NSZeroRect];
+    [clip_view setDocumentView:nil];
+    [scroll_view setContentView:clip_view];
+    [clip_view release];
 
-static int cocoaCanvasSetNativeFocusRingAttrib(Ihandle* ih, const char* value)
-{
-	IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
-	bool should_use_native = (bool)iupStrBoolean(value);
+    /* Explicitly prevent the document view from resizing automatically with the scroll view.
+       Its size is managed manually in cocoaCanvasLayoutUpdateMethod based on XMAX/YMAX.
+       If the document view resizes to fit the content area, scrolling will not occur. */
+    [canvas_view setAutoresizingMask:NSViewNotSizable];
 
-	[canvas_view setUseNativeFocusRing:should_use_native];
-/*
-	struct _IdrawCanvas* dc = [canvas_view dc];
-	if(dc)
-	{
-		dc->useNativeFocusRing = should_use_native;
-	}
-*/
-	return 1;
-}
+    [scroll_view setDocumentView:canvas_view];
+    [canvas_view release];
 
-static int cocoaCanvasSetContextMenuAttrib(Ihandle* ih, const char* value)
-{
-	Ihandle* menu_ih = (Ihandle*)value;
- 	IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
-	iupCocoaCommonBaseSetContextMenuForWidget(ih, canvas_view, menu_ih);
+    /* Disable automatic scrollbar hiding and let IUP manage it explicitly
+       based on DX/DY and AUTOHIDE attributes. */
+    [scroll_view setAutohidesScrollers:NO];
 
-	return 1;
-}
 
+    [scroll_view setHasHorizontalScroller:(ih->data->sb & IUP_SB_HORIZ)];
+    [scroll_view setHorizontalScrollElasticity:NSScrollElasticityNone];
+    [scroll_view setHasVerticalScroller:(ih->data->sb & IUP_SB_VERT)];
+    [scroll_view setVerticalScrollElasticity:NSScrollElasticityNone];
+    [scroll_view setBorderType:iupAttribGetBoolean(ih, "BORDER") ? NSBezelBorder : NSNoBorder];
+    [scroll_view setDrawsBackground:NO];
 
+    /* Set up scroller action handlers to detect user dragging */
+    if (ih->data->sb & IUP_SB_HORIZ)
+    {
+      NSScroller* h_scroller = [scroll_view horizontalScroller];
+      [h_scroller setTarget:canvas_view];
+      [h_scroller setAction:@selector(scrollerAction:)];
+    }
+    if (ih->data->sb & IUP_SB_VERT)
+    {
+      NSScroller* v_scroller = [scroll_view verticalScroller];
+      [v_scroller setTarget:canvas_view];
+      [v_scroller setAction:@selector(scrollerAction:)];
+    }
 
-static int cocoaCanvasMapMethod(Ihandle* ih)
-{
-	NSView* root_view = nil;
-	IupCocoaCanvasView* canvas_view = [[IupCocoaCanvasView alloc] initWithFrame:NSZeroRect ih:ih];
-	
-	if(iupAttribGetBoolean(ih, "SCROLLBAR"))
-	{
-		NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
-		[scroll_view setDocumentView:canvas_view];
-		[canvas_view release];
-		[scroll_view setHasVerticalScroller:YES];
-	
-		[scroll_view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
-		[canvas_view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
-		
-		root_view = scroll_view;
-		iupAttribSet(ih, "_IUPCOCOA_CANVAS_HAS_SCROLLBAR", "1");
-	}
-	else
-	{
-		root_view = canvas_view;
-	}
-	
-	
-	ih->handle = root_view;
+    /* For logical scrolling, DON'T observe clip view frame changes
+       The clip view changes size when scrollbars appear/disappear,
+       which would cause RESIZE_CB to fire with inconsistent DX/DY values
+       Instead, observe the scroll view frame changes (window resize only) */
+    [scroll_view setPostsFrameChangedNotifications:YES];
+    [notification_center addObserver:canvas_view
+                            selector:@selector(frameDidChangeNotification:)
+                                name:NSViewFrameDidChangeNotification
+                              object:scroll_view];
 
-	
-	iupCocoaSetAssociatedViews(ih, canvas_view, root_view);
+    /* Register for window move/screen changes (for OpenGL context updates) */
+    [notification_center addObserver:canvas_view
+                            selector:@selector(globalFrameDidChangeNotification:)
+                                name:NSWindowDidMoveNotification
+                              object:nil];
+    [notification_center addObserver:canvas_view
+                            selector:@selector(globalFrameDidChangeNotification:)
+                                name:NSWindowDidChangeScreenNotification
+                              object:nil];
 
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
-	
-	
-	IupSourceDragAssociatedData* source_drag_associated_data = cocoaSourceDragCreateAssociatedData(ih, canvas_view, root_view);
-	IupTargetDropAssociatedData* target_drop_associated_data = cocoaTargetDropCreateAssociatedData(ih,  canvas_view, root_view);
+    /* Register for scroll notifications to trigger SCROLL_CB. */
+    [clip_view setPostsBoundsChangedNotifications:YES];
+    [notification_center addObserver:canvas_view
+                            selector:@selector(boundsDidChangeNotification:)
+                                name:NSViewBoundsDidChangeNotification
+                              object:clip_view];
 
-	[source_drag_associated_data setDefaultFilePromiseName:@"IupCanvas.png"];
-//	[source_drag_associated_data setUseAutoBeginDrag:true];
-	
-	
-	// Ideally, we want IUP to automatically do the thing that gives users the best experience because devs may not know enough to turn on the right features.
-	// Native Focus Rings are one of those things that seem to provide the best user experience.
-	// But due to an Apple bug, the native focus ring causes draw corruption unless layerbacked is enabled.
-	// Historically, enabling layer backed views has been known to cause various problems.
-	// And even today, layer backed views are still off by default.
-	// So I'm hesitent to turn them on by default.
-	// Additionally, the Canvas drawing is classic CoreGrpahics, CPU based, so this is not necessarily the greatest performance path to take.
-	// But layer backed seems to be getting better over time, and this is a case where we need it on in order to work correctly.
-	// So for the fake widget case, I think we should turn on native focus rings.
-	// For regular, I'm less certain.
-	// But maybe we should only activate if needsPanelToBecomeKey (FOCUSMODE) is true, because that is the only time we care about the focus ring.
-/*
-	if(IupClassMatch(ih, "canvas"))
-	{
-		IupSetAttribute(ih, "LAYERBACKED", "YES");
-		IupSetAttribute(ih, "NATIVEFOCUSRING", "YES");
-	}
-	else
-	{
-		IupSetAttribute(ih, "LAYERBACKED", "YES");
-		IupSetAttribute(ih, "NATIVEFOCUSRING", "YES");
-	}
-*/
+    root_view = scroll_view;
+    iupAttribSet(ih, "_IUPCOCOA_CANVAS_HAS_SCROLLBAR", "1");
+  }
+  else
+  {
+    /* Standalone canvas setup.
+       Observe frame changes on the canvas_view itself (RESIZE_CB). */
+    [canvas_view setPostsFrameChangedNotifications:YES];
+    [notification_center addObserver:canvas_view
+                            selector:@selector(frameDidChangeNotification:)
+                                name:NSViewFrameDidChangeNotification
+                              object:canvas_view];
 
-	
-	return IUP_NOERROR;
+    /* Register for window move/screen changes (for OpenGL context updates) */
+    [notification_center addObserver:canvas_view
+                            selector:@selector(globalFrameDidChangeNotification:)
+                                name:NSWindowDidMoveNotification
+                              object:nil];
+    [notification_center addObserver:canvas_view
+                            selector:@selector(globalFrameDidChangeNotification:)
+                                name:NSWindowDidChangeScreenNotification
+                              object:nil];
+
+    [canvas_view setPostsBoundsChangedNotifications:YES];
+    root_view = canvas_view;
+  }
+
+  /* Add the root_view (canvas or scrollview) as subview of extra_parent */
+  [extra_parent addSubview:root_view];
+
+  /* ih->handle is the extra_parent (for layout positioning). The actual canvas/scrollview is stored in the attributes. */
+  ih->handle = extra_parent;
+  iupAttribSet(ih, "_IUP_EXTRAPARENT", (char*)extra_parent);
+  iupAttribSet(ih, "_IUPCOCOA_CANVAS_ROOT", (char*)root_view);
+
+  iupcocoaSetAssociatedViews(ih, canvas_view, extra_parent);
+
+  iupcocoaAddToParent(ih);
+
+  /* Setup Drag and Drop */
+  IupSourceDragAssociatedData* source_drag = cocoaSourceDragCreateAssociatedData(ih, canvas_view, root_view);
+  cocoaTargetDropCreateAssociatedData(ih, canvas_view, root_view);
+  [source_drag setDefaultFilePromiseName:@"IupCanvas.png"];
+
+  /* Set initial BGCOLOR */
+  cocoaCanvasSetBgColorAttrib(ih, iupAttribGet(ih, "BGCOLOR"));
+
+  /* Set initial Scrollbar state */
+  cocoaCanvasSetDXAttrib(ih, NULL);
+  cocoaCanvasSetDYAttrib(ih, NULL);
+
+  return IUP_NOERROR;
 }
 
 static void cocoaCanvasUnMapMethod(Ihandle* ih)
 {
-	id root_view = ih->handle;
-	
-	
-	cocoaTargetDropDestroyAssociatedData(ih);
-	cocoaSourceDragDestroyAssociatedData(ih);
-	
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-	
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[root_view release];
-	ih->handle = NULL;
+  IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+
+  if (canvas_view)
+  {
+    [[NSNotificationCenter defaultCenter] removeObserver:canvas_view];
+  }
+
+  if (ih->data->sb)
+  {
+    NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
+    if (scroll_view)
+    {
+      NSScroller* h_scroller = [scroll_view horizontalScroller];
+      NSScroller* v_scroller = [scroll_view verticalScroller];
+      if (h_scroller)
+        [h_scroller setTarget:nil];
+      if (v_scroller)
+        [v_scroller setTarget:nil];
+    }
+  }
+
+  cocoaTargetDropDestroyAssociatedData(ih);
+  cocoaSourceDragDestroyAssociatedData(ih);
+
+  Ihandle* context_menu_ih = (Ihandle*)iupcocoaCommonBaseGetContextMenuAttrib(ih);
+  if(context_menu_ih)
+  {
+    IupDestroy(context_menu_ih);
+  }
+  iupcocoaCommonBaseSetContextMenuAttrib(ih, NULL);
+
+  iupcocoaRemoveFromParent(ih);
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+
+  /* ih->handle is the extra_parent which contains the canvas_root */
+  NSView* extra_parent = (NSView*)ih->handle;
+  if (extra_parent)
+  {
+    [extra_parent release];
+  }
+
+  ih->handle = NULL;
+  iupAttribSet(ih, "_IUPCOCOA_CANVAS_VIEW", NULL);
+  iupAttribSet(ih, "_IUP_EXTRAPARENT", NULL);
+  iupAttribSet(ih, "_IUPCOCOA_CANVAS_ROOT", NULL);
 }
 
+static void cocoaCanvasLayoutUpdateMethod(Ihandle *ih)
+{
+  /* First call the base layout update to position the extra_parent */
+  iupdrvBaseLayoutUpdateMethod(ih);
 
+  /* Now resize the canvas_root to fill the extra_parent */
+  NSView* canvas_root = (NSView*)iupAttribGet(ih, "_IUPCOCOA_CANVAS_ROOT");
 
+  if (canvas_root)
+  {
+    [canvas_root setFrame:NSMakeRect(0, 0, ih->currentwidth, ih->currentheight)];
+  }
 
-void iupdrvCanvasInitClass(Iclass* ic)
+  if (ih->data->sb)
+  {
+    /* For logical scrolling, keep document view (canvas) at a fixed size
+       The size should match ih->currentwidth x ih->currentheight (IUP's calculated size) */
+    NSScrollView* scroll_view = cocoaCanvasGetScrollView(ih);
+    IupCocoaCanvasView* canvas_view = cocoaCanvasGetCanvasView(ih);
+    if (scroll_view && canvas_view)
+    {
+      NSSize canvas_size = NSMakeSize(ih->currentwidth, ih->currentheight);
+
+      [canvas_view setFrameSize:canvas_size];
+
+      /* Force scroll view to update scroller display without changing document size */
+      [scroll_view tile];
+    }
+
+    /* Update scrollbar visibility/enabled state based on layout.
+       These functions manually set knobProportion based on DX/DY */
+    cocoaCanvasSetDXAttrib(ih, NULL);
+    cocoaCanvasSetDYAttrib(ih, NULL);
+
+    /* Re-apply knobProportion after tile (which may have reset it) */
+    if (scroll_view)
+    {
+      [scroll_view tile];
+      cocoaCanvasSetDXAttrib(ih, NULL);
+      cocoaCanvasSetDYAttrib(ih, NULL);
+    }
+  }
+}
+
+static void cocoaCanvasComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *expand)
 {
-	/* Driver Dependent Class functions */
-	ic->Map = cocoaCanvasMapMethod;
-	ic->UnMap = cocoaCanvasUnMapMethod;
-#if 0
-	ic->LayoutUpdate = gtkCanvasLayoutUpdateMethod;
-	
-	/* Driver Dependent Attribute functions */
-#endif
-	/* Visual */
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, "255 255 255", NULL, IUPAF_DEFAULT);  /* force new default value */
+  /*
+     IUP core layout computes natural size from SIZE and RASTERSIZE
+     and stores it in ih->naturalwidth, ih->naturalheight.
+     */
+  int natural_w = ih->naturalwidth;
+  int natural_h = ih->naturalheight;
 
-#if 0
-	/* IupCanvas only */
-#endif
-	iupClassRegisterAttribute(ic, "DRAWSIZE", cocoaCanvasGetDrawSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
-	
-#if 0
-	iupClassRegisterAttribute(ic, "DX", NULL, gtkCanvasSetDXAttrib, NULL, NULL, IUPAF_NO_INHERIT);  /* force new default value */
-	iupClassRegisterAttribute(ic, "DY", NULL, gtkCanvasSetDYAttrib, NULL, NULL, IUPAF_NO_INHERIT);  /* force new default value */
-	iupClassRegisterAttribute(ic, "POSX", iupCanvasGetPosXAttrib, gtkCanvasSetPosXAttrib, "0", NULL, IUPAF_NO_INHERIT);  /* force new default value */
-	iupClassRegisterAttribute(ic, "POSY", iupCanvasGetPosYAttrib, gtkCanvasSetPosYAttrib, "0", NULL, IUPAF_NO_INHERIT);  /* force new default value */
-#endif
-	
-	// TODO: Returns the CGContext. Is this the right thing, or should it be the NSGraphicsContext? Or should it be the NSView?
-	iupClassRegisterAttribute(ic, "DRAWABLE", cocoaCanvasGetDrawableAttrib, NULL, NULL, NULL, IUPAF_NO_STRING);
+  /* If no size is specified, use a default minimum size */
+  if (natural_w == 0) natural_w = 1;
+  if (natural_h == 0) natural_h = 1;
 
-	// Private helper, used by iupdrvDrawCreateCanvas and currently cocoaCanvasGetDrawableAttrib calls this.
-	// Do not start with an underscore, because I need this to trigger the function
-	iupClassRegisterAttribute(ic, "CGCONTEXT", cocoaCanvasGetCGContextAttrib, NULL, NULL, NULL, IUPAF_NO_STRING);
+  *w = natural_w;
+  *h = natural_h;
+  *expand = iupAttribGetBoolean(ih, "EXPAND");
 
-#if 0
-	/* IupCanvas Windows or X only */
-#ifndef GTK_MAC
-#ifdef WIN32
-	iupClassRegisterAttribute(ic, "HWND", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);
-#else
-	iupClassRegisterAttribute(ic, "XWINDOW", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_NO_STRING);
-	iupClassRegisterAttribute(ic, "XDISPLAY", (IattribGetFunc)iupdrvGetDisplay, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);
-#endif
-#endif
-	
-	/* Not Supported */
-	iupClassRegisterAttribute(ic, "BACKINGSTORE", NULL, NULL, "YES", NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-#endif
+  /* Add space for scrollbars if they are visible */
+  if (ih->data->sb)
+  {
+    int sb_size = iupdrvGetScrollbarSize();
+    if ((ih->data->sb & IUP_SB_VERT) && !iupAttribGetBoolean(ih, "YHIDDEN"))
+      *w += sb_size;
+    if ((ih->data->sb & IUP_SB_HORIZ) && !iupAttribGetBoolean(ih, "XHIDDEN"))
+      *h += sb_size;
+  }
+}
 
-//	TODO:
-//	iupClassRegisterAttribute(ic, "TOUCH", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+static void* cocoaCanvasGetInnerNativeContainerHandleMethod(Ihandle* ih, Ihandle* child)
+{
+  (void)child;
+  /* Return the extra_parent view for absolute positioning of child elements */
+  NSView* extra_parent = (NSView*)iupAttribGet(ih, "_IUP_EXTRAPARENT");
+  if (extra_parent)
+    return (void*)extra_parent;
+  return ih->handle;
+}
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, cocoaCanvasSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+void iupdrvCanvasInitClass(Iclass* ic)
+{
+  /* Driver Dependent Class functions */
+  ic->Map = cocoaCanvasMapMethod;
+  ic->UnMap = cocoaCanvasUnMapMethod;
+  ic->LayoutUpdate = cocoaCanvasLayoutUpdateMethod;
+  ic->ComputeNaturalSize = cocoaCanvasComputeNaturalSizeMethod;
+  ic->GetInnerNativeContainerHandle = cocoaCanvasGetInnerNativeContainerHandleMethod;
 
-	iupClassRegisterAttribute(ic, "NATIVEFOCUSRING", cocoaCanvasGetNativeFocusRingAttrib, cocoaCanvasSetNativeFocusRingAttrib, NULL, "NO", IUPAF_DEFAULT);
+  /* Visual */
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, cocoaCanvasSetBgColorAttrib, "232 232 232", NULL, IUPAF_DEFAULT);
 
-	// TODO: We need a layer backed API for everything. But especially for here to workaround the native focus ring rendering corruption.
-	iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupCocoaCommonBaseSetLayerBackedAttrib, NULL,  NULL, IUPAF_NO_DEFAULTVALUE);
+  /* IupCanvas only */
+  iupClassRegisterAttribute(ic, "DRAWSIZE", cocoaCanvasGetDrawSizeAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
 
+  /* Scrollbar attributes */
+  iupClassRegisterAttribute(ic, "DX", NULL, cocoaCanvasSetDXAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DY", NULL, cocoaCanvasSetDYAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "POSX", iupCanvasGetPosXAttrib, cocoaCanvasSetPosXAttrib, "0", NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "POSY", iupCanvasGetPosYAttrib, cocoaCanvasSetPosYAttrib, "0", NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "XAUTOHIDE", NULL, NULL, "YES", NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "YAUTOHIDE", NULL, NULL, "YES", NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", cocoaCanvasGetScrollVisibleAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
 
-	iupClassRegisterCallback(ic, "VALIDATEMENU_CB", "s");
-	iupClassRegisterCallback(ic, "UNDO_CB", "");
-	iupClassRegisterCallback(ic, "REDO_CB", "");
-	iupClassRegisterCallback(ic, "CUT_CB", "");
-	iupClassRegisterCallback(ic, "COPY_CB", "");
-	iupClassRegisterCallback(ic, "PASTE_CB", "");
-	iupClassRegisterCallback(ic, "PASTESTYLE_CB", "");
-	
-	iupClassRegisterAttribute(ic, "SENDACTION", NULL, iupCocoaCommonBaseSetSendActionAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+  /* Platform specific */
+  iupClassRegisterAttribute(ic, "DRAWABLE", cocoaCanvasGetDrawableAttrib, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "CGCONTEXT", cocoaCanvasGetCGContextAttrib, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "NSVIEW", cocoaCanvasGetNSViewAttrib, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT|IUPAF_READONLY);
 
-	// EXPERIMENTAL: May not work because it uses currentEvent. This is an override of cocoaSourceDragSetBeginDragAttrib
-  iupClassRegisterAttribute(ic, "DRAGINITIATE", NULL, cocoaCanvasSetBeginDragAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+  /* Focus ring support */
+  iupClassRegisterAttribute(ic, "NATIVEFOCUSRING", cocoaCanvasGetNativeFocusRingAttrib, cocoaCanvasSetNativeFocusRingAttrib, "NO", NULL, IUPAF_NO_INHERIT);
 
+  /* Drag and drop */
+  iupClassRegisterAttribute(ic, "DRAGINITIATE", NULL, cocoaCanvasSetBeginDragAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "AUTOBEGINDRAG", NULL, NULL, "NO", NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SENDACTION", NULL, iupcocoaCommonBaseSetSendActionAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+
+  /* Not Supported */
+  iupClassRegisterAttribute(ic, "BACKINGSTORE", NULL, NULL, "YES", NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+
+  /* Layer backing */
+  iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupcocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_clipboard.m
===================================================================
--- src/cocoa/iupcocoa_clipboard.m	(revision 5971)
+++ src/cocoa/iupcocoa_clipboard.m	(working copy)
@@ -1,310 +1,361 @@
 /** \file
- * \brief Clipboard for the GTK Driver.
+ * \brief Clipboard for the Cocoa Driver.
  *
  * See Copyright Notice in "iup.h"
  */
 
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <memory.h>
+#include <string.h>
 
 #import <Cocoa/Cocoa.h>
 
 #include "iup.h"
-
 #include "iup_object.h"
 #include "iup_attrib.h"
 #include "iup_str.h"
 #include "iup_image.h"
-
 #include "iupcocoa_drv.h"
 
 
-// The only reason we have this class is  because ADDFORMAT requires us to carry state around.
-// Cocoa doesn't have an ADD API, so we have to manually save/accumulate all the values.
-@interface IupClipboardState : NSObject
-@property(nonatomic, assign) Ihandle* ihandle;
-@property(nonatomic, copy) NSArray* arrayOfTypes;
-@end
 
-@implementation IupClipboardState
+static int cocoaClipboardSetTextAttrib(Ihandle* ih, const char* value)
+{
+  (void)ih;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
 
-- (void) dealloc
-{
-	[self setIhandle:NULL];
-	[self setArrayOfTypes:nil];
-	[super dealloc];
+  if (!value)
+  {
+    [paste_board clearContents];
+    return 0;
+  }
+
+  NSString* ns_string = [NSString stringWithUTF8String:value];
+  if (!ns_string)
+  {
+    ns_string = @"";
+  }
+
+  [paste_board clearContents];
+  [paste_board writeObjects:@[ns_string]];
+
+  return 0;
 }
 
-@end
+static char* cocoaClipboardGetTextAttrib(Ihandle* ih)
+{
+  (void)ih;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSString* type_available = [paste_board availableTypeFromArray:@[NSPasteboardTypeString]];
 
+  if (type_available)
+  {
+    NSString* pasteboard_string = [paste_board stringForType:NSPasteboardTypeString];
+    return iupStrReturnStr([pasteboard_string UTF8String]);
+  }
 
+  return NULL;
+}
+
 static char* cocoaClipboardGetTextAvailableAttrib(Ihandle* ih)
 {
-	(void)ih;
-	
-	NSPasteboard* paste_board;
-	NSString* type_available;
+  (void)ih;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSString* type_available = [paste_board availableTypeFromArray:@[NSPasteboardTypeString]];
+  return iupStrReturnBoolean(type_available != nil);
+}
 
-	paste_board = [NSPasteboard generalPasteboard];
-	/* Ask if this kind of data is available on the paste board? */
-	type_available = [paste_board availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]];
-	return iupStrReturnBoolean((int)type_available);
+static int cocoaClipboardSetImageAttrib(Ihandle* ih, const char* value)
+{
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
 
+  if (!value)
+  {
+    [paste_board clearContents];
+    return 0;
+  }
+
+  NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
+  if (ns_image)
+  {
+    [paste_board clearContents];
+    [paste_board writeObjects:@[ns_image]];
+  }
+
+  return 0;
 }
 
-static int cocoaClipboardSetTextAttrib(Ihandle* ih, const char* value)
+static int cocoaClipboardSetNativeImageAttrib(Ihandle* ih, const char* value)
 {
-	NSPasteboard* paste_board;
-	
-	
-	NSString* ns_string = nil;
-	if(value)
-	{
-		// This will return nil if the string can't be converted.
-		ns_string = [NSString stringWithUTF8String:value];
-	}
-	else
-	{
-		ns_string = @"";
-	}
-	
-	paste_board = [NSPasteboard generalPasteboard];
-	[paste_board declareTypes:[NSArray arrayWithObject:NSStringPboardType] owner:nil];
-	
-	/* Note: Assuming null terminated C string here. src_len is ignored. */
-	[paste_board setString:ns_string forType:NSStringPboardType];
-	
-	return 0;
+  (void)ih;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  [paste_board clearContents];
+
+  if (value)
+  {
+    NSImage* ns_image = (NSImage*)value;
+    [paste_board writeObjects:@[ns_image]];
+  }
+
+  return 0;
 }
 
-static char* cocoaClipboardGetTextAttrib(Ihandle* ih)
+static char* cocoaClipboardGetNativeImageAttrib(Ihandle* ih)
 {
-	NSPasteboard* paste_board;
-	NSString* type_available;
-	NSString* pasteboard_string = nil;
+  (void)ih;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSArray* valid_classes = @[[NSImage class]];
+  NSDictionary* options_dict = @{};
 
-	paste_board = [NSPasteboard generalPasteboard];
-	/* Ask if this kind of data is available on the paste board? */
-	type_available = [paste_board availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]];
-	if(type_available)
-//	if([type_available isEqualToString:NSStringPboardType])
-	{
-		/* Get the text string from the pasteboard */
-		pasteboard_string = [paste_board stringForType:NSStringPboardType];
-	}
-	return iupStrReturnStr([pasteboard_string UTF8String]);
+  if ([paste_board canReadObjectForClasses:valid_classes options:options_dict])
+  {
+    NSArray* array_of_objects = [paste_board readObjectsForClasses:valid_classes options:options_dict];
+    if ([array_of_objects count] > 0)
+    {
+      NSImage* ns_image = (NSImage*)[array_of_objects firstObject];
+      return (char*)ns_image;
+    }
+  }
+
+  return NULL;
 }
 
-
 static char* cocoaClipboardGetImageAvailableAttrib(Ihandle* ih)
 {
-	(void)ih;
-	
-	NSPasteboard* paste_board;
-	NSString* type_available;
+  (void)ih;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSString* type_available = [paste_board availableTypeFromArray:[NSImage imageTypes]];
+  return iupStrReturnBoolean(type_available != nil);
+}
 
-	paste_board = [NSPasteboard generalPasteboard];
-	/* Ask if this kind of data is available on the paste board? */
-	type_available = [paste_board availableTypeFromArray:[NSArray arrayWithObjects:NSPasteboardTypeTIFF, NSPasteboardTypePNG, nil]];
-	return iupStrReturnBoolean((int)type_available);
+static int cocoaClipboardSetNativeVectorImageAttrib(Ihandle *ih, const char *value)
+{
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
 
+  if (!value)
+  {
+    [paste_board clearContents];
+    return 0;
+  }
+
+  int data_size = iupAttribGetInt(ih, "FORMATDATASIZE");
+  if (data_size > 0)
+  {
+    [paste_board clearContents];
+    NSData* pdf_data = [NSData dataWithBytes:value length:data_size];
+    [paste_board setData:pdf_data forType:NSPasteboardTypePDF];
+  }
+
+  return 0;
 }
 
-static int cocoaClipboardSetNativeImageAttrib(Ihandle* ih, const char* value)
+static char* cocoaClipboardGetNativeVectorImageAttrib(Ihandle *ih)
 {
-	NSPasteboard* paste_board;
-	paste_board = [NSPasteboard generalPasteboard];
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSData* pdf_data = [paste_board dataForType:NSPasteboardTypePDF];
 
-	NSImage* ns_image = nil;
-	if(value)
-	{
-		ns_image = (NSImage*)value;
-		[paste_board writeObjects:@[ns_image]];
-	}
-	else
-	{
-		[paste_board clearContents];
-	}
-	return 0;
+  if (!pdf_data)
+  {
+    iupAttribSetInt(ih, "FORMATDATASIZE", 0);
+    return NULL;
+  }
+
+  NSUInteger data_size = [pdf_data length];
+  if (data_size == 0)
+  {
+    iupAttribSetInt(ih, "FORMATDATASIZE", 0);
+    return NULL;
+  }
+
+  void* data_buffer = iupStrGetMemory((int)data_size);
+  memcpy(data_buffer, [pdf_data bytes], data_size);
+
+  iupAttribSetInt(ih, "FORMATDATASIZE", (int)data_size);
+  return (char*)data_buffer;
 }
 
-static char* cocoaClipboardGetNativeImageAttrib(Ihandle* ih)
+static char* cocoaClipboardGetPDFAvailableAttrib(Ihandle* ih)
 {
-	NSPasteboard* paste_board;
-	paste_board = [NSPasteboard generalPasteboard];
-	NSArray* valid_classes = @[[NSImage class]];
-	NSDictionary* options_dict = @{};
-	BOOL has_objects = [paste_board canReadObjectForClasses:valid_classes options:options_dict];
-	if(has_objects)
-	{
-		NSArray* array_of_objects = [paste_board readObjectsForClasses:valid_classes options:options_dict];
-		if([array_of_objects count] > 0)
-		{
-			NSImage* ns_image = (NSImage*)[array_of_objects firstObject];
-			[ns_image retain]; // API says user needs to call release on this
-			return (char*)ns_image;
-		}
-	}
-	return NULL;
+  (void)ih;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSString* type_available = [paste_board availableTypeFromArray:@[NSPasteboardTypePDF]];
+  return iupStrReturnBoolean(type_available != nil);
 }
 
-static int cocoaClipboardSetImageAttrib(Ihandle* ih, const char* value)
+static int cocoaClipboardSetSaveNativeVectorImageAttrib(Ihandle* ih, const char* value)
 {
-	NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
-	if(NULL == value)
-	{
-		[paste_board clearContents];
-		return 0;
-	}
+  (void)ih;
+  if (!value)
+  {
+    return 0;
+  }
 
-	NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
-	[paste_board writeObjects:@[ns_image]];
-	return 0;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSData* pdf_data = [paste_board dataForType:NSPasteboardTypePDF];
+
+  if (pdf_data)
+  {
+    NSString* path = [NSString stringWithUTF8String:value];
+    [pdf_data writeToFile:path atomically:NO];
+  }
+
+  return 0;
 }
 
 static int cocoaClipboardSetAddFormatAttrib(Ihandle* ih, const char* value)
 {
-	if(NULL == ih)
-	{
-		return 0;
-	}
-	if(NULL == value)
-	{
-		return 0;
-	}
-	
-	NSString* new_type = [NSString stringWithUTF8String:value];
-	
-	IupClipboardState* iup_clipboard_state = ih->handle;
-	NSArray* new_array = [[iup_clipboard_state arrayOfTypes] arrayByAddingObject:new_type];
-	[iup_clipboard_state setArrayOfTypes:new_array];
+  (void)ih;
 
-	return 0;
+  if (!value)
+    return 0;
+
+  /* Custom pasteboard types on macOS don't require explicit registration. */
+  /* They are identified by strings, typically Uniform Type Identifiers (UTIs). */
+  /* Validation occurs when the format is used in FORMATDATA operations. */
+
+  return 0;
 }
 
-static char* cocoaClipboardGetFormatAvailableAttrib(Ihandle* ih)
+static int cocoaClipboardSetFormatDataAttrib(Ihandle* ih, const char* value)
 {
-	NSPasteboard* paste_board;
-	NSString* type_available;
+  if (!ih)
+  {
+    return 0;
+  }
 
-	IupClipboardState* iup_clipboard_state = ih->handle;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
 
-	paste_board = [NSPasteboard generalPasteboard];
-	/* Ask if this kind of data is available on the paste board? */
-	type_available = [paste_board availableTypeFromArray:[iup_clipboard_state arrayOfTypes]];
-	return iupStrReturnBoolean((int)type_available);
-}
+  if (!value)
+  {
+    [paste_board clearContents];
+    return 0;
+  }
 
+  char* format = iupAttribGetStr(ih, "FORMAT");
+  if (!format)
+  {
+    return 0;
+  }
 
-static int cocoaClipboardSetFormatDataAttrib(Ihandle* ih, const char* value)
-{
-	if(NULL == ih)
-	{
-		return 0;
-	}
-	NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
-	if(NULL == value)
-	{
-		[paste_board clearContents];
-		return 0;
-	}
+  int data_size = iupAttribGetInt(ih, "FORMATDATASIZE");
+  if (data_size <= 0)
+  {
+    return 0;
+  }
 
+  NSString* format_string = [NSString stringWithUTF8String:format];
+  if (!format_string)
+  {
+    return 0;
+  }
 
-	int data_size = iupAttribGetInt(ih, "FORMATDATASIZE");
-	if(data_size <= 0)
-	{
-		return 0;
-	}
+  NSData* ns_data = [[NSData alloc] initWithBytes:value length:data_size];
+  [paste_board clearContents];
+  [paste_board setData:ns_data forType:format_string];
+  [ns_data release];
 
-	IupClipboardState* iup_clipboard_state = ih->handle;
-	[paste_board declareTypes:[iup_clipboard_state arrayOfTypes] owner:nil];
-	
-	NSData* ns_data = [[NSData alloc] initWithBytes:value length:data_size];
-	[ns_data autorelease];
-	
-	// I'm not sure how to use writeObjects in a way that preserves the type mapping.
-	// So doing it the slow, legacy way.
-	// Remember, this is copying the data now, instead of lazily, unlike the new way.
-	for(NSString* a_type in [iup_clipboard_state arrayOfTypes])
-	{
-		[paste_board setData:ns_data forType:a_type];
-	}
-
-	return 0;
+  return 0;
 }
 
 static char* cocoaClipboardGetFormatDataAttrib(Ihandle* ih)
 {
-	if(NULL == ih)
-	{
-		return 0;
-	}
-	NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  if (!ih)
+  {
+    return NULL;
+  }
 
-	IupClipboardState* iup_clipboard_state = ih->handle;
-	
-	NSData* ns_data = nil;
-	for(NSString* a_type in [iup_clipboard_state arrayOfTypes])
-	{
-		ns_data = [paste_board dataForType:a_type];
-		if(nil != ns_data)
-		{
-			break;
-		}
-	}
+  char* format = iupAttribGetStr(ih, "FORMAT");
+  if (!format)
+  {
+    return NULL;
+  }
 
-	if(nil == ns_data)
-	{
-		iupAttribSetInt(ih, "FORMATDATASIZE", 0);
-		return NULL;
-	}
+  NSString* format_string = [NSString stringWithUTF8String:format];
+  if (!format_string)
+  {
+    return NULL;
+  }
 
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSData* ns_data = [paste_board dataForType:format_string];
 
-	NSUInteger data_size = [ns_data length];
-	void* data_buffer = iupStrGetMemory((int)data_size);
+  if (!ns_data)
+  {
+    iupAttribSetInt(ih, "FORMATDATASIZE", 0);
+    return NULL;
+  }
 
-	memcpy(data_buffer, [ns_data bytes], data_size);
+  NSUInteger data_size = [ns_data length];
+  if (data_size == 0)
+  {
+    iupAttribSetInt(ih, "FORMATDATASIZE", 0);
+    return NULL;
+  }
 
-	iupAttribSetInt(ih, "FORMATDATASIZE", (int)data_size);
-	return data_buffer;
+  void* data_buffer = iupStrGetMemory((int)data_size + 1);
+  memcpy(data_buffer, [ns_data bytes], data_size);
+
+  iupAttribSetInt(ih, "FORMATDATASIZE", (int)data_size);
+  return (char*)data_buffer;
 }
 
-/*
-static int cocoaClipboardSetClearAttrib(Ihandle* ih, const char* value)
+static char* cocoaClipboardGetFormatAvailableAttrib(Ihandle* ih)
 {
-	NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
-	[paste_board clearContents];
-	return 0;
-}
-*/
+  if (!ih)
+  {
+    return NULL;
+  }
 
+  char* format = iupAttribGetStr(ih, "FORMAT");
+  if (!format)
+  {
+    return iupStrReturnBoolean(0);
+  }
 
-/******************************************************************************/
+  NSString* format_string = [NSString stringWithUTF8String:format];
+  if (!format_string)
+  {
+    return iupStrReturnBoolean(0);
+  }
 
-Ihandle* IupClipboard(void)
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSString* type_available = [paste_board availableTypeFromArray:@[format_string]];
+  return iupStrReturnBoolean(type_available != nil);
+}
+
+static int cocoaClipboardSetFormatDataStringAttrib(Ihandle* ih, const char* value)
 {
-  return IupCreate("clipboard");
+  if (value)
+  {
+    int len = (int)strlen(value);
+    iupAttribSetInt(ih, "FORMATDATASIZE", len + 1); /* include the terminator */
+    return cocoaClipboardSetFormatDataAttrib(ih, value);
+  }
+  else
+  {
+    return cocoaClipboardSetFormatDataAttrib(ih, NULL);
+  }
 }
 
-// We need Create/Destroy because ADDFORMAT requires us to carry state around. Cocoa doesn't have an ADD API, so we have to manually save/accumulate all the values.
-static int cocoaClipboardCreateMethod(Ihandle* ih, void** params)
+static char* cocoaClipboardGetFormatDataStringAttrib(Ihandle* ih)
 {
-	IupClipboardState* iup_clipboard_state = [[IupClipboardState alloc] init];
-	
-	ih->handle = iup_clipboard_state;
-	[iup_clipboard_state setIhandle:ih];
-	
-	
-	return IUP_NOERROR;
+  char* data = cocoaClipboardGetFormatDataAttrib(ih);
+  if (!data)
+  {
+    return NULL;
+  }
+
+  int size = iupAttribGetInt(ih, "FORMATDATASIZE");
+  data[size] = 0;
+  return iupStrReturnStr(data);
 }
 
-static void cocoaClipboardDestroyMethod(Ihandle* ih)
+/******************************************************************************/
+
+IUP_API Ihandle* IupClipboard(void)
 {
-	IupClipboardState* iup_clipboard_state = ih->handle;
-	[iup_clipboard_state release];
-	ih->handle = nil;
+  return IupCreate("clipboard");
 }
 
 Iclass* iupClipboardNewClass(void)
@@ -311,33 +362,29 @@
 {
   Iclass* ic = iupClassNew(NULL);
 
-  // We need Create/Destroy because ADDFORMAT requires us to carry state around. Cocoa doesn't have an ADD API, so we have to manually save/accumulate all the values.
-  ic->Create = cocoaClipboardCreateMethod;
-  ic->Destroy = cocoaClipboardDestroyMethod;
   ic->name = "clipboard";
-  ic->format = NULL;  /* no parameters */
-  ic->nativetype = IUP_TYPECONTROL;
+  ic->format = NULL;
+  ic->nativetype = IUP_TYPEOTHER;
   ic->childtype = IUP_CHILDNONE;
   ic->is_interactive = 0;
 
-  ic->New = iupClipboardNewClass;
-
-  /* Attribute functions */
   iupClassRegisterAttribute(ic, "TEXT", cocoaClipboardGetTextAttrib, cocoaClipboardSetTextAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TEXTAVAILABLE", cocoaClipboardGetTextAvailableAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
+  iupClassRegisterAttribute(ic, "IMAGE", NULL, cocoaClipboardSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "NATIVEIMAGE", cocoaClipboardGetNativeImageAttrib, cocoaClipboardSetNativeImageAttrib, NULL, NULL, IUPAF_NO_STRING|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "IMAGE", NULL, cocoaClipboardSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "IMAGEAVAILABLE", cocoaClipboardGetImageAvailableAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
+  iupClassRegisterAttribute(ic, "NATIVEVECTORIMAGE", cocoaClipboardGetNativeVectorImageAttrib, cocoaClipboardSetNativeVectorImageAttrib, NULL, NULL, IUPAF_NO_STRING|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "PDFAVAILABLE", cocoaClipboardGetPDFAvailableAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SAVENATIVEVECTORIMAGE", NULL, cocoaClipboardSetSaveNativeVectorImageAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+
   iupClassRegisterAttribute(ic, "ADDFORMAT", NULL, cocoaClipboardSetAddFormatAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FORMAT", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FORMATAVAILABLE", cocoaClipboardGetFormatAvailableAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FORMATDATA", cocoaClipboardGetFormatDataAttrib, cocoaClipboardSetFormatDataAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "FORMATDATASTRING", cocoaClipboardGetFormatDataStringAttrib, cocoaClipboardSetFormatDataStringAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FORMATDATASIZE", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
-	// New API: Do we need this, or is it intended that value==NULL for above APIs invokes clear?
-//	iupClassRegisterAttribute(ic, "CLEAR", NULL, cocoaClipboardSetClearAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
-
   return ic;
 }
Index: src/cocoa/iupcocoa_common.m
===================================================================
--- src/cocoa/iupcocoa_common.m	(revision 5971)
+++ src/cocoa/iupcocoa_common.m	(working copy)
@@ -1,16 +1,18 @@
 /** \file
- * \brief GTK Base Functions
+ * \brief Cocoa Base Functions
  *
  * See Copyright Notice in "iup.h"
  */
 
-#include <stdio.h>              
+#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>             
-#include <limits.h>             
+#include <string.h>
+#include <limits.h>
 
 #import <Cocoa/Cocoa.h>
 #import <objc/runtime.h>
+#import <CoreGraphics/CoreGraphics.h>
+#import <unistd.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -27,1202 +29,1168 @@
 #include "iup_image.h"
 #include "iup_loop.h"
 #include "iup_drv.h"
+#include "iup_menu.h"
 
 #include "iupcocoa_drv.h"
 
 
-#if __has_feature(objc_arc)
-#error "Cocoa backend for IUP does not use ARC. Compile with -fno-objc-arc"
-#endif
+const void* IHANDLE_ASSOCIATED_OBJ_KEY = @"IHANDLE_ASSOCIATED_OBJ_KEY";
+const void* MAINVIEW_ASSOCIATED_OBJ_KEY = @"MAINVIEW_ASSOCIATED_OBJ_KEY";
+const void* ROOTVIEW_ASSOCIATED_OBJ_KEY = @"ROOTVIEW_ASSOCIATED_OBJ_KEY";
 
-
-const void* IHANDLE_ASSOCIATED_OBJ_KEY = @"IHANDLE_ASSOCIATED_OBJ_KEY"; // the point of this is we have a unique memory address for an identifier
-const void* MAINVIEW_ASSOCIATED_OBJ_KEY = @"MAINVIEW_ASSOCIATED_OBJ_KEY"; // ih->handle is the root object, but often the main view is lower down, (e.g. scrollview contains the real widget).
-const void* ROOTVIEW_ASSOCIATED_OBJ_KEY = @"ROOTVIEW_ASSOCIATED_OBJ_KEY"; // ih->handle is the root object, but in a few cases, this is not a View, e.g. NSWindow. Many times we want the root view.
-
-NSObject* iupCocoaGetRootObject(Ihandle* ih)
+NSObject* iupcocoaGetRootObject(Ihandle* ih)
 {
-	if(NULL == ih)
-	{
-		return nil;
-	}
-	return (NSObject*)ih->handle;
+  if(NULL == ih)
+  {
+    return nil;
+  }
+  return (NSObject*)ih->handle;
 }
 
-NSView* iupCocoaGetRootView(Ihandle* ih)
+NSView* iupcocoaGetRootView(Ihandle* ih)
 {
-	if(NULL == ih)
-	{
-		return nil;
-	}
-	id root_object = (NSObject*)ih->handle;
+  if(NULL == ih)
+  {
+    return nil;
+  }
+  id root_object = (NSObject*)ih->handle;
 
-	if(nil == root_object)
-	{
-		return nil;
-	}
-	
-	NSView* main_view = (NSView*)objc_getAssociatedObject(root_object, ROOTVIEW_ASSOCIATED_OBJ_KEY);
+  if(nil == root_object)
+  {
+    return nil;
+  }
 
-	NSCAssert([main_view isKindOfClass:[NSView class]], @"Expected NSView");
-	return main_view;
+  NSView* root_view = (NSView*)objc_getAssociatedObject(root_object, ROOTVIEW_ASSOCIATED_OBJ_KEY);
+
+  if (ih->iclass->nativetype == IUP_TYPEMENU || [root_object isKindOfClass:[NSStatusItem class]])
+  {
+    return nil;
+  }
+
+  NSCAssert([root_view isKindOfClass:[NSView class]], @"Expected NSView");
+  return root_view;
 }
 
-NSView* iupCocoaGetMainView(Ihandle* ih)
+NSView* iupcocoaGetMainView(Ihandle* ih)
 {
-	if(NULL == ih)
-	{
-		return nil;
-	}
-	id root_object = (NSObject*)ih->handle;
+  if(NULL == ih)
+  {
+    return nil;
+  }
+  id root_object = (NSObject*)ih->handle;
 
-	if(nil == root_object)
-	{
-		return nil;
-	}
-	
-	NSView* main_view = (NSView*)objc_getAssociatedObject(root_object, MAINVIEW_ASSOCIATED_OBJ_KEY);
+  if(nil == root_object)
+  {
+    return nil;
+  }
 
-	NSCAssert([main_view isKindOfClass:[NSView class]], @"Expected NSView");
-	return main_view;
+  NSView* main_view = (NSView*)objc_getAssociatedObject(root_object, MAINVIEW_ASSOCIATED_OBJ_KEY);
+
+  if (ih->iclass->nativetype == IUP_TYPEMENU || [root_object isKindOfClass:[NSStatusItem class]])
+  {
+    return nil;
+  }
+
+  NSCAssert([main_view isKindOfClass:[NSView class]], @"Expected NSView");
+  return main_view;
 }
 
-void iupCocoaSetAssociatedViews(Ihandle* ih, NSView* main_view, NSView* root_view)
+void iupcocoaSetAssociatedViews(Ihandle* ih, NSView* main_view, NSView* root_view)
 {
-	NSCAssert(ih->handle, @"Expected ih->handle to be set");
+  NSCAssert(ih->handle, @"Expected ih->handle to be set");
 
-	// Using assign because I don't want to accidentally create retain cycles.
-	// I expect these values to always be available as long as the ih->handle is alive.
-	objc_setAssociatedObject((id)ih->handle, MAINVIEW_ASSOCIATED_OBJ_KEY, main_view, OBJC_ASSOCIATION_ASSIGN);
-
-	objc_setAssociatedObject((id)ih->handle, ROOTVIEW_ASSOCIATED_OBJ_KEY, root_view, OBJC_ASSOCIATION_ASSIGN);
+  objc_setAssociatedObject((id)ih->handle, MAINVIEW_ASSOCIATED_OBJ_KEY, main_view, OBJC_ASSOCIATION_ASSIGN);
+  objc_setAssociatedObject((id)ih->handle, ROOTVIEW_ASSOCIATED_OBJ_KEY, root_view, OBJC_ASSOCIATION_ASSIGN);
 }
 
+void iupcocoaAddToParent(Ihandle* ih)
+{
+  NSView* parent_view = nil;
 
+  /* Check if this element is intended for a specific container within a composite control (e.g., IupTabs).
+     This allows the native hierarchy (child inside container) to differ from the IUP hierarchy (child inside Tabs). */
+  NSView* specific_container = (NSView*)iupAttribGet(ih, "_IUPTAB_CONTAINER");
 
-void iupCocoaAddToParent(Ihandle* ih)
-{
-	id parent_native_handle = iupChildTreeGetNativeParentHandle(ih);
-	
-	id child_handle = ih->handle;
-	if([child_handle isKindOfClass:[NSViewController class]])
-	{
-		child_handle = [child_handle view];
-		// fall through to next block
-	}
-	
-	
-	if([child_handle isKindOfClass:[NSView class]])
-	{
-		NSView* the_view = (NSView*)child_handle;
-		
-		// From David Phillip Oster:
-		/* 
-		 now, when you resize the window, you see the hidden content. This makes the subviews preserve their relative x,y offset from the top left of the window, instead of the Mac default of the bottom left. It probably isn't the right way to do it, since there's probably some iup property that is specifying somethign more complex.
-		 
-		 
-		 If I had set [the_view setAutoresizingMask:NSViewMinXMargin|NSViewWidthSizable|NSViewMaxXMargin];
-		 
-		 Then, as the window widens, that view widens along with it.
-		 */
-		NSAutoresizingMaskOptions current_mask = [the_view autoresizingMask];
-		current_mask = current_mask & (NSViewWidthSizable | NSViewHeightSizable); // Preserve Sizable flags if set
-		[the_view setAutoresizingMask:current_mask|NSViewMaxXMargin|NSViewMinYMargin];
-//		[the_view setAutoresizingMask:NSViewMaxXMargin|NSViewMinYMargin];
+  if (specific_container != NULL)
+  {
+    NSCAssert([specific_container isKindOfClass:[NSView class]], @"Expected specific container (e.g., _IUPTAB_CONTAINER) to be an NSView");
+    parent_view = specific_container;
+  }
+  else
+  {
+    id parent_native_handle = iupChildTreeGetNativeParentHandle(ih);
 
-		
-		if([parent_native_handle isKindOfClass:[NSWindow class]])
-		{
-			NSWindow* parent_window = (NSWindow*)parent_native_handle;
-			NSView* window_view = [parent_window contentView];
-			[window_view addSubview:the_view];
-//			[parent_window recalculateKeyViewLoop];
+    if (parent_native_handle == nil)
+    {
+      /* If parent_native_handle is nil, parent_view remains nil.
+         This is expected for top-level elements like dialogs before mapping, or unparented elements. */
+    }
+    else if([parent_native_handle isKindOfClass:[NSWindow class]])
+    {
+      NSWindow* parent_window = (NSWindow*)parent_native_handle;
+      parent_view = [parent_window contentView];
+    }
+    else if([parent_native_handle isKindOfClass:[NSBox class]])
+    {
+      parent_view = [(NSBox*)parent_native_handle contentView];
+    }
+    else if([parent_native_handle isKindOfClass:[NSView class]])
+    {
+      parent_view = (NSView*)parent_native_handle;
+    }
+    else if([parent_native_handle isKindOfClass:[NSViewController class]])
+    {
+      NSViewController* view_controller = (NSViewController*)parent_native_handle;
+      parent_view = [view_controller view];
+    }
+    else if([parent_native_handle isKindOfClass:[NSStatusItem class]])
+    {
+      /* An NSStatusItem (tray icon) cannot contain a view. This is an invalid hierarchy.
+         We simply ignore the addition.
+         Menus are handled via the TRAYMENU attribute and not via child tree addition. */
+      return;
+    }
+    else
+    {
+      if (ih->iclass->nativetype != IUP_TYPEMENU)
+      {
+        NSCAssert(0, @"Unexpected type for parent widget: %@", [parent_native_handle class]);
+        @throw @"Unexpected type for parent widget";
+      }
+    }
+  }
 
-		}
-		/*
-		else if([parent_native_handle isKindOfClass:[NSBox class]])
-		{
-			NSBox* parent_view = (NSBox*)parent_native_handle;
-			[[parent_view contentView] addSubview:the_view];
+  id child_handle = ih->handle;
+  if([child_handle isKindOfClass:[NSViewController class]])
+  {
+    child_handle = [child_handle view];
+  }
 
-		}
-		 */
+  if([child_handle isKindOfClass:[NSView class]])
+  {
+    if (parent_view == nil)
+    {
+      return;
+    }
 
-		else if([parent_native_handle isKindOfClass:[NSView class]])
-		{
-			NSView* parent_view = (NSView*)parent_native_handle;
-			
-			[parent_view addSubview:the_view];
-			
-//			[[parent_view window] recalculateKeyViewLoop];
-		}
-		else if([parent_native_handle isKindOfClass:[NSViewController class]])
-		{
-			NSViewController* view_controller = (NSViewController*)parent_native_handle;
-			NSView* parent_view = [view_controller view];
-			[parent_view addSubview:the_view];
+    NSView* the_view = (NSView*)child_handle;
 
-		}
-		else
-		{
-			NSCAssert(1, @"Unexpected type for parent widget");
-			@throw @"Unexpected type for parent widget";
-		}
-	
-//		[[the_view window] recalculateKeyViewLoop];
+    [the_view setAutoresizingMask:NSViewMaxXMargin | NSViewMinYMargin];
 
-	}
-	else if([child_handle isKindOfClass:[CALayer class]])
-	{
-		NSCAssert(1, @"CALayer not implemented");
-		@throw @"CALayer not implemented";
-	}
-	else
-	{
-		NSCAssert(1, @"Unexpected type for parent widget");
-		@throw @"Unexpected type for parent widget";
-	}
-	
+    [parent_view addSubview:the_view];
+  }
+  else
+  {
+    if (ih->iclass->nativetype != IUP_TYPEMENU)
+    {
+      if (child_handle != nil) {
+          NSCAssert(0, @"Unexpected type for child widget: %@", [child_handle class]);
+          @throw @"Unexpected type for child widget";
+      }
+    }
+  }
 }
 
-void iupCocoaRemoveFromParent(Ihandle* ih)
+void iupcocoaRemoveFromParent(Ihandle* ih)
 {
-	
-	id child_handle = ih->handle;
-	if([child_handle isKindOfClass:[NSView class]])
-	{
-		NSView* the_view = (NSView*)child_handle;
-		NSWindow* parent_window = [the_view window];
-		[the_view removeFromSuperview];
-//		[parent_window recalculateKeyViewLoop];
-	}
-	else if([child_handle isKindOfClass:[NSViewController class]])
-	{
-		NSViewController* view_controller = (NSViewController*)child_handle;
-		NSView* the_view = [view_controller view];
-//		NSWindow* parent_window = [the_view window];
-		[the_view removeFromSuperview];
-//		[parent_window recalculateKeyViewLoop];
-	}
-	else if([child_handle isKindOfClass:[CALayer class]])
-	{
-		CALayer* the_layer = (CALayer*)child_handle;
-		[the_layer removeFromSuperlayer];
-	}
-	else
-	{
-		NSCAssert(1, @"Unexpected type for widget");
-		@throw @"Unexpected type for widget";
-	}
+  id child_handle = ih->handle;
+  if([child_handle isKindOfClass:[NSView class]])
+  {
+    NSView* the_view = (NSView*)child_handle;
+    [the_view removeFromSuperview];
+  }
+  else if([child_handle isKindOfClass:[NSViewController class]])
+  {
+    NSViewController* view_controller = (NSViewController*)child_handle;
+    NSView* the_view = [view_controller view];
+    [the_view removeFromSuperview];
+  }
+  else
+  {
+    if (ih->iclass->nativetype != IUP_TYPEMENU)
+    {
+      NSCAssert(0, @"Unexpected type for widget");
+      @throw @"Unexpected type for widget";
+    }
+  }
 }
 
-int iupCocoaComputeCartesianScreenHeightFromIup(int iup_height)
+int iupcocoaComputeCartesianScreenHeightFromIup(int iup_height)
 {
-	// Do I want the full screen height or the visible height?
-	NSRect screen_rect = [[NSScreen mainScreen] frame];
-//	NSRect screen_rect = [[NSScreen mainScreen] visibleFrame];
-	CGFloat inverted_height = screen_rect.size.height - iup_height;
-	return iupROUND(inverted_height);
+  /* This function converts from IUP's top-left based system to Cocoa's global bottom-left based system. */
+  NSRect main_screen_frame = [[NSScreen mainScreen] frame];
+  CGFloat main_screen_top = main_screen_frame.origin.y + main_screen_frame.size.height;
+  CGFloat cartesian_y = main_screen_top - iup_height;
+  return iupROUND(cartesian_y);
 }
 
-int iupCocoaComputeIupScreenHeightFromCartesian(int cartesian_height)
+int iupcocoaComputeIupScreenHeightFromCartesian(int cartesian_height)
 {
-	// Do I want the full screen height or the visible height?
-	NSRect screen_rect = [[NSScreen mainScreen] frame];
-//	NSRect screen_rect = [[NSScreen mainScreen] visibleFrame];
-	CGFloat inverted_height = screen_rect.size.height - cartesian_height;
-	return iupROUND(inverted_height);
+  /* This function converts from Cocoa's global bottom-left coordinate system
+     to IUP's top-left based system, where (0,0) is the top-left of the main screen. */
+  NSRect main_screen_frame = [[NSScreen mainScreen] frame];
+  CGFloat main_screen_top = main_screen_frame.origin.y + main_screen_frame.size.height;
+  CGFloat iup_y = main_screen_top - cartesian_height;
+  return iupROUND(iup_y);
 }
 
-void iupCocoaCommonLoopCallExitCb()
+void iupdrvActivate(Ihandle* ih)
 {
-	static BOOL has_called_exit_cb = NO;
-	if(NO == has_called_exit_cb)
-	{
-		has_called_exit_cb = YES;
-		iupLoopCallExitCb();
-	}
-	else
-	{
-		// Drat. I don't think I have a way around this.
-		// There seems to be at least 2 different possible exit triggers.
-		// 1. Apple stopping the native event loop (cmd-Q)
-		// 2. Iup manually terminating the event loop. (close/destroy last window or use IUP_CLOSE)
-		// Because of that, when I tried to put the callback in only one location, I sometimes missed doing the callback.
-		// But if I cover all the bases, I get multiple callbacks sometimes depending on the sequence of events.
-		NSLog(@"Warning: iupCocoaCommonLoopCallExitCb has been already been called. Skipping callback.");
-	}
+  id control = ih->handle;
+  if ([control respondsToSelector:@selector(performClick:)])
+  {
+    [control performClick:nil];
+  }
 }
 
-
-void iupdrvActivate(Ihandle* ih)
+void iupdrvReparent(Ihandle* ih)
 {
+  NSView* child_view = iupcocoaCommonBaseLayoutGetChildView(ih);
+  if (!child_view) return;
 
+  NSView* old_parent_view = [child_view superview];
+  NSView* new_parent_view = iupcocoaCommonBaseLayoutGetParentView(ih);
+
+  if (old_parent_view != new_parent_view && new_parent_view)
+  {
+    /* Retain the view to prevent it from being deallocated when removed */
+    [child_view retain];
+    [child_view removeFromSuperview];
+    [new_parent_view addSubview:child_view];
+    [child_view release];
+  }
 }
 
-void iupdrvReparent(Ihandle* ih)
+NSView* iupcocoaCommonBaseLayoutGetParentView(Ihandle* ih)
 {
+  NSView* specific_container = (NSView*)iupAttribGet(ih, "_IUPTAB_CONTAINER");
+  if (specific_container != NULL)
+  {
+    NSCAssert([specific_container isKindOfClass:[NSView class]], @"Expected specific container (e.g., _IUPTAB_CONTAINER) to be an NSView");
+    return specific_container;
+  }
 
-	
-}
+  id parent_native_handle = iupChildTreeGetNativeParentHandle(ih);
+  NSView* parent_view = nil;
 
+  if([parent_native_handle isKindOfClass:[NSWindow class]])
+  {
+    NSWindow* parent_window = (NSWindow*)parent_native_handle;
+    parent_view = [parent_window contentView];
+  }
+  else if([parent_native_handle isKindOfClass:[NSBox class]])
+  {
+    parent_view = [(NSBox*)parent_native_handle contentView];
+  }
+  else if([parent_native_handle isKindOfClass:[NSView class]])
+  {
+    parent_view = (NSView*)parent_native_handle;
+  }
+  else if([parent_native_handle isKindOfClass:[NSViewController class]])
+  {
+    parent_view = [(NSViewController*)parent_native_handle view];
+  }
+  else if([parent_native_handle isKindOfClass:[NSStatusItem class]])
+  {
+    return nil;
+  }
+  else
+  {
+    if (ih->iclass->nativetype != IUP_TYPEMENU && parent_native_handle != nil)
+    {
+      NSCAssert(0, @"Unexpected type for parent widget: %@", [parent_native_handle class]);
+      @throw @"Unexpected type for parent widget";
+    }
+  }
 
-// If you change these, make sure to update any overrides that copy/paste this pattern (e.g. cocoaButtonLayoutUpdateMethod)
-// TODO: Consider CALayer
-NSView* iupCocoaCommonBaseLayoutGetParentView(Ihandle* ih)
-{
-	id parent_native_handle = iupChildTreeGetNativeParentHandle(ih);
-	NSView* parent_view = nil;
-	
-	if([parent_native_handle isKindOfClass:[NSWindow class]])
-	{
-		NSWindow* parent_window = (NSWindow*)parent_native_handle;
-		parent_view = [parent_window contentView];
-	}
-	/* // Part of NSBox experiment
-	 else if([parent_native_handle isKindOfClass:[NSBox class]])
-	 {
-		NSBox* box_view = (NSBox*)parent_native_handle;
-		parent_view = [box_view contentView];
-		
-		CGFloat diff_width = NSWidth([box_view frame]) - NSWidth([parent_view frame]);
-		CGFloat diff_height = NSHeight([box_view frame]) - NSHeight([parent_view frame]);
-	 
-		current_width = current_width - diff_width;
-		current_height = current_height - diff_height;
-	 }
-	 */
-	else if([parent_native_handle isKindOfClass:[NSView class]])
-	{
-		parent_view = (NSView*)parent_native_handle;
-	}
-	/*
-	else if([parent_native_handle isKindOfClass:[NSTabViewController class]])
-	{
-		parent_view = [(NSTabViewController*)parent_native_handle tabView];
-	}
-	*/
-	else if([parent_native_handle isKindOfClass:[NSViewController class]])
-	{
-		parent_view = [(NSViewController*)parent_native_handle view];
-	}
-	else
-	{
-		NSCAssert(1, @"Unexpected type for parent widget");
-		@throw @"Unexpected type for parent widget";
-	}
-	
-	return parent_view;
+  return parent_view;
 }
 
-// If you change these, make sure to update any overrides that copy/paste this pattern (e.g. cocoaButtonLayoutUpdateMethod)
-// TODO: Consider CALayer
-NSView* iupCocoaCommonBaseLayoutGetChildView(Ihandle* ih)
+NSView* iupcocoaCommonBaseLayoutGetChildView(Ihandle* ih)
 {
-	id child_handle = ih->handle;
-	NSView* the_view = nil;
+  id child_handle = ih->handle;
+  NSView* the_view = nil;
 
-	if([child_handle isKindOfClass:[NSViewController class]])
-	{
-		child_handle = [(NSViewController*)child_handle view];
-		// fall through to next block
-	}
-	
-	if([child_handle isKindOfClass:[NSView class]])
-	{
-		the_view = (NSView*)child_handle;
-	}
-	else if([child_handle isKindOfClass:[CALayer class]])
-	{
-		NSCAssert(1, @"CALayer not implemented");
-		@throw @"CALayer not implemented";
-	}
-	else
-	{
-		NSCAssert(1, @"Unexpected type for child widget");
-		@throw @"Unexpected type for child widget";
-	}
-	return the_view;
+  if([child_handle isKindOfClass:[NSViewController class]])
+  {
+    child_handle = [(NSViewController*)child_handle view];
+  }
+
+  if([child_handle isKindOfClass:[NSView class]])
+  {
+    the_view = (NSView*)child_handle;
+  }
+  else
+  {
+    if (ih->iclass->nativetype != IUP_TYPEMENU)
+    {
+      NSCAssert(0, @"Unexpected type for child widget");
+      @throw @"Unexpected type for child widget";
+    }
+  }
+  return the_view;
 }
 
-// If you change these, make sure to update any overrides that copy/paste this pattern (e.g. cocoaButtonLayoutUpdateMethod)
-NSRect iupCocoaCommonBaseLayoutComputeChildFrameRectFromParentRect(Ihandle* ih, NSRect parent_rect)
+void iupdrvBaseLayoutUpdateMethod(Ihandle *ih)
 {
+  NSView* parent_view = iupcocoaCommonBaseLayoutGetParentView(ih);
+  if (!parent_view) return;
 
-	NSRect the_rect = NSMakeRect(
-		ih->x,
-		// Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-		parent_rect.size.height - ih->y - ih->currentheight,
-		ih->currentwidth,
-		ih->currentheight
-	);
-//	the_rect.origin.y = the_rect.origin.y - 16.0*0.5; // I don't realy understand the logic of this offset, particularly the -1
+  NSView* child_view = iupcocoaCommonBaseLayoutGetChildView(ih);
+  if (!child_view) return;
 
+  NSRect parent_bounds = [parent_view bounds];
+  NSRect child_rect;
 
-	// for padding
-	// drat, data is private and requires a per-widget header
-	{
+  if ([parent_view isFlipped])
+  {
+    child_rect = NSMakeRect(
+        ih->x,
+        ih->y,
+        ih->currentwidth,
+        ih->currentheight
+    );
+  }
+  else
+  {
+    child_rect = NSMakeRect(
+        ih->x,
+        parent_bounds.size.height - ih->y - ih->currentheight,
+        ih->currentwidth,
+        ih->currentheight
+    );
+  }
 
-		char* padding_str = iupAttribGet(ih, "PADDING");
-		if((NULL != padding_str) && (padding_str[0] != '\0'))
-		{
-			int horiz_padding = 0;
-			int vert_padding = 0;
-			iupStrToIntInt(padding_str, &horiz_padding, &vert_padding, 'x');
-			
-			NSRect old_frame = the_rect;
-			NSRect new_frame;
-			new_frame.origin.x = old_frame.origin.x + (CGFloat)horiz_padding*0.5;
-			new_frame.origin.y = old_frame.origin.y + (CGFloat)vert_padding*0.5;
-			new_frame.size.width = old_frame.size.width - (CGFloat)horiz_padding;
-			new_frame.size.height = old_frame.size.height - (CGFloat)vert_padding;
-			
-			the_rect = new_frame;
-		}
-		
-	}
+  [child_view setFrame:child_rect];
 
-//	NSLog(@"view %@, rect:%@", the_view, NSStringFromRect(the_rect));
-	return the_rect;
+  NSRect actual_bounds = [child_view bounds];
 
+  cocoaUpdateTip(ih);
 }
 
-// If you change these, make sure to update any overrides that copy/paste this pattern (e.g. cocoaButtonLayoutUpdateMethod)
-void iupdrvBaseLayoutUpdateMethod(Ihandle *ih)
+void iupdrvBaseUnMapMethod(Ihandle* ih)
 {
+  if (!ih->handle) return;
 
-	NSView* parent_view = nil;
-	NSView* child_view = nil;
-	
-	parent_view = iupCocoaCommonBaseLayoutGetParentView(ih);
-	child_view = iupCocoaCommonBaseLayoutGetChildView(ih);
-	
-	
-	
-	
-	NSRect parent_rect = [parent_view frame];
+  Ihandle* context_menu_ih = (Ihandle*)iupcocoaCommonBaseGetContextMenuAttrib(ih);
+  if(NULL != context_menu_ih)
+  {
+    IupDestroy(context_menu_ih);
+  }
+  iupcocoaCommonBaseSetContextMenuAttrib(ih, NULL);
 
-	
-/*
-#if 0 // experiment to try to handle NSBox directly instead of using cocoaFrameGetInnerNativeContainerHandleMethod. I think cocoaFrameGetInnerNativeContainerHandleMethod is better, but I haven't vetted everything.
-	int current_width = ih->currentwidth;
-	int current_height = ih->currentheight;
+  if (iupAttribGet(ih, "_IUPCOCOA_CURSOR_DELEGATE"))
+  {
+    iupdrvBaseSetCursorAttrib(ih, "NONE");
+  }
 
-	if([parent_native_handle isKindOfClass:[NSBox class]])
-	{
-		NSBox* box_view = (NSBox*)parent_native_handle;
-		NSView* box_content_view = [box_view contentView];
-		
-		CGFloat diff_width = NSWidth([box_view frame]) - NSWidth([box_content_view frame]);
-		CGFloat diff_height = NSHeight([box_view frame]) - NSHeight([box_content_view frame]);
+  iupcocoaTipsDestroy(ih);
 
-		current_width = current_width - diff_width;
-		current_height = current_height - diff_height;
-		
-		NSRect the_rect = NSMakeRect(
-		ih->x,
-		// Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-		parent_rect.size.height - ih->y - ih->currentheight,
-		current_width,
-		ih->currentheight
-	);
-	[the_view setFrame:the_rect];
-//	[the_view setBounds:the_rect];
-	}
-	else
-	{
-		
-	NSRect the_rect = NSMakeRect(
-		ih->x,
-		// Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-		parent_rect.size.height - ih->y - ih->currentheight,
-		ih->currentwidth,
-		ih->currentheight
-	);
-	[the_view setFrame:the_rect];
-//	[the_view setBounds:the_rect];
-	}
-#else
-	
-			
-	NSRect the_rect = NSMakeRect(
-		ih->x,
-		// Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-		parent_rect.size.height - ih->y - ih->currentheight,
-		ih->currentwidth,
-		ih->currentheight
-	);
-//	the_rect.origin.y = the_rect.origin.y - 16.0*0.5; // I don't realy understand the logic of this offset, particularly the -1
+  objc_setAssociatedObject(ih->handle, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  objc_setAssociatedObject(ih->handle, MAINVIEW_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  objc_setAssociatedObject(ih->handle, ROOTVIEW_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
 
+  id the_handle = ih->handle;
+  iupcocoaRemoveFromParent(ih);
 
-	// for padding
-	// drat, data is private and requires a per-widget header
-	{
+  [the_handle release];
+  ih->handle = NULL;
+}
 
-		char* padding_str = iupAttribGet(ih, "PADDING");
-		if((NULL != padding_str) && (padding_str[0] != '\0'))
-		{
-			int horiz_padding = 0;
-			int vert_padding = 0;
-			iupStrToIntInt(padding_str, &horiz_padding, &vert_padding, 'x');
-			
-			NSRect old_frame = the_rect;
-			NSRect new_frame;
-			new_frame.origin.x = old_frame.origin.x + (CGFloat)horiz_padding*0.5;
-			new_frame.origin.y = old_frame.origin.y + (CGFloat)vert_padding*0.5;
-			new_frame.size.width = old_frame.size.width - (CGFloat)horiz_padding;
-			new_frame.size.height = old_frame.size.height - (CGFloat)vert_padding;
-			
-			the_rect = new_frame;
-		}
-		
-	}
+static void iupCocoaDisplayUpdate(Ihandle *ih)
+{
+  id the_handle = ih->handle;
 
-//	NSLog(@"view %@, rect:%@", the_view, NSStringFromRect(the_rect));
-	[child_view setFrame:the_rect];
-#endif
-*/
-	
-	NSRect child_rect = iupCocoaCommonBaseLayoutComputeChildFrameRectFromParentRect(ih, parent_rect);
-	[child_view setFrame:child_rect];
-	
+  if([the_handle isKindOfClass:[NSView class]])
+  {
+    NSView* the_view = (NSView*)the_handle;
+    [the_view setNeedsDisplay:YES];
+  }
+  else if([the_handle isKindOfClass:[NSViewController class]])
+  {
+    NSView* the_view = [(NSViewController*)the_handle view];
+    [the_view setNeedsDisplay:YES];
+  }
 
-	
+  NSView* main_view = iupcocoaGetMainView(ih);
+  if (main_view && main_view != (NSView*)the_handle)
+  {
+    [main_view setNeedsDisplay:YES];
+  }
 }
 
-void iupdrvBaseUnMapMethod(Ihandle* ih)
+void iupdrvRedrawNow(Ihandle *ih)
 {
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-	
-	// Why do I need this when everything else has its own UnMap method?
-	NSLog(@"iupdrvBaseUnMapMethod not implemented. Might be leaking");
-	id the_handle = ih->handle;
-	iupCocoaRemoveFromParent(ih);
-	[the_handle release];
+  iupCocoaDisplayUpdate(ih);
+  NSView* view = iupcocoaGetMainView(ih);
+  if(view)
+  {
+    [view displayIfNeeded];
+  }
 }
 
-static void iupCocoaDisplayUpdate(Ihandle *ih)
+void iupdrvPostRedraw(Ihandle *ih)
 {
-	id the_handle = ih->handle;
-	
-	if([the_handle isKindOfClass:[NSView class]])
-	{
-		NSView* the_view = (NSView*)the_handle;
-		[the_view setNeedsDisplay:YES];
-	}
-	else if([the_handle isKindOfClass:[NSWindow class]])
-	{
-		// Cocoa generally does this automatically
-//		[the_handle display];
-	}
-	else if([the_handle isKindOfClass:[CALayer class]])
-	{
-		CALayer* the_layer = (CALayer*)the_handle;
-		[the_layer setNeedsDisplay];
-	}
-	else
-	{
-		NSCAssert(1, @"Unexpected type for widget");
-		@throw @"Unexpected type for widget";
-	}
-
+  iupCocoaDisplayUpdate(ih);
 }
 
-void iupdrvDisplayRedraw(Ihandle *ih)
-{
-	iupCocoaDisplayUpdate(ih);
-}
-
-// Untested: I'm not sure what actually uses/needs this. (I see an MDI reference, but we MDI shouldn't exist on anything but Windows.)
 void iupdrvScreenToClient(Ihandle* ih, int *x, int *y)
 {
-	// Do we need to invert the y?
-	// And is it the mainScreen or a different one?
-	NSRect main_screen = [[NSScreen mainScreen] frame];
-	
+  NSRect main_screen = [[NSScreen mainScreen] frame];
+  CGFloat main_screen_top = main_screen.origin.y + main_screen.size.height;
+  NSPoint screen_point = { *x, main_screen_top - *y }; /* IUP screen to Cocoa screen (bottom-left) */
 
-	NSPoint screen_point = { *x, main_screen.size.height - *y };
-	
-	NSView* main_view = iupCocoaGetMainView(ih);
-	NSWindow* the_window = [main_view window];
-	NSRect screen_rect = NSMakeRect(screen_point.x, screen_point.y, 0, 0);
-	NSRect window_rect = [the_window convertRectFromScreen:screen_rect];
+  NSView* main_view = iupcocoaGetMainView(ih);
+  if (!main_view) return;
 
-	NSPoint window_point = window_rect.origin;
-	NSPoint view_point = [main_view convertPoint:window_point fromView:nil];
-	NSRect view_frame = [main_view frame];
+  NSWindow* the_window = [main_view window];
+  if (!the_window) return;
 
-	CGFloat inverted_y = view_frame.size.height - view_point.y;
-	view_point.y = inverted_y;
+  NSRect screen_rect = NSMakeRect(screen_point.x, screen_point.y, 0, 0);
+  NSRect window_rect = [the_window convertRectFromScreen:screen_rect];
 
-	*x = view_point.x;
-	*y = view_point.y;
+  NSPoint window_point = window_rect.origin;
+  NSPoint view_point = [main_view convertPoint:window_point fromView:nil];
+
+  /* If the view is not flipped, its coordinate system has the origin at the bottom-left.
+     We must convert the y-coordinate to IUP's top-left based system. For flipped views, the coordinate is already correct. */
+  if (![main_view isFlipped])
+  {
+    NSRect view_bounds = [main_view bounds];
+    view_point.y = view_bounds.size.height - view_point.y;
+  }
+
+  *x = iupROUND(view_point.x);
+  *y = iupROUND(view_point.y);
 }
 
-
 void iupdrvClientToScreen(Ihandle* ih, int *x, int *y)
 {
-	
-	NSView* main_view = iupCocoaGetMainView(ih);
-	NSWindow* the_window = [main_view window];
+  NSView* main_view = iupcocoaGetMainView(ih);
+  if (!main_view) return;
 
-	NSRect view_frame = [main_view frame];
-	// Do we need to invert the y?
-	NSPoint start_point = { *x, view_frame.size.height - *y };
+  NSWindow* the_window = [main_view window];
+  if (!the_window) return;
 
-	NSPoint window_point = [main_view convertPoint:start_point toView:nil];
-	
-	NSRect window_rect = NSMakeRect(window_point.x, window_point.y, 0, 0);
-	NSRect screen_rect = [the_window convertRectToScreen:window_rect];
+  NSPoint start_point = { *x, *y };
 
-	
-	// And is it the mainScreen or a different one?
-	NSRect main_screen = [[NSScreen mainScreen] frame];
-	
-	*x = screen_rect.origin.x;
-	*y = main_screen.size.height - screen_rect.origin.y;
+  /* If the view is not flipped, we must convert from IUP's top-left
+     coordinate system to Cocoa's bottom-left system before converting to screen coordinates. */
+  if (![main_view isFlipped])
+  {
+    NSRect view_bounds = [main_view bounds];
+    start_point.y = view_bounds.size.height - *y;
+  }
+
+  NSPoint window_point = [main_view convertPoint:start_point toView:nil];
+
+  NSRect window_rect = NSMakeRect(window_point.x, window_point.y, 0, 0);
+  NSRect screen_rect = [the_window convertRectToScreen:window_rect];
+
+  NSRect main_screen = [[NSScreen mainScreen] frame];
+  CGFloat main_screen_top = main_screen.origin.y + main_screen.size.height;
+
+  *x = screen_rect.origin.x;
+  *y = main_screen_top - screen_rect.origin.y; /* convert from cocoa screen coords to IUP screen coords */
 }
 
 int iupdrvBaseSetZorderAttrib(Ihandle* ih, const char* value)
 {
-  return 0;
+  NSView* child_view = iupcocoaGetMainView(ih);
+  if (!child_view) return 0;
+
+  NSView* parent_view = [child_view superview];
+  if (!parent_view) return 0;
+
+  if (iupStrEqualNoCase(value, "TOP"))
+  {
+    [parent_view addSubview:child_view positioned:NSWindowAbove relativeTo:nil];
+  }
+  else
+  {
+    [parent_view addSubview:child_view positioned:NSWindowBelow relativeTo:nil];
+  }
+  return 1;
 }
 
 void iupdrvSetVisible(Ihandle* ih, int visible)
 {
-	id the_object = ih->handle;
-	if([the_object isKindOfClass:[NSWindow class]])
-	{
-		// NOT IMPLEMENTED
-		NSLog(@"iupdrvSetVisible for NSWindow is not implemented");
-	}
-	else if([the_object isKindOfClass:[NSView class]])
-	{
-		NSView* the_view = (NSView*)the_object;
-		bool is_hidden = !(bool)visible;
-		[the_view setHidden:is_hidden];
-	}
-	else if([the_object isKindOfClass:[NSViewController class]])
-	{
-		NSViewController* the_viewcontroller = (NSViewController*)the_object;
-		NSView* the_view = [the_viewcontroller view];
-		bool is_hidden = !(bool)visible;
-		[the_view setHidden:is_hidden];
-	}
-	
+  id the_object = ih->handle;
+  bool is_hidden = !(bool)visible;
+
+  if([the_object isKindOfClass:[NSView class]])
+  {
+    [(NSView*)the_object setHidden:is_hidden];
+  }
+  else if([the_object isKindOfClass:[NSViewController class]])
+  {
+    [[(NSViewController*)the_object view] setHidden:is_hidden];
+  }
 }
 
 int iupdrvIsVisible(Ihandle* ih)
 {
-	id the_object = ih->handle;
-	if([the_object isKindOfClass:[NSWindow class]])
-	{
-		NSWindow* the_window = (NSWindow*)ih->handle;
-		return [the_window isVisible];
-	}
-	else if([the_object isKindOfClass:[NSView class]])
-	{
-		NSView* the_view = (NSView*)the_object;
-		return [the_view isHidden] ? NO : YES;
-	}
-	else if([the_object isKindOfClass:[NSViewController class]])
-	{
-		NSViewController* the_viewcontroller = (NSViewController*)the_object;
-		NSView* the_view = [the_viewcontroller view];
-		return [the_view isHidden] ? NO : YES;
-	}
-	else
-	{
-		return 1;
-	}
+  id the_object = ih->handle;
+  if([the_object isKindOfClass:[NSWindow class]])
+  {
+    return [(NSWindow*)ih->handle isVisible];
+  }
+  else if([the_object isKindOfClass:[NSView class]])
+  {
+    return [(NSView*)the_object isHidden] ? NO : YES;
+  }
+  else if([the_object isKindOfClass:[NSViewController class]])
+  {
+    return [[(NSViewController*)the_object view] isHidden] ? NO : YES;
+  }
+  else
+  {
+    return 1;
+  }
 }
 
+
 int iupdrvIsActive(Ihandle *ih)
 {
-	id the_object = ih->handle;
-#if 0
-	if([the_object isKindOfClass:[NSControl class]])
-	{
-		NSControl* the_control = (NSControl*)the_object;
-		return [the_control isEnabled];
-	}
-#else
+  char* value = iupAttribGet(ih, "_IUPCOCOA_ACTIVE");
+  int result;
 
-	// Note: NSViewController's contentView is probably never going to respond to the enabled property, so its handling is skipped.
+  if (value == NULL)
+    result = 1;
+  else
+    result = iupStrBoolean(value);
 
-	// Our custom CanvasView is going back and forth between subclassing NSView and NSControl.
-	// Make sure to not implement any other NSViews that do something wonky with the enabled property.
-	if([the_object respondsToSelector:@selector(isEnabled)])
-	{
-		// I forgot if there are rules about primitive types when there is no header definition.
-		// So I'm going to pretend it is a NSControl even though it may not be
-		NSControl* the_control = (NSControl*)the_object;
-		return [the_control isEnabled];
-	}
-	else if([the_object isKindOfClass:[NSScrollView class]])
-	{
-		NSView* document_view = [the_object documentView];
-		if([document_view respondsToSelector:@selector(isEnabled)])
-		{
-			// I forgot if there are rules about primitive types when there is no header definition.
-			// So I'm going to pretend it is a NSControl even though it may not be
-			NSControl* the_control = (NSControl*)document_view;
-			return [the_control isEnabled];
-		}
-	}
-#endif
-	return 1;
+  return result;
 }
 
 void iupdrvSetActive(Ihandle* ih, int enable)
 {
-	id the_object = ih->handle;
-#if 0
-	if([the_object isKindOfClass:[NSControl class]])
-	{
-		NSControl* the_control = (NSControl*)the_object;
-		[the_control setEnabled:enable];
-	}
-#else
+  iupAttribSet(ih, "_IUPCOCOA_ACTIVE", iupStrReturnBoolean(enable));
 
+  if (ih->iclass->nativetype == IUP_TYPEDIALOG)
+  {
+    NSWindow* window = cocoaDialogGetWindow(ih);
+    if (!window)
+    {
+        return;
+    }
 
-	// Note: NSViewController's contentView is probably never going to respond to the enabled property, so its handling is skipped.
+    if (enable)
+    {
+      [window setIgnoresMouseEvents:NO];
+      [NSApp activateIgnoringOtherApps:YES];
+      [window makeKeyAndOrderFront:nil];
+    }
+    else
+    {
+      [window setIgnoresMouseEvents:YES];
+    }
+    return;
+  }
 
+  id main_view = iupcocoaGetMainView(ih);
 
-	// Our custom CanvasView is going back and forth between subclassing NSView and NSControl.
-	// Make sure to not implement any other NSViews that do something wonky with the enabled property.
-	if([the_object respondsToSelector:@selector(setEnabled:)])
-	{
-		// I forgot if there are rules about primitive types when there is no header definition.
-		// So I'm going to pretend it is a NSControl even though it may not be
-		NSControl* the_control = (NSControl*)the_object;
-		[the_control setEnabled:enable];
-	}
-	else if([the_object isKindOfClass:[NSScrollView class]])
-	{
-		NSView* document_view = [the_object documentView];
-		if([document_view respondsToSelector:@selector(setEnabled:)])
-		{
-			// I forgot if there are rules about primitive types when there is no header definition.
-			// So I'm going to pretend it is a NSControl even though it may not be
-			NSControl* the_control = (NSControl*)document_view;
-			[the_control setEnabled:enable];
-		}
-	}
-#endif
+  if ([main_view isKindOfClass:[NSImageView class]])
+  {
+    return;
+  }
+
+  if ([main_view respondsToSelector:@selector(setEnabled:)])
+  {
+    [(NSControl*)main_view setEnabled:(BOOL)enable];
+  }
+  else
+  {
+    if([main_view isKindOfClass:[NSView class]])
+    {
+      [(NSView*)main_view setNeedsDisplay:YES];
+    }
+  }
 }
 
-char* iupdrvBaseGetXAttrib(Ihandle *ih)
+int iupdrvBaseSetBgColorAttrib(Ihandle* ih, const char* value)
 {
-  return NULL;
+  id the_object = ih->handle;
+
+  if([the_object respondsToSelector:@selector(setBackgroundColor:)])
+  {
+    unsigned char r, g, b;
+    if(iupStrToRGB(value, &r, &g, &b))
+    {
+      CGFloat red = r/255.0;
+      CGFloat green = g/255.0;
+      CGFloat blue = b/255.0;
+
+      NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+      [the_object setBackgroundColor:the_color];
+    }
+    else
+    {
+      [the_object setBackgroundColor:nil];
+    }
+    return 1;
+  }
+
+  return 0;
 }
 
-char* iupdrvBaseGetYAttrib(Ihandle *ih)
+int iupdrvBaseSetFgColorAttrib(Ihandle* ih, const char* value)
 {
+  id main_view = iupcocoaGetMainView(ih);
+  if (!main_view)
+    return 0;
 
-  return NULL;
+  unsigned char r, g, b;
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
+
+  CGFloat red = r/255.0;
+  CGFloat green = g/255.0;
+  CGFloat blue = b/255.0;
+  NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+
+  /* For NSTextField, NSTextView, etc. */
+  if ([main_view respondsToSelector:@selector(setTextColor:)])
+  {
+    [main_view setTextColor:the_color];
+    return 1;
+  }
+
+  /* For NSButton */
+  if ([main_view isKindOfClass:[NSButton class]])
+  {
+    NSButton* button = (NSButton*)main_view;
+    NSMutableAttributedString *coloredTitle = [[button attributedTitle] mutableCopy];
+    NSRange titleRange = NSMakeRange(0, [coloredTitle length]);
+    [coloredTitle addAttribute:NSForegroundColorAttributeName value:the_color range:titleRange];
+    [button setAttributedTitle:coloredTitle];
+    [coloredTitle release];
+    return 1;
+  }
+
+  /* For NSBox (used by IupFrame) */
+  if ([main_view respondsToSelector:@selector(setTitleColor:)])
+  {
+    [main_view setTitleColor:the_color];
+    return 1;
+  }
+
+  return 0; /* Control does not support changing foreground color */
 }
 
-/*
-char* iupdrvBaseGetClientSizeAttrib(Ihandle *ih)
+@interface IUPCursorTrackingDelegate : NSObject
 {
+  NSCursor* _cursor;
+}
+@property(nonatomic, retain) NSCursor* cursor;
+- (void)mouseEntered:(NSEvent *)event;
+- (void)mouseExited:(NSEvent *)event;
+- (void)dealloc;
+@end
 
-    return NULL;
+@implementation IUPCursorTrackingDelegate
+@synthesize cursor = _cursor;
+- (void)mouseEntered:(NSEvent *)event { [self.cursor set]; }
+- (void)mouseExited:(NSEvent *)event { [[NSCursor arrowCursor] set]; }
+- (void)dealloc { self.cursor = nil; [super dealloc]; }
+@end
 
-}
- */
 
-// TODO: I don't know if anything actually uses this.
-int iupdrvBaseSetBgColorAttrib(Ihandle* ih, const char* value)
+static NSCursor* iupCocoaGetCursor(Ihandle* ih, const char* name)
 {
-	id the_object = ih->handle;
+  static struct {
+    const char* iupname;
+    const char* sel_name;
+  } table[] = {
+    {"ARROW",     "arrowCursor"},
+    {"BUSY",      "busyButClickableCursor"}, /* Not part of the API for NSCursor but apps are using it (i.e. Blender) */
+    {"CROSS",     "crosshairCursor"},
+    {"HAND",      "pointingHandCursor"},
+    {"MOVE",      "closedHandCursor"},
+    {"RESIZE_N",  "_windowResizeNorthCursor"},
+    {"RESIZE_S",  "_windowResizeSouthCursor"},
+    {"RESIZE_NS", "resizeUpDownCursor"},
+    {"RESIZE_W",  "_windowResizeWestCursor"},
+    {"RESIZE_E",  "_windowResizeEastCursor"},
+    {"RESIZE_WE", "resizeLeftRightCursor"},
+    {"RESIZE_NE", "_windowResizeNorthEastCursor"},
+    {"RESIZE_SE", "_windowResizeSouthEastCursor"},
+    {"RESIZE_NW", "_windowResizeNorthWestCursor"},
+    {"RESIZE_SW", "_windowResizeSouthWestCursor"},
+    {"TEXT",      "IBeamCursor"},
+    {"HELP",      "contextualMenuCursor"},
+    {"IUP",       "contextualMenuCursor"},
+    {"NO",        "operationNotAllowedCursor"},
+    {"UPARROW",   "arrowCursor"} /* No direct up-arrow cursor */
+  };
 
-	// Our custom CanvasView is going back and forth between subclassing NSView and NSControl.
-	// Make sure to not implement any other NSViews that do something wonky with the enabled property.
-	if([the_object respondsToSelector:@selector(setBackgroundColor:)])
-	{
-		unsigned char r, g, b;
-		if(iupStrToRGB(value, &r, &g, &b))
-		{
-			CGFloat red = r/255.0;
-			CGFloat green = g/255.0;
-			CGFloat blue = b/255.0;
-			
-			NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-			[the_object setBackgroundColor:the_color];
-		}
-		else
-		{
-			[the_object setBackgroundColor:nil];
-		}
-		return 1;
-	}
-	
-  return 0;
+  if (iupStrEqualNoCase(name, "NONE") || iupStrEqualNoCase(name, "NULL"))
+    return nil;
+
+  for (int i = 0; i < sizeof(table)/sizeof(table[0]); i++)
+  {
+    if (iupStrEqualNoCase(name, table[i].iupname))
+    {
+      SEL syssel = NSSelectorFromString([NSString stringWithUTF8String:table[i].sel_name]);
+      if ([NSCursor respondsToSelector:syssel])
+      {
+        return [NSCursor performSelector:syssel];
+      }
+    }
+  }
+
+  return iupImageGetCursor(name);
 }
 
 int iupdrvBaseSetCursorAttrib(Ihandle* ih, const char* value)
 {
+  NSView* main_view = iupcocoaGetMainView(ih);
+  if (!main_view) return 0;
 
-  return 0;
+  IUPCursorTrackingDelegate* old_delegate = (IUPCursorTrackingDelegate*)iupAttribGet(ih, "_IUPCOCOA_CURSOR_DELEGATE");
+  if (old_delegate)
+  {
+    NSTrackingArea* old_area = (NSTrackingArea*)iupAttribGet(ih, "_IUPCOCOA_TRACKINGAREA");
+    if (old_area)
+      [main_view removeTrackingArea:old_area];
+
+    [old_delegate release];
+    iupAttribSet(ih, "_IUPCOCOA_CURSOR_DELEGATE", NULL);
+    iupAttribSet(ih, "_IUPCOCOA_TRACKINGAREA", NULL);
+  }
+
+  NSCursor* cursor = iupCocoaGetCursor(ih, value);
+  if (cursor)
+  {
+    IUPCursorTrackingDelegate* delegate = [[IUPCursorTrackingDelegate alloc] init];
+    delegate.cursor = cursor;
+
+    NSTrackingArea* area = [[NSTrackingArea alloc] initWithRect:[main_view bounds]
+                                                        options:(NSTrackingMouseEnteredAndExited | NSTrackingActiveInKeyWindow | NSTrackingInVisibleRect)
+                                                          owner:delegate
+                                                       userInfo:nil];
+    [main_view addTrackingArea:area];
+
+    /* Store delegate and area to be cleaned up later. The view retains the area. */
+    iupAttribSet(ih, "_IUPCOCOA_CURSOR_DELEGATE", (char*)delegate);
+    iupAttribSet(ih, "_IUPCOCOA_TRACKINGAREA", (char*)area);
+    [area release];
+  }
+
+  return 1;
 }
 
-
 int iupdrvGetScrollbarSize(void)
 {
-
-  return 0;
+  return [NSScroller scrollerWidthForControlSize:NSControlSizeRegular scrollerStyle:NSScrollerStyleLegacy];
 }
 
-/*
-From Apple's quick documentation:
-Do not include the accessibility elements type in the label (for example, write Play not Play button.). If possible, use a single word. To help ensure that accessibility clients like VoiceOver read the label with the correct intonation, this label should start with a capital letter. Do not put a period at the end. Always localize the label.
-*/
 IUP_SDK_API void iupdrvSetAccessibleTitle(Ihandle *ih, const char* title)
 {
-	id the_object = ih->handle;
-
-	// Our custom CanvasView is going back and forth between subclassing NSView and NSControl.
-	// Make sure to not implement any other NSViews that do something wonky with the enabled property.
-	if([the_object respondsToSelector:@selector(setAccessibilityLabel:)])
-	{
-		if(!title)
-		{
-			[the_object setAccessibilityLabel:nil];
-		}
-		else
-		{
-            NSString* ns_title = [NSString stringWithUTF8String:title];
-			[the_object setAccessibilityLabel:ns_title];
-		}
-	}
+  id the_object = iupcocoaGetMainView(ih);
+  if([the_object respondsToSelector:@selector(setAccessibilityLabel:)])
+  {
+    if(!title)
+    {
+      [the_object setAccessibilityLabel:nil];
+    }
+    else
+    {
+      NSString* ns_title = [NSString stringWithUTF8String:title];
+      [the_object setAccessibilityLabel:ns_title];
+    }
+  }
 }
 
 void iupdrvBaseRegisterCommonAttrib(Iclass* ic)
 {
-	/*
-#ifndef GTK_MAC
-  #ifdef WIN32                                 
-    iupClassRegisterAttribute(ic, "HFONT", iupgtkGetFontIdAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);
-  #else
-    iupClassRegisterAttribute(ic, "XFONTID", iupgtkGetFontIdAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);
-  #endif
-#endif
-  iupClassRegisterAttribute(ic, "PANGOFONTDESC", iupgtkGetPangoFontDescAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);
-*/
 }
 
 void iupdrvBaseRegisterVisualAttrib(Iclass* ic)
 {
-	
 }
 
+void iupdrvSendKey(int key, int press)
+{
+  unsigned int maccode, state;
+  iupdrvKeyEncode(key, &maccode, &state);
+  if (!maccode) return;
 
-void iupdrvPostRedraw(Ihandle *ih)
-{
-	iupCocoaDisplayUpdate(ih);
+  CGEventSourceRef source = CGEventSourceCreate(kCGEventSourceStateHIDSystemState);
+
+  if (press & 0x01) /* Press */
+  {
+    CGEventRef event = CGEventCreateKeyboardEvent(source, (CGKeyCode)maccode, true);
+    if (state != 0) CGEventSetFlags(event, (CGEventFlags)state);
+    CGEventPost(kCGHIDEventTap, event);
+    CFRelease(event);
+  }
+
+  if (press & 0x02) /* Release */
+  {
+    CGEventRef event = CGEventCreateKeyboardEvent(source, (CGKeyCode)maccode, false);
+    if (state != 0) CGEventSetFlags(event, (CGEventFlags)state);
+    CGEventPost(kCGHIDEventTap, event);
+    CFRelease(event);
+  }
+
+  CFRelease(source);
 }
 
-void iupdrvRedrawNow(Ihandle *ih)
-{
-	iupCocoaDisplayUpdate(ih);
-}
-void iupdrvSendKey(int key, int press)
-{
-	
-}
 void iupdrvSendMouse(int x, int y, int bt, int status)
 {
-	
+  iupdrvWarpPointer(x, y);
+
+  if (status != -1)
+  {
+    CGPoint point = CGPointMake(x, y);
+    CGEventType press_type, release_type;
+    CGMouseButton button;
+
+    switch(bt)
+    {
+      case IUP_BUTTON1: press_type=kCGEventLeftMouseDown; release_type=kCGEventLeftMouseUp; button=kCGMouseButtonLeft; break;
+      case IUP_BUTTON2: press_type=kCGEventOtherMouseDown; release_type=kCGEventOtherMouseUp; button=kCGMouseButtonCenter; break;
+      case IUP_BUTTON3: press_type=kCGEventRightMouseDown; release_type=kCGEventRightMouseUp; button=kCGMouseButtonRight; break;
+      default: return;
+    }
+
+    /* IUP Spec: status: 1 (press), 0 (release), -1 (move), 2 (double-click). */
+
+    if (status == 1) /* Press */
+    {
+      CGEventRef event = CGEventCreateMouseEvent(NULL, press_type, point, button);
+      CGEventSetIntegerValueField(event, kCGMouseEventClickState, 1);
+      CGEventPost(kCGHIDEventTap, event);
+      CFRelease(event);
+    }
+    else if (status == 0) /* Release */
+    {
+      CGEventRef event = CGEventCreateMouseEvent(NULL, release_type, point, button);
+      CGEventSetIntegerValueField(event, kCGMouseEventClickState, 1);
+      CGEventPost(kCGHIDEventTap, event);
+      CFRelease(event);
+    }
+    else if (status == 2) /* Double-click (Generate full sequence) */
+    {
+      /* Click 1 (Count 1) */
+      CGEventRef event_down1 = CGEventCreateMouseEvent(NULL, press_type, point, button);
+      CGEventSetIntegerValueField(event_down1, kCGMouseEventClickState, 1);
+      CGEventPost(kCGHIDEventTap, event_down1);
+
+      CGEventRef event_up1 = CGEventCreateMouseEvent(NULL, release_type, point, button);
+      CGEventSetIntegerValueField(event_up1, kCGMouseEventClickState, 1);
+      CGEventPost(kCGHIDEventTap, event_up1);
+
+      /* Click 2 (Count 2) */
+      CGEventRef event_down2 = CGEventCreateMouseEvent(NULL, press_type, point, button);
+      CGEventSetIntegerValueField(event_down2, kCGMouseEventClickState, 2);
+      CGEventPost(kCGHIDEventTap, event_down2);
+
+      CGEventRef event_up2 = CGEventCreateMouseEvent(NULL, release_type, point, button);
+      CGEventSetIntegerValueField(event_up2, kCGMouseEventClickState, 2);
+      CGEventPost(kCGHIDEventTap, event_up2);
+
+      CFRelease(event_down1);
+      CFRelease(event_up1);
+      CFRelease(event_down2);
+      CFRelease(event_up2);
+    }
+  }
 }
+
 void iupdrvSleep(int time)
 {
-	
+  usleep(time * 1000);
 }
+
 void iupdrvWarpPointer(int x, int y)
 {
-	
+  CGPoint point = CGPointMake(x, y);
+  CGWarpMouseCursorPosition(point);
+  CGAssociateMouseAndMouseCursorPosition(true);
 }
 
-// This will copy all the menu items provided by src_menu and append them into dst_menu with a separator.
-void iupCocoaCommonBaseAppendMenuItems(NSMenu* dst_menu, NSMenu* src_menu)
+void iupcocoaCommonBaseAppendMenuItems(NSMenu* dst_menu, NSMenu* src_menu)
 {
-	if((src_menu != nil) && ([src_menu numberOfItems] > 0))
-	{
-		// Add a separator to separate the user's items from the default items
-		[dst_menu addItem:[NSMenuItem separatorItem]];
-		
-		NSArray<NSMenuItem*>* item_array = [src_menu itemArray];
-		for(NSMenuItem* a_default_item in item_array)
-		{
-			// We have to copy the item otherwise Cocoa will complain that the same menu item is used in multiple places.
-			NSMenuItem* item_copy = [a_default_item copy];
-			[dst_menu addItem:item_copy];
-			[item_copy release];
-		}
-	}
+  if((src_menu != nil) && ([src_menu numberOfItems] > 0))
+  {
+    [dst_menu addItem:[NSMenuItem separatorItem]];
+
+    NSArray<NSMenuItem*>* item_array = [src_menu itemArray];
+    for(NSMenuItem* a_default_item in item_array)
+    {
+      NSMenuItem* item_copy = [a_default_item copy];
+      [dst_menu addItem:item_copy];
+      [item_copy release];
+    }
+  }
 }
 
-// This will copy all the menu items provided by the class's defaultMenu and append them into dst_menu with a separator.
-void iupCocoaCommonBaseAppendDefaultMenuItemsForClassType(NSMenu* dst_menu, Class class_of_widget)
+void iupcocoaCommonBaseAppendDefaultMenuItemsForClassType(NSMenu* dst_menu, Class class_of_widget)
 {
-	// If the class provides a defaultMenu, we should merge those items with our menu
-	if([class_of_widget respondsToSelector:@selector(defaultMenu)])
-	{
-		NSMenu* default_menu = [class_of_widget defaultMenu];
-		iupCocoaCommonBaseAppendMenuItems(dst_menu, default_menu);
-	}
+  if([class_of_widget respondsToSelector:@selector(defaultMenu)])
+  {
+    NSMenu* default_menu = [class_of_widget defaultMenu];
+    iupcocoaCommonBaseAppendMenuItems(dst_menu, default_menu);
+  }
 }
 
-// Because we often have container views wrapping our core objects (e.g. scrollview wraps canvas, stackview wraps NSTextField)
-// this helper function lets us split out the ih from the widget, so we don't have to assume the widget is ih->handle.
-// So provide the ih, and provide the real core widget that provides [NSResponder setMenu:] that we should set.
-// The menu should be in menu_ih.
-void iupCocoaCommonBaseSetContextMenuForWidget(Ihandle* ih, id widget_to_attach_menu_to, Ihandle* menu_ih)
+void iupcocoaCommonBaseSetContextMenuForWidget(Ihandle* ih, id widget_to_attach_menu_to, Ihandle* menu_ih)
 {
-	// Save the menu Ihandle in this widget's Ihandle so we can GetContextMenuAttrib
-	iupAttribSet(ih, "_COCOA_CONTEXT_MENU_IH", (const char*)menu_ih);
+  /* Mark that the user has configured this attribute. This allows delegate methods
+     to distinguish between "never set" (use default behavior) and "set to nil" (disable menu). */
+  iupAttribSet(ih, "_IUPCOCOA_CONTEXTMENU_SET", "1");
+  iupAttribSet(ih, "_COCOA_CONTEXT_MENU_IH", (const char*)menu_ih);
 
+  if (NULL == menu_ih)
+  {
+    if ([widget_to_attach_menu_to respondsToSelector:@selector(setMenu:)])
+    {
+      [widget_to_attach_menu_to setMenu:nil];
+    }
+    return;
+  }
 
-	// Unset the existing menu
-	if(NULL == menu_ih)
-	{
-		if([widget_to_attach_menu_to respondsToSelector:@selector(setMenu:)])
-		{
-			[widget_to_attach_menu_to setMenu:nil];
-		}
-		return;
-	}
+  if (NULL == menu_ih->handle)
+  {
+    IupMap(menu_ih);
+  }
 
-	// FIXME: The Menu might not be IupMap'd yet. (Presumably because we do not attach it directly to a dialog in this case.)
-	// I think calling IupMap() is the correct thing to do and fixes the problem.
-	// But this should be reviewed.
-	if(NULL == menu_ih->handle)
-	{
-		IupMap(menu_ih);
-	}
-	
-	// Make sure we have an IupMenu
-	if(menu_ih->iclass->nativetype != IUP_TYPEMENU)
-	{
-		// call IUPASSERT?
-		return;
-	}
-	// Make sure we have a NSMenu
-	if(![(id)menu_ih->handle isKindOfClass:[NSMenu class]])
-	{
-		// call IUPASSERT?
-		return;
-	}
+  if (menu_ih->iclass->nativetype != IUP_TYPEMENU || ![(id)menu_ih->handle isKindOfClass:[NSMenu class]])
+  {
+    return;
+  }
 
-
-	NSMenu* the_menu = (NSMenu*)menu_ih->handle;
-	if([widget_to_attach_menu_to respondsToSelector:@selector(setMenu:)])
-	{
-		iupCocoaCommonBaseAppendDefaultMenuItemsForClassType(the_menu, [widget_to_attach_menu_to class]);
-		[widget_to_attach_menu_to setMenu:the_menu];
-	}
-
+  NSMenu* the_menu = (NSMenu*)menu_ih->handle;
+  if ([widget_to_attach_menu_to respondsToSelector:@selector(setMenu:)])
+  {
+    iupcocoaCommonBaseAppendDefaultMenuItemsForClassType(the_menu, [widget_to_attach_menu_to class]);
+    [widget_to_attach_menu_to setMenu:the_menu];
+  }
 }
 
-
-int iupCocoaCommonBaseIupButtonForCocoaButton(NSInteger which_cocoa_button)
+int iupcocoaCommonBaseIupButtonForCocoaButton(NSInteger which_cocoa_button)
 {
-	if(0 == which_cocoa_button)
-	{
-		return IUP_BUTTON1;
-	}
-	else if(1 == which_cocoa_button) // right
-	{
-		return IUP_BUTTON3;
-	}
-	else if(2 == which_cocoa_button) // middle
-	{
-		return IUP_BUTTON2;
-	}
-	else
-	{
-		// NOTE: IUP_BUTTON are ASCII values.
-		return (int)(which_cocoa_button + 0x30);
-	}
+  if(0 == which_cocoa_button) return IUP_BUTTON1;
+  if(1 == which_cocoa_button) return IUP_BUTTON3;
+  if(2 == which_cocoa_button) return IUP_BUTTON2;
+  if(3 == which_cocoa_button) return IUP_BUTTON4;
+  if(4 == which_cocoa_button) return IUP_BUTTON5;
+  return (int)(which_cocoa_button + '0'); /* Other buttons */
 }
 
-bool iupCocoaCommonBaseHandleMouseButtonCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view, bool is_pressed)
+bool iupcocoaCommonBaseHandleMouseButtonCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view, bool is_pressed)
 {
-	IFniiiis callback_function;
-	bool caller_should_propagate = true;
+  IFniiiis callback_function;
+  bool caller_should_propagate = true;
 
-	callback_function = (IFniiiis)IupGetCallback(ih, "BUTTON_CB");
-	if(callback_function)
-	{
-	    // We must convert the mouse event locations from the window coordinate system to the
-		// local view coordinate system.
-		NSPoint the_point = [the_event locationInWindow];
-		NSPoint converted_point = [represented_view convertPoint:the_point fromView:nil];
+  callback_function = (IFniiiis)IupGetCallback(ih, "BUTTON_CB");
+  if(callback_function)
+  {
+    NSPoint the_point = [the_event locationInWindow];
+    NSPoint converted_point = [represented_view convertPoint:the_point fromView:nil];
+    CGFloat final_y = converted_point.y;
 
-		// We must flip the y to go from Cartesian to IUP
-		NSRect view_frame = [represented_view frame];
-		CGFloat inverted_y = view_frame.size.height - converted_point.y;
+    /* Convert from Cocoa's coordinate system (origin bottom-left) to IUP's (origin top-left),
+       but only if the view is not already flipped (which would mean it is already top-left). */
+    if(![represented_view isFlipped])
+    {
+      NSRect view_bounds = [represented_view bounds];
+      final_y = view_bounds.size.height - converted_point.y;
+    }
 
-		// Button 0 is left
-		// Button 1 is right
-		// Button 2 is middle
-		// Button 3 keeps going
-		NSInteger which_cocoa_button = [the_event buttonNumber];
-		char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
-		iupcocoaButtonKeySetStatus(the_event, mod_status);
+    NSInteger which_cocoa_button = [the_event buttonNumber];
+    char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+    iupcocoaButtonKeySetStatus(the_event, mod_status);
 
-		if([the_event modifierFlags] & NSControlKeyMask)
-		{
-			// Should Ctrl-Left-click be a right click?
-			if(0 == which_cocoa_button)
-			{
-				which_cocoa_button = 1; // make right button
-			}
-		}
-		else if([the_event modifierFlags] & NSAlternateKeyMask)
-		{
+    if([the_event modifierFlags] & NSEventModifierFlagControl && 0 == which_cocoa_button)
+    {
+      which_cocoa_button = 1; /* Ctrl-Left-click becomes a right-click */
+    }
 
-		}
-		else if([the_event modifierFlags] & NSCommandKeyMask)
-		{
-		}
-		else
-		{
-		}
-		
-		int which_iup_button = iupCocoaCommonBaseIupButtonForCocoaButton(which_cocoa_button);
-	
-		NSLog(@"Iup mouse button callback: <x,y>=<%f, %f, %f>, is_pressed=%d, button_num:%d", converted_point.x, converted_point.y, inverted_y, is_pressed, which_iup_button);
+    int which_iup_button = iupcocoaCommonBaseIupButtonForCocoaButton(which_cocoa_button);
 
-	
-		int callback_result = callback_function(ih, which_iup_button, is_pressed, iupROUND(converted_point.x), iupROUND(inverted_y), mod_status);
-		if(IUP_CLOSE == callback_result)
-		{
-			IupExitLoop();
-			caller_should_propagate = false;
-		}
-		else if(IUP_IGNORE == callback_result)
-		{
-			caller_should_propagate = false;
-		}
-		else if(IUP_CONTINUE == callback_result)
-		{
-			caller_should_propagate = true;
-		}
-		else
-		{
-			caller_should_propagate = false;
-		}
-	}
-	else
-	{
-		caller_should_propagate = true;
-	}
-	return !caller_should_propagate;
+    int callback_result = callback_function(ih, which_iup_button, is_pressed, iupROUND(converted_point.x), iupROUND(final_y), mod_status);
+    if(IUP_CLOSE == callback_result)
+    {
+      IupExitLoop();
+      caller_should_propagate = false;
+    }
+    else if(IUP_IGNORE == callback_result)
+    {
+      caller_should_propagate = false;
+    }
+    else if(IUP_CONTINUE == callback_result)
+    {
+      caller_should_propagate = true;
+    }
+    else
+    {
+      caller_should_propagate = false;
+    }
+  }
+  else
+  {
+    caller_should_propagate = true;
+  }
+  return !caller_should_propagate;
 }
 
-bool iupCocoaCommonBaseHandleMouseMotionCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view)
+bool iupcocoaCommonBaseHandleMouseMotionCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view)
 {
-	bool caller_should_propagate = true;
-	IFniis callback_function;
-	callback_function = (IFniis)IupGetCallback(ih, "MOTION_CB");
-	if(callback_function)
-	{
-	    // We must convert the mouse event locations from the window coordinate system to the
-		// local view coordinate system.
-		NSPoint the_point = [the_event locationInWindow];
-		NSPoint converted_point = [represented_view convertPoint:the_point fromView:nil];
-		
-		// We must flip the y to go from Cartesian to IUP
-		NSRect view_frame = [represented_view frame];
-		CGFloat inverted_y = view_frame.size.height - converted_point.y;
-		char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
-		iupcocoaButtonKeySetStatus(the_event, mod_status);
+  bool caller_should_propagate = true;
+  IFniis callback_function;
+  callback_function = (IFniis)IupGetCallback(ih, "MOTION_CB");
+  if(callback_function)
+  {
+    NSPoint the_point = [the_event locationInWindow];
+    NSPoint converted_point = [represented_view convertPoint:the_point fromView:nil];
+    CGFloat final_y = converted_point.y;
 
-	
-		int callback_result = callback_function(ih,  iupROUND(converted_point.x), iupROUND(inverted_y), mod_status);
-		if(IUP_CLOSE == callback_result)
-		{
-			IupExitLoop();
-			caller_should_propagate = false;
-		}
-		else if(IUP_IGNORE == callback_result)
-		{
-			caller_should_propagate = false;
-		}
-		else if(IUP_CONTINUE == callback_result)
-		{
-			caller_should_propagate = true;
-		}
-		else
-		{
-			caller_should_propagate = false;
-		}
-	}
-	else
-	{
-		caller_should_propagate = true;
-	}
-	return !caller_should_propagate;
+    /* Convert from Cocoa's coordinate system (origin bottom-left) to IUP's (origin top-left),
+       but only if the view is not already flipped (which would mean it is already top-left). */
+    if(![represented_view isFlipped])
+    {
+      NSRect view_bounds = [represented_view bounds];
+      final_y = view_bounds.size.height - converted_point.y;
+    }
+
+    char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+    iupcocoaButtonKeySetStatus(the_event, mod_status);
+
+    callback_function(ih,  iupROUND(converted_point.x), iupROUND(final_y), mod_status);
+  }
+  return !caller_should_propagate;
 }
 
-
-// TODO: IUP doesn't support y-axis scroll events. We need to add a new API.
-bool iupCocoaCommonBaseScrollWheelCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view)
+bool iupcocoaCommonBaseScrollWheelCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view)
 {
-	IFnfiis callback_function;
-	bool caller_should_propagate = true;
+  IFnfiis callback_function;
+  bool caller_should_propagate = true;
 
-	callback_function = (IFnfiis)IupGetCallback(ih, "WHEEL_CB");
-	if(callback_function)
-	{
-	    // We must convert the mouse event locations from the window coordinate system to the
-		// local view coordinate system.
-		NSPoint the_point = [the_event locationInWindow];
-		NSPoint converted_point = [represented_view convertPoint:the_point fromView:nil];
+  callback_function = (IFnfiis)IupGetCallback(ih, "WHEEL_CB");
+  if(callback_function)
+  {
+    NSPoint the_point = [the_event locationInWindow];
+    NSPoint converted_point = [represented_view convertPoint:the_point fromView:nil];
+    CGFloat final_y = converted_point.y;
 
-		CGFloat delta_x = -[the_event deltaX];
-		CGFloat delta_y = [the_event deltaY];
+    /* IUP's WHEEL_CB 'delta' corresponds to vertical scrolling.
+       On macOS, deltaY > 0 means scroll up (content should move up, showing content above).
+       This matches the IUP convention where positive delta means scroll up. */
+    CGFloat delta = [the_event deltaY];
 
-		// We must flip the y to go from Cartesian to IUP
-		NSRect view_frame = [represented_view frame];
-		CGFloat inverted_y = view_frame.size.height - converted_point.y;
+    /* IUP does not have a separate parameter for horizontal scrolling (deltaX). */
 
-		char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
-		iupcocoaButtonKeySetStatus(the_event, mod_status);
+    /* Convert from Cocoa's coordinate system (origin bottom-left) to IUP's (origin top-left),
+       but only if the view is not already flipped (which would mean it is already top-left). */
+    if(![represented_view isFlipped])
+    {
+      NSRect view_bounds = [represented_view bounds];
+      final_y = view_bounds.size.height - converted_point.y;
+    }
 
-		int callback_result = callback_function(ih, delta_x, iupROUND(converted_point.x), iupROUND(inverted_y), mod_status);
-		if(IUP_CLOSE == callback_result)
-		{
-			IupExitLoop();
-			caller_should_propagate = false;
-		}
-		else if(IUP_IGNORE == callback_result)
-		{
-			caller_should_propagate = false;
-		}
-		else if(IUP_CONTINUE == callback_result)
-		{
-			caller_should_propagate = true;
-		}
-		else
-		{
-			caller_should_propagate = false;
-		}
-	}
-	else
-	{
-		caller_should_propagate = true;
-	}
-	return !caller_should_propagate;
+    char mod_status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+    iupcocoaButtonKeySetStatus(the_event, mod_status);
+
+    int callback_result = callback_function(ih, delta, iupROUND(converted_point.x), iupROUND(final_y), mod_status);
+    if(IUP_CLOSE == callback_result)
+    {
+      IupExitLoop();
+      caller_should_propagate = false;
+    }
+    else if(IUP_IGNORE == callback_result)
+    {
+      caller_should_propagate = false;
+    }
+  }
+  return !caller_should_propagate;
 }
 
-
-int iupCocoaCommonBaseSetLayerBackedAttrib(Ihandle* ih, const char* value)
+int iupcocoaCommonBaseSetLayerBackedAttrib(Ihandle* ih, const char* value)
 {
-	id the_object = ih->handle;
-	
-	NSView* main_view = iupCocoaGetMainView(ih);
-	if(nil != main_view)
-	{
-		BOOL should_enable = (BOOL)iupStrBoolean(value);
-		[main_view setWantsLayer:should_enable];
-		NSView* root_view = iupCocoaGetMainView(ih);
-		if(root_view != main_view)
-		{
-			[root_view setWantsLayer:should_enable];
-		}
-	}
-	else if([the_object respondsToSelector:@selector(setWantsLayer:)])
-	{
-		BOOL should_enable = (BOOL)iupStrBoolean(value);
-		[the_object setWantsLayer:should_enable];
-	}
-	else if([the_object isKindOfClass:[NSViewController class]])
-	{
-		NSView* the_view = [(NSViewController*)the_object view];
-		BOOL should_enable = (BOOL)iupStrBoolean(value);
-		[the_view setWantsLayer:should_enable];
-	}
-	return 0;
+  NSView* main_view = iupcocoaGetMainView(ih);
+  if(nil != main_view)
+  {
+    BOOL should_enable = (BOOL)iupStrBoolean(value);
+    [main_view setWantsLayer:should_enable];
+    NSView* root_view = iupcocoaGetRootView(ih);
+    if(root_view != main_view)
+    {
+      [root_view setWantsLayer:should_enable];
+    }
+  }
+  return 0;
 }
 
 char* iupCocoaCommonBaseGetLayerBackedAttrib(Ihandle* ih)
 {
-	id the_object = ih->handle;
-	NSView* main_view = iupCocoaGetRootView(ih);
-	if(nil != main_view)
-	{
-		BOOL is_enabled = [main_view wantsLayer];
-		return iupStrReturnBoolean(is_enabled);
-	}
-	else if([the_object respondsToSelector:@selector(wantsLayer)])
-	{
-		BOOL is_enabled = [the_object wantsLayer];
-		return iupStrReturnBoolean(is_enabled);
-	}
-	else if([the_object isKindOfClass:[NSViewController class]])
-	{
-		NSView* the_view = [(NSViewController*)the_object view];
-		BOOL is_enabled = [the_view wantsLayer];
-		return iupStrReturnBoolean(is_enabled);
-	}
-	return iupStrReturnBoolean(false);
+  NSView* main_view = iupcocoaGetRootView(ih);
+  if(nil != main_view)
+  {
+    BOOL is_enabled = [main_view wantsLayer];
+    return iupStrReturnBoolean(is_enabled);
+  }
+  return iupStrReturnBoolean(false);
 }
 
-int iupCocoaCommonBaseSetContextMenuAttrib(Ihandle* ih, const char* value)
+int iupcocoaCommonBaseSetContextMenuAttrib(Ihandle* ih, const char* value)
 {
-	Ihandle* menu_ih = (Ihandle*)value;
-//	id widget_to_attach_menu_to = ih->handle;
-	id widget_to_attach_menu_to = iupCocoaGetMainView(ih);
+  Ihandle* menu_ih = (Ihandle*)value;
+  id widget_to_attach_menu_to = iupcocoaGetMainView(ih);
 
-	iupCocoaCommonBaseSetContextMenuForWidget(ih, widget_to_attach_menu_to, menu_ih);
-	
-	return 1;
+  iupcocoaCommonBaseSetContextMenuForWidget(ih, widget_to_attach_menu_to, menu_ih);
+
+  return 1;
 }
 
-char* iupCocoaCommonBaseGetContextMenuAttrib(Ihandle* ih)
+char* iupcocoaCommonBaseGetContextMenuAttrib(Ihandle* ih)
 {
-	return (char*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+  return (char*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
 }
 
-int iupCocoaCommonBaseSetSendActionAttrib(Ihandle* ih, const char* value)
+int iupcocoaCommonBaseSetSendActionAttrib(Ihandle* ih, const char* value)
 {
-	if(NULL == value)
-	{
-		return 0;
-	}
-	
-	NSView* target_view = nil;
-	id sender_object = nil;
-	if(NULL == ih)
-	{
-		// Send through the normal responder chain starting at the first responder
-		target_view = nil;
-		sender_object = nil;
-	}
-	else
-	{
-	 	target_view = iupCocoaGetMainView(ih);
-	 	sender_object = target_view;
-	}
-	
-	// TODO: Create well know aliases.
-	// For now, user must put the exact selector name, with the colon
-	// undo: redo: cut: copy: paste: pasteAsPlainText:
-	SEL the_selector = sel_registerName(value);
-	
-	[[NSApplication sharedApplication] sendAction:the_selector to:target_view from:sender_object];
+  if(NULL == value)
+  {
+    return 0;
+  }
 
-	return 0;
+  NSView* target_view = nil;
+  id sender_object = nil;
+  if(NULL == ih)
+  {
+    target_view = nil;
+    sender_object = nil;
+  }
+  else
+  {
+    target_view = iupcocoaGetMainView(ih);
+    sender_object = target_view;
+  }
+
+  SEL the_selector = sel_getUid(value);
+
+  [[NSApplication sharedApplication] sendAction:the_selector to:target_view from:sender_object];
+
+  return 0;
 }
 
+NSWindow* cocoaDialogGetWindow(Ihandle* ih)
+{
+  if (!ih || !ih->handle) return nil;
+  id root_object = (id)ih->handle;
+  if ([root_object isKindOfClass:[NSWindow class]])
+  {
+    return (NSWindow*)root_object;
+  }
+  return nil;
+}
+
+int iupcocoaIsSystemDarkMode(void)
+{
+  NSAppearance *appearance = [NSApp effectiveAppearance];
+  NSString *appearanceName = [appearance bestMatchFromAppearancesWithNames:@[NSAppearanceNameAqua, NSAppearanceNameDarkAqua]];
+  return [appearanceName isEqualToString:NSAppearanceNameDarkAqua] ? 1 : 0;
+}
Index: src/cocoa/iupcocoa_dialog.m
===================================================================
--- src/cocoa/iupcocoa_dialog.m	(revision 5971)
+++ src/cocoa/iupcocoa_dialog.m	(working copy)
@@ -7,18 +7,14 @@
 #import <Cocoa/Cocoa.h>
 #import <objc/runtime.h>
 
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <memory.h>
 #include <stdarg.h>
-#include <limits.h>
-#include <time.h>
 
 #include "iup.h"
 #include "iupcbs.h"
-
 #include "iup_class.h"
 #include "iup_object.h"
 #include "iup_layout.h"
@@ -25,7 +21,6 @@
 #include "iup_dlglist.h"
 #include "iup_attrib.h"
 #include "iup_drv.h"
-#include "iup_drvfont.h"
 #include "iup_drvinfo.h"
 #include "iup_focus.h"
 #include "iup_str.h"
@@ -32,1599 +27,1695 @@
 #define _IUPDLG_PRIVATE
 #include "iup_dialog.h"
 #include "iup_image.h"
-#include "iup_assert.h"
 
 #include "iupcocoa_drv.h"
+#include "iupcocoa_keycodes.h"
 
-static void* TRAYMENUIHANDLE_ASSOCIATED_OBJ_KEY = "TRAYMENUIHANDLE_ASSOCIATED_OBJ_KEY";
-extern NSMutableArray* g_stackOfModals;
 
+static const void* DOCKPROGRESS_ASSOCIATED_OBJ_KEY = @"DOCKPROGRESS_ASSOCIATED_OBJ_KEY";
+static const char IUPCocoaZoomRestoreFrameKey = 0;
+
+static void* IupCocoaAppearanceContext = &IupCocoaAppearanceContext;
+
 @interface ModalInfo : NSObject
 {
-	Ihandle* _ih;
-	NSModalSession _modalSession;
+  Ihandle* _ih;
+  NSModalSession _modalSession;
 }
 @property(assign, nonatomic) Ihandle* ih;
 @property(assign, nonatomic) NSModalSession modalSession;
 @end
+
 @implementation ModalInfo
 @synthesize ih;
 @synthesize modalSession;
 @end
 
+@interface IupCocoaWindowDelegate : NSObject <NSWindowDelegate>
+@end
 
+@interface IupCocoaWindow : NSWindow
+@end
 
+@implementation IupCocoaWindow
 
-static NSWindow* cocoaDialogGetWindow(Ihandle* ih)
+- (BOOL)performKeyEquivalent:(NSEvent *)event
 {
-	NSWindow* root_object = (NSWindow*)ih->handle;
-	NSCAssert([root_object isKindOfClass:[NSWindow class]], @"Expected NSWindow");
-	return root_object;
+  if ([event type] == NSEventTypeKeyDown)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY); /* this is the dialog handle */
+    if (iupObjectCheck(ih))
+    {
+      NSResponder* first_responder = [self firstResponder];
+      Ihandle* focused_ih = nil;
+
+      if (first_responder && [first_responder isKindOfClass:[NSView class]])
+      {
+        focused_ih = (Ihandle*)objc_getAssociatedObject(first_responder, IHANDLE_ASSOCIATED_OBJ_KEY);
+      }
+
+      if (!iupObjectCheck(focused_ih))
+      {
+        focused_ih = ih;
+      }
+
+      int mac_key_code = [event keyCode];
+      if (iupcocoaKeyEvent(focused_ih, event, mac_key_code, true))
+      {
+        return YES;
+      }
+
+      if (mac_key_code == kVK_Return)
+      {
+        if (focused_ih && IupClassMatch(focused_ih, "button"))
+        {
+          return [super performKeyEquivalent:event];
+        }
+        Ihandle* button_ih = IupGetAttributeHandle(ih, "DEFAULTENTER");
+        if (iupObjectCheck(button_ih))
+        {
+          iupdrvActivate(button_ih);
+          return YES;
+        }
+      }
+      else if (mac_key_code == kVK_Escape)
+      {
+        Ihandle* button_ih = IupGetAttributeHandle(ih, "DEFAULTESC");
+        if (iupObjectCheck(button_ih))
+        {
+          iupdrvActivate(button_ih);
+          return YES;
+        }
+      }
+    }
+  }
+
+  return [super performKeyEquivalent:event];
 }
 
-static NSStatusItem* cocoaDialogGetStatusItem(Ihandle* ih)
+- (void)keyDown:(NSEvent *)event
 {
-	NSStatusItem* root_object = (NSStatusItem*)ih->handle;
-	NSCAssert([root_object isKindOfClass:[NSStatusItem class]], @"Expected NSStatusItem");
-	return root_object;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    BOOL handled = iupcocoaKeyEvent(ih, event, mac_key_code, true);
+    if (!handled)
+    {
+      [super keyDown:event];
+    }
+  }
+  else
+  {
+    [super keyDown:event];
+  }
 }
 
-/*
-@interface NSWindow () 
-@property(readwrite, unsafe_unretained) Ihandle* iupIhandle;
-@end
+- (void)keyUp:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaKeyEvent(ih, event, mac_key_code, false))
+      [super keyUp:event];
+  }
+  else
+    [super keyUp:event];
+}
 
-@implementation NSWindow
-@synthesize iupIhandle = _iupIhandle;
+- (void)flagsChanged:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaModifierEvent(ih, event, mac_key_code))
+      [super flagsChanged:event];
+  }
+  else
+    [super flagsChanged:event];
+}
+
 @end
- */
-@interface IupCocoaWindowDelegate : NSObject <NSWindowDelegate>
-- (BOOL) windowShouldClose:(id)the_sender;
-- (NSSize) windowWillResize:(NSWindow*)the_sender toSize:(NSSize)frame_size;
 
+/****************************************************************
+ ****************** Utilities & Helpers *************************
+ ****************************************************************/
 
-- (void) windowDidEnterFullScreen:(NSNotification*)the_notification; // 10.7+
-- (void) windowDidExitFullScreen:(NSNotification*)the_notification;   // 10.7+
+static NSWindowStyleMask cocoaDialogGetStyleMask(Ihandle* ih)
+{
+  NSWindowStyleMask style_mask;
+  int has_titlebar = 0;
 
-@end
+  if (iupAttribGet(ih, "TITLE"))
+    has_titlebar = 1;
 
-static void cocoaCleanUpWindow(Ihandle* ih)
-{
-//	NSLog(@"cocoaCleanUpWindow");
-	NSWindow* the_window = (__bridge NSWindow*)ih->handle;
-	[the_window close];
-	// Expecting windowWillClose to run immediately here
-	
-	IupCocoaWindowDelegate* window_delegate = [the_window delegate];
-	[the_window setDelegate:nil];
-	[window_delegate release];
+  if (iupAttribGetBoolean(ih, "MAXBOX") ||
+      iupAttribGetBoolean(ih, "MINBOX") ||
+      iupAttribGetBoolean(ih, "MENUBOX"))
+    has_titlebar = 1;
 
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[the_window release];
-}
+  if (iupAttribGetBoolean(ih, "BORDER"))
+    has_titlebar = 1;
 
-static void cocoaDialogRunModalLoop(Ihandle* ih, NSWindow* the_window)
-{
-	// Gotcha: beginModalSessionForWindow sets [NSApp isRunning] to 1
-	NSModalSession the_session = [[NSApplication sharedApplication] beginModalSessionForWindow:the_window];
-	
-	iupAttribSet(ih, "_COCOA_MODAL", "YES");
-	iupAttribSet(ih, "_COCOA_MODAL_SESSION", (const char*)the_session);
-	
-	
-	ModalInfo* modal_info = [[[ModalInfo alloc] init] autorelease];
-	[modal_info setIh:ih];
-	[modal_info setModalSession:the_session];
-	[g_stackOfModals addObject:modal_info];
+  if (has_titlebar)
+    style_mask = NSWindowStyleMaskTitled;
+  else
+    style_mask = NSWindowStyleMaskBorderless;
 
-	for(;;)
-	{
-		if([NSApp runModalSession:the_session] != NSModalResponseContinue)
-		{
-			break;
-		}
-	}
-	
-	// Normally, we would call endModalSession here, but this doesn't seem to quite work for us.
-	// But there seems to be an ordering problem.
-	// Calling IupDestroy to close the modal window goes through the entire teardown process before this loop can return in the next pump.
-	// This seems to be causing bugs where the window doesn't fully get destroyed and a ghost window is stuck on the screen sometimes.
-	// The workaround seems to be to call endModalSession directly next to where we call stopModal.
-	// I think the teardown then will work because the window is no longer modal.
-	//	[NSApp endModalSession:the_session];
-	// UPDATE: I now believe the ghost/stuck windows are because of not using the [NSApp run] (real runloop). I now have a special case to handle this.
+  if (iupAttribGetBoolean(ih, "RESIZE"))
+    style_mask |= NSWindowStyleMaskResizable;
 
-	// Drat: ih may be destroyed by now.
-//	iupAttribSet(ih, "_COCOA_MODAL", "NO");
-//	iupAttribSet(ih, "_COCOA_MODAL_SESSION", NULL);
+  if (iupAttribGetBoolean(ih, "MINBOX"))
+    style_mask |= NSWindowStyleMaskMiniaturizable;
+
+  if (iupAttribGetBoolean(ih, "MENUBOX"))
+    style_mask |= NSWindowStyleMaskClosable;
+
+  if (iupAttribGetBoolean(ih, "TOOLBOX"))
+    style_mask |= NSWindowStyleMaskUtilityWindow;
+
+  return style_mask;
 }
 
+static void cocoaDialogUpdateStyleMask(Ihandle* ih)
+{
+  NSWindow* window = cocoaDialogGetWindow(ih);
+  if (window)
+  {
+    NSWindowStyleMask new_mask = cocoaDialogGetStyleMask(ih);
+    [window setStyleMask:new_mask];
+  }
+}
 
+/****************************************************************
+ ********************** Modal Loop ******************************
+ ****************************************************************/
 
 @interface IupNonRunLoopModalAppDelegate : NSObject <NSApplicationDelegate>
 {
-	Ihandle* _ih;
+  Ihandle* _ih;
 }
 - (instancetype) initWithIhandle:(Ihandle*)ih;
 - (Ihandle*) ih;
 @end
 
-
-
 @implementation IupNonRunLoopModalAppDelegate
 
 - (instancetype) initWithIhandle:(Ihandle*)ih
 {
-	self = [super init];
-	if(nil == self)
-	{
-		return nil;
-	}
-	_ih = ih;
-	return self;
+  self = [super init];
+  if(nil != self)
+  {
+    _ih = ih;
+  }
+  return self;
 }
 
 - (Ihandle*) ih
 {
-	return _ih;
+  return _ih;
 }
 
+- (void) applicationWillFinishLaunching:(NSNotification*)a_notification
+{
+  if ([NSApp activationPolicy] == NSApplicationActivationPolicyProhibited)
+  {
+    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
+  }
+
+  Ihandle* ih = _ih;
+  if (ih->data->menu)
+  {
+    if (!ih->data->menu->handle)
+      IupMap(ih->data->menu);
+
+    if (ih->data->menu->handle)
+      iupcocoaMenuSetApplicationMenu(ih->data->menu);
+  }
+  else
+  {
+    Ihandle* global_menu = (Ihandle*)IupGetGlobal("MENU");
+    if (global_menu)
+    {
+      if (!global_menu->handle)
+        IupMap(global_menu);
+
+      if (global_menu->handle)
+        iupcocoaMenuSetApplicationMenu(global_menu);
+    }
+    else
+    {
+      iupcocoaEnsureDefaultApplicationMenu();
+    }
+  }
+}
+
 - (void) applicationDidFinishLaunching:(NSNotification*)a_notification
 {
-	Ihandle* ih = _ih;
-	
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
+  Ihandle* ih = _ih;
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
 
-	// This blocks until done.
-	cocoaDialogRunModalLoop(ih, the_window);
+  [NSApp activateIgnoringOtherApps:YES];
+  [the_window makeKeyAndOrderFront:nil];
+  [the_window makeMainWindow];
 
-	// Now stop this special case run loop.
-	// Ugh. [NSApp stop:nil]; throws a NSApp with wrong _running count exception.
-	// I think we need to let this callback finish before we can stop it.
-	// Fortunately, now that we have a working runloop, we can try to schedule the stop to happen later.
-//	[NSApp stop:nil];
-	[NSApp performSelectorOnMainThread:@selector(stop:) withObject:NSApp waitUntilDone:NO];
+  [NSApp runModalForWindow:the_window];
 
-	
+  [NSApp performSelectorOnMainThread:@selector(stop:) withObject:NSApp waitUntilDone:NO];
 }
 
 - (void) applicationWillTerminate:(NSNotification*)a_notification
 {
-	// Invoke the IupEntry callback function to start the user code.
-	IFentry exit_callback = (IFentry)IupGetFunction("EXIT_CB");
-	
-	if(NULL != exit_callback)
-	{
-		exit_callback();
-	}
+  IFentry exit_callback = (IFentry)IupGetFunction("EXIT_CB");
+  if(NULL != exit_callback)
+  {
+    exit_callback();
+  }
 }
-
-
 @end
 
-static void cocoaDialogStartModal(Ihandle* ih)
+bool cocoaDialogExitModal(Ihandle* modal_ih)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if(!iupObjectCheck(modal_ih))
+  {
+    return false;
+  }
 
-	
-	
-	// HACK:
-	// This seems to be another one of those *must use [NSApp run] bugs*.
-	// If I create a modal IupPopup as the first dialog, it prevents IupMainLoop() from getting called and thus [NSApp run].
-	// The problem seems to come in dismissing the dialog. It sometimes does not go away and becomes a stuck ghost window.
-	// Additionally, if I swap spaces, and then click the Dock icon, sometimes the window actually resurrects and becomes a stuck ghost window.
-	// The solution seems to be to always run with [NSApp run].
-	// So to make this happen in this IupPopup as first dialog (special) case, I need to check if isRunning.
-	// If not running, I need to invoke [NSApp run].
-	// However, this will transfer control flow to the AppDelegate and not return until that run is stopped.
-	// Since this is a special case, I want to make a special AppDelegate for just this case.
-	// So we want to save the real app delegate, swap in our new one, let it run the modal stuff until end, stop the run (which returns the control flow), and swap back in the original app delegate.
-	
-	// WARNING: There is a potential bug in that if the rest of this implementation is depending on something the real AppDelegate provides and we didn't implement it (correctly),
-	// functionality will not behave correctly.
-	
-	if(NO == [[NSApplication sharedApplication] isRunning])
-	{
-		// Save the original delegate. It is weak ownership so retain counts are not changed.
-		id original_delegate = [NSApp delegate];
-		// Create our own special case app delegate for just this case.
-		IupNonRunLoopModalAppDelegate* temp_delegate = [[IupNonRunLoopModalAppDelegate alloc] initWithIhandle:ih];
-		[NSApp setDelegate:temp_delegate];
-		
-		// Remember this blocks until the run is stopped (presumably when the modal dialog is done)
-		[NSApp run];
+  Ihandle* parent_ih = IupGetAttributeHandle(modal_ih, "PARENTDIALOG");
+  NSWindow* parent_window = nil;
+  if(iupObjectCheck(parent_ih))
+  {
+    parent_window = cocoaDialogGetWindow(parent_ih);
+  }
 
-		// Now swap back the original app delegate
-		[NSApp setDelegate:original_delegate];
-		// free our temp delegate
-		[temp_delegate release];
-		return;
-	}
-	else
-	{
-		cocoaDialogRunModalLoop(ih, the_window);
-	}
-	
+  if(!parent_window)
+  {
+    NSWindow* the_window = cocoaDialogGetWindow(modal_ih);
+    if(the_window)
+    {
+      parent_window = [the_window parentWindow];
+      if(parent_window)
+      {
+        parent_ih = (Ihandle*)objc_getAssociatedObject(parent_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+      }
+    }
+  }
 
-	
+  if (parent_window && iupObjectCheck(parent_ih))
+  {
+    [NSApp activateIgnoringOtherApps:YES];
+    [parent_window makeKeyAndOrderFront:nil];
+    iupcocoaFocusIn(parent_ih);
+    return true;
+  }
+
+  return false;
 }
 
-
-static void cocoaDialogEndModal(Ihandle* ih)
+static void cocoaDialogChildDestroyNotification(NSNotification* notification)
 {
-	
-	void* the_session = iupAttribGet(ih, "_COCOA_MODAL_SESSION");
-	[NSApp stopModal];
-	// We need to call endModalSession now instead of after the return to the infinite-poll-loop because IupDestroy() wasn't fully working and a ghost window was sometimes being left behind/stuck.
-	// I was a little worried this entire block needed to be called in Unmap, before cocoaCleanUpWindow(),
-	// but this seems to work so far. I like here better because I don't have to handle two separate cases of whether it was called via IupDestroy or the user hit the close button.
-	// Note that endModalSession can only be called once per session, or it throws an exception.
-	[NSApp endModalSession:(NSModalSession)the_session];
-	
-	// IupHide seemed like the right thing to call based on all the times I saw it in the source.
-	// However, it seems to get called already in the window close so this is redundant.
-//	IupHide(ih); /* default: close the window */
-	
-	iupAttribSet(ih, "_COCOA_MODAL", "NO");
-	iupAttribSet(ih, "_COCOA_MODAL_SESSION", NULL);
-	
-	ModalInfo* modal_info = [g_stackOfModals lastObject];
-	NSCAssert([modal_info ih] == ih, @"ih pointers need to match");
-	NSCAssert([modal_info modalSession] == the_session, @"sessions need to match");
-	[g_stackOfModals removeLastObject];
-}
+  NSWindow* child_window = [notification object];
+  Ihandle* child_ih = (Ihandle*)objc_getAssociatedObject(child_window, IHANDLE_ASSOCIATED_OBJ_KEY);
 
-bool cocoaDialogExitModal()
-{
-	if([g_stackOfModals count] > 0)
-	{
-		ModalInfo* modal_info = [g_stackOfModals lastObject];
-		
-		cocoaDialogEndModal([modal_info ih]);
-		return true;
-	}
-	else
-	{
-		return false;
-	}
+  if (iupObjectCheck(child_ih))
+  {
+    NSWindow* parent_window = [child_window parentWindow];
+    if (parent_window)
+    {
+      Ihandle* parent_ih = (Ihandle*)objc_getAssociatedObject(parent_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+      if (iupObjectCheck(parent_ih))
+      {
+        if (iupAttribGetBoolean(child_ih, "MODAL"))
+        {
+          cocoaDialogExitModal(child_ih);
+        }
+      }
+    }
+  }
 }
 
+/****************************************************************
+ ********************** Delegates *******************************
+ ****************************************************************/
 
 @implementation IupCocoaWindowDelegate
 
 - (BOOL) windowShouldClose:(id)the_sender
 {
-//	NSLog(@"windowShouldClose");
-	// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars. And category extension isn't working for some reason...NSWindow might be too big/complicated and is expecting me to define Apple stuff.
-	
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
-	
-	/* even when ACTIVE=NO the dialog gets this evt */
-#if 0
-	if (!iupdrvIsActive(ih)) // not implemented yet
-	{
-		return YES;
-	}
-#endif
-	
-	Icallback callback_function = IupGetCallback(ih, "CLOSE_CB");
-	if(callback_function)
-	{
-		int ret = callback_function(ih);
-		if (ret == IUP_IGNORE)
-		{
-			return NO;
-		}
-		if (ret == IUP_CLOSE)
-		{
-			IupExitLoop();
-		}
-	}
-	
-	return YES; /* do not propagate */
-	
-}
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
 
+  if (!iupObjectCheck(ih))
+  {
+    return YES;
+  }
 
-- (void) windowWillClose:(NSNotification*)the_notification
-{
-	NSWindow* the_window = [the_notification object];
-//	NSLog(@"windowWillClose:");
-	
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+  Icallback callback_function = IupGetCallback(ih, "CLOSE_CB");
+  if(callback_function)
+  {
+    int ret = callback_function(ih);
+    if (ret == IUP_IGNORE)
+    {
+      return NO;
+    }
+  }
 
-	// I think??? we need to hide and not destroy because the user is supposed to call IupDestroy explicitly
-	
-	//	IupDestroy(ih);
-	
-	if(iupAttribGetBoolean(ih, "_COCOA_MODAL"))
-	{
-		cocoaDialogEndModal(ih);
-	}
-	else
-	{
-		// This contains a bunch of stuff for modal handling which doesn't work for us.
-		IupHide(ih); /* default: close the window */
-		
-	}
+  IupHide(ih);
 
+  return NO;
 }
 
-- (NSSize) windowWillResize:(NSWindow*)the_sender toSize:(NSSize)frame_size
+- (void) windowWillClose:(NSNotification*)the_notification
 {
-	// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars. And category extension isn't working for some reason...NSWindow might be too big/complicated and is expecting me to define Apple stuff.
-	
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
-	
-	/* even when ACTIVE=NO the dialog gets this evt */
-#if 0
-	if (!iupdrvIsActive(ih)) // not implemented yet
-	{
-		return YES;
-	}
-#endif
-	
-//	NSLog(@"resize current_ih:<%d,%d>, target:<%f,%f>", ih->currentwidth, ih->currentheight, frame_size.width, frame_size.height);
-//	NSLog(@"resize current_win:<%f,%f>", [the_sender frame].size.width, [the_sender frame].size.height);
+  NSWindow* the_window = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
 
-//	iupdrvDialogGetSize(ih, NULL, &(ih->currentwidth), &(ih->currentheight));
+  if (!iupObjectCheck(ih)) return;
 
-	
-	
-//	ih->currentwidth = frame_size.width;
-//	ih->currentheight = frame_size.height;
-	
-	
-	IFnii cb;
-	cb = (IFnii)IupGetCallback(ih, "RESIZE_CB");
-	// FIXME: Are the parameters supposed to be the contentView or the entire window. The Windows code comments make me think contentView, but the actual code makes me think entire window. The latter is way easier to do.
-	if(!cb || cb(ih, frame_size.width, frame_size.height)!=IUP_IGNORE)
-	{
-		ih->currentwidth = iupROUND(frame_size.width);
-		ih->currentheight = iupROUND(frame_size.height);
-		
-		ih->data->ignore_resize = 1;
-		IupRefresh(ih);
-		ih->data->ignore_resize = 0;
-		return frame_size;
-	}
-	else
-	{
-		// don't allow resize
-		return [the_sender frame].size;
-	}
-	
-	
-	
+  if(iupAttribGetBoolean(ih, "MODAL"))
+  {
+    cocoaDialogExitModal(ih);
+  }
 }
 
+- (void) windowDidBecomeKey:(NSNotification*)notification
+{
+  NSWindow* the_window = [notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
 
+  if (!iupObjectCheck(ih)) return;
 
-static int cocoaDialogSetInternalIUPFullScreenAttrib(Ihandle* ih, const char* value)
-{
-// I don't think I need any of this. Cocoa handles everything.
-#if 0
-	if (iupStrBoolean(value))
-	{
-		if (!iupAttribGet(ih, "_IUPCOCOA_FS_STYLE"))
-		{
-			int width, height;
-			
-			/* save the previous decoration attributes */
-//			iupAttribSetStr(ih, "_IUPCOCOA_FS_MAXBOX", iupAttribGet(ih, "MAXBOX"));
-//			iupAttribSetStr(ih, "_IUPCOCOA_FS_MINBOX", iupAttribGet(ih, "MINBOX"));
-			//			iupAttribSetStr(ih, "_IUPCOCOA_FS_MENUBOX",iupAttribGet(ih, "MENUBOX"));
-			//			iupAttribSetStr(ih, "_IUPCOCOA_FS_RESIZE", iupAttribGet(ih, "RESIZE"));
-//			iupAttribSetStr(ih, "_IUPCOCOA_FS_BORDER", iupAttribGet(ih, "BORDER"));
-			//			iupAttribSetStr(ih, "_IUPCOCOA_FS_TITLE",  iupAttribGet(ih, "TITLE"));
-			
-			/* save the previous position and size */
-			iupAttribSetStr(ih, "_IUPCOCOA_FS_X", IupGetAttribute(ih, "X"));  /* must use IupGetAttribute to check from the native implementation */
-			iupAttribSetStr(ih, "_IUPCOCOA_FS_Y", IupGetAttribute(ih, "Y"));
-			iupAttribSetStr(ih, "_IUPCOCOA_FS_SIZE", IupGetAttribute(ih, "RASTERSIZE"));
-			
-			/* remove the decorations attributes */
-//			iupAttribSet(ih, "MAXBOX", "NO");
-//			iupAttribSet(ih, "MINBOX", "NO");
-			//			iupAttribSet(ih, "MENUBOX", "NO");
-			//			IupSetAttribute(ih, "TITLE", NULL);  /* must use IupSetAttribute to update the native implementation */
-			//			iupAttribSet(ih, "RESIZE", "NO");
-//			iupAttribSet(ih, "BORDER", "NO");
-			
-			/* full screen size */
-			//			iupdrvGetFullSize(&width, &height);
-			
-			//			SetWindowPos(ih->handle, HWND_TOP, 0, 0, width, height, SWP_FRAMECHANGED);
-			
-			
-			
-		}
-	}
-	else
-	{
-		char* style = iupAttribGet(ih, "_IUPCOCOA_FS_STYLE");
-		if (style)
-		{
-			
-			/* restore the decorations attributes */
-//			iupAttribSetStr(ih, "MAXBOX", iupAttribGet(ih, "_IUPCOCOA_FS_MAXBOX"));
-//			iupAttribSetStr(ih, "MINBOX", iupAttribGet(ih, "_IUPCOCOA_FS_MINBOX"));
-			//			iupAttribSetStr(ih, "MENUBOX",iupAttribGet(ih, "_IUPCOCOA_FS_MENUBOX"));
-			//			IupSetAttribute(ih, "TITLE",  iupAttribGet(ih, "_IUPCOCOA_FS_TITLE"));  /* must use IupSetAttribute to update the native implementation */
-			//			iupAttribSetStr(ih, "RESIZE", iupAttribGet(ih, "_IUPCOCOA_FS_RESIZE"));
-//			iupAttribSetStr(ih, "BORDER", iupAttribGet(ih, "_IUPCOCOA_FS_BORDER"));
-			
-			
-			
-			/* remove auxiliary attributes */
-//			iupAttribSet(ih, "_IUPCOCOA_FS_MAXBOX", NULL);
-//			iupAttribSet(ih, "_IUPCOCOA_FS_MINBOX", NULL);
-			//			iupAttribSet(ih, "_IUPCOCOA_FS_MENUBOX",NULL);
-			//			iupAttribSet(ih, "_IUPCOCOA_FS_TITLE",  NULL);
-			//			iupAttribSet(ih, "_IUPCOCOA_FS_RESIZE", NULL);
-//			iupAttribSet(ih, "_IUPCOCOA_FS_BORDER", NULL);
-			
-			iupAttribSet(ih, "_IUPCOCOA_FS_X", NULL);
-			iupAttribSet(ih, "_IUPCOCOA_FS_Y", NULL);
-			iupAttribSet(ih, "_IUPCOCOA_FS_SIZE", NULL);
-			
-			iupAttribSet(ih, "_IUPCOCOA_FS_STYLE", NULL);
-		}
-	}
-#endif
-	return 1;
+  iupcocoaFocusIn(ih);
+
+  if (ih->data->menu)
+  {
+    iupcocoaMenuSetApplicationMenu(ih->data->menu);
+  }
+  else
+  {
+    Ihandle* global_menu = (Ihandle*)IupGetGlobal("MENU");
+    iupcocoaMenuSetApplicationMenu(global_menu);
+  }
 }
 
-// 10.7+ fullscreen
-
-- (void) windowWillEnterFullScreen:(NSNotification*)the_notification
+- (void) windowDidResignKey:(NSNotification*)notification
 {
-//	NSLog(@"windowWillEnterFullScreen");
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject([the_notification object], IHANDLE_ASSOCIATED_OBJ_KEY);
-	iupAttribSet(ih, "FULLSCREEN", "YES");
-	cocoaDialogSetInternalIUPFullScreenAttrib(ih, "YES");
+  NSWindow* the_window = [notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
 }
 
-- (void) windowDidEnterFullScreen:(NSNotification*)the_notification
+- (NSSize) windowWillResize:(NSWindow*)the_sender toSize:(NSSize)frame_size
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject([the_notification object], IHANDLE_ASSOCIATED_OBJ_KEY);
-//	NSLog(@"windowDidEnterFullScreen");
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return frame_size;
 
+  NSSize content_size = [the_sender contentRectForFrameRect:NSMakeRect(0, 0, frame_size.width, frame_size.height)].size;
 
-	
-	ih->data->ignore_resize = 1;
-	IupRefresh(ih);
-	ih->data->ignore_resize = 0;
-
+  IFnii cb = (IFnii)IupGetCallback(ih, "RESIZE_CB");
+  if(!cb || cb(ih, content_size.width, content_size.height)!=IUP_IGNORE)
+  {
+    return frame_size;
+  }
+  else
+  {
+    return [the_sender frame].size;
+  }
 }
 
-/*
-- (void) windowWillExitFullScreen:(NSNotification*)the_notification
+- (NSRect)windowWillUseStandardFrame:(NSWindow *)window defaultFrame:(NSRect)newFrame
 {
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(window, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  if (ih && ih->data->ignore_resize)
+    return [window frame];
+
+  NSValue* previousFrameValue = objc_getAssociatedObject(window, &IUPCocoaZoomRestoreFrameKey);
+
+  if (previousFrameValue)
+  {
+    NSRect restoreFrame = [previousFrameValue rectValue];
+    objc_setAssociatedObject(window, &IUPCocoaZoomRestoreFrameKey, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    return restoreFrame;
+  }
+  else
+  {
+    NSRect currentFrame = [window frame];
+    NSValue* frameValue = [NSValue valueWithRect:currentFrame];
+    objc_setAssociatedObject(window, &IUPCocoaZoomRestoreFrameKey, frameValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    return newFrame;
+  }
 }
-*/
 
-- (void) windowDidExitFullScreen:(NSNotification*)the_notification
+- (void) windowDidResize:(NSNotification*)the_notification
 {
-//	NSLog(@"windowDidExitFullScreen");
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject([the_notification object], IHANDLE_ASSOCIATED_OBJ_KEY);
-	iupAttribSet(ih, "FULLSCREEN", "NO");
-	cocoaDialogSetInternalIUPFullScreenAttrib(ih, "NO");
-	
-	ih->data->ignore_resize = 1;
-	IupRefresh(ih);
-	ih->data->ignore_resize = 0;
-	
-}
+  NSWindow* the_window = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return;
 
+  if (ih->data->ignore_resize) return;
 
-@end
+  NSRect frame_rect = [the_window frame];
+  NSRect content_rect = [[the_window contentView] bounds];
 
+  int new_width = iupROUND(frame_rect.size.width);
+  int new_height = iupROUND(frame_rect.size.height);
 
-/*
- This is a quick and dirty NSToolbar implementation. This was used to help me figure out the "menu" height metrics.
- But we eventually will need to implement toolbar support so this may be useful.
-*/
-/*
-#define FIXME_TOOLBAR_IDENT @"FIXME:Need unique identifier"
+  if (ih->currentwidth == new_width && ih->currentheight == new_height)
+    return;
 
-@interface IupCocoaToolbarDelegate : NSObject<NSToolbarDelegate>
+  ih->currentwidth = new_width;
+  ih->currentheight = new_height;
 
-- (NSArray*) toolbarAllowedItemIdentifiers:(NSToolbar*)tool_bar;
-- (NSArray*) toolbarDefaultItemIdentifiers:(NSToolbar*)tool_bar;
-- (NSToolbarItem*) toolbar:(NSToolbar*)tool_bar itemForItemIdentifier:(NSString*)the_identifier willBeInsertedIntoToolbar:(BOOL)will_insert;
+  int new_state = IUP_RESTORE;
+  if ([the_window isZoomed])
+    new_state = IUP_MAXIMIZE;
 
-@end
+  if (ih->data->show_state != new_state)
+  {
+    IFni show_cb = (IFni)IupGetCallback(ih, "SHOW_CB");
+    ih->data->show_state = new_state;
+    if (show_cb && show_cb(ih, new_state) == IUP_CLOSE)
+      IupExitLoop();
+  }
 
-@implementation IupCocoaToolbarDelegate
+  IFnii resize_cb = (IFnii)IupGetCallback(ih, "RESIZE_CB");
+  if (!resize_cb || resize_cb(ih, (int)content_rect.size.width, (int)content_rect.size.height) != IUP_IGNORE)
+  {
+    ih->data->ignore_resize = 1;
+    IupRefresh(ih);
+    ih->data->ignore_resize = 0;
+  }
+}
 
+- (void) windowDidMove:(NSNotification*)the_notification
+{
+  NSWindow* the_window = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return;
 
-- (NSArray*) toolbarSelectableItemIdentifiers:(NSToolbar *)tool_bar
+  IFnii cb = (IFnii)IupGetCallback(ih, "MOVE_CB");
+  if (cb)
+  {
+    int x, y;
+    iupdrvDialogGetPosition(ih, NULL, &x, &y);
+    cb(ih, x, y);
+  }
+}
+
+- (void) windowDidMiniaturize:(NSNotification*)the_notification
 {
-	NSLog(@"%s",__func__);
-	return [self toolbarDefaultItemIdentifiers:tool_bar];
+  NSWindow* the_window = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return;
+
+  if (ih->data->show_state != IUP_MINIMIZE)
+  {
+    IFni cb = (IFni)IupGetCallback(ih, "SHOW_CB");
+    ih->data->show_state = IUP_MINIMIZE;
+    if (cb && cb(ih, IUP_MINIMIZE) == IUP_CLOSE)
+      IupExitLoop();
+  }
 }
 
-- (void) toolbarWillAddItem:(NSNotification *)tool_bar
+- (void) windowDidDeminiaturize:(NSNotification*)the_notification
 {
-	NSLog(@"%s",__func__);
+  NSWindow* the_window = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return;
+
+  int new_state = [the_window isZoomed] ? IUP_MAXIMIZE : IUP_RESTORE;
+  if (ih->data->show_state != new_state)
+  {
+    IFni cb = (IFni)IupGetCallback(ih, "SHOW_CB");
+    ih->data->show_state = new_state;
+    if (cb && cb(ih, new_state) == IUP_CLOSE)
+      IupExitLoop();
+  }
 }
 
-- (void) toolbarDidRemoveItem:(NSNotification*)the_notification
+- (void) windowWillEnterFullScreen:(NSNotification*)the_notification
 {
-	NSLog(@"%s",__func__);
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject([the_notification object], IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return;
+
+  NSWindow* window = [the_notification object];
+  if (!objc_getAssociatedObject(window, &IUPCocoaZoomRestoreFrameKey))
+  {
+    NSRect currentFrame = [window frame];
+    NSValue* frameValue = [NSValue valueWithRect:currentFrame];
+    objc_setAssociatedObject(window, &IUPCocoaZoomRestoreFrameKey, frameValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  }
+
+  iupAttribSet(ih, "_IUPCOCOA_FULLSCREEN", "YES");
 }
 
+- (void) windowDidEnterFullScreen:(NSNotification*)the_notification
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject([the_notification object], IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return;
 
-- (NSArray*) toolbarAllowedItemIdentifiers:(NSToolbar*)tool_bar
+  ih->data->ignore_resize = 1;
+  IupRefresh(ih);
+  ih->data->ignore_resize = 0;
+}
+
+- (void) windowDidExitFullScreen:(NSNotification*)the_notification
 {
-	return @[@"One", @"Two"];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject([the_notification object], IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupObjectCheck(ih)) return;
+
+  iupAttribSet(ih, "_IUPCOCOA_FULLSCREEN", "NO");
+  ih->data->ignore_resize = 1;
+  IupRefresh(ih);
+  ih->data->ignore_resize = 0;
 }
 
-- (NSArray*) toolbarDefaultItemIdentifiers:(NSToolbar*)tool_bar
+- (void)cocoaDialogChildDestroyNotification:(NSNotification*)notification
 {
-	return @[@"One", @"Two"];
+  cocoaDialogChildDestroyNotification(notification);
 }
 
-- (NSToolbarItem*) toolbar:(NSToolbar*)tool_bar itemForItemIdentifier:(NSString*)item_identifier willBeInsertedIntoToolbar:(BOOL)will_insert
+- (void)observeValueForKeyPath:(NSString *)keyPath
+                      ofObject:(id)object
+                        change:(NSDictionary *)change
+                       context:(void *)context
 {
-	NSToolbarItem* return_val = nil;
-	NSString* the_label = @"default";
-	NSString* toolbar_identifier = [tool_bar identifier];
-	
-	if([toolbar_identifier isEqualToString:FIXME_TOOLBAR_IDENT])
-	{
-		if([item_identifier isEqualToString:@"One"])
-		{
-			return_val = [[NSToolbarItem alloc] initWithItemIdentifier:@"One"];
-			the_label = @"Toolbar One";
-		}
-		else if([item_identifier isEqualToString:@"Two"])
-		{
-			return_val = [[NSToolbarItem alloc] initWithItemIdentifier:@"Two"];
-			the_label = @"Toolbar Two";
-		}
-	}
-	
-	[return_val setLabel:the_label];
-	[return_val setPaletteLabel:the_label];
-	return return_val;
+  if (context == IupCocoaAppearanceContext)
+  {
+    NSWindow* the_window = (NSWindow*)object;
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+    if (!iupObjectCheck(ih))
+    return;
+
+    iupcocoaSetGlobalColors();
+
+    int dark_mode = iupcocoaIsSystemDarkMode();
+
+    IFni cb = (IFni)IupGetCallback(ih, "THEMECHANGED_CB");
+    if (cb)
+    cb(ih, dark_mode);
+
+    NSView* content_view = [the_window contentView];
+    if (content_view)
+    {
+    /* Recursively mark the content view and all subviews for redraw */
+    NSMutableArray* view_stack = [NSMutableArray arrayWithObject:content_view];
+    while ([view_stack count] > 0)
+    {
+      NSView* current_view = [view_stack lastObject];
+      [view_stack removeLastObject];
+
+      [current_view setNeedsDisplay:YES];
+
+      [view_stack addObjectsFromArray:[current_view subviews]];
+    }
+    }
+
+    ih->data->ignore_resize = 1;
+    IupRefresh(ih);
+    ih->data->ignore_resize = 0;
+  }
+  else
+  {
+    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
+  }
 }
 
 @end
-*/
 
 
 /****************************************************************
- Utilities
+ ******************* Driver Functions ***************************
  ****************************************************************/
 
-
-
-
 int iupdrvDialogIsVisible(Ihandle* ih)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		NSStatusItem* status_item = (NSStatusItem*)root_object;
-		return [status_item isVisible];
-	}
-	
-//	return iupdrvIsVisible(ih);
-
-	// This is a little bit of a hack.
-	// iupDialogShowXY needs to increment the number of visible windows.
-	// When this window is being created, without this check, Cocoa will return true.
-	// But Iup then seems to bypass the initialization routine because it assumes it had already gone through the init process.
-	// This hack works because I set first_show to 1 in my Map function.
-	// After Iup goes through its initialization, it also will set first_show to 1 again.
-	// Without this hack, even if I have a bunch of windows open, IUP thinks I closed the last one
-	// and will call IupExitLoop().
-	if(ih->data->first_show)
-	{
-		return 0;
-	}
-
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	int ret_val = (int)[the_window isVisible];
-	return ret_val;
+  return iupdrvIsVisible(ih);
 }
 
-
 void iupdrvDialogGetSize(Ihandle* ih, InativeHandle* handle, int *w, int *h)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return;
-	}
-	
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSRect the_rect = [the_window frame];
-	
-	if (w) *w = iupROUND(the_rect.size.width);
-	if (h) *h = iupROUND(the_rect.size.height);
+  NSWindow* the_window = handle ? (NSWindow*)handle : cocoaDialogGetWindow(ih);
+  if (!the_window) return;
+
+  NSRect frame_rect = [the_window frame];
+
+  if (w) *w = iupROUND(frame_rect.size.width);
+  if (h) *h = iupROUND(frame_rect.size.height);
 }
 
 void iupdrvDialogSetVisible(Ihandle* ih, int visible)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		NSStatusItem* status_item = (NSStatusItem*)root_object;
-		[status_item setVisible:visible];
-		return;
-	}
-	
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window)
+  {
+    return;
+  }
 
-	if(visible)
-	{
-		[the_window makeKeyAndOrderFront:nil];
+  if (visible)
+  {
+    if (iupAttribGetBoolean(ih, "SHOWNOACTIVATE"))
+    {
+      [the_window orderFront:nil];
+    }
+    else
+    {
+      [the_window makeKeyAndOrderFront:nil];
+    }
+  }
+  else
+  {
+    Ihandle* parent_ih = IupGetAttributeHandle(ih, "PARENTDIALOG");
+    NSWindow* parent_window = nil;
 
-	}
-	else
-	{
+    if (iupObjectCheck(parent_ih))
+    {
+      parent_window = cocoaDialogGetWindow(parent_ih);
+    }
 
-		[the_window orderOut:nil];
-	}
+    if (!parent_window)
+    {
+      parent_window = [the_window parentWindow];
+      if (parent_window)
+      {
+        parent_ih = (Ihandle*)objc_getAssociatedObject(parent_window, IHANDLE_ASSOCIATED_OBJ_KEY);
+      }
+    }
+
+    if (parent_window && iupObjectCheck(parent_ih))
+    {
+      [NSApp activateIgnoringOtherApps:YES];
+      [parent_window makeKeyAndOrderFront:nil];
+    }
+
+    [the_window orderOut:nil];
+
+    if (parent_window && iupObjectCheck(parent_ih))
+    {
+      IupSetFocus(parent_ih);
+    }
+  }
 }
 
 void iupdrvDialogGetPosition(Ihandle *ih, InativeHandle* handle, int *x, int *y)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return;
-	}
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSRect the_rect = [the_window frame];
-	
-	if (x) *x = the_rect.origin.x;
-	if (y) *y = iupCocoaComputeIupScreenHeightFromCartesian(the_rect.origin.y);
+  NSWindow* the_window = handle ? (NSWindow*)handle : cocoaDialogGetWindow(ih);
+  if (!the_window) return;
+
+  NSRect the_rect = [the_window frame];
+
+  if (x) *x = the_rect.origin.x;
+  if (y) *y = iupcocoaComputeIupScreenHeightFromCartesian(the_rect.origin.y + the_rect.size.height);
 }
 
 void iupdrvDialogSetPosition(Ihandle *ih, int x, int y)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return;
-	}
-	
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSRect the_rect = [the_window frame];
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window) return;
 
-	if(ih->data->first_show)
-	{
-		int is_first_window = IupGetInt(ih, "_FIRST_WINDOW");
-		if(is_first_window)
-		{
-			[the_window center];
-			
-			
-			NSPoint new_pos = [the_window frame].origin;
-			
-			ih->x = new_pos.x;
-			ih->y = iupCocoaComputeIupScreenHeightFromCartesian(new_pos.y);
-		}
-		else
-		{
-		
-			ih->x = IupGetInt(ih, "CASCADE_X");
-			ih->y = IupGetInt(ih, "CASCADE_Y");
-		///		int inverted_height = iupCocoaComputeCartesianScreenHeightFromIup(ih->y);
-		
-		//		[the_window setFrame:NSMakeRect(ih->x, inverted_height, ih->currentwidth , ih->currentheight) display:YES];
-		//		[the_window setFrameTopLeftPoint:NSMakePoint(ih->x, ih->y)];
-		//	[the_window setFrameTopLeftPoint:NSMakePoint(90, 90)];
-		
-		}
-		ih->data->first_show = 0;
-	}
-	else
-	{
-		int inverted_height = iupCocoaComputeCartesianScreenHeightFromIup(ih->y);
-		
-		[the_window setFrame:NSMakeRect(ih->x, inverted_height, ih->currentwidth , ih->currentheight) display:YES];
-	}
-	
-	
-	int inverted_height = iupCocoaComputeCartesianScreenHeightFromIup(y);
-
-
+  int inverted_y = iupcocoaComputeCartesianScreenHeightFromIup(y);
+  [the_window setFrameTopLeftPoint:NSMakePoint(x, inverted_y)];
 }
 
-
 void iupdrvDialogGetDecoration(Ihandle* ih, int *border, int *caption, int *menu)
 {
-	id root_object = (id)ih->handle;
-	if(nil == root_object)
-	{
-		// We are hitting this case for alert and file panels. Presumably other dialogs to.
-		*border = 2; // Maybe this is 0?
-		*menu = 0;
-		*caption = 24; // title bar height?
-	
-	
-//		NSLog(@"WARNIng: ih->handle==nil in iupdrvDialogGetDecoration. Maybe alert dialog?");
-		return;
-	}
-	
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return;
-	}
+  *menu = 0; /* In Cocoa, the menu bar is not part of the window's decoration height. */
 
-//	NSLog(@"border=%d, caption%d, menu=%d", *border, *caption, *menu);
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
+  /* Determine the window's style mask, which defines its decorations. */
+  NSWindowStyleMask style_mask = 0;
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
 
-	
-	
-	CGFloat title_bar_height = 0.0;
-	// What is "menu"? Is this supposed to encompass things like toolbars?
-	CGFloat menu_bar_height = 0.0;
-	CGFloat window_border_thickness = 0.0;
-	
-	NSRect window_frame = [the_window frame];
+  if (the_window)
+  {
+    style_mask = [the_window styleMask];
+  }
+  else
+  {
+    /* If the window is not yet mapped, we must infer the style mask from IUP attributes. */
+    /* This logic is derived from what cocoaDialogMapMethod would do. */
+    int has_titlebar = iupAttribGet(ih, "TITLE") ||
+                       iupAttribGetBoolean(ih, "MAXBOX") ||
+                       iupAttribGetBoolean(ih, "MINBOX") ||
+                       iupAttribGetBoolean(ih, "MENUBOX");
 
-	// Now get the window contents. Assuming this includes the toolbar if any
-	NSRect content_frame = [the_window contentRectForFrameRect:window_frame];
-	
-	
-	// TODO: Test borderless windows, fullscreen windows
-	if([the_window styleMask] & NSTitledWindowMask)
-	{
+    if (has_titlebar || iupAttribGetBoolean(ih, "BORDER"))
+      style_mask = NSWindowStyleMaskTitled;
+    else
+      style_mask = NSWindowStyleMaskBorderless;
 
-		// Use the class method to avoid getting a window with a toolbar?
-		NSRect plain_window_frame = [NSWindow frameRectForContentRect:content_frame styleMask:NSTitledWindowMask];
-		CGFloat content_diff_height = plain_window_frame.size.height - content_frame.size.height;
-		title_bar_height = content_diff_height;
+    if (iupAttribGetBoolean(ih, "RESIZE"))
+      style_mask |= NSWindowStyleMaskResizable;
+    if (iupAttribGetBoolean(ih, "MINBOX"))
+      style_mask |= NSWindowStyleMaskMiniaturizable;
+    if (iupAttribGetBoolean(ih, "MENUBOX"))
+      style_mask |= NSWindowStyleMaskClosable;
+    if (iupAttribGetBoolean(ih, "TOOLBOX"))
+      style_mask |= NSWindowStyleMaskUtilityWindow;
+  }
 
-		
-	}
-	else
-	{
-		title_bar_height = 0;
-	}
-	
+  if (iupAttribGetBoolean(ih, "CUSTOMFRAME") || iupAttribGetBoolean(ih, "CUSTOMFRAMESIMULATE"))
+  {
+    style_mask = NSWindowStyleMaskBorderless;
+  }
 
+  /* Using a sample content rectangle, we ask Cocoa for the corresponding frame rectangle. */
+  /* The difference between them gives us the total size of the decorations. */
+  NSRect sample_content_rect = NSMakeRect(0, 0, 100, 100);
+  NSRect sample_frame_rect = [NSWindow frameRectForContentRect:sample_content_rect styleMask:style_mask];
 
-	NSToolbar* the_toolbar = [the_window toolbar];
-	if((nil != the_toolbar) && [the_toolbar isVisible])
-	{
-		CGFloat content_diff_height = window_frame.size.height - content_frame.size.height;
-		menu_bar_height = content_diff_height - title_bar_height;
-	}
-	else
-	{
-		menu_bar_height = 0.0;
-	}
-	
-	
+  int total_decor_width = (int)round(sample_frame_rect.size.width - sample_content_rect.size.width);
+  int total_decor_height = (int)round(sample_frame_rect.size.height - sample_content_rect.size.height);
 
-	if([the_window styleMask] == NSWindowStyleMaskBorderless)
-	{
-		// assume window_frame - content_frame is the border thickness? Do width because height has title bars and toolbars.
-		window_border_thickness = window_frame.size.width - content_frame.size.width;
-		NSCAssert(window_border_thickness == 0.0, @"Expected border width to be 0");
-		
-	}
-	else if(([the_window styleMask] & NSWindowStyleMaskFullSizeContentView) || ([the_window styleMask] & NSWindowStyleMaskFullScreen))
-	{
-		// assume window_frame - content_frame is the border thickness? Do width because height has title bars and toolbars.
-		window_border_thickness = window_frame.size.width - content_frame.size.width;
-		NSCAssert(window_border_thickness == 0.0, @"Expected border width to be 0");
-		
-	}
-	else
-	{
-		// assume window_frame - content_frame is the border thickness? Do width because height has title bars and toolbars.
-		window_border_thickness = window_frame.size.width - content_frame.size.width;
-		
-		CGFloat left_edge = [the_window contentBorderThicknessForEdge:NSRectEdgeMinX];
-		CGFloat right_edge = [the_window contentBorderThicknessForEdge:NSRectEdgeMaxX];
+  /* Translate these total decoration sizes into IUP's `border` and `caption` model. */
+  /* The IUP layout engine formulas assume: */
+  /* total_decor_width = 2 * border */
+  /* total_decor_height = caption + 2 * border */
+  /* We derive our values to satisfy these formulas. */
 
-		NSCAssert((left_edge+right_edge) == window_border_thickness, @"border width not what I expected");
-	}
- 
-	
-	*border = window_border_thickness;
-	*menu = menu_bar_height;
-	*caption = title_bar_height;
+  *border = total_decor_width / 2;
+  *caption = total_decor_height - (2 * (*border));
+  if (*caption < 0)
+  {
+    *caption = 0;
+  }
 
+  if (iupAttribGetBoolean(ih, "HIDETITLEBAR"))
+  {
+    *caption = 0;
+  }
 }
 
 int iupdrvDialogSetPlacement(Ihandle* ih)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return 0;
-	}
-	
-	char* placement;
-	
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSRect the_rect = [the_window frame];
-	
-	
-	int old_state = ih->data->show_state;
-	ih->data->show_state = IUP_SHOW;
-	
-	if (iupAttribGetBoolean(ih, "FULLSCREEN"))
-	{
+  id root_object = (id)ih->handle;
+  if([root_object isKindOfClass:[NSStatusItem class]] || !root_object) return 0;
 
-		NSUInteger masks = [the_window styleMask];
-		if ( masks & NSFullScreenWindowMask)
-		{
-			// Do something
-		}
-		else
-		{
-			[the_window toggleFullScreen:nil];
-		}
-		
-		
-		return 1;
-	}
-	
-	placement = iupAttribGet(ih, "PLACEMENT");
-	if (!placement)
-	{
-		if (old_state == IUP_MAXIMIZE || old_state == IUP_MINIMIZE)
-			ih->data->show_state = IUP_RESTORE;
-		
-//		gtk_window_unmaximize((GtkWindow*)ih->handle);
-//		gtk_window_deiconify((GtkWindow*)ih->handle);
-		return 0;
-	}
-	
-	if (iupStrEqualNoCase(placement, "MINIMIZED"))
-	{
-//		ih->data->show_state = IUP_MINIMIZE;
-//		gtk_window_iconify((GtkWindow*)ih->handle);
-	}
-	else if (iupStrEqualNoCase(placement, "MAXIMIZED"))
-	{
-//		ih->data->show_state = IUP_MAXIMIZE;
-//		gtk_window_maximize((GtkWindow*)ih->handle);
-	}
-	else if (iupStrEqualNoCase(placement, "FULL"))
-	{
-#if 0
-		int width, height, x, y;
-		int border, caption, menu;
-		iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
-		
-		/* position the decoration outside the screen */
-		x = -(border);
-		y = -(border+caption+menu);
-		
-		/* the dialog client area will cover the task bar */
-		iupdrvGetFullSize(&width, &height);
-		
-		height += menu; /* menu is inside the client area. */
-		
-		/* set the new size and position */
-		/* The resize evt will update the layout */
-		gtk_window_move((GtkWindow*)ih->handle, x, y);
-		gtk_window_resize((GtkWindow*)ih->handle, width, height);
-		
-		if (old_state == IUP_MAXIMIZE || old_state == IUP_MINIMIZE)
-			ih->data->show_state = IUP_RESTORE;
-#endif
-	}
-	
-	iupAttribSet(ih, "PLACEMENT", NULL); /* reset to NORMAL */
-	
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  char* placement;
+  int old_state = ih->data->show_state;
 
+  ih->data->show_state = IUP_SHOW;
 
-	return 1;
-}
+  if (iupAttribGetBoolean(ih, "FULLSCREEN"))
+  {
+    if (!([the_window styleMask] & NSWindowStyleMaskFullScreen))
+    {
+      [the_window toggleFullScreen:nil];
+    }
+    return 1;
+  }
 
+  if ([the_window styleMask] & NSWindowStyleMaskFullScreen)
+  {
+    [the_window toggleFullScreen:nil];
+  }
 
+  placement = iupAttribGet(ih, "PLACEMENT");
+  if (!placement)
+  {
+    if (old_state == IUP_MAXIMIZE || old_state == IUP_MINIMIZE)
+      ih->data->show_state = IUP_RESTORE;
 
-static int cocoaDialogSetFullScreenAttrib(Ihandle* ih, const char* value)
-{
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	cocoaDialogSetInternalIUPFullScreenAttrib(ih, value);
-	if (iupStrBoolean(value))
-	{
-		if(([the_window styleMask] & NSWindowStyleMaskFullSizeContentView) || ([the_window styleMask] & NSWindowStyleMaskFullScreen))
-		{
-		}
-		else
-		{
-			[the_window toggleFullScreen:the_window];
-		}
-	}
-	else
-	{
-		if(([the_window styleMask] & NSWindowStyleMaskFullSizeContentView) || ([the_window styleMask] & NSWindowStyleMaskFullScreen))
-		{
-			[the_window toggleFullScreen:the_window];
-		}
-		else
-		{
-		}
-	}
-	return 1;
+    if ([the_window isZoomed])
+      [the_window zoom:nil];
+    if ([the_window isMiniaturized])
+      [the_window deminiaturize:nil];
+
+    if (iupAttribGetBoolean(ih, "CUSTOMFRAMESIMULATE") && iupDialogCustomFrameRestore(ih))
+    {
+      ih->data->show_state = IUP_RESTORE;
+      return 1;
+    }
+
+    return 0;
+  }
+
+  if (iupAttribGetBoolean(ih, "CUSTOMFRAMESIMULATE") && iupStrEqualNoCase(placement, "MAXIMIZED"))
+  {
+    iupDialogCustomFrameMaximize(ih);
+    iupAttribSet(ih, "PLACEMENT", NULL);
+    ih->data->show_state = IUP_MAXIMIZE;
+    return 1;
+  }
+
+  if (iupStrEqualNoCase(placement, "MINIMIZED"))
+  {
+    ih->data->show_state = IUP_MINIMIZE;
+    if (![the_window isMiniaturized])
+      [the_window miniaturize:nil];
+  }
+  else if (iupStrEqualNoCase(placement, "MAXIMIZED"))
+  {
+    ih->data->show_state = IUP_MAXIMIZE;
+    if (![the_window isZoomed])
+      [the_window zoom:nil];
+  }
+  else if (iupStrEqualNoCase(placement, "FULL"))
+  {
+    NSRect screen_frame = [[NSScreen mainScreen] visibleFrame];
+    [the_window setFrame:screen_frame display:YES];
+
+    if ([the_window isMiniaturized])
+      [the_window deminiaturize:nil];
+
+    if (old_state == IUP_MAXIMIZE || old_state == IUP_MINIMIZE)
+      ih->data->show_state = IUP_RESTORE;
+  }
+
+  iupAttribSet(ih, "PLACEMENT", NULL);
+  return 1;
 }
 
-// FIXME: Not sure what this is supposed to do. This implementation is a total guess.
 void iupdrvDialogSetParent(Ihandle* ih, InativeHandle* parent)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return;
-	}
-	
-	NSWindow* parent_window = (NSWindow*)parent;
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSCAssert([parent_window isKindOfClass:[NSWindow class]], @"Expected NSWindow for parent");
-	
-	[parent_window addChildWindow:the_window ordered:NSWindowAbove];
+  id root_object = (id)ih->handle;
+  if([root_object isKindOfClass:[NSStatusItem class]]) return;
 
+  NSWindow* parent_window = (NSWindow*)parent;
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if ([parent_window isKindOfClass:[NSWindow class]])
+  {
+    [parent_window addChildWindow:the_window ordered:NSWindowAbove];
+  }
 }
 
+
 /****************************************************************
- Callbacks and Events
+ ********************** Attributes ******************************
  ****************************************************************/
 
+static int cocoaDialogSetMenuAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->handle && [(NSWindow*)ih->handle isKeyWindow])
+  {
+    Ihandle* menu_ih = IupGetHandle(value);
+    iupcocoaMenuSetApplicationMenu(menu_ih);
+  }
 
+  return 1;
+}
+
 static int cocoaDialogSetMinSizeAttrib(Ihandle* ih, const char* value)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window)
+    return iupBaseSetMinSizeAttrib(ih, value);
 
-	int min_w = 1, min_h = 1;          /* MINSIZE default value */
-	iupStrToIntInt(value, &min_w, &min_h, 'x');
+  int min_w = 1, min_h = 1;
+  int max_w = 65535, max_h = 65535;
+  iupStrToIntInt(value, &min_w, &min_h, 'x');
 
-	
-	[the_window setMinSize:NSMakeSize(min_w, min_h)];
+  iupStrToIntInt(iupAttribGet(ih, "MAXSIZE"), &max_w, &max_h, 'x');
 
-	
-	return iupBaseSetMinSizeAttrib(ih, value);
+  int decorwidth = 0, decorheight = 0;
+  iupDialogGetDecorSize(ih, &decorwidth, &decorheight);
+
+  NSSize minSize = NSMakeSize(1, 1);
+  if (min_w > decorwidth)
+    minSize.width = min_w - decorwidth;
+  if (min_h > decorheight)
+    minSize.height = min_h - decorheight;
+
+  NSSize maxSize = NSMakeSize(65535, 65535);
+  if (max_w > decorwidth && max_w > minSize.width)
+    maxSize.width = max_w - decorwidth;
+  if (max_h > decorheight && max_h > minSize.height)
+    maxSize.height = max_h - decorheight;
+
+  [the_window setContentMinSize:minSize];
+  [the_window setContentMaxSize:maxSize];
+
+  return iupBaseSetMinSizeAttrib(ih, value);
 }
 
 static int cocoaDialogSetMaxSizeAttrib(Ihandle* ih, const char* value)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window)
+    return iupBaseSetMaxSizeAttrib(ih, value);
 
-	int max_w = 65535, max_h = 65535;  /* MAXSIZE default value */
-	iupStrToIntInt(value, &max_w, &max_h, 'x');
+  int min_w = 1, min_h = 1;
+  int max_w = 65535, max_h = 65535;
+  iupStrToIntInt(value, &max_w, &max_h, 'x');
 
-	[the_window setMaxSize:NSMakeSize(max_w, max_h)];
-	
-	return iupBaseSetMaxSizeAttrib(ih, value);
+  iupStrToIntInt(iupAttribGet(ih, "MINSIZE"), &min_w, &min_h, 'x');
+
+  int decorwidth = 0, decorheight = 0;
+  iupDialogGetDecorSize(ih, &decorwidth, &decorheight);
+
+  NSSize minSize = NSMakeSize(1, 1);
+  if (min_w > decorwidth)
+    minSize.width = min_w - decorwidth;
+  if (min_h > decorheight)
+    minSize.height = min_h - decorheight;
+
+  NSSize maxSize = NSMakeSize(65535, 65535);
+  if (max_w > decorwidth && max_w > minSize.width)
+    maxSize.width = max_w - decorwidth;
+  if (max_h > decorheight && max_h > minSize.height)
+    maxSize.height = max_h - decorheight;
+
+  [the_window setContentMinSize:minSize];
+  [the_window setContentMaxSize:maxSize];
+
+  return iupBaseSetMaxSizeAttrib(ih, value);
 }
 
+static char* cocoaDialogGetClientSizeAttrib(Ihandle *ih)
+{
+  if (ih->handle)
+  {
+    NSWindow* the_window = cocoaDialogGetWindow(ih);
+    if (the_window)
+    {
+      NSRect content_rect = [[the_window contentView] bounds];
+      int width = (int)content_rect.size.width;
+      int height = (int)content_rect.size.height;
 
+      if (iupAttribGetBoolean(ih, "CUSTOMFRAMEDRAW"))
+      {
+        int border, caption, menu;
+        iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
+        width -= 2 * border;
+        height -= caption + menu + 2 * border;
+      }
 
-static int cocoaDialogSetTitleAttrib(Ihandle* ih, const char* value)
+      if (width < 0) width = 0;
+      if (height < 0) height = 0;
+
+      return iupStrReturnIntInt(width, height, 'x');
+    }
+  }
+
+  return iupDialogGetClientSizeAttrib(ih);
+}
+
+static char* cocoaDialogGetClientOffsetAttrib(Ihandle *ih)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return 0;
-	}
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	if(value)
-	{
-		NSString* ns_string = [NSString stringWithUTF8String:value];
-		[the_window setTitle:ns_string];
-	}
-	else
-	{
-		[the_window setTitle:@""];
-	}
-	// Not sure if this should be 0 or 1. The PROXYICONTITLE could theoretically change this.
-	return 0;
+  if (iupAttribGetBoolean(ih, "CUSTOMFRAMEDRAW"))
+  {
+    int border, caption, menu;
+    iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
+
+    int x = border;
+    int y = border + caption + menu;
+
+    return iupStrReturnIntInt(x, y, 'x');
+  }
+
+  return "0x0";
 }
 
+static char* cocoaDialogGetResizeAttrib(Ihandle* ih)
+{
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window) return iupAttribGet(ih, "RESIZE");
 
-static int cocoaDialogSetLayerBackedAttrib(Ihandle* ih, const char* value)
+  NSWindowStyleMask style_mask = [the_window styleMask];
+  return iupStrReturnBoolean(style_mask & NSWindowStyleMaskResizable);
+}
+
+static int cocoaDialogSetResizeAttrib(Ihandle* ih, const char* value)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSView* the_view = [the_window contentView];
-	BOOL should_enable = (BOOL)iupStrBoolean(value);
-	[the_view setWantsLayer:should_enable];
-	return 0;
+  cocoaDialogUpdateStyleMask(ih);
+  return 1;
 }
 
-static char* cocoaDialogGetLayerBackedAttrib(Ihandle* ih)
+static int cocoaDialogSetMinBoxAttrib(Ihandle* ih, const char* value)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSView* the_view = [the_window contentView];
-	BOOL is_enabled = [the_view wantsLayer];
-	return iupStrReturnBoolean(is_enabled);
+  cocoaDialogUpdateStyleMask(ih);
+  return 1;
 }
 
+static int cocoaDialogSetMaxBoxAttrib(Ihandle* ih, const char* value)
+{
+  cocoaDialogUpdateStyleMask(ih);
+  return 1;
+}
 
-static char* cocoaDialogGetProxyIconAttrib(Ihandle* ih)
+static int cocoaDialogSetMenuBoxAttrib(Ihandle* ih, const char* value)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSString* ns_file_name = [the_window representedFilename];
-	return iupStrReturnStr([ns_file_name fileSystemRepresentation]);
+  cocoaDialogUpdateStyleMask(ih);
+  return 1;
 }
 
-static int cocoaDialogSetProxyIconAttrib(Ihandle* ih, const char* value)
+static int cocoaDialogSetBorderAttrib(Ihandle* ih, const char* value)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	if(value)
-	{
-		NSString* ns_string = [NSString stringWithUTF8String:value];
-		[the_window setRepresentedFilename:ns_string];
-	}
-	else
-	{
-		[the_window setRepresentedFilename:@""];
-	}
-	return 0;
+  cocoaDialogUpdateStyleMask(ih);
+  return 1;
 }
 
-// WATCH OUT: Setting the window title conflicts with this setting. They will clobber each other. Last one to call, "wins".
-// If you call before Map, the call order is undefined. Thus you must avoid setting the window title for this to work.
-// Setting the title to @"" doesn't work, and setting to nil is disallowed (assertion failure).
-static int cocoaDialogSetProxyIconTitleAttrib(Ihandle* ih, const char* value)
+static int cocoaDialogSetTitleAttrib(Ihandle* ih, const char* value)
 {
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	if(value)
-	{
-		NSString* ns_string = [NSString stringWithUTF8String:value];
-		[the_window setTitleWithRepresentedFilename:ns_string];
-	}
-	else
-	{
-		[the_window setTitleWithRepresentedFilename:@""];
-	}
-	return 0;
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (the_window)
+  {
+    NSString* ns_string = value ? [NSString stringWithUTF8String:value] : @"";
+    [the_window setTitle:ns_string];
+  }
+
+  if (iupAttribGetBoolean(ih, "CUSTOMFRAME") || iupAttribGetBoolean(ih, "CUSTOMFRAMESIMULATE"))
+    return 0;
+
+  return 1;
 }
 
+static int cocoaDialogSetFullScreenAttrib(Ihandle* ih, const char* value)
+{
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window) return 0;
 
-static int cocoaDialogModalPopupMethod(Ihandle* ih, int x, int y)
+  if (iupStrBoolean(value))
+  {
+    if (!iupAttribGet(ih, "_IUPCOCOA_FS_STYLE"))
+    {
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_MAXBOX", iupAttribGet(ih, "MAXBOX"));
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_MINBOX", iupAttribGet(ih, "MINBOX"));
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_MENUBOX", iupAttribGet(ih, "MENUBOX"));
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_RESIZE", iupAttribGet(ih, "RESIZE"));
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_BORDER", iupAttribGet(ih, "BORDER"));
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_TITLE", iupAttribGet(ih, "TITLE"));
+
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_X", IupGetAttribute(ih, "X"));
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_Y", IupGetAttribute(ih, "Y"));
+      iupAttribSetStr(ih, "_IUPCOCOA_FS_SIZE", IupGetAttribute(ih, "RASTERSIZE"));
+
+      iupAttribSet(ih, "MAXBOX", "NO");
+      iupAttribSet(ih, "MINBOX", "NO");
+      iupAttribSet(ih, "MENUBOX", "NO");
+      IupSetAttribute(ih, "TITLE", NULL);
+      iupAttribSet(ih, "RESIZE", "NO");
+      iupAttribSet(ih, "BORDER", "NO");
+
+      [the_window toggleFullScreen:nil];
+
+      iupAttribSet(ih, "_IUPCOCOA_FS_STYLE", "YES");
+    }
+  }
+  else
+  {
+    if (iupAttribGet(ih, "_IUPCOCOA_FS_STYLE"))
+    {
+      iupAttribSet(ih, "_IUPCOCOA_FS_STYLE", NULL);
+
+      iupAttribSetStr(ih, "MAXBOX", iupAttribGet(ih, "_IUPCOCOA_FS_MAXBOX"));
+      iupAttribSetStr(ih, "MINBOX", iupAttribGet(ih, "_IUPCOCOA_FS_MINBOX"));
+      iupAttribSetStr(ih, "MENUBOX",iupAttribGet(ih, "_IUPCOCOA_FS_MENUBOX"));
+      IupSetAttribute(ih, "TITLE", iupAttribGet(ih, "_IUPCOCOA_FS_TITLE"));
+      iupAttribSetStr(ih, "RESIZE", iupAttribGet(ih, "_IUPCOCOA_FS_RESIZE"));
+      iupAttribSetStr(ih, "BORDER", iupAttribGet(ih, "_IUPCOCOA_FS_BORDER"));
+
+      [the_window toggleFullScreen:nil];
+
+      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
+        int x = iupAttribGetInt(ih, "_IUPCOCOA_FS_X");
+        int y = iupAttribGetInt(ih, "_IUPCOCOA_FS_Y");
+        int w = IupGetInt(ih, "_IUPCOCOA_FS_SIZE");
+        int h = IupGetInt2(ih, "_IUPCOCOA_FS_SIZE");
+
+        if (w > 0 && h > 0)
+        {
+          iupdrvDialogSetPosition(ih, x, y);
+          NSRect frame = [the_window frame];
+          frame.size.width = w;
+          frame.size.height = h;
+          [the_window setFrame:frame display:YES];
+        }
+      });
+
+      iupAttribSet(ih, "_IUPCOCOA_FS_MAXBOX", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_MINBOX", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_MENUBOX", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_TITLE", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_RESIZE", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_BORDER", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_X", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_Y", NULL);
+      iupAttribSet(ih, "_IUPCOCOA_FS_SIZE", NULL);
+    }
+  }
+
+  return 1;
+}
+
+static char* cocoaDialogGetFullScreenAttrib(Ihandle* ih)
 {
-	cocoaDialogStartModal(ih);
-	return IUP_NOERROR;
-	
+  return iupAttribGet(ih, "_IUPCOCOA_FULLSCREEN");
 }
 
 
-static int cocoaDialogMapMethod(Ihandle* ih)
+static int cocoaDialogSetDialogHintAttrib(Ihandle* ih, const char* value)
 {
-	
-//	iupAttribSet(ih, "RASTERSIZE", "500x400");
-	
-	
-	// Special case to handle TRAY because it is part of IupDialog, yet completely unreleated to NSWindow.
-	if(iupAttribGetBoolean(ih, "TRAY"))
-	{
-		NSStatusBar* status_bar = [NSStatusBar systemStatusBar];
-		NSStatusItem* status_item = [status_bar statusItemWithLength:NSSquareStatusItemLength];
-		[status_item retain];
-		ih->handle = status_item;
-		
-		// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars. And category extension isn't working for some reason...NSWindow might be too big/complicated and is expecting me to define Apple stuff.
-		objc_setAssociatedObject(status_item, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-		
-		return IUP_DEFAULT;
-	}
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window) return 0;
 
-	
-	
-	
-	
-	// Warning: Don't make the initial window too big. There is code in the IUP core that does a MAX(current_size, needed_size)
-	// which is intended to make the window grow to fit.
-	// I made the mistake of making the initial window too big and didn't understand why I could never get a window that perfectly fit the contents.
-	// I think the other implementations start with 100x100.
-	NSWindow* the_window = [[NSWindow alloc] initWithContentRect:NSMakeRect(0, 0, 100, 100)
-//	NSWindow* the_window = [[NSWindow alloc] initWithContentRect:NSZeroRect
-													styleMask:NSTitledWindowMask|NSClosableWindowMask|NSResizableWindowMask|NSMiniaturizableWindowMask backing:NSBackingStoreBuffered defer:NO];
+  if (iupStrBoolean(value))
+    [the_window setLevel:NSFloatingWindowLevel];
+  else
+    [the_window setLevel:NSNormalWindowLevel];
 
-/*
-	NSToolbar* the_toolbar = [[NSToolbar alloc] initWithIdentifier:FIXME_TOOLBAR_IDENT];
-	IupCocoaToolbarDelegate* toolbar_delegate = [[IupCocoaToolbarDelegate alloc] init];
-	[the_toolbar setDelegate:toolbar_delegate];
-	[the_toolbar setDisplayMode:NSToolbarDisplayModeIconAndLabel];
-	[the_toolbar setAllowsUserCustomization:YES];
-	[the_toolbar setAutosavesConfiguration:YES];
-	[the_window setToolbar:the_toolbar];
-*/
-	
-	// We are manually managing the memory, so don't let the window release itself
-	[the_window setReleasedWhenClosed:NO];
+  return 1;
+}
 
-	// It seems that IUP wants to take control of the Previous/Next focus. But we haven't fully integrated things yet.
-	[the_window setAutorecalculatesKeyViewLoop:YES];
-//	[the_window setAutorecalculatesKeyViewLoop:NO];
-//	[the_window setInitialFirstResponder:nil];
+static int cocoaDialogSetHideTitleBarAttrib(Ihandle *ih, const char *value)
+{
+  NSWindow* window = cocoaDialogGetWindow(ih);
+  if (!window) return 0;
 
+  BOOL hide = (BOOL)iupStrBoolean(value);
+  if (hide)
+  {
+    window.styleMask |= NSWindowStyleMaskFullSizeContentView;
+    window.titlebarAppearsTransparent = YES;
+    window.titleVisibility = NSWindowTitleHidden;
+  }
+  else
+  {
+    window.styleMask &= ~NSWindowStyleMaskFullSizeContentView;
+    window.titlebarAppearsTransparent = NO;
+    window.titleVisibility = NSWindowTitleVisible;
+  }
+  return 1;
+}
 
-	static _Bool s_isFirstWindow = true;
+static char* cocoaDialogGetActiveWindowAttrib(Ihandle* ih)
+{
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window)
+    return NULL;
 
-	static NSPoint last_cascade_point = {0, 0};
-	NSPoint new_cascade_point = {0, 0};
-	
-	
-	if(s_isFirstWindow)
-	{
-		// I would like to detect if this is the very first window created and center the window in this case.
-		// TODO: Save window locations between runs
-		[the_window center];
-		last_cascade_point = [the_window cascadeTopLeftFromPoint:NSZeroPoint];
-		IupSetInt(ih, "_FIRST_WINDOW", 1);
-		s_isFirstWindow = false;
+  return iupStrReturnBoolean([the_window isKeyWindow]);
+}
 
-	}
-	else
-	{
-		
-		NSWindow* key_window = [[NSApplication sharedApplication] keyWindow];
-		if(nil != key_window)
-		{
-			//		last_cascade_point = [key_window frame].origin;
-			//		last_cascade_point.y = iupCocoaComputeCartesianScreenHeightFromIup(last_cascade_point.y);
-			
-			// Just in case the user moved the window from the last time we saved the variable
-			last_cascade_point = [key_window cascadeTopLeftFromPoint:NSZeroPoint];
-			
-			
-			//   new_cascade_point = [the_window cascadeTopLeftFromPoint:last_cascade_point];
-			new_cascade_point = [the_window cascadeTopLeftFromPoint:last_cascade_point];
-			IupSetInt(ih, "_FIRST_WINDOW", 0);
-			
-			new_cascade_point = [the_window cascadeTopLeftFromPoint:last_cascade_point];
-			//ih->x = cascade_point.x;
-			//ih->y = iupCocoaComputeIupScreenHeightFromCartesian(cascade_point.y);
-			IupSetInt(ih, "CASCADE_X", last_cascade_point.x);
-			//	IupSetInt(ih, "CASCADE_Y", iupCocoaComputeIupScreenHeightFromCartesian(last_cascade_point.y));
-			IupSetInt(ih, "CASCADE_Y", last_cascade_point.y);
-			last_cascade_point = new_cascade_point;
-			
-		}
-		else
-		{
-			NSLog(@"did not find keywindow for cascade calculation");
-			
-			//   new_cascade_point = [the_window cascadeTopLeftFromPoint:last_cascade_point];
-			new_cascade_point = [the_window cascadeTopLeftFromPoint:last_cascade_point];
-			IupSetInt(ih, "_FIRST_WINDOW", 0);
-			
-			new_cascade_point = [the_window cascadeTopLeftFromPoint:last_cascade_point];
-			//ih->x = cascade_point.x;
-			//ih->y = iupCocoaComputeIupScreenHeightFromCartesian(cascade_point.y);
-			IupSetInt(ih, "CASCADE_X", last_cascade_point.x);
-			//	IupSetInt(ih, "CASCADE_Y", iupCocoaComputeIupScreenHeightFromCartesian(last_cascade_point.y));
-			IupSetInt(ih, "CASCADE_Y", last_cascade_point.y);
-			last_cascade_point = new_cascade_point;
+static int cocoaDialogSetTopMostAttrib(Ihandle *ih, const char *value)
+{
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window) return 0;
 
-		}
-		
-	}
-	
-    
-	ih->data->first_show = 1;
+  if (iupStrBoolean(value))
+    [the_window setLevel:NSStatusWindowLevel];
+  else
+    [the_window setLevel:NSNormalWindowLevel];
+  return 1;
+}
 
+static int cocoaDialogSetBringFrontAttrib(Ihandle *ih, const char *value)
+{
+  if (iupStrBoolean(value))
+  {
+    NSWindow* the_window = cocoaDialogGetWindow(ih);
+    if (the_window)
+    {
+      [NSApp activateIgnoringOtherApps:YES];
+      [the_window makeKeyAndOrderFront:nil];
+    }
+  }
+  return 0;
+}
 
-//	[the_window setTitle:@"First Window"];
-	
-	ih->handle = (__unsafe_unretained void*)the_window;
-	
-	// This case may not make sense and nil might be the better value
-	iupCocoaSetAssociatedViews(ih, [the_window contentView], [the_window contentView]);
+static int cocoaDialogSetOpacityAttrib(Ihandle *ih, const char *value)
+{
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window) return 0;
 
-	
-	IupCocoaWindowDelegate* window_delegate = [[IupCocoaWindowDelegate alloc] init];
-	[the_window setDelegate:window_delegate];
-//	[window setIupIhandle:ih];
-	
-	// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars. And category extension isn't working for some reason...NSWindow might be too big/complicated and is expecting me to define Apple stuff.
-	objc_setAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+  int opacity;
+  if (iupStrToInt(value, &opacity))
+  {
+    if (opacity < 0) opacity = 0;
+    if (opacity > 255) opacity = 255;
+    [the_window setAlphaValue:(CGFloat)opacity / 255.0];
+    return 1;
+  }
+  return 0;
+}
 
+static int cocoaDialogSetIconAttrib(Ihandle* ih, const char *value)
+{
+  NSImage* icon = iupImageGetIcon(value);
+  [NSApp setApplicationIconImage:icon];
+  return 1;
+}
 
-	// IUP will call the activate function later
-//	[the_window makeKeyAndOrderFront:nil];
+static int cocoaDialogSetBackgroundAttrib(Ihandle* ih, const char* value)
+{
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window) return 0;
 
-//	ih->currentwidth = 200;
-//	ih->currentheight = 200;
-	
-	return IUP_NOERROR;
-
+  unsigned char r, g, b;
+  if (iupStrToRGB(value, &r, &g, &b))
+  {
+    NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+    [the_window setBackgroundColor:color];
+    return 1;
+  }
+  else
+  {
+    NSImage* image = iupImageGetImage(value, ih, 0, NULL);
+    if (image)
+    {
+      [the_window setBackgroundColor:[NSColor colorWithPatternImage:image]];
+      return 1;
+    }
+  }
+  return 0;
 }
 
-static void cocoaDialogUnMapMethod(Ihandle* ih)
+static int cocoaDialogSetShapeImageAttrib(Ihandle *ih, const char *value)
 {
-	id root_object = (id)ih->handle;
-	// Special case to handle TRAY because it is part of IupDialog, yet completely unreleated to NSWindow.
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		NSStatusItem* status_item = ih->handle;
-		NSStatusBar* status_bar = [NSStatusBar systemStatusBar];
+  NSWindow* window = cocoaDialogGetWindow(ih);
+  if (!window) return 0;
 
-		Ihandle* menu_ih = (Ihandle*)objc_getAssociatedObject(status_item, TRAYMENUIHANDLE_ASSOCIATED_OBJ_KEY);
-		IupDestroy(menu_ih);
-		objc_setAssociatedObject(status_item, TRAYMENUIHANDLE_ASSOCIATED_OBJ_KEY, (id)nil, OBJC_ASSOCIATION_ASSIGN);
+  if (!value)
+  {
+    cocoaDialogUpdateStyleMask(ih);
+    [window setOpaque:YES];
+    [window setBackgroundColor:[NSColor windowBackgroundColor]];
+    return 1;
+  }
 
+  NSImage* image = iupImageGetImage(value, ih, 0, NULL);
+  if (!image)
+    return 0;
 
-		objc_setAssociatedObject(status_item, IHANDLE_ASSOCIATED_OBJ_KEY, (id)nil, OBJC_ASSOCIATION_ASSIGN);
+  [window setStyleMask:NSWindowStyleMaskBorderless];
+  [window setOpaque:NO];
+  [window setBackgroundColor:[NSColor clearColor]];
+  [window setHasShadow:YES];
+  [window setMovableByWindowBackground:YES];
 
-		[status_bar removeStatusItem:status_item];
-		[status_item release];
-		ih->handle = nil;
-		return;
-	}
+  NSImageView* imageView = [[NSImageView alloc] initWithFrame:NSMakeRect(0, 0, image.size.width, image.size.height)];
+  [imageView setImage:image];
+  [imageView setImageFrameStyle:NSImageFrameNone];
+  [imageView setImageScaling:NSImageScaleNone];
 
+  [window setContentView:imageView];
+  [window setContentSize:image.size];
+  [imageView release];
 
+  return 1;
+}
 
-	// I am having problems with stuck ghost windows. I don't know what's causing it, but one theory I have is that tearing down a window while modal is bad.
-	// So this is my attempt to stop the modal stuff before we tear down the window.
-	// This means I need this code here and possilby if the user just closes the window first instead of triggered by IupDestroy.
-	// Unfortunately, this doesn't seem to actually fix the problem. I still see it sometimes, especially with breakpoints on.
-	// However, it seems to help a little. It seems like a race condiition.
-	// My test creates the popup before [NSApp run] is started. So I hope maybe this is just another one of those bugs, and one that is rare.
-	// Another theory is I need to wait for the loop control to return to the infinite-loop. But I don't know if it is possible to wait.
-	// The problem is that IUP wants to destroy the IH now. If I try to defer the Cocoa teardown somehow, the ih handle may be gone which contains data I need.
-	// UPDATE: I now believe the ghost/stuck windows are because of not using the [NSApp run] (real runloop). I now have a special case to handle this.
-	if(iupAttribGetBoolean(ih, "_COCOA_MODAL"))
-	{
-		cocoaDialogEndModal(ih);
-	}
-	cocoaCleanUpWindow(ih);
+static int cocoaDialogSetOpacityImageAttrib(Ihandle *ih, const char *value)
+{
+  return cocoaDialogSetShapeImageAttrib(ih, value);
+}
 
+static int cocoaDialogSetCustomFrameAttrib(Ihandle *ih, const char *value)
+{
+  NSWindow* window = cocoaDialogGetWindow(ih);
+  if (!window) return 0;
+
+  if (iupStrBoolean(value))
+  {
+    [window setStyleMask:NSWindowStyleMaskBorderless];
+    [window setMovableByWindowBackground:YES];
+    [window setHasShadow:YES];
+  }
+  else
+  {
+    cocoaDialogUpdateStyleMask(ih);
+    [window setMovableByWindowBackground:NO];
+  }
+  return 1;
 }
 
-static void cocoaDialogLayoutUpdateMethod(Ihandle* ih)
+static char* cocoaDialogGetMaximizedAttrib(Ihandle *ih)
 {
-	id root_object = (id)ih->handle;
-	if([root_object isKindOfClass:[NSStatusItem class]])
-	{
-		return;
-	}
-	
-#if 1
-	if(ih->data->ignore_resize)
-	{
-		return;
-	}
-	
-	ih->data->ignore_resize = 1;
-	
-	/* for dialogs the position is not updated here */
-	
-	NSWindow* the_window = cocoaDialogGetWindow(ih);
-	NSRect the_frame = [the_window frame];
-	the_frame.size.width = ih->currentwidth;
-	the_frame.size.height = ih->currentheight;
-	
-//	[the_window setFrame:the_frame display:YES animate:YES];
-	[the_window setFrame:the_frame display:YES animate:NO];
-	
-	ih->data->ignore_resize = 0;
-#endif
-	
+  if (iupAttribGetBoolean(ih, "CUSTOMFRAMESIMULATE"))
+    return iupAttribGet(ih, "MAXIMIZED");
 
-	
-//	NSRect the_rect = [the_window frame];
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window)
+    return NULL;
 
+  return iupStrReturnBoolean([the_window isZoomed]);
+}
 
+static char* cocoaDialogGetMinimizedAttrib(Ihandle *ih)
+{
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
+  if (!the_window)
+    return NULL;
 
+  return iupStrReturnBoolean([the_window isMiniaturized]);
 }
 
 
-/////////// NSStatusItem/Tray stuff
-// WARNING: NSStatusItem is not exactly a "tray" item, so maybe this should be moved to something else, not in IupDialog.
-// Issues:
-// - The IUP API ties this to a Dialog, but this should be a separate thing.
-// - NSStatusBar does allow for multiple NSStatusItems to be created.
-// However, this is extremely rare in practice and to prevent bad habits from forming because we get a separate instance for every dialog, we will only support 1.
-// - The NSStatusItem is expected to bring up a menu.
-// This is unlike what IUP is designed for and we will need to introduce a new attribute for that.
-// - Icons must be black and white, not color, for guidelines.
-// But Apple does allow color icons here.
-// (I heard the colored flags are required by law in some countries as it is illegal to change their representation.)
-// This is a constant porting problem where Windows centric devs don't bother to special case for Mac
-// and Mac users are stuck with an annoying color icon in their status bar.
-// So we will attempt to force to grayscale.
-// - Particularly for Yosemite 10.10, light/dark theme toggling must be black/white so Apple can attempt to auto-invert.
-// The old APIs for alternate image are deprecated. It doesn't seem like we should add another attribute to IUP for this legacy thing.
+/****************************************************************
+ ********************** Class Methods ***************************
+ ****************************************************************/
 
-static int cocoaDialogSetTrayAttrib(Ihandle* ih, const char* value)
+static void cocoaDialogSetChildrenPositionMethod(Ihandle* ih, int x, int y)
 {
-	NSStatusItem* status_item = cocoaDialogGetStatusItem(ih);
-	bool should_enable = (bool)iupStrBoolean(value);
-	if(should_enable)
-	{
-		[status_item setVisible:YES];
-	}
-	else
-	{
-		[status_item setVisible:NO];
-		// NOTE: We do not release our NSStatusItem instance here.
-		// The reason is that if the user wants to re-enable it, we don't want to make them re-apply the menu and image.
-		// This also means we need to release the item on IupClose() before the autorelease pool is closed.
-//		NSStatusBar* status_bar = [NSStatusBar systemStatusBar];
-//		[status_bar removeStatusItem:status_item];
-	}
+  (void)x;
+  (void)y;
 
-	return 1;
+  if (ih->firstchild)
+  {
+    char* offset = iupAttribGet(ih, "CHILDOFFSET");
+    int offset_x = 0;
+    int offset_y = 0;
+
+    if (offset)
+      iupStrToIntInt(offset, &offset_x, &offset_y, 'x');
+
+    iupBaseSetPosition(ih->firstchild, ih->firstchild->x + offset_x, ih->firstchild->y + offset_y);
+  }
 }
 
-static int cocoaDialogSetTrayImageAttrib(Ihandle* ih, const char* value)
+static int cocoaDialogMapMethod(Ihandle* ih)
 {
-	NSImage* user_image = (NSImage*)iupImageGetIcon(value);
-//	[user_image autorelease]; // I think IUP is caching. releasing here could mean a double-autorelease the next time it gets called since it does not retain when it fetches from the cache.
-	NSImageRep* user_image_rep = nil;
+  InativeHandle* parent;
+  NSWindowStyleMask style_mask = cocoaDialogGetStyleMask(ih);
 
-	NSStatusItem* status_item = cocoaDialogGetStatusItem(ih);
+  NSWindow* the_window = [[IupCocoaWindow alloc] initWithContentRect:NSMakeRect(0, 0, 100, 100)
+                                                   styleMask:style_mask
+                                                     backing:NSBackingStoreBuffered
+                                                       defer:NO];
 
-	NSArray* array_of_representations = [user_image representations];
+  [the_window setReleasedWhenClosed:NO];
+  [the_window setAutorecalculatesKeyViewLoop:YES];
 
-	if([array_of_representations count] > 0)
-	{
-		user_image_rep = [array_of_representations objectAtIndex:0];
-	}
+  [[the_window contentView] setAutoresizesSubviews:NO];
 
-	// We must scale the image to fix the statusbar.
-	NSStatusBar* status_bar = [NSStatusBar systemStatusBar];
-	CGFloat status_bar_height = [status_bar thickness];
-	// From this, it sounds like we should shrink by 4 pixels (thickess is 22, but real height is 21 so subtract 1. Then subtract 3 more for margins.)
-	NSSize target_image_size = NSMakeSize(status_bar_height-4, status_bar_height-4);
-	
-	
-	// I originally tried to convert the image to grayscale in hopes setTemplate:YES would work better with it.
-	// But in practice, it doesn't help and my template yields unusable results.
-	//
-#if 0
-	// A common problem I am anticipating from seeing other cross-platform kits, is that the Windows devs use a color icon and never test or realize that Mac is only supposed to have black & white icons.
-	// And the lazy factor never fixes this leading to a poor user experience for Mac users.
-	// So like it or not, I'm going to convert the image to grayscale.
-	if([user_image_rep respondsToSelector:@selector(bitmapImageRepByConvertingToColorSpace:renderingIntent:)])
-	{
-		// Assuming it is a NSBitmapImageRep
-		NSBitmapImageRep* image_rep = [(NSBitmapImageRep*)user_image_rep bitmapImageRepByConvertingToColorSpace:[NSColorSpace genericGrayColorSpace] renderingIntent:NSColorRenderingIntentDefault];
+  ih->handle = (__bridge void*)the_window;
+  iupcocoaSetAssociatedViews(ih, [the_window contentView], [the_window contentView]);
 
-	//	NSImage* icon_image = [[NSImage alloc] initWithSize:[image_rep size]];
-	
+  IupCocoaWindowDelegate* window_delegate = [[IupCocoaWindowDelegate alloc] init];
+  [the_window setDelegate:window_delegate];
+  objc_setAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
 
-		//  I think there is supposed to be 3 pixel margins.
-		NSImage* icon_image = [[NSImage alloc] initWithSize:target_image_size];
-		[icon_image autorelease];
-		[icon_image addRepresentation:image_rep];
-		
-		// 10.10 Yosemite introduces light/dark themes so we must make the icon handle both.
-		[icon_image setTemplate:YES];
-		// 10.10+ API
-		if([status_item respondsToSelector:@selector(button)])
-		{
-			[[status_item button] setImage:icon_image];
-		}
-		else
-		{
-			// pre 10.10 legacy path
-			[status_item setImage:icon_image];
-			[status_item setHighlightMode:YES];
+  parent = iupDialogGetNativeParent(ih);
+  if (parent && [(id)parent isKindOfClass:[NSWindow class]])
+  {
+    NSWindow* parent_window = (NSWindow*)parent;
+    [parent_window addChildWindow:the_window ordered:NSWindowAbove];
 
-		}
-		
-	}
-	else
-	{
-		NSLog(@"Not sure what kind of image this is: %@", user_image);
-		// 10.10 Yosemite introduces light/dark themes so we must make the icon handle both.
-		[user_image setSize:target_image_size];
-		[user_image setTemplate:YES];
-		// 10.10+ API
-		if([status_item respondsToSelector:@selector(button)])
-		{
-			[[status_item button] setImage:user_image];
-		}
-		else
-		{
-			// pre 10.10 legacy path
-			[status_item setImage:user_image];
-			[status_item setHighlightMode:YES];
+    /* addChildWindow makes the window visible as a side effect.
+       Hide it so IupShowXY properly increments the visible count. */
+    [the_window orderOut:nil];
 
-		}
-	
-	}
-#else
-	
-	// So here we always take the image and use setTemplate:YES.
-	// Users are expected to provide only black & white images.
-	// If it is not, they will probably get a screwed up icon (maybe all black or all white).
-	// This is kind of a good thing. This will serve as a reminder that they need to provide a different image.
-	// This also may serve as a reminder that they need to set the menu too.
+    [[NSNotificationCenter defaultCenter] addObserver:window_delegate
+                                             selector:@selector(cocoaDialogChildDestroyNotification:)
+                                                 name:NSWindowWillCloseNotification
+                                               object:the_window];
+  }
 
-	// 10.10 Yosemite introduces light/dark themes so we must make the icon handle both.
-	[user_image setSize:target_image_size];
-	[user_image setTemplate:YES];
-	
-	// 10.10+ API
-	if([status_item respondsToSelector:@selector(button)])
-	{
-		[[status_item button] setImage:user_image];
-	}
-	else
-	{
-		// pre 10.10 legacy path
-		[status_item setImage:user_image];
-		[status_item setHighlightMode:YES];
+  NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
+  [nc addObserver:window_delegate selector:@selector(windowDidResize:) name:NSWindowDidResizeNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowDidMove:) name:NSWindowDidMoveNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowDidMiniaturize:) name:NSWindowDidMiniaturizeNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowDidDeminiaturize:) name:NSWindowDidDeminiaturizeNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowWillEnterFullScreen:) name:NSWindowWillEnterFullScreenNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowDidEnterFullScreen:) name:NSWindowDidEnterFullScreenNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowDidExitFullScreen:) name:NSWindowDidExitFullScreenNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowDidBecomeKey:) name:NSWindowDidBecomeKeyNotification object:the_window];
+  [nc addObserver:window_delegate selector:@selector(windowDidResignKey:) name:NSWindowDidResignKeyNotification object:the_window];
 
-	}
-#endif
+  [the_window addObserver:window_delegate
+               forKeyPath:@"effectiveAppearance"
+                  options:NSKeyValueObservingOptionNew
+                  context:IupCocoaAppearanceContext];
 
+  if (IupGetCallback(ih, "DROPFILES_CB"))
+    iupAttribSet(ih, "DROPFILESTARGET", "YES");
 
-	return 1;
+  iupAttribSet(ih, "VISIBLE", NULL);
+
+  return IUP_NOERROR;
 }
 
-
-// This returns the Ihandle* set via cocoaDialogSetTrayMenuAttrib
-static char* cocoaDialogGetTrayMenuAttrib(Ihandle* ih)
+static void cocoaDialogUnMapMethod(Ihandle* ih)
 {
-	NSStatusItem* status_item = cocoaDialogGetStatusItem(ih);
-	Ihandle* menu_ih = (Ihandle*)objc_getAssociatedObject(status_item, TRAYMENUIHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih->handle) return;
 
-	return (char*)menu_ih;
+  if (ih->data->menu)
+  {
+    ih->data->menu->handle = NULL;
+    IupDestroy(ih->data->menu);
+    ih->data->menu = NULL;
+  }
+
+  NSWindow* the_window = (__bridge NSWindow*)ih->handle;
+
+  NSWindow* parent_window = [the_window parentWindow];
+  if (parent_window)
+  {
+    [[NSNotificationCenter defaultCenter] removeObserver:[parent_window delegate]
+                                                     name:NSWindowWillCloseNotification
+                                                   object:the_window];
+    [parent_window removeChildWindow:the_window];
+  }
+
+
+  @try
+  {
+    [the_window removeObserver:[the_window delegate]
+                    forKeyPath:@"effectiveAppearance"
+                       context:IupCocoaAppearanceContext];
+  }
+  @catch (NSException *exception)
+  {
+    /* Observer might not have been added, ignore */
+  }
+
+  [[NSNotificationCenter defaultCenter] removeObserver:[the_window delegate] name:nil object:the_window];
+
+  objc_setAssociatedObject(the_window, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+
+  [the_window close];
+
+  IupCocoaWindowDelegate* window_delegate = [the_window delegate];
+  [the_window setDelegate:nil];
+  [window_delegate release];
+
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+  [the_window release];
+  ih->handle = NULL;
 }
 
-// IMPORTANT: We are taking ownership of the menu. User should never call IupDestroy on the menu item.
-// We will do that.
-// My understanding is this is how window menus are done on other platforms (GTK), i.e. the dialog destroy calls destroy on the attached menu.
-// So this is modeled after that.
-static int cocoaDialogSetTrayMenuAttrib(Ihandle* ih, const char* value)
+static void cocoaDialogLayoutUpdateMethod(Ihandle *ih)
 {
-	if((NULL == ih) || (NULL == ih->handle))
-	{
-		return 1;
-	}
-	
-	Ihandle* menu_ih = (Ihandle*)value;
+  int width, height;
 
-	NSStatusItem* status_item = cocoaDialogGetStatusItem(ih);
-	Ihandle* old_menu_ih = (Ihandle*)objc_getAssociatedObject(status_item, TRAYMENUIHANDLE_ASSOCIATED_OBJ_KEY);
+  id root_object = (id)ih->handle;
+  if([root_object isKindOfClass:[NSStatusItem class]] || !root_object) return;
 
-	// Unset the existing menu
-	if(NULL == menu_ih)
-	{
-		[status_item setMenu:nil];
-		IupDestroy(old_menu_ih);
-		objc_setAssociatedObject(status_item, IHANDLE_ASSOCIATED_OBJ_KEY, (id)nil, OBJC_ASSOCIATION_ASSIGN);
-		return 1;
-	}
+  if(ih->data->ignore_resize || iupAttribGet(ih, "_IUPCOCOA_FS_STYLE"))
+    return;
 
+  ih->data->ignore_resize = 1;
 
-	// FIXME: The Menu might not be IupMap'd yet. (Presumably because we do not attach it directly to a dialog in this case.)
-	// I think calling IupMap() is the correct thing to do and fixes the problem.
-	// But this should be reviewed.
-	if(NULL == menu_ih->handle)
-	{
-		IupMap(menu_ih);
-	}
-	
-	// Make sure we have an IupMenu
-	if(menu_ih->iclass->nativetype != IUP_TYPEMENU)
-	{
-		// call IUPASSERT?
-		return 0;
-	}
-	// Make sure we have a NSMenu
-	if(![(id)menu_ih->handle isKindOfClass:[NSMenu class]])
-	{
-		// call IUPASSERT?
-		return 0;
-	}
+  NSWindow* the_window = cocoaDialogGetWindow(ih);
 
+  if (!the_window)
+  {
+    ih->data->ignore_resize = 0;
+    return;
+  }
 
-	NSMenu* the_menu = (NSMenu*)menu_ih->handle;
-	[status_item setMenu:the_menu];
+  if ([the_window isMiniaturized])
+  {
+    ih->data->ignore_resize = 0;
+    return;
+  }
 
-	// Save the menu_ih and destroy the old one.
-	IupDestroy(old_menu_ih);
-	objc_setAssociatedObject(status_item, IHANDLE_ASSOCIATED_OBJ_KEY, (id)menu_ih, OBJC_ASSOCIATION_ASSIGN);
+  if ([the_window isZoomed])
+  {
+    NSRect zoomed_frame = [the_window frame];
 
-	return 1;
+    /* Compare the desired total size from IUP with the current zoomed frame size. */
+    /* If they differ significantly, we should unzoom before applying the new size. */
+    if (abs(ih->currentwidth - (int)zoomed_frame.size.width) > 10 ||
+        abs(ih->currentheight - (int)zoomed_frame.size.height) > 10)
+    {
+      /* Unzoom before resizing */
+      [the_window setStyleMask:[the_window styleMask] & ~NSWindowStyleMaskFullScreen];
+      [the_window zoom:nil];
+      /* Clear the zoom restore frame */
+      objc_setAssociatedObject(the_window, &IUPCocoaZoomRestoreFrameKey, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+      /* Update show state */
+      ih->data->show_state = IUP_RESTORE;
+    }
+    else
+    {
+      /* Size is similar to zoomed size, don't unzoom */
+      ih->data->ignore_resize = 0;
+      return;
+    }
+  }
+
+  int decor_w, decor_h;
+  NSRect sample_content_rect = NSMakeRect(0, 0, 100, 100);
+  NSRect sample_frame_rect = [NSWindow frameRectForContentRect:sample_content_rect styleMask:[the_window styleMask]];
+  decor_w = (int)round(sample_frame_rect.size.width - sample_content_rect.size.width);
+  decor_h = (int)round(sample_frame_rect.size.height - sample_content_rect.size.height);
+
+  width = ih->currentwidth - decor_w;
+  height = ih->currentheight - decor_h;
+  if(width <= 0) width = 1;
+  if(height <= 0) height = 1;
+
+  NSSize content_size = NSMakeSize(width, height);
+
+  /* Clear any existing size constraints before resizing */
+  [the_window setContentMinSize:NSMakeSize(1, 1)];
+  [the_window setContentMaxSize:NSMakeSize(65535, 65535)];
+
+  [the_window setContentSize:content_size];
+
+  if (!iupAttribGetBoolean(ih, "RESIZE"))
+  {
+    [the_window setContentMinSize:content_size];
+    [the_window setContentMaxSize:content_size];
+  }
+
+  ih->data->ignore_resize = 0;
 }
 
 
+/****************************************************************
+ ******************** Other Attributes **************************
+ ****************************************************************/
 
+static int cocoaDialogSetTaskBarProgressAttrib(Ihandle *ih, const char *value)
+{
+  if (iupStrBoolean(value))
+  {
+    NSProgress* progress = [NSProgress progressWithTotalUnitCount:100];
+    progress.completedUnitCount = 0;
+    [[NSApp dockTile] setBadgeLabel:nil];
+    objc_setAssociatedObject((id)ih->handle, DOCKPROGRESS_ASSOCIATED_OBJ_KEY, progress, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  }
+  else
+  {
+    [[NSApp dockTile] setBadgeLabel:nil];
+    objc_setAssociatedObject((id)ih->handle, DOCKPROGRESS_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  }
+  return 1;
+}
+
+static int cocoaDialogSetTaskBarProgressStateAttrib(Ihandle *ih, const char *value)
+{
+  NSProgress* progress = objc_getAssociatedObject((id)ih->handle, DOCKPROGRESS_ASSOCIATED_OBJ_KEY);
+  if (progress)
+  {
+    if (iupStrEqualNoCase(value, "NOPROGRESS"))
+    {
+      cocoaDialogSetTaskBarProgressAttrib(ih, "NO");
+    }
+    else if (iupStrEqualNoCase(value, "INDETERMINATE"))
+    {
+      progress.totalUnitCount = -1;
+      [[NSApp dockTile] setBadgeLabel:@""];
+    }
+    else if (iupStrEqualNoCase(value, "PAUSED"))
+    {
+      if (progress.totalUnitCount < 0)
+        progress.totalUnitCount = 100;
+      [progress pause];
+    }
+    else
+    {
+      if (progress.totalUnitCount < 0)
+        progress.totalUnitCount = 100;
+      [progress resume];
+      [[NSApp dockTile] setBadgeLabel:nil];
+    }
+  }
+  return 1;
+}
+
+static int cocoaDialogSetTaskBarProgressValueAttrib(Ihandle *ih, const char *value)
+{
+  NSProgress* progress = objc_getAssociatedObject((id)ih->handle, DOCKPROGRESS_ASSOCIATED_OBJ_KEY);
+  if (progress)
+  {
+    int int_value;
+    if (iupStrToInt(value, &int_value))
+    {
+      if (int_value < 0) int_value = 0;
+      if (int_value > 100) int_value = 100;
+
+      progress.completedUnitCount = int_value;
+
+      if (int_value > 0 && int_value < 100)
+      {
+        NSString* badge_label = [NSString stringWithFormat:@"%d%%", int_value];
+        [[NSApp dockTile] setBadgeLabel:badge_label];
+      }
+      else if (int_value >= 100)
+      {
+        [[NSApp dockTile] setBadgeLabel:nil];
+        cocoaDialogSetTaskBarProgressAttrib(ih, "NO");
+      }
+    }
+  }
+  return 1;
+}
+
+
+/****************************************************************
+ ******************** Class Registration ************************
+ ****************************************************************/
+
 void iupdrvDialogInitClass(Iclass* ic)
 {
-	/* Driver Dependent Class methods */
-	ic->Map = cocoaDialogMapMethod;
-	ic->UnMap = cocoaDialogUnMapMethod;
-	ic->LayoutUpdate = cocoaDialogLayoutUpdateMethod;
-	
+  ic->Map = cocoaDialogMapMethod;
+  ic->UnMap = cocoaDialogUnMapMethod;
+  ic->LayoutUpdate = cocoaDialogLayoutUpdateMethod;
+  ic->SetChildrenPosition = cocoaDialogSetChildrenPositionMethod;
 
-	// Setting DlgPopup is not typical, but IUP's modal dialog system for IupPopup doesn't work the way Cocoa does.
-	// IUP wants to control the modality and the event loop pumping with IupMainLoop(). This doesn't work so well for us.
-	// So we set this callback to notify IUP that we are using the native platform's modal stuff.
-	// IUP seemed to intend it to be for specific dialogs like the FileDialog, but Antonio Scuri thinks we can use it here too.
-	ic->DlgPopup = cocoaDialogModalPopupMethod;
+  iupClassRegisterCallback(ic, "MOVE_CB", "ii");
+  iupClassRegisterCallback(ic, "THEMECHANGED_CB", "i");
 
+  iupClassRegisterAttribute(ic, "CLIENTSIZE", cocoaDialogGetClientSizeAttrib, iupDialogSetClientSizeAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_SAVE | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "CLIENTOFFSET", cocoaDialogGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_DEFAULTVALUE | IUPAF_READONLY | IUPAF_NO_INHERIT);
 
-#if 0
-	ic->LayoutUpdate = gtkDialogLayoutUpdateMethod;
-	ic->GetInnerNativeContainerHandle = gtkDialogGetInnerNativeContainerHandleMethod;
-	ic->SetChildrenPosition = gtkDialogSetChildrenPositionMethod;
-	
-	/* Callback Windows and GTK Only */
-	iupClassRegisterCallback(ic, "TRAYCLICK_CB", "iii");
-	
-	/* Driver Dependent Attribute functions */
-#ifndef GTK_MAC
-#ifdef WIN32
-	iupClassRegisterAttribute(ic, "HWND", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);
-#else
-	iupClassRegisterAttribute(ic, "XWINDOW", iupgtkGetNativeWindowHandle, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_NO_STRING);
-#endif
-#endif
-	
-	/* Visual */
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, "DLGBGCOLOR", NULL, IUPAF_DEFAULT);  /* force new default value */
-	
-	/* Base Container */
-	iupClassRegisterAttribute(ic, "CLIENTSIZE", gtkDialogGetClientSizeAttrib, iupDialogSetClientSizeAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);  /* dialog is the only not read-only */
-	iupClassRegisterAttribute(ic, "CLIENTOFFSET", gtkDialogGetClientOffsetAttrib, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_READONLY|IUPAF_NO_INHERIT);
-#endif
-	
-	
-	/* Special */
-	iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaDialogSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	
-	
-#if 0
-	/* IupDialog only */
-	iupClassRegisterAttribute(ic, "BACKGROUND", NULL, gtkDialogSetBackgroundAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "ICON", NULL, gtkDialogSetIconAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
-#endif
-	iupClassRegisterAttribute(ic, "FULLSCREEN", NULL, cocoaDialogSetFullScreenAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "MINSIZE", NULL, cocoaDialogSetMinSizeAttrib, IUPAF_SAMEASSYSTEM, "1x1", IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "MAXSIZE", NULL, cocoaDialogSetMaxSizeAttrib, IUPAF_SAMEASSYSTEM, "65535x65535", IUPAF_NO_INHERIT);
-#if 0
-	iupClassRegisterAttribute(ic, "SAVEUNDER", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);  /* saveunder not supported in GTK */
-	
-	/* IupDialog Windows and GTK Only */
-	iupClassRegisterAttribute(ic, "ACTIVEWINDOW", gtkDialogGetActiveWindowAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "TOPMOST", NULL, gtkDialogSetTopMostAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "DIALOGHINT", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "OPACITY", NULL, gtkDialogSetOpacityAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "OPACITYIMAGE", NULL, gtkDialogSetOpacityImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-#endif
+  iupClassRegisterAttribute(ic, "MENU", NULL, cocoaDialogSetMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaDialogSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "RESIZE", cocoaDialogGetResizeAttrib, cocoaDialogSetResizeAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "BORDER", NULL, cocoaDialogSetBorderAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MINBOX", NULL, cocoaDialogSetMinBoxAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MAXBOX", NULL, cocoaDialogSetMaxBoxAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MENUBOX", NULL, cocoaDialogSetMenuBoxAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MINSIZE", NULL, cocoaDialogSetMinSizeAttrib, IUPAF_SAMEASSYSTEM, "1x1", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MAXSIZE", NULL, cocoaDialogSetMaxSizeAttrib, IUPAF_SAMEASSYSTEM, "65535x65535", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "FULLSCREEN", cocoaDialogGetFullScreenAttrib, cocoaDialogSetFullScreenAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "CUSTOMFRAME", NULL, cocoaDialogSetCustomFrameAttrib, NULL, "NO", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SHOWNOACTIVATE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DIALOGHINT", NULL, cocoaDialogSetDialogHintAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "HELPBUTTON", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TOOLBOX", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "HIDETITLEBAR", NULL, cocoaDialogSetHideTitleBarAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-	// TODO: Consider using different names because these are not going to work perfectly out of the box porting from other platforms.
-	// TRAYIMAGE specifically most likely needs to be a different image that is only black & white. (e.g. TRAYIMAGE_BW)
-	iupClassRegisterAttribute(ic, "TRAY", NULL, cocoaDialogSetTrayAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "TRAYIMAGE", NULL, cocoaDialogSetTrayImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "TRAYMENU", cocoaDialogGetTrayMenuAttrib, cocoaDialogSetTrayMenuAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "BACKGROUND", NULL, cocoaDialogSetBackgroundAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ICON", NULL, cocoaDialogSetIconAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "OPACITY", NULL, cocoaDialogSetOpacityAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SHAPEIMAGE", NULL, cocoaDialogSetShapeImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "OPACITYIMAGE", NULL, cocoaDialogSetOpacityImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-#if 1
+  iupClassRegisterAttribute(ic, "TOPMOST", NULL, cocoaDialogSetTopMostAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ACTIVEWINDOW", cocoaDialogGetActiveWindowAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MAXIMIZED", cocoaDialogGetMaximizedAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MINIMIZED", cocoaDialogGetMinimizedAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "BRINGFRONT", NULL, cocoaDialogSetBringFrontAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 
-	iupClassRegisterAttribute(ic, "TRAYTIP", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "TRAYTIPMARKUP", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "TASKBARPROGRESS", NULL, cocoaDialogSetTaskBarProgressAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TASKBARPROGRESSSTATE", NULL, cocoaDialogSetTaskBarProgressStateAttrib, IUPAF_SAMEASSYSTEM, "NORMAL", IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TASKBARPROGRESSVALUE", NULL, cocoaDialogSetTaskBarProgressValueAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 
-	iupClassRegisterAttribute(ic, "HIDETASKBAR", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupcocoaCommonBaseSetLayerBackedAttrib, NULL, "NO", IUPAF_NO_INHERIT);
 
-	/* Not Supported */
-	iupClassRegisterAttribute(ic, "BRINGFRONT", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "COMPOSITED", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "CONTROL", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "HELPBUTTON", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "TOOLBOX", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "MDIFRAME", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "MDICLIENT", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "MDIMENU", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "MDICHILD", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-#endif
+  iupClassRegisterAttribute(ic, "COMPOSITED", NULL, NULL, IUPAF_SAMEASSYSTEM, "YES", IUPAF_READONLY|IUPAF_NO_INHERIT);
 
+  iupClassRegisterAttribute(ic, "SAVEUNDER", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "CONTROL", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, iupCocoaCommonBaseSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "LAYERBACKED", cocoaDialogGetLayerBackedAttrib, cocoaDialogSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
-	iupClassRegisterAttribute(ic, "PROXYICONPATH", cocoaDialogGetProxyIconAttrib, cocoaDialogSetProxyIconAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "PROXYICONTITLE", NULL, cocoaDialogSetProxyIconTitleAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
+  iupClassRegisterAttribute(ic, "MDIFRAME", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MDICLIENT", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MDIMENU", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MDICHILD", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
-
Index: src/cocoa/iupcocoa_dragdrop.h
===================================================================
--- src/cocoa/iupcocoa_dragdrop.h	(revision 5971)
+++ src/cocoa/iupcocoa_dragdrop.h	(working copy)
@@ -1,4 +1,4 @@
-#ifndef __IUPCOCOA_DRAGDROP_H 
+#ifndef __IUPCOCOA_DRAGDROP_H
 #define __IUPCOCOA_DRAGDROP_H
 
 #import <Cocoa/Cocoa.h>
@@ -6,16 +6,15 @@
 #include <stdbool.h>
 #include "iup.h"
 
-extern const void* _Nonnull IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY;
-extern const void* _Nonnull IUPTARGETDROP_ASSOCIATED_OBJ_KEY;
+extern const void* IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY;
+extern const void* IUPTARGETDROP_ASSOCIATED_OBJ_KEY;
 
-
 @interface IupTargetDropAssociatedData : NSObject
 @property(nonatomic, assign) Ihandle* ihandle;
 @property(nonatomic, copy) NSArray<NSString*>* dropRegisteredTypes;
 @property(nonatomic, assign, getter=isDropTargetEnabled) bool dropTargetEnabled;
 
-// These must be weak references because we don't want to create a retain cycle back to the view we operating on
+/* These must be weak references because we don't want to create a retain cycle back to the view we are operating on. */
 @property(nonatomic, assign) NSView* mainView;
 @property(nonatomic, assign) NSView* rootView;
 
@@ -23,29 +22,24 @@
 
 @interface IupSourceDragAssociatedData : NSObject <NSDraggingSource, NSPasteboardTypeOwner, NSPasteboardItemDataProvider, NSFilePromiseProviderDelegate>
 @property(nonatomic, assign) Ihandle* ihandle;
-// Used to distinguish between needing copy or if drag is actually enabled. Setting the types assumes copy is active.
+/* Used to distinguish between needing copy or if drag is actually enabled. Setting the types assumes copy is active. */
 @property(nonatomic, assign, getter=isDragSourceEnabled) bool dragSourceEnabled;
-// TODO: Can we support multiple types via DataProvider?
-//@property(nonatomic, copy) NSString* dragRegisteredType;
 @property(nonatomic, copy) NSArray<NSString*>* dragRegisteredTypes;
-//@property(nonatomic, copy) NSArray* dropRegisteredTypes;
 @property(nonatomic, assign) bool useAutoBeginDrag;
 @property(nonatomic, assign) bool useAutoGenerateDragImage;
-@property(nonatomic, copy) NSString* defaultFilePromiseName; // used for when the user doesn't define a callback. Intended for when we design our own widgets with built-in behaviors, like IupCanvas.
-//@property(nonatomic, assign) bool wantsFilePromise;
-// helper: true if (user's) wantsFilePromise OR CALLBACK is set
+@property(nonatomic, copy) NSString* defaultFilePromiseName; /* Used for when the user doesn't define a callback. */
 - (bool) usesFilePromise;
 - (bool) hasFilePromiseCallback;
 
-// These must be weak references because we don't want to create a retain cycle back to the view we operating on
+/* These must be weak references because we don't want to create a retain cycle back to the view we are operating on. */
 @property(nonatomic, assign) NSView* mainView;
 @property(nonatomic, assign) NSView* rootView;
 
-// @protocol: NSPasteboardItemDataProvider
-- (void) pasteboard:(NSPasteboard* _Nullable)paste_board item:(NSPasteboardItem* _Nonnull)pasteboard_item provideDataForType:(NSPasteboardType _Nonnull)type_name;
+/* @protocol: NSPasteboardItemDataProvider */
+- (void) pasteboard:(NSPasteboard*)paste_board item:(NSPasteboardItem*)pasteboard_item provideDataForType:(NSPasteboardType)type_name;
 
-// @protocol: NSDraggingSource
-- (NSDragOperation) draggingSession:(NSDraggingSession* _Nonnull)dragging_session sourceOperationMaskForDraggingContext:(NSDraggingContext)dragging_context;
+/* @protocol: NSDraggingSource */
+- (NSDragOperation) draggingSession:(NSDraggingSession*)dragging_session sourceOperationMaskForDraggingContext:(NSDraggingContext)dragging_context;
 
 
 - (NSDraggingItem*) defaultDraggingItem;
@@ -52,10 +46,10 @@
 - (NSPasteboardItem*) defaultPasteboardItem;
 
 
-// @protocol: NSFilePromiseProviderDelegate
+/* @protocol: NSFilePromiseProviderDelegate */
 - (NSString*) filePromiseProvider:(NSFilePromiseProvider*)file_promise_provider fileNameForType:(NSString*)file_type;
-// @protocol: NSFilePromiseProviderDelegate
-- (void) filePromiseProvider:(NSFilePromiseProvider*)file_promise_provider writePromiseToURL:(NSURL*)write_url completionHandler:(void (^)(NSError * __nullable errorOrNil))completion_handler;
+/* @protocol: NSFilePromiseProviderDelegate */
+- (void) filePromiseProvider:(NSFilePromiseProvider*)file_promise_provider writePromiseToURL:(NSURL*)write_url completionHandler:(void (^)(NSError* errorOrNil))completion_handler;
 
 - (void) draggingSession:(NSDraggingSession*)dragging_session willBeginAtPoint:(NSPoint)screen_point;
 - (void) draggingSession:(NSDraggingSession*)dragging_session endedAtPoint:(NSPoint)screen_point operation:(NSDragOperation)drag_operation;
@@ -63,7 +57,6 @@
 @end
 
 
-
 IupTargetDropAssociatedData* cocoaTargetDropGetAssociatedData(Ihandle* ih);
 IupSourceDragAssociatedData* cocoaSourceDragGetAssociatedData(Ihandle* ih);
 
@@ -73,7 +66,8 @@
 void cocoaTargetDropDestroyAssociatedData(Ihandle* ih);
 void cocoaSourceDragDestroyAssociatedData(Ihandle* ih);
 
+/* These functions are called by the widget's NSView(DraggingDestination) implementation */
 int cocoaTargetDropBasePerformDropCallback(Ihandle* ih, id<NSDraggingInfo> the_sender, NSPasteboard* paste_board, NSPoint drop_point);
+NSDragOperation cocoaTargetDropBaseDraggingUpdated(Ihandle* ih, id<NSDraggingInfo> the_sender);
 
 #endif /* __IUPCOCOA_DRAGDROP_H */
-
Index: src/cocoa/iupcocoa_dragdrop.m
===================================================================
--- src/cocoa/iupcocoa_dragdrop.m	(revision 5971)
+++ src/cocoa/iupcocoa_dragdrop.m	(working copy)
@@ -1,16 +1,17 @@
 /** \file
- * \brief GTK Drag&Drop Functions
+ * \brief Drag&Drop Functions
  *
  * See Copyright Notice in "iup.h"
  */
 
-#include <stdio.h>              
+#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>             
-#include <limits.h>             
+#include <string.h>
+#include <limits.h>
 
 #import <Cocoa/Cocoa.h>
 #import <objc/runtime.h>
+#import <CoreServices/CoreServices.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -26,1979 +27,1359 @@
 #include "iupcocoa_drv.h"
 #import "iupcocoa_dragdrop.h"
 
-// To avoid problems on pre-10.13, redefine the strings.
-NSPasteboardType const kCompatNSPasteboardTypeFileURL = @"public.file-url";
-NSPasteboardType const kCompatNSPasteboardTypeURL = @"public.url";
 
+const void* IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY = @"IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY";
+const void* IUPTARGETDROP_ASSOCIATED_OBJ_KEY = @"IUPTARGETDROP_ASSOCIATED_OBJ_KEY";
 
-const void* IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY = @"IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY"; // the point of this is we have a unique memory address for an identifier
-const void* IUPTARGETDROP_ASSOCIATED_OBJ_KEY = @"IUPTARGETDROP_ASSOCIATED_OBJ_KEY"; // the point of this is we have a unique memory address for an identifier
 
-
 @implementation IupTargetDropAssociatedData
 
-/*
-- (instancetype) init
-{
-	self = [super init];
-	if(nil != self)
-	{
-	
-	}
-	return self;
-}
-*/
-
 - (void) dealloc
 {
-	[self setDropRegisteredTypes:nil];
-	[self setIhandle:NULL];
-	[self setDropTargetEnabled:false];
-	[self setMainView:nil];
-	[self setRootView:nil];
-	[super dealloc];
+  [self setDropRegisteredTypes:nil];
+  [self setIhandle:NULL];
+  [self setDropTargetEnabled:false];
+  [self setMainView:nil];
+  [self setRootView:nil];
+  [super dealloc];
 }
 
-/*
-- (IupTargetDropAssociatedData*) iupTargetDropAssociatedData
-{
-	Ihandle* ih = [self ihandle];
-	
-	IupTargetDropAssociatedData* associated_data = (IupTargetDropAssociatedData*)objc_getAssociatedObject((id)ih->handle, IUPTARGETDROP_ASSOCIATED_OBJ_KEY);
+@end
 
-	return associated_data;
-}
-*/
-int cocoaTargetDropBasePerformDropCallback(Ihandle* ih, id<NSDraggingInfo> the_sender, NSPasteboard* paste_board, NSPoint drop_point)
+NSDragOperation cocoaTargetDropBaseDraggingUpdated(Ihandle* ih, id<NSDraggingInfo> the_sender)
 {
+  IFniis cbDropMotion = (IFniis)IupGetCallback(ih, "DROPMOTION_CB");
+  if(cbDropMotion)
+  {
+    IupTargetDropAssociatedData* associated_data = cocoaTargetDropGetAssociatedData(ih);
+    NSView* main_view = [associated_data mainView];
+    if (!main_view)
+    {
+      return NSDragOperationNone;
+    }
 
-//	NSPasteboard* paste_board = [the_sender draggingPasteboard];
-//	NSPoint drop_point = [the_sender draggingLocation];
-//	NSPoint converted_point = [self convertPoint:drop_point fromView:nil];
+    NSWindow* the_window = [main_view window];
+    NSPoint screen_point = [the_sender draggingLocation];
+    NSRect screen_rect = NSMakeRect(screen_point.x, screen_point.y, 0, 0);
+    NSRect window_rect = [the_window convertRectFromScreen:screen_rect];
+    NSPoint window_point = window_rect.origin;
+    NSPoint view_point = [main_view convertPoint:window_point fromView:nil];
 
-	IFnsViii drop_data_callback = (IFnsViii)IupGetCallback(ih, "DROPDATA_CB");
-	if(NULL == drop_data_callback)
-	{
-		return 0;
-	}
+    if (![main_view isFlipped])
+    {
+      NSRect view_bounds = [main_view bounds];
+      view_point.y = view_bounds.size.height - view_point.y;
+    }
 
-	IupTargetDropAssociatedData* associated_data = cocoaTargetDropGetAssociatedData(ih);
-	NSArray* drop_types = [associated_data dropRegisteredTypes];
+    char status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
 
-//	NSInteger number_of_files = [the_sender numberOfValidItemsForDrop];
+    NSEventModifierFlags modifier_flags = [[NSApp currentEvent] modifierFlags];
+    if (modifier_flags & NSEventModifierFlagShift)
+      iupKEY_SETSHIFT(status);
+    if (modifier_flags & NSEventModifierFlagControl)
+      iupKEY_SETCONTROL(status);
+    if (modifier_flags & NSEventModifierFlagOption)
+      iupKEY_SETALT(status);
+    if (modifier_flags & NSEventModifierFlagCommand)
+      iupKEY_SETSYS(status);
 
-//	NSString* best_type = [paste_board availableTypeFromArray:drop_types];
+    if (CGEventSourceButtonState(kCGEventSourceStateHIDSystemState, kCGMouseButtonLeft))
+      iupKEY_SETBUTTON1(status);
+    if (CGEventSourceButtonState(kCGEventSourceStateHIDSystemState, kCGMouseButtonRight))
+      iupKEY_SETBUTTON3(status);
+    if (CGEventSourceButtonState(kCGEventSourceStateHIDSystemState, kCGMouseButtonCenter))
+      iupKEY_SETBUTTON2(status);
 
+    cbDropMotion(ih, (int)view_point.x, (int)view_point.y, status);
 
-/* Classes in the provided array must implement the NSPasteboardReading protocol.
-	Cocoa classes that implement this protocol include NSImage, NSString, NSURL, NSColor, NSAttributedString, and NSPasteboardItem.
-	For every item on the pasteboard, each class in the provided array will be
-	queried for the types it can read using -readableTypesForPasteboard:.
-	An instance will be created of the first class found in the provided array
-	whose readable types match a conforming type contained in that pasteboard item.
-	Any instances that could be created from pasteboard item data is returned to the caller.
-    Additional options, such as restricting the search to file URLs with particular content types,
-    can be specified with an options dictionary.  See the comments for the option keys for a full description.
-	Returns nil if there is an error in retrieving the requested items from the pasteboard
-	or if no objects of the specified types can be created.
+    return [the_sender draggingSourceOperationMask];
+  }
 
-	Example: there are five items on the pasteboard, two contain TIFF data, two contain RTF data, one contains a private data type.  Calling -readObjectsForClasses: with just the NSImage class, will return an array containing two image objects.  Calling with just the NSAttributedString class, will return an array containing two attributed strings.  Calling with both classes will return two image objects and two attributed strings.  Note that in the above examples, the count of objects returned is less than the number of items on the pasteboard.  Only objects of the requested classes are returned.  You can always ensure to receive one object per item on the pasteboard by including the NSPasteboardItem class in the array of classes.  In this example, an array containing the NSImage, NSAttributedString, and NSSPasteboardItem classes will return an array with two images, two attributed strings, and one pasteboard item containing the private data type.
-*/
-	NSMutableArray* acceptable_classes = [NSMutableArray arrayWithCapacity:[drop_types count]];
-//	NSArray* file_promise_types = [NSFilePromiseReceiver readableDraggedTypes];
-	for(NSString* type_name in drop_types)
-	{
-	
-		// Special case: Look for FILEPROMISE and replace with the real values.
-		// UPDATE: I do not know how to make this work and I have not actually hit this case.
-		// I am disabling for noww.
-/*
-		BOOL is_file_promise = [file_promise_types containsObject:type_name];
-		if(is_file_promise)
-		{
-			// This case needs to come before the file-url case.
-			[acceptable_classes addObject:[NSFilePromiseReceiver class]];
-			continue;
-		}
-*/
-		
-		if([type_name isEqualToString:NSPasteboardTypeString])
-		{
-//			[acceptable_classes addObject:[NSAttributedString class]];
-			[acceptable_classes addObject:[NSString class]];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeTIFF])
-		{
-			[acceptable_classes addObject:[NSImage class]];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypePNG])
-		{
-			[acceptable_classes addObject:[NSImage class]];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRTF])
-		{
-			[acceptable_classes addObject:[NSAttributedString class]];
-//			[acceptable_classes addObject:[NSString class]];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRTFD])
-		{
-			[acceptable_classes addObject:[NSAttributedString class]];
-//			[acceptable_classes addObject:[NSString class]];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeHTML])
-		{
-			[acceptable_classes addObject:[NSAttributedString class]];
-//			[acceptable_classes addObject:[NSString class]];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeTextFinderOptions])
-		{
-			[acceptable_classes addObject:[NSURL class]];
-		}
-		else if([type_name isEqualToString:kCompatNSPasteboardTypeURL])
-		{
-			[acceptable_classes addObject:[NSURL class]];
-		}
-		else if([type_name isEqualToString:kCompatNSPasteboardTypeFileURL])
-		{
-			[acceptable_classes addObject:[NSURL class]];
-		}
-		else
-		{
-			[acceptable_classes addObject:[NSPasteboardItem class]];
-		}
-	}
-	
-	// Grrr. There is a complication with choosing the "best" type.
-	// I need to use NSPasteboardItem to handle custom types (and maybe fonts).
-	// But if it comes in order before the built-in types,
-	// the built-in types will be pre-empted and become a NSPasteboardItem.
-	// For example, I have a custom type at the beginning (highest priority).
-	// I drop a file-url onto the the target.
-	// Instead of getting the [NSURL class], I get the NSPasteboardItem.
-	// But if the item was at the end of the array, I would have gotten the [NSURL class].
-	// This seems messier than it should be.
+  return [the_sender draggingSourceOperationMask];
+}
 
-	/*
-	NSPasteboardTypeString: public.utf8-plain-text
-NSPasteboardTypePDF: com.adobe.pdf
-NSPasteboardTypeTIFF: public.tiff
-NSPasteboardTypePNG: public.png
-NSPasteboardTypeRTF: public.rtf
-NSPasteboardTypeRTFD: com.apple.flat-rtfd
-NSPasteboardTypeHTML: public.html
-NSPasteboardTypeTabularText: public.utf8-tab-separated-values-text
-NSPasteboardTypeFont: com.apple.cocoa.pasteboard.character-formatting
-NSPasteboardTypeRuler: com.apple.cocoa.pasteboard.paragraph-formatting
-NSPasteboardTypeColor: com.apple.cocoa.pasteboard.color
-NSPasteboardTypeSound: com.apple.cocoa.pasteboard.sound
-NSPasteboardTypeMultipleTextSelection: com.apple.cocoa.pasteboard.multiple-text-selection
-NSPasteboardTypeTextFinderOptions: com.apple.cocoa.pasteboard.find-panel-search-options
-NSPasteboardTypeURL: public.url
-NSPasteboardTypeFileURL: public.file-url
-*/
-//- (nullable NSArray *)readObjectsForClasses:(NSArray<Class> *)classArray options:(nullable NSDictionary<NSPasteboardReadingOptionKey, id> *)options NS_AVAILABLE_MAC(10_6);
+/* Helper to convert NSFont to an IUP font string, preserving style. */
+static NSString* iupcocoaGetFontStringFromFont(NSFont* ns_font)
+{
+  if (!ns_font)
+  {
+    return @"";
+  }
 
-	NSArray* acceptable_drop_items = [paste_board readObjectsForClasses:acceptable_classes options:nil];
+  NSFontManager* font_manager = [NSFontManager sharedFontManager];
+  NSFontTraitMask traits = [font_manager traitsOfFont:ns_font];
 
-	IFni drop_data_begin_callback = (IFni)IupGetCallback(ih, "DROPDATABEGIN_CB");
-	if(NULL != drop_data_begin_callback)
-	{
-		drop_data_begin_callback(ih, (int)[acceptable_drop_items count]);
-	}
+  NSMutableString* style_string = [NSMutableString string];
+  if ((traits & NSBoldFontMask))
+  {
+    [style_string appendString:@"Bold "];
+  }
+  if ((traits & NSItalicFontMask))
+  {
+    [style_string appendString:@"Italic "];
+  }
 
+  /* Trim trailing space */
+  NSString* final_style = [style_string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
 
-	for(id drop_item in acceptable_drop_items)
-	{
-//		NSLog(@"drop_item:%@", drop_item);
-		
-		int ret_val = 0;
-		
-		if([drop_item isKindOfClass:[NSImage class]])
-		{
-			NSImage* ns_image = (NSImage*)drop_item;
-			int w;
-			int h;
-			int bpp;
-			iupdrvImageGetInfo(ns_image,&w, &h, &bpp);
-			int bytes_per_row = iupCocoaImageCaluclateBytesPerRow(w, bpp/8);
-			size_t buffer_size = bytes_per_row*h;
-			unsigned char* img_data = malloc(buffer_size);
-			iupdrvImageGetData(ns_image, img_data);
-			char type_string[1024];
-			snprintf(type_string, 1024, "IMAGE %d %d %d", w, h, bpp);
-			ret_val = drop_data_callback(ih, type_string, (char*)img_data, (int)buffer_size, drop_point.x, drop_point.y);
+  NSString* family_name = [ns_font familyName];
+  double point_size = [ns_font pointSize];
 
-			free(img_data);
-		}
-/*
-		else if([drop_item isKindOfClass:[NSFilePromiseReceiver class]])
-		{
-			NSFilePromiseReceiver* file_promise_receiver = (NSFilePromiseReceiver*)drop_item;
-			// WWDC 2018 Session 505 says to call this.
-			// But I don't know what URL to use.
-			// Example: I want to paste from our app to create/paste a file into the Finder.
-			// I don't have sandbox permissions.
-			// I don't think code works.
-			// And I have not seen this case ever hit.
-			NSURL* ns_url = [NSURL fileURLWithPath:@"MyFile"];
-			[file_promise_receiver receivePromisedFilesAtDestination:ns_url options:@{} operationQueue:[NSOperationQueue mainQueue] reader:^(NSURL* file_url, NSError* error_or_nil)
-				{
-			
-				}
-			];
-		}
-*/
-		else if([drop_item isKindOfClass:[NSURL class]])
-		{
-			NSURL* ns_url = (NSURL*)drop_item;
-			
-			if([ns_url isFileURL])
-			{
-				NSString* file_url = [ns_url path]; // still has file://
-				const char* file_path = [file_url fileSystemRepresentation];
-				size_t buffer_size = strlen(file_path) + 1;
-				ret_val = drop_data_callback(ih, "FILE", (char*)file_path, (int)buffer_size, drop_point.x, drop_point.y);
-			}
-			else
-			{
-			
-				NSString* ns_string = [ns_url absoluteString];
-				const char* c_str = [ns_string UTF8String];
-				size_t buffer_size = strlen(c_str) + 1;
-				ret_val = drop_data_callback(ih, "URL", (char*)c_str, (int)buffer_size, drop_point.x, drop_point.y);
-			}
-		}
-		else if([drop_item isKindOfClass:[NSString class]])
-		{
-			NSString* ns_string = (NSString*)drop_item;
-			const char* c_str = [ns_string UTF8String];
-			size_t buffer_size = strlen(c_str) + 1;
-			ret_val = drop_data_callback(ih, "TEXT", (char*)c_str, (int)buffer_size, drop_point.x, drop_point.y);
+  if ([final_style length] > 0)
+  {
+    return [NSString stringWithFormat:@"%@, %@ %g", family_name, final_style, point_size];
+  }
+  else
+  {
+    return [NSString stringWithFormat:@"%@, %g", family_name, point_size];
+  }
+}
 
-		}
-		else if([drop_item isKindOfClass:[NSAttributedString class]])
-		{
-			// Not supported.
-		}
-		else if([drop_item isKindOfClass:[NSColor class]])
-		{
-			NSColor* ns_color = (NSColor*)drop_item;
-			NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
-			int r = iupROUND([rgb_color redComponent] * 255.0);
-			int g = iupROUND([rgb_color greenComponent] * 255.0);
-			int b = iupROUND([rgb_color blueComponent] * 255.0);
-			int a = iupROUND([rgb_color alphaComponent] * 255.0);
+int cocoaTargetDropBasePerformDropCallback(Ihandle* ih, id<NSDraggingInfo> the_sender, NSPasteboard* paste_board, NSPoint drop_point)
+{
+  IFnsViii drop_data_callback = (IFnsViii)IupGetCallback(ih, "DROPDATA_CB");
+  IFnsiii drop_files_callback = (IFnsiii)IupGetCallback(ih, "DROPFILES_CB");
 
-			char color_string[20];
-			snprintf(color_string, 20, "%d %d %d %d", r, g, b, a);
+  if(!drop_data_callback && !drop_files_callback)
+  {
+    return 0;
+  }
 
-			size_t buffer_size = strlen(color_string) + 1;
-			ret_val = drop_data_callback(ih, "COLOR", (char*)color_string, (int)buffer_size, drop_point.x, drop_point.y);
-			
-		}
- 		// NSFont is not mentioned as one of the NSPasteboardReading classes, so this might never be called
- 		else if([drop_item isKindOfClass:[NSFont class]])
-		{
-//			NSLog(@"got NSFont1");
-			NSFont* ns_font = (NSFont*)drop_item;
+  IupTargetDropAssociatedData* associated_data = cocoaTargetDropGetAssociatedData(ih);
+  NSArray* drop_types = [associated_data dropRegisteredTypes];
 
-			// FIXME: Does not include style
-			NSString* ns_string = [NSString stringWithFormat:@"%@, %lf", [ns_font fontName], [ns_font pointSize]];
-			const char* c_str = [ns_string UTF8String];
-			size_t buffer_size = strlen(c_str) + 1;
-			ret_val = drop_data_callback(ih, "FONT", (char*)c_str, (int)buffer_size, drop_point.x, drop_point.y);
+  NSView* main_view = [associated_data mainView];
+  NSPoint drop_point_iup = drop_point;
+  if (main_view)
+  {
+    if (![main_view isFlipped])
+    {
+      drop_point_iup.y = [main_view bounds].size.height - drop_point.y;
+    }
+  }
 
-		}
-		else // NSPasteboardItem
-		{
-			NSPasteboardItem* pasteboard_item = (NSPasteboardItem*)drop_item;
+  NSMutableArray* acceptable_classes = [NSMutableArray arrayWithCapacity:[drop_types count]];
+  for(NSString* type_name in drop_types)
+  {
+    if([type_name isEqualToString:NSPasteboardTypeString])
+    {
+      [acceptable_classes addObject:[NSString class]];
+    }
+    else if([type_name isEqualToString:NSPasteboardTypeTIFF] || [type_name isEqualToString:NSPasteboardTypePNG])
+    {
+      [acceptable_classes addObject:[NSImage class]];
+    }
+    else if([type_name isEqualToString:NSPasteboardTypeRTF] || [type_name isEqualToString:NSPasteboardTypeRTFD] || [type_name isEqualToString:NSPasteboardTypeHTML])
+    {
+      [acceptable_classes addObject:[NSAttributedString class]];
+    }
+    else if([type_name isEqualToString:NSPasteboardTypeURL] || [type_name isEqualToString:NSPasteboardTypeFileURL])
+    {
+      [acceptable_classes addObject:[NSURL class]];
+    }
+    else
+    {
+      [acceptable_classes addObject:[NSPasteboardItem class]];
+    }
+  }
 
-			NSString* best_type = [pasteboard_item availableTypeFromArray:drop_types];
-			if(nil == best_type)
-			{
-				continue;
-			}
-			NSData* ns_data = [pasteboard_item dataForType:best_type];
-			if(nil == ns_data)
-			{
-				continue;
-			}
-			
-			// Grrr. There is a complication with choosing the "best" type.
-			// I need to use NSPasteboardItem to handle custom types (and maybe fonts).
-			// But if it comes in order before the built-in types,
-			// the built-in types will be pre-empted and become a NSPasteboardItem.
-			// For example, I have a custom type at the beginning (highest priority).
-			// I drop a file-url onto the the target.
-			// Instead of getting the [NSURL class], I get the NSPasteboardItem.
-			// But if the item was at the end of the array, I would have gotten the [NSURL class].
-			// This seems messier than it should be.
-			// So all the [Foo class] cases above are somewhat redundant with the below.
-			// Maybe I should remove the above cases, but they have been mostly tested already.
+  NSArray* acceptable_drop_items = [paste_board readObjectsForClasses:acceptable_classes options:nil];
 
-			if([best_type isEqualToString:NSPasteboardTypePNG] || [best_type isEqualToString:NSPasteboardTypeTIFF])
-			{
-				NSImage* ns_image = [[[NSImage alloc] initWithData:ns_data] autorelease];
-				
-				int w;
-				int h;
-				int bpp;
-				iupdrvImageGetInfo(ns_image,&w, &h, &bpp);
-				int bytes_per_row = iupCocoaImageCaluclateBytesPerRow(w, bpp/8);
-				size_t buffer_size = bytes_per_row*h;
-				unsigned char* img_data = malloc(buffer_size);
-				iupdrvImageGetData(ns_image, img_data);
-				char type_string[1024];
-				snprintf(type_string, 1024, "IMAGE %d %d %d", w, h, bpp);
-				ret_val = drop_data_callback(ih, type_string, (char*)img_data, (int)buffer_size, drop_point.x, drop_point.y);
+  if(drop_files_callback)
+  {
+    NSMutableArray* file_urls = [NSMutableArray array];
+    for(id drop_item in acceptable_drop_items)
+    {
+      if([drop_item isKindOfClass:[NSURL class]])
+      {
+        NSURL* ns_url = (NSURL*)drop_item;
+        if([ns_url isFileURL])
+        {
+          [file_urls addObject:ns_url];
+        }
+      }
+    }
 
-				free(img_data);
-			}
-			else if([best_type isEqualToString:kCompatNSPasteboardTypeFileURL])
-			{
-				NSString* ns_string = [[[NSString alloc] initWithData:ns_data encoding:NSUTF8StringEncoding] autorelease];
- 				NSURL* ns_url = [[[NSURL alloc] initWithString:ns_string] autorelease];
+    if([file_urls count] > 0)
+    {
+      int total_files = (int)[file_urls count];
+      for(int i = 0; i < total_files; i++)
+      {
+        NSURL* ns_url = file_urls[i];
+        NSString* file_url_string = [ns_url path];
+        const char* file_path = [file_url_string fileSystemRepresentation];
+        if (drop_files_callback(ih, (char*)file_path, total_files - i - 1, (int)drop_point_iup.x, (int)drop_point_iup.y) == IUP_IGNORE)
+        {
+          break;
+        }
+      }
+      return 0;
+    }
+  }
 
-				NSString* file_url = [ns_url path]; // still has file://
-				const char* file_path = [file_url fileSystemRepresentation];
-				size_t buffer_size = strlen(file_path) + 1;
-				ret_val = drop_data_callback(ih, "FILE", (char*)file_path, (int)buffer_size, drop_point.x, drop_point.y);
+  if(!drop_data_callback)
+  {
+    return 0;
+  }
 
-			}
-			else if([best_type isEqualToString:kCompatNSPasteboardTypeURL])
-			{
-				NSString* ns_string = [[[NSString alloc] initWithData:ns_data encoding:NSUTF8StringEncoding] autorelease];
- 				NSURL* ns_url = [[[NSURL alloc] initWithString:ns_string] autorelease];
+  for(id drop_item in acceptable_drop_items)
+  {
+    int ret_val = IUP_DEFAULT;
 
-				NSString* ns_string2 = [ns_url absoluteString];
-				const char* c_str = [ns_string2 UTF8String];
-				size_t buffer_size = strlen(c_str) + 1;
-				ret_val = drop_data_callback(ih, "URL", (char*)c_str, (int)buffer_size, drop_point.x, drop_point.y);
-			}
-			if([best_type isEqualToString:NSPasteboardTypeString]
-				|| [best_type isEqualToString:NSPasteboardTypeHTML]
-				|| [best_type isEqualToString:NSPasteboardTypeTabularText]
-				|| [best_type isEqualToString:NSPasteboardTypeMultipleTextSelection]
-			)
-			{
-				NSString* ns_string = [[[NSString alloc] initWithData:ns_data encoding:NSUTF8StringEncoding] autorelease];
-				const char* c_str = [ns_string UTF8String];
-				size_t buffer_size = strlen(c_str) + 1;
-				ret_val = drop_data_callback(ih, "TEXT", (char*)c_str, (int)buffer_size, drop_point.x, drop_point.y);
+    if([drop_item isKindOfClass:[NSImage class]])
+    {
+      NSImage* ns_image = (NSImage*)drop_item;
+      int w, h, bpp;
+      iupdrvImageGetInfo(ns_image, &w, &h, &bpp);
+      int bytes_per_row = iupcocoaImageCalculateBytesPerRow(w, bpp/8);
+      size_t buffer_size = bytes_per_row * h;
+      unsigned char* img_data = malloc(buffer_size);
+      iupdrvImageGetData(ns_image, img_data);
 
-			}
-			else if([drop_item isKindOfClass:[NSColor class]])
-			{
-				NSColor* ns_color = (NSColor*)[NSUnarchiver unarchiveObjectWithData:ns_data];
-				NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
-				int r = iupROUND([rgb_color redComponent] * 255.0);
-				int g = iupROUND([rgb_color greenComponent] * 255.0);
-				int b = iupROUND([rgb_color blueComponent] * 255.0);
-				int a = iupROUND([rgb_color alphaComponent] * 255.0);
+      char type_string[1024];
+      snprintf(type_string, 1024, "IMAGE %d %d %d", w, h, bpp);
+      ret_val = drop_data_callback(ih, type_string, (void*)img_data, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
 
-				char color_string[20];
-				snprintf(color_string, 20, "%d %d %d %d", r, g, b, a);
+      free(img_data);
+    }
+    else if([drop_item isKindOfClass:[NSURL class]])
+    {
+      NSURL* ns_url = (NSURL*)drop_item;
 
-				size_t buffer_size = strlen(color_string) + 1;
-				ret_val = drop_data_callback(ih, "COLOR", (char*)color_string, (int)buffer_size, drop_point.x, drop_point.y);
-				
-			}
-			if([best_type isEqualToString:NSPasteboardTypeFont])
-			{
-//				NSLog(@"got NSFont2");
-				NSFont* ns_font = (NSFont*)[NSUnarchiver unarchiveObjectWithData:ns_data];
+      if([ns_url isFileURL])
+      {
+        NSString* file_url = [ns_url path];
+        const char* file_path = [file_url fileSystemRepresentation];
+        size_t buffer_size = strlen(file_path) + 1;
+        ret_val = drop_data_callback(ih, "FILE", (void*)file_path, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+      else
+      {
+        NSString* ns_string = [ns_url absoluteString];
+        const char* c_str = [ns_string UTF8String];
+        size_t buffer_size = strlen(c_str) + 1;
+        ret_val = drop_data_callback(ih, "URL", (void*)c_str, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+    }
+    else if([drop_item isKindOfClass:[NSString class]])
+    {
+      NSString* ns_string = (NSString*)drop_item;
+      const char* c_str = [ns_string UTF8String];
+      size_t buffer_size = strlen(c_str) + 1;
+      ret_val = drop_data_callback(ih, "TEXT", (void*)c_str, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+    }
+    else if([drop_item isKindOfClass:[NSColor class]])
+    {
+      NSColor* ns_color = (NSColor*)drop_item;
+      NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
+      int r = iupROUND([rgb_color redComponent] * 255.0);
+      int g = iupROUND([rgb_color greenComponent] * 255.0);
+      int b = iupROUND([rgb_color blueComponent] * 255.0);
+      int a = iupROUND([rgb_color alphaComponent] * 255.0);
 
-				// FIXME: Does not include style
-				NSString* ns_string = [NSString stringWithFormat:@"%@, %lf", [ns_font fontName], [ns_font pointSize]];
-				const char* c_str = [ns_string UTF8String];
-				size_t buffer_size = strlen(c_str) + 1;
-				ret_val = drop_data_callback(ih, "FONT", (char*)c_str, (int)buffer_size, drop_point.x, drop_point.y);
+      char color_string[20];
+      snprintf(color_string, 20, "%d %d %d %d", r, g, b, a);
+      size_t buffer_size = strlen(color_string) + 1;
+      ret_val = drop_data_callback(ih, "COLOR", (void*)color_string, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+    }
+    else if([drop_item isKindOfClass:[NSFont class]])
+    {
+      NSFont* ns_font = (NSFont*)drop_item;
+      NSString* ns_string = iupcocoaGetFontStringFromFont(ns_font);
+      const char* c_str = [ns_string UTF8String];
+      size_t buffer_size = strlen(c_str) + 1;
+      ret_val = drop_data_callback(ih, "FONT", (void*)c_str, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+    }
+    else
+    {
+      NSPasteboardItem* pasteboard_item = (NSPasteboardItem*)drop_item;
+      NSString* best_type = [pasteboard_item availableTypeFromArray:drop_types];
+      if(nil == best_type)
+      {
+        continue;
+      }
 
-			}
-			else
-			{
-				const void* data_buffer = [ns_data bytes];
-				NSUInteger buffer_size = [ns_data length];
-				const char* c_type_str = [best_type UTF8String];
-				ret_val = drop_data_callback(ih, (char*)c_type_str, (char*)data_buffer, (int)buffer_size, drop_point.x, drop_point.y);
-			}
+      NSData* ns_data = [pasteboard_item dataForType:best_type];
+      if(nil == ns_data)
+      {
+        continue;
+      }
 
-		}
-		
-		
-	}
-	
-	Icallback drop_data_end_callback = (Icallback)IupGetCallback(ih, "DROPDATAEND_CB");
-	if(NULL != drop_data_end_callback)
-	{
-		drop_data_end_callback(ih);
-	}
+      if([best_type isEqualToString:NSPasteboardTypePNG] || [best_type isEqualToString:NSPasteboardTypeTIFF])
+      {
+        NSImage* ns_image = [[[NSImage alloc] initWithData:ns_data] autorelease];
+        int w, h, bpp;
+        iupdrvImageGetInfo(ns_image,&w, &h, &bpp);
+        int bytes_per_row = iupcocoaImageCalculateBytesPerRow(w, bpp/8);
+        size_t buffer_size = bytes_per_row*h;
+        unsigned char* img_data = malloc(buffer_size);
+        iupdrvImageGetData(ns_image, img_data);
 
-	
-	// Should I auto-update, or require the user to call IupUpdate?
-	// Only they know for sure if a redraw is actually needed.
-	// [main_view setNeedsDisplay];
-	
-	return 0;
+        char type_string[1024];
+        snprintf(type_string, 1024, "IMAGE %d %d %d", w, h, bpp);
+        ret_val = drop_data_callback(ih, type_string, (void*)img_data, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+        free(img_data);
+      }
+      else if([best_type isEqualToString:NSPasteboardTypeFileURL])
+      {
+        NSString* ns_string = [[[NSString alloc] initWithData:ns_data encoding:NSUTF8StringEncoding] autorelease];
+        NSURL* ns_url = [[[NSURL alloc] initWithString:ns_string] autorelease];
+        NSString* file_url = [ns_url path];
+        const char* file_path = [file_url fileSystemRepresentation];
+        size_t buffer_size = strlen(file_path) + 1;
+        ret_val = drop_data_callback(ih, "FILE", (void*)file_path, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+      else if([best_type isEqualToString:NSPasteboardTypeURL])
+      {
+        NSString* ns_string = [[[NSString alloc] initWithData:ns_data encoding:NSUTF8StringEncoding] autorelease];
+        NSURL* ns_url = [[[NSURL alloc] initWithString:ns_string] autorelease];
+        NSString* ns_string2 = [ns_url absoluteString];
+        const char* c_str = [ns_string2 UTF8String];
+        size_t buffer_size = strlen(c_str) + 1;
+        ret_val = drop_data_callback(ih, "URL", (void*)c_str, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+      else if([best_type isEqualToString:NSPasteboardTypeString] || [best_type isEqualToString:NSPasteboardTypeHTML] ||
+              [best_type isEqualToString:NSPasteboardTypeTabularText] || [best_type isEqualToString:NSPasteboardTypeMultipleTextSelection])
+      {
+        NSString* ns_string = [[[NSString alloc] initWithData:ns_data encoding:NSUTF8StringEncoding] autorelease];
+        const char* c_str = [ns_string UTF8String];
+        size_t buffer_size = strlen(c_str) + 1;
+        ret_val = drop_data_callback(ih, "TEXT", (void*)c_str, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+      else if([best_type isEqualToString:NSPasteboardTypeColor])
+      {
+        NSError* error = nil;
+        NSColor* ns_color = [NSKeyedUnarchiver unarchivedObjectOfClass:[NSColor class] fromData:ns_data error:&error];
+        NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
+        int r = iupROUND([rgb_color redComponent] * 255.0);
+        int g = iupROUND([rgb_color greenComponent] * 255.0);
+        int b = iupROUND([rgb_color blueComponent] * 255.0);
+        int a = iupROUND([rgb_color alphaComponent] * 255.0);
+
+        char color_string[20];
+        snprintf(color_string, 20, "%d %d %d %d", r, g, b, a);
+        size_t buffer_size = strlen(color_string) + 1;
+        ret_val = drop_data_callback(ih, "COLOR", (void*)color_string, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+      else if([best_type isEqualToString:NSPasteboardTypeFont])
+      {
+        NSError* error = nil;
+        NSFont* ns_font = [NSKeyedUnarchiver unarchivedObjectOfClass:[NSFont class] fromData:ns_data error:&error];
+        NSString* ns_string = iupcocoaGetFontStringFromFont(ns_font);
+        const char* c_str = [ns_string UTF8String];
+        size_t buffer_size = strlen(c_str) + 1;
+        ret_val = drop_data_callback(ih, "FONT", (void*)c_str, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+      else
+      {
+        const void* data_buffer = [ns_data bytes];
+        NSUInteger buffer_size = [ns_data length];
+        const char* c_type_str = [best_type UTF8String];
+        ret_val = drop_data_callback(ih, (char*)c_type_str, (void*)data_buffer, (int)buffer_size, (int)drop_point_iup.x, (int)drop_point_iup.y);
+      }
+    }
+
+    if (ret_val == IUP_IGNORE)
+      break;
+  }
+
+  return 0;
 }
 
-@end
-
 @implementation IupSourceDragAssociatedData
 
-
 - (instancetype) init
 {
-	self = [super init];
-	if(nil != self)
-	{
- 		[self setDefaultFilePromiseName:@"IupDragDrop.iup"];
- 		[self setUseAutoBeginDrag:true];
-	}
-	return self;
+  self = [super init];
+  if(nil != self)
+  {
+    [self setDefaultFilePromiseName:@"IupDragDrop.iup"];
+    [self setUseAutoBeginDrag:true];
+  }
+  return self;
 }
 
-
 - (void) dealloc
 {
-	[self setIhandle:NULL];
-	[self setDragSourceEnabled:false];
-	[self setUseAutoBeginDrag:false];
-	[self setDragRegisteredTypes:nil];
-	[self setUseAutoGenerateDragImage:false];
-	[self setDefaultFilePromiseName:nil];
-	[self setMainView:nil];
-	[self setRootView:nil];
+  [self setIhandle:NULL];
+  [self setDragSourceEnabled:false];
+  [self setUseAutoBeginDrag:false];
+  [self setDragRegisteredTypes:nil];
+  [self setUseAutoGenerateDragImage:false];
+  [self setDefaultFilePromiseName:nil];
+  [self setMainView:nil];
+  [self setRootView:nil];
 
-	[super dealloc];
+  [super dealloc];
 }
 
 - (NSDragOperation) draggingSession:(NSDraggingSession*)dragging_session sourceOperationMaskForDraggingContext:(NSDraggingContext)dragging_context
 {
-    if(NSDraggingContextOutsideApplication == dragging_context)
-    {
-        return NSDragOperationCopy;
-    }
-	
-    // NSDraggingContextWithinApplication
-   	Ihandle* ih = [self ihandle];
-   	// FIXME/TODO:
-   	// 1. The user may need finer grain control on when to set copy or move
-   	// (i.e. which widget is targeted, which key modifier is pressed).
-	// 2. The user may need the other types
-	// e.g. NSDragOperationLink, NSDragOperationNone
-	
-   	bool is_move = iupAttribGetBoolean(ih, "DRAGSOURCEMOVE");
-	if(is_move)
-	{
-		return NSDragOperationMove;
-	}
-	else
-	{
-	    return NSDragOperationCopy;
-	}
+  if(NSDraggingContextOutsideApplication == dragging_context)
+  {
+    return NSDragOperationCopy;
+  }
+
+  Ihandle* ih = [self ihandle];
+  bool is_move = iupAttribGetBoolean(ih, "DRAGSOURCEMOVE");
+  if(is_move)
+  {
+    return NSDragOperationMove | NSDragOperationCopy;
+  }
+  else
+  {
+    return NSDragOperationCopy;
+  }
 }
 
-
 static void cocoaSourceDragProvideDataForTypeDefault(Ihandle* ih, NSPasteboard* paste_board, NSPasteboardItem* pasteboard_item, NSPasteboardType type_name, NSView* main_view, NSView* root_view)
 {
-		if([type_name isEqualToString:NSPasteboardTypeTIFF])
-		{
-			
-			NSRect bounds_rect = [main_view bounds];
-#if 1
-			NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
-			NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
-			[image_data autorelease];
-			NSData* tiff_data = [image_data TIFFRepresentation];
-			[pasteboard_item setData:tiff_data forType:type_name];
-#else
-			// this doesn't work
-			NSBitmapImageRep* bitmap_rep = [main_view bitmapImageRepForCachingDisplayInRect:bounds_rect];
-			NSData* tiff_data = [bitmap_rep representationUsingType:NSBitmapImageFileTypeTIFF properties:@{}];
-			[pasteboard_item setData:tiff_data forType:type_name];
-#endif
+  if([type_name isEqualToString:NSPasteboardTypeTIFF])
+  {
+    NSRect bounds_rect = [main_view bounds];
+    NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
+    NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
+    [image_data autorelease];
+    NSData* tiff_data = [image_data TIFFRepresentation];
+    [pasteboard_item setData:tiff_data forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypePNG])
+  {
+    NSRect bounds_rect = [main_view bounds];
+    NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
+    NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
+    [image_data autorelease];
+    NSData* tiff_data = [image_data TIFFRepresentation];
+    NSBitmapImageRep* bitmap_rep = [[NSBitmapImageRep alloc] initWithData:tiff_data];
+    [bitmap_rep autorelease];
+    NSData* png_rep = [bitmap_rep representationUsingType:NSBitmapImageFileTypePNG properties:@{}];
 
+    [pasteboard_item setData:png_rep forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeRTF] || [type_name isEqualToString:NSPasteboardTypeRTFD])
+  {
+    if([main_view respondsToSelector:@selector(attributedStringValue)])
+    {
+      NSAttributedString* attr_str = [(id)main_view attributedStringValue];
+      NSError* error = nil;
+      NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:attr_str requiringSecureCoding:NO error:&error];
+      if (ns_data)
+        [pasteboard_item setData:ns_data forType:type_name];
+    }
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeHTML])
+  {
+    if([main_view respondsToSelector:@selector(stringValue)])
+    {
+      NSString* ns_string = [(id)main_view stringValue];
+      [pasteboard_item setString:ns_string forType:type_name];
+    }
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeFileURL] || [type_name isEqualToString:NSPasteboardTypeURL])
+  {
+    /* Providing a file or URL requires a string value from the view, which is then converted to a URL. */
+    if([main_view respondsToSelector:@selector(stringValue)])
+    {
+      NSString* ns_str = [(id)main_view stringValue];
+      NSURL* ns_url = [NSURL URLWithString:ns_str];
+      NSData* ns_data = [NSData dataWithContentsOfURL:ns_url];
+      [pasteboard_item setData:ns_data forType:type_name];
+    }
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeTabularText] || [type_name isEqualToString:NSPasteboardTypeString] || [type_name isEqualToString:NSPasteboardTypeMultipleTextSelection])
+  {
+    if([main_view respondsToSelector:@selector(stringValue)])
+    {
+      NSString* ns_string = [(id)main_view stringValue];
+      [pasteboard_item setString:ns_string forType:type_name];
+    }
+  }
+  else if([type_name isEqualToString:NSPasteboardTypePDF])
+  {
+    NSRect bounds_rect = [main_view bounds];
+    NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
+    [pasteboard_item setData:pdf_data forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeColor])
+  {
+    NSColor* the_color = nil;
+    if([main_view respondsToSelector:@selector(color)])
+    {
+      the_color = [(id)main_view color];
+    }
+    else if([main_view respondsToSelector:@selector(foregroundColor)])
+    {
+      the_color = [(id)main_view foregroundColor];
+    }
+    else if([main_view respondsToSelector:@selector(backgroundColor)])
+    {
+      the_color = [(id)main_view backgroundColor];
+    }
 
-//			NSLog(@"Type:%@, value:%@", type_name, pdf_data);
-
-		}
-		else if([type_name isEqualToString:NSPasteboardTypePNG])
-		{
-			NSRect bounds_rect = [main_view bounds];
-			NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
-			NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
-			[image_data autorelease];
-			NSData* tiff_data = [image_data TIFFRepresentation];
-			NSBitmapImageRep* bitmap_rep = [[NSBitmapImageRep alloc] initWithData:tiff_data];
-			[bitmap_rep autorelease];
-			NSData* png_rep = [bitmap_rep representationUsingType:NSBitmapImageFileTypePNG properties:@{}];
-			
-			[pasteboard_item setData:png_rep forType:type_name];
-//			NSLog(@"Type:%@, value:%@", type_name, pdf_data);
-
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRTF])
-		{
-			if([main_view respondsToSelector:@selector(attributedStringValue)])
-			{
-				NSAttributedString* attr_str = [main_view attributedStringValue];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:attr_str];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, attr_str);
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRTFD])
-		{
-			if([main_view respondsToSelector:@selector(attributedStringValue)])
-			{
-				NSAttributedString* attr_str = [main_view attributedStringValue];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:attr_str];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, attr_str);
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeHTML])
-		{
-		/*
-			if([main_view respondsToSelector:@selector(attributedStringValue)])
-			{
-				NSAttributedString* attr_str = [main_view attributedStringValue];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:attr_str];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-				NSLog(@"Type:%@, value:%@", type_name, attr_str);
-			}
-		*/
-			if([main_view respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_string = [main_view stringValue];
-				[pasteboard_item setString:ns_string forType:type_name];
-//				NSLog(@"Type:%@, value:%@", type_name, ns_string);
-			}
-		}
-		// I don't understand what Apple intends this to be.
-		else if([type_name isEqualToString:NSPasteboardTypeTextFinderOptions])
-		{
-#if 0
-			if([self respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_str = [main_view stringValue];
-				NSURL* ns_url = [NSURL URLWithString:ns_str];
-				NSData* ns_data = [NSData dataWithContentsOfURL:ns_url];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, ns_str);
-			}
-#else
-			if([main_view respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_string = [main_view stringValue];
-				[pasteboard_item setString:ns_string forType:type_name];
-//				NSLog(@"Type:%@, value:%@", type_name, ns_string);
-			}
-#endif
-
-		}
-		else if([type_name isEqualToString:kCompatNSPasteboardTypeFileURL])
-		{
-			// This one is extra tricky.
-			// If the user wants to provide a file path, then we get to do the easy thing.
-			// But if the user has data (like an image), and wants to automatically create a file from it,
-			// we have to use the NSFilePromise APIs and require the user to deal with the associated callbacks for that.
-			// But we need to be able to distinguish which case the user wants.
-		
-			if([main_view respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_str = [main_view stringValue];
-				NSURL* ns_url = [NSURL URLWithString:ns_str];
-				NSData* ns_data = [NSData dataWithContentsOfURL:ns_url];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, ns_str);
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeURL])
-		{
-			if([main_view respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_str = [main_view stringValue];
-				NSURL* ns_url = [NSURL URLWithString:ns_str];
-				NSData* ns_data = [NSData dataWithContentsOfURL:ns_url];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, ns_str);
-			}
-
-			
-		}
-
-		else if([type_name isEqualToString:NSPasteboardTypeTabularText])
-		{
-
-			if([main_view respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_string = [main_view stringValue];
-				[pasteboard_item setString:ns_string forType:type_name];
-//				NSLog(@"Type:%@, value:%@", type_name, ns_string);
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeString])
-		{
-			if([main_view respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_string = [main_view stringValue];
-				[pasteboard_item setString:ns_string forType:type_name];
-//				NSLog(@"Type:%@, value:%@", type_name, ns_string);
-			}
-		}
-	
-		else if([type_name isEqualToString:NSPasteboardTypePDF])
-		{
-			NSRect bounds_rect = [main_view bounds];
-			NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
-			[pasteboard_item setData:pdf_data forType:type_name];
-//			NSLog(@"Type:%@, value:%@", type_name, pdf_data);
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeFont])
-		{
-			//
-			NSData* ns_data = [pasteboard_item dataForType:type_name];
-//			NSLog(@"Type:%@, value:%@", type_name, ns_data);
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRuler])
-		{
-			if([main_view respondsToSelector:@selector(attributedStringValue)])
-			{
-				NSAttributedString* attr_str = [main_view attributedStringValue];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:attr_str];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, attr_str);
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeColor])
-		{
-			if([main_view respondsToSelector:@selector(color)])
-			{
-				NSColor* the_color = [main_view color];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:the_color];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, the_color);
-			}
-			else if([main_view respondsToSelector:@selector(foregroundColor)])
-			{
-				NSColor* the_color = [main_view foregroundColor];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:the_color];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, the_color);
-			}
-			else if([main_view respondsToSelector:@selector(backgroundColor)])
-			{
-				NSColor* the_color = [main_view backgroundColor];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:the_color];
-				[pasteboard_item setData:ns_data forType:type_name];
-
-//				NSLog(@"Type:%@, value:%@", type_name, the_color);
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeSound])
-		{
-
-			NSData* ns_data = [pasteboard_item dataForType:type_name];
-//			NSLog(@"Type:%@, value:%@", type_name, ns_data);
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeMultipleTextSelection])
-		{
-			if([main_view respondsToSelector:@selector(stringValue)])
-			{
-				NSString* ns_string = [main_view stringValue];
-				[pasteboard_item setString:ns_string forType:type_name];
-//				NSLog(@"Type:%@, value:%@", type_name, ns_string);
-			}
-		}
-
-		else
-		{
-//			NSData* ns_data = [pasteboard_item dataForType:type_name];
-//			NSLog(@"Type:%@, value:%@", type_name, ns_data);
-		}
-
+    if(the_color)
+    {
+      NSError* error = nil;
+      NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:the_color requiringSecureCoding:NO error:&error];
+      if (ns_data)
+        [pasteboard_item setData:ns_data forType:type_name];
+    }
+  }
 }
 
 static void cocoaSourceDragProvideDataForTypeUser(Ihandle* ih, NSPasteboard* paste_board, NSPasteboardItem* pasteboard_item, NSPasteboardType type_name, NSView* main_view, NSView* root_view, void* data_buffer, int data_size)
 {
+  if([type_name isEqualToString:NSPasteboardTypeTIFF] || [type_name isEqualToString:NSPasteboardTypePNG])
+  {
+    /* For images, the user can provide either an IUP image name or raw image data. */
+    bool found_image = false;
+    NSString* ns_string = [[[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding] autorelease];
+    if(nil != ns_string)
+    {
+      /* Attempt to resolve as an IUP image name first. */
+      const char* c_string = [ns_string UTF8String];
+      NSImage* ns_image = (NSImage*)iupImageGetImage(c_string, ih, 0, NULL);
+      NSBitmapImageRep* bitmap_image = nil;
+      if(ns_image && [[ns_image representations] count] > 0)
+      {
+        bitmap_image = (NSBitmapImageRep*)[[ns_image representations] objectAtIndex:0];
+      }
 
-		if([type_name isEqualToString:NSPasteboardTypeTIFF])
-		{
-			// I'm not thrilled with this, but our options aren't great.
+      if(nil != bitmap_image)
+      {
+        found_image = true;
+        NSData* ns_data_image = nil;
+        if([type_name isEqualToString:NSPasteboardTypePNG])
+        {
+          ns_data_image = [bitmap_image representationUsingType:NSBitmapImageFileTypePNG properties:@{}];
+        }
+        else
+        {
+          ns_data_image = [bitmap_image TIFFRepresentation];
+        }
+        [pasteboard_item setData:ns_data_image forType:type_name];
+      }
+    }
 
-			// In order to construct a usable image, I need not only the pixel data,
-			// but also the width, height, and bit depth.
-			// I would have to invent a new format for the user to provide this information in the buffer, which I don't want to do.
+    if(!found_image)
+    {
+      /* If not a known image name, assume the buffer contains raw TIFF or PNG data. */
+      NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
+      [pasteboard_item setData:ns_data forType:type_name];
+    }
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeRTF] || [type_name isEqualToString:NSPasteboardTypeRTFD])
+  {
+    NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
+    [pasteboard_item setData:ns_data forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeHTML] || [type_name isEqualToString:NSPasteboardTypeTabularText] || [type_name isEqualToString:NSPasteboardTypeString] || [type_name isEqualToString:NSPasteboardTypeMultipleTextSelection])
+  {
+    NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
+    [ns_string autorelease];
+    [pasteboard_item setString:ns_string forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeFileURL])
+  {
+    /* User provides a file path string. */
+    NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
+    [ns_string autorelease];
+    NSURL* ns_url = [NSURL fileURLWithPath:ns_string];
+    NSData* ns_data = [NSData dataWithContentsOfURL:ns_url]; /* This is inefficient but necessary for some contexts. */
+    [pasteboard_item setData:ns_data forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeURL])
+  {
+    /* User provides a URL string. */
+    NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
+    [ns_string autorelease];
+    NSURL* ns_url = [NSURL URLWithString:ns_string];
+    NSData* ns_data = [NSData dataWithContentsOfURL:ns_url];
+    [pasteboard_item setData:ns_data forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypePDF])
+  {
+    NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
+    [pasteboard_item setData:ns_data forType:type_name];
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeFont])
+  {
+    /* WARNING: This relies on passing an Ihandle* as a pointer in the data buffer. */
+    if(data_size >= sizeof(intptr_t))
+    {
+      intptr_t int_ptr_for_iupfont = 0;
+      memcpy(&int_ptr_for_iupfont, data_buffer, sizeof(intptr_t));
+      Ihandle* iup_font = (Ihandle*)int_ptr_for_iupfont;
 
-			// The more robust thing to do is just accept an IupImage which has all this information.
-			// However, the Iup callback interface isn't well designed for this.
-			// So this means the user will need to convert their IupFont Ihandle* to an intptr_t,
-			// write the intptr_t value into the buffer (using sizeof(intptr_t)),
-			// and we have to convert it back to a pointer here.
-			// This will work fine as C99 allows this sort of thing if the platform provides intptr_t.
-			// But those binding from other languages will have to pay special attention here.
+      IupCocoaFont* iup_cocoa_font = iupcocoaGetFont(iup_font);
+      NSFont* cocoa_font = [iup_cocoa_font nativeFont];
+      NSError* error = nil;
+      NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:cocoa_font requiringSecureCoding:NO error:&error];
+      if (ns_data)
+        [pasteboard_item setData:ns_data forType:type_name];
+    }
+  }
+  else if([type_name isEqualToString:NSPasteboardTypeColor])
+  {
+    unsigned char r = 0, g = 0, b = 0, a = 255;
+    int is_valid = iupStrToRGBA(data_buffer, &r, &g, &b, &a);
+    if(1 != is_valid)
+    {
+      is_valid = iupStrToRGB(data_buffer, &r, &g, &b);
+    }
 
+    if(is_valid)
+    {
+      NSColor* the_color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:a/255.0];
+      NSError* error = nil;
+      NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:the_color requiringSecureCoding:NO error:&error];
+      if (ns_data)
+        [pasteboard_item setData:ns_data forType:type_name];
+    }
+  }
+  else /* Handle as custom binary data. */
+  {
+    NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
+    [pasteboard_item setData:ns_data forType:type_name];
+  }
 
-			// Late Entry: Case 1: This is what IupClipboard does. It tries the associated string name for the loaded image.
-			bool found_image = false;
-			NSString* ns_string = [[[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding] autorelease];
-			if(nil != ns_string)
-			{
-				// This is an Iup mapped name, not a file name. So we use UTF8String, not fileSystemRepresentation
-				const char* c_string = [ns_string UTF8String];
-				NSImage* ns_image = (NSImage*)iupImageGetImage(c_string, ih, 0, NULL);
-				NSBitmapImageRep* bitmap_image = nil;
-				if([[ns_image representations] count] > 0)
-				{
-					bitmap_image = (NSBitmapImageRep*)[[ns_image representations] objectAtIndex:0];
-				}
-
-				if(nil != bitmap_image)
-				{
-					found_image = true;
-					
-					NSData* ns_data_image = [bitmap_image TIFFRepresentation];
-					[pasteboard_item setData:ns_data_image forType:type_name];
-				}
-			}
-
-			if(!found_image)
-			{
-			
-				// Because of the IupClipboard 'name' technique, I don't need the IupImage intptr_t hack.
-				// There are things I still kind of like about it, but because the string length above
-				// could be the same as sizeof(intptr_t),
-				// if the name resolution fails for some reason,
-				// we end up in this block and crash on the IupGetInt(iup_image, "WIDTH").
-				// So it is safer to remove this hack.
-/*
-				if(data_size == sizeof(intptr_t))
-				{
-					intptr_t int_ptr_for_iupimage = 0;
-					memcpy(&int_ptr_for_iupimage, data_buffer, sizeof(intptr_t));
-					//NSLog(@"int_ptr_for_iupfont: %zu\n", int_ptr_for_iupfont);
-					Ihandle* iup_image = (Ihandle*)int_ptr_for_iupimage;
-					
-					int height = IupGetInt(iup_image, "WIDTH");
-					int width = IupGetInt(iup_image, "HEIGHT");
-					int bpp = IupGetInt(iup_image, "BPP");
-					const char* pixel_data = IupGetAttribute(iup_image, "WID");
-
-					NSBitmapImageRep* bitmap_image = iupCocoaImageNSBitmapImageRepFromPixels(width, height, bpp, NULL, 0, (unsigned char*)pixel_data);
-					NSData* ns_data_image = [bitmap_image TIFFRepresentation];
-					[pasteboard_item setData:ns_data_image forType:type_name];
-				}
-				else
-				{
-*/
-					// Assume the user has provided a proper TIFF buffer
-					NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-					[pasteboard_item setData:ns_data forType:type_name];
-/*
-				}
-*/
-			}
-
-		}
-		else if([type_name isEqualToString:NSPasteboardTypePNG])
-		{
-			// I'm not thrilled with this, but our options aren't great.
-
-			// In order to construct a usable image, I need not only the pixel data,
-			// but also the width, height, and bit depth.
-			// I would have to invent a new format for the user to provide this information in the buffer, which I don't want to do.
-
-			// The more robust thing to do is just accept an IupImage which has all this information.
-			// However, the Iup callback interface isn't well designed for this.
-			// So this means the user will need to convert their IupFont Ihandle* to an intptr_t,
-			// write the intptr_t value into the buffer (using sizeof(intptr_t)),
-			// and we have to convert it back to a pointer here.
-			// This will work fine as C99 allows this sort of thing if the platform provides intptr_t.
-			// But those binding from other languages will have to pay special attention here.
-			
-			// Late Entry: Case 1: This is what IupClipboard does. It tries the associated string name for the loaded image.
-			bool found_image = false;
-			NSString* ns_string = [[[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding] autorelease];
-			if(nil != ns_string)
-			{
-				// This is an Iup mapped name, not a file name. So we use UTF8String, not fileSystemRepresentation
-				const char* c_string = [ns_string UTF8String];
-				NSImage* ns_image = (NSImage*)iupImageGetImage(c_string, ih, 0, NULL);
-				NSBitmapImageRep* bitmap_image = nil;
-				if([[ns_image representations] count] > 0)
-				{
-					bitmap_image = (NSBitmapImageRep*)[[ns_image representations] objectAtIndex:0];
-				}
-
-				if(nil != bitmap_image)
-				{
-					found_image = true;
-					
-					NSData* ns_data_image = [bitmap_image representationUsingType:NSBitmapImageFileTypePNG properties:@{}];
-					[pasteboard_item setData:ns_data_image forType:type_name];
-				}
-			}
-
-			if(!found_image)
-			{
-				// Because of the IupClipboard 'name' technique, I don't need the IupImage intptr_t hack.
-				// There are things I still kind of like about it, but because the string length above
-				// could be the same as sizeof(intptr_t),
-				// if the name resolution fails for some reason,
-				// we end up in this block and crash on the IupGetInt(iup_image, "WIDTH").
-				// So it is safer to remove this hack.
-/*
-				if(data_size == sizeof(intptr_t))
-				{
-					intptr_t int_ptr_for_iupimage = 0;
-					memcpy(&int_ptr_for_iupimage, data_buffer, sizeof(intptr_t));
-					//NSLog(@"int_ptr_for_iupfont: %zu\n", int_ptr_for_iupfont);
-					Ihandle* iup_image = (Ihandle*)int_ptr_for_iupimage;
-					
-					int height = IupGetInt(iup_image, "WIDTH");
-					int width = IupGetInt(iup_image, "HEIGHT");
-					int bpp = IupGetInt(iup_image, "BPP");
-					const char* pixel_data = IupGetAttribute(iup_image, "WID");
-
-					NSBitmapImageRep* bitmap_image = iupCocoaImageNSBitmapImageRepFromPixels(width, height, bpp, NULL, 0, (unsigned char*)pixel_data);
-					NSData* ns_data_image = [bitmap_image representationUsingType:NSBitmapImageFileTypePNG properties:@{}];
-
-					[pasteboard_item setData:ns_data_image forType:type_name];
-				}
-				else
-				{
-*/
-					// Assume the user has provided a proper PNG buffer
-					NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-					[pasteboard_item setData:ns_data forType:type_name];
-/*
-				}
-*/
-			}
-
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRTF])
-		{
-			// I don't what to do
-			NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-			[pasteboard_item setData:ns_data forType:type_name];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRTFD])
-		{
-			// I don't what to do
-			NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-			[pasteboard_item setData:ns_data forType:type_name];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeHTML])
-		{
-			// I'm guessing the user can enter plain text HTML data (including tags)
-			NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
-			[ns_string autorelease];
-			[pasteboard_item setString:ns_string forType:type_name];
-		}
-		// I don't understand what Apple intends this to be.
-		else if([type_name isEqualToString:NSPasteboardTypeTextFinderOptions])
-		{
-			NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
-			[ns_string autorelease];
-			[pasteboard_item setString:ns_string forType:type_name];
-		}
-		else if([type_name isEqualToString:kCompatNSPasteboardTypeFileURL])
-		{
-			// This one is extra tricky.
-			// If the user wants to provide a file path, then we get to do the easy thing.
-			// But if the user has data (like an image), and wants to automatically create a file from it,
-			// we have to use the NSFilePromise APIs and require the user to deal with the associated callbacks for that.
-			// But we need to be able to distinguish which case the user wants.
-		
-			NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
-			[ns_string autorelease];
-			NSURL* ns_url = [NSURL fileURLWithPath:ns_string];
-			NSData* ns_data = [NSData dataWithContentsOfURL:ns_url];
-			[pasteboard_item setData:ns_data forType:type_name];
-
-		}
-		else if([type_name isEqualToString:kCompatNSPasteboardTypeURL])
-		{
-			NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
-			[ns_string autorelease];
-			NSURL* ns_url = [NSURL URLWithString:ns_string];
-			NSData* ns_data = [NSData dataWithContentsOfURL:ns_url];
-			[pasteboard_item setData:ns_data forType:type_name];
-		}
-
-		else if([type_name isEqualToString:NSPasteboardTypeTabularText])
-		{
-			NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
-			[ns_string autorelease];
-			[pasteboard_item setString:ns_string forType:type_name];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeString])
-		{
-			NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
-			[ns_string autorelease];
-			[pasteboard_item setString:ns_string forType:type_name];
-		}
-	
-		else if([type_name isEqualToString:NSPasteboardTypePDF])
-		{
-			// I don't know what to do. Trust that the user gave me a valid PDF, and that Apple knows what to do with it when put in an NSData?
-			NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-			[pasteboard_item setData:ns_data forType:type_name];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeFont])
-		{
-			// I'm not thrilled with this, but our options aren't great.
-			// Should we support taking an IupFont pointer (check for sizeof pointer)?
-			// Or do we require a string description?
-			
-			// I can try to parse a Iup font string, but at the moment of this writing,
-			// the Iup font string format is pretty lose as each platform can define it slightly differently,
-			// and I haven't really decided if I need to invent a new variation for Cocoa.
-			// The more robust thing to do is just accept an IupFont, so if we change the string format,
-			// this code doesn't need to care.
-			// However, the Iup callback interface isn't well designed for this.
-			// So this means the user will need to convert their IupFont Ihandle* to an intptr_t,
-			// write the intptr_t value into the buffer (using sizeof(intptr_t)),
-			// and we have to convert it back to a pointer here.
-			// This will work fine as C99 allows this sort of thing if the platform provides intptr_t.
-			// But those binding from other languages will have to pay special attention here.
-			
-			if(data_size >= sizeof(intptr_t))
-			{
-				intptr_t int_ptr_for_iupfont = 0;
-				memcpy(&int_ptr_for_iupfont, data_buffer, sizeof(intptr_t));
-				//NSLog(@"int_ptr_for_iupfont: %zu\n", int_ptr_for_iupfont);
-				Ihandle* iup_font = (Ihandle*)int_ptr_for_iupfont;
-				
-				// Get the internal Cocoa representation backing the iup_font
-				IupCocoaFont* iup_cocoa_font = iupCocoaGetFont(iup_font);
-				// Get the native Cocoa representation backing the IupCocoaFont
-				NSFont* cocoa_font = [iup_cocoa_font nativeFont];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:cocoa_font];
-				[pasteboard_item setData:ns_data forType:type_name];
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeRuler])
-		{
-			// I don't know what to do. Maybe somehow integrate with IupText???
-			NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-			[pasteboard_item setData:ns_data forType:type_name];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeColor])
-		{
-			unsigned char r = 0;
-			unsigned char g = 0;
-			unsigned char b = 0;
-			unsigned char a = 0;
-
-			int is_valid = iupStrToRGBA(data_buffer, &r, &g, &b, &a);
-			if(1 != is_valid)
-			{
-				is_valid = iupStrToRGB(data_buffer, &r, &g, &b);
-				a = 255;
-			}
-			if(is_valid)
-			{
-				NSColor* the_color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:a/255.0];
-				NSData* ns_data = [NSKeyedArchiver archivedDataWithRootObject:the_color];
-				[pasteboard_item setData:ns_data forType:type_name];
-			}
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeSound])
-		{
-			// No idea. NSSound doesn't provide APIs for raw PCM data.
-			NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-			[pasteboard_item setData:ns_data forType:type_name];
-		}
-		else if([type_name isEqualToString:NSPasteboardTypeMultipleTextSelection])
-		{
-			NSString* ns_string = [[NSString alloc] initWithBytes:data_buffer length:data_size encoding:NSUTF8StringEncoding];
-			[ns_string autorelease];
-			[pasteboard_item setString:ns_string forType:type_name];
-		}
-
-		else
-		{
-			NSData* ns_data = [NSData dataWithBytes:data_buffer length:data_size];
-			[pasteboard_item setData:ns_data forType:type_name];
-		}
-
 }
 
 - (bool) usesFilePromise
 {
-	Ihandle* ih = [self ihandle];
-	Icallback file_promise_name_callback = IupGetCallback(ih, "DRAGFILECREATENAME_CB");
-	if(nil != file_promise_name_callback)
-	{
-		return true;
-	}
+  Ihandle* ih = [self ihandle];
+  if(IupGetCallback(ih, "DRAGFILECREATENAME_CB"))
+  {
+    return true;
+  }
 
-	// Check to see if the file promise types are in the registered list.
-	NSArray* registered_types = [self dragRegisteredTypes];
-	NSArray* file_promise_types = [NSFilePromiseReceiver readableDraggedTypes];
+  NSArray* registered_types = [self dragRegisteredTypes];
+  NSArray* file_promise_types = [NSFilePromiseReceiver readableDraggedTypes];
+  NSSet* file_promise_set = [NSSet setWithArray:file_promise_types];
 
-	NSSet* file_promise_set = [NSSet setWithArray:file_promise_types];
-	for(NSString* a_type in registered_types)
-	{
-		if([file_promise_set containsObject:a_type])
-		{
-			return true;
-		}
-	}
-	return false;
+  for(NSString* a_type in registered_types)
+  {
+    if([file_promise_set containsObject:a_type])
+    {
+      return true;
+    }
+  }
+  return false;
 }
 
 - (bool) hasFilePromiseCallback
 {
-	Ihandle* ih = [self ihandle];
-	Icallback file_promise_callback = IupGetCallback(ih, "DRAGFILECREATE_CB");
-	return(file_promise_callback);
+  Ihandle* ih = [self ihandle];
+  return (IupGetCallback(ih, "DRAGFILECREATE_CB") != NULL);
 }
 
-
-- (void) pasteboard:(nullable NSPasteboard*)paste_board item:(NSPasteboardItem*)pasteboard_item provideDataForType:(NSPasteboardType)type_name
+- (void) pasteboard:(NSPasteboard*)paste_board item:(NSPasteboardItem*)pasteboard_item provideDataForType:(NSPasteboardType)type_name
 {
-//	NSLog(@"%@, %@, %@", NSStringFromSelector(_cmd), pasteboard_item, type_name);
+  Ihandle* ih = [self ihandle];
+  if(nil == ih)
+  {
+    return;
+  }
 
-	// Because Cocoa
-	// 1. supports so many types
-	// 2. users expect these things to work
-	// 3. Iup lacks equivalent 1-to-1 easily mappable data types to the native Cocoa types
-	// 4. It is extra work to try to handle all these types manually
-	// I am trying to supply a way to automatically handle common cases without user intervention.
-	// So I am going to look at both
-	// 1. whether the user defined a callback
-	// 2. What return value did they hand back.
-	// Depending on these factors, I will call a default routine.
-	// Otherwise, I will try to use their data, but they must supply me data in a particular way depending on the type.
-	Ihandle* ih = [self ihandle];
+  bool use_default_implementation = true;
+  IFnsVi drag_data_callback = (IFnsVi)IupGetCallback(ih, "DRAGDATA_CB");
+  IFns drag_data_size_callback = (IFns)IupGetCallback(ih, "DRAGDATASIZE_CB");
+  void* data_buffer = NULL;
 
+  if(drag_data_callback && drag_data_size_callback)
+  {
+    const char* c_type_name = [type_name UTF8String];
+    int data_size = drag_data_size_callback(ih, (char*)c_type_name);
+    if(data_size > 0)
+    {
+      data_buffer = malloc(data_size);
+      int ret_val = drag_data_callback(ih, (char*)c_type_name, data_buffer, data_size);
 
+      if(IUP_IGNORE == ret_val)
+      {
+        free(data_buffer);
+        data_buffer = NULL;
+      }
+      else if(IUP_CONTINUE == ret_val)
+      {
+        free(data_buffer);
+        data_buffer = NULL;
+        use_default_implementation = true;
+      }
+      else
+      {
+        use_default_implementation = false;
+      }
 
-	// BUG: NSPasteboard copy may invoke pastebord:provideDataForType: on Quit/terminate: if there is lazy data in the clipboard.
-	// But Apple seems to invoke this after this method returns.
-	// But by that point, we have already shutdown IUP and freed a lot of objects, which may lead to a crash in pasteboard:provideDataForType:
-	// Unfortunately, I don't know how to fix this.
-	// We have two options:
-	// 1) Clear out all pasteboard pointers when we tear down everything. But this will prevent the final copy of data being sent to the pasteboard before quit, so the data will not be pastable after this.
-	// 2) Don't call IupClose() in the IupExit callback.
-	// I'm starting to think in the loop redesign,
-	// we should not call IupClose and maybe the platform takes responsbility for calling it.
-	// In the Mac/Cocoa case, I don't think it is necessary to call IupClose at all which might solve this problem.
-	// For now, IupClose is assumed and there is explicit clearing.
-	// The delegate on the NSPasteboardItem is still set because I don't have access to it.
-	// But assuming we don't crash and still reach here, bail out if ih is NULL.
-	if(nil == ih)
-	{
-//		NSLog(@"Warnign: ih is NULL in %@", NSStringFromSelector(_cmd));
-		return;
-	}
-	
-	bool use_default_implementation = true;
-	IFnsVi drag_data_callback = (IFnsVi)IupGetCallback(ih, "DRAGDATA_CB");
-	IFns drag_data_size_callback = (IFns)IupGetCallback(ih, "DRAGDATASIZE_CB");
-	void* data_buffer = NULL;
-	if(drag_data_callback && drag_data_size_callback)
-	{
-		const char* c_type_name = [type_name UTF8String];
-		int data_size = drag_data_size_callback(ih, (char*)c_type_name);
-	    if(data_size > 0)
-	    {
-			data_buffer = malloc(data_size);
-			// fill data
-			int ret_val = drag_data_callback(ih, (char*)c_type_name, data_buffer, data_size);
-			/*
-			Which value should we use to represent what?
-			- For legacy code, most people will probably be returning IUP_DEFAULT already.
-			- Do we assume if they implemented this, this will do the correct thing?
-			- If so, then IUP_DEFAULT should mean use the user's implementation (not the built-in-automatic-default-implementation.
-			- So for the built-in-automatic-default-implementation, that suggests IUP_IGNORE or IUP_CONTINUE.
-			- Do I want to reserve IUP_IGNORE to say skip entirely (i.e. don't do anything)?
-				- It seems like they should avoid registering the data type instead of relying on this,
-				- but maybe there is an edge case???
-			- So if we reserve that, then IUP_CONTINUE would be the logicial remainder. (I don't think IUP_CLOSE makes sense.)
-			*/
-			
-			if(IUP_IGNORE == ret_val)
-			{
-				free(data_buffer);
-				data_buffer = NULL;
-			}
-			else if(IUP_CONTINUE == ret_val)
-			{
-				free(data_buffer);
-				data_buffer = NULL;
-				use_default_implementation = true;
-			}
-			else
-			{
-				use_default_implementation = false;
-			}
-			
-			
-			if(!use_default_implementation)
-			{
-				NSView* main_view = [self mainView];
-				NSView* root_view = [self rootView];
-				cocoaSourceDragProvideDataForTypeUser(ih, paste_board, pasteboard_item, type_name, main_view, root_view, data_buffer, data_size);
+      if(!use_default_implementation)
+      {
+        NSView* main_view = [self mainView];
+        NSView* root_view = [self rootView];
+        cocoaSourceDragProvideDataForTypeUser(ih, paste_board, pasteboard_item, type_name, main_view, root_view, data_buffer, data_size);
 
-				IFns drag_data_end_callback = (IFns)IupGetCallback(ih, "DRAGDATAEND_CB");
-				if(NULL != drag_data_end_callback)
-				{
-					drag_data_end_callback(ih, (char*)c_type_name);
-				}
+        free(data_buffer);
+        data_buffer = NULL;
+      }
+    }
+  }
 
-				free(data_buffer);
-				data_buffer = NULL;
-				return;
-			}
-			else
-			{
-				NSView* main_view = [self mainView];
-				NSView* root_view = [self rootView];
-				cocoaSourceDragProvideDataForTypeDefault(ih, paste_board, pasteboard_item, type_name, main_view, root_view);
-	
-	
-				IFns drag_data_end_callback = (IFns)IupGetCallback(ih, "DRAGDATAEND_CB");
-				if(NULL != drag_data_end_callback)
-				{
-					drag_data_end_callback(ih, (char*)c_type_name);
-				}
-
-				return;
-			}
-
-		}
-		else
-		{
-			// Special case for file promise
-			//IFnsVi drag_data_callback = (IFnsVi)IupGetCallback(ih, "DRAGFILECREATE_CB");
-
-		}
-		
-	}
-	
-
-	NSView* main_view = [self mainView];
-	NSView* root_view = [self rootView];
-	cocoaSourceDragProvideDataForTypeDefault(ih, paste_board, pasteboard_item, type_name, main_view, root_view);
-	
-
+  if(use_default_implementation)
+  {
+    NSView* main_view = [self mainView];
+    NSView* root_view = [self rootView];
+    cocoaSourceDragProvideDataForTypeDefault(ih, paste_board, pasteboard_item, type_name, main_view, root_view);
+  }
 }
 
-
-
 - (NSPasteboardItem*) defaultPasteboardItem
 {
-	IupSourceDragAssociatedData* drag_source_data = self;
+  IupSourceDragAssociatedData* drag_source_data = self;
+  NSArray* registered_types = [drag_source_data dragRegisteredTypes];
 
-	NSArray* registered_types = [drag_source_data dragRegisteredTypes];
-	// Because copy/paste & drag/drop are interconnected, we want to allow this to work for copy/paste even when drag is disabled
-//	if([drag_source_data isDragSourceEnabled] && ([registered_types count] > 0))
-	if([registered_types count] > 0)
-	{
+  if([registered_types count] > 0)
+  {
+    /* NSFilePromiseProvider is used to generate file data on-demand, for example, */
+    /* when dragging an in-memory image to the Finder to create a new file. */
+    bool wants_file_promise = [drag_source_data usesFilePromise];
+    id return_item = nil;
+    if(wants_file_promise)
+    {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+      NSFilePromiseProvider* promise_provider = [[NSFilePromiseProvider alloc] initWithFileType:(NSString*)kUTTypeData delegate:self];
+#pragma clang diagnostic pop
+      [promise_provider autorelease];
+      return_item = promise_provider;
+    }
+    else
+    {
+      NSPasteboardItem* pasteboard_item = [[NSPasteboardItem alloc] init];
+      [pasteboard_item autorelease];
+      [pasteboard_item setDataProvider:drag_source_data forTypes:registered_types];
+      return_item = pasteboard_item;
+    }
+    return return_item;
+  }
+  return nil;
+}
 
-		
-		
-		
-	//		DRAGDATA_CB: request for drag data from source. It is called when the data is dropped.
-//int function(Ihandle* ih, char* type, void* data, int size) [in C]
+- (NSDraggingItem*) defaultDraggingItem
+{
+  IupSourceDragAssociatedData* drag_source_data = self;
+  NSView* main_view = [self mainView];
+  Ihandle* ih = [self ihandle];
 
-		// If not DRAGDATA_CB, try to do automatically?
-		// Else if DRAGDATA_CB, then
-		//	text, let the user fill it out
-		// 		if an image type, do automatically, or force them to provide RGBA? or IupImage?
-		
+  NSDraggingItem* dragging_item = nil;
+  NSPasteboardItem* pasteboard_item = [self defaultPasteboardItem];
 
+  if(nil != pasteboard_item)
+  {
+    dragging_item = [[NSDraggingItem alloc] initWithPasteboardWriter:pasteboard_item];
+    [dragging_item autorelease];
 
+    NSImage* drag_image = nil;
 
-		// We are using the new APIs
-		// https://stackoverflow.com/questions/7243668/nspasteboard-and-simple-custom-data
-		// The downside is that in the drop callback, we can't get the specific original type.
-		// But the major upside is that it allows us to specify multiple possible types for the source,
-		// so the user can drag it onto different things.
-//			[pasteboard_item setDataProvider:drag_source_data forTypes:@[NSPasteboardTypeTIFF, NSPasteboardTypePNG, NSPasteboardTypeFileURL]];
+    bool is_move = iupAttribGetBoolean(ih, "DRAGSOURCEMOVE");
+    char* drag_cursor_name = NULL;
 
+    if (!is_move)
+    {
+      drag_cursor_name = iupAttribGet(ih, "DRAGCURSORCOPY");
+    }
 
-		// I need to use NSFilePromiseProvider to allow generating a file from memory.
-		// Example: I drag an image from Safari to the desktop and it writes out a file.
-		// In this example, the type was a file URL. But there is no actual file URL since the image is loaded in memory from a website.
-		// So using NSFilePromiseProvider, we can get an addition series of callbacks to write a file when needed.
-	
-		bool wants_file_promise = [drag_source_data usesFilePromise];
-		//NSDraggingItem* dragging_item = nil;
-		id return_item = nil;
-		if(wants_file_promise)
-		{
-			//		NSFilePromiseProvider* promise_provider = [[NSFilePromiseProvider alloc] initWithFileType:kUTTypePNG delegate:self];
-			NSFilePromiseProvider* promise_provider = [[NSFilePromiseProvider alloc] initWithFileType:(NSString*)kUTTypeData delegate:self];
-			[promise_provider autorelease];
-//			dragging_item = [[NSDraggingItem alloc] initWithPasteboardWriter:promise_provider];
-//			[dragging_item autorelease];
-			// [promise_provider setDataProvider:drag_source_data forTypes:@[NSPasteboardTypeTIFF, NSPasteboardTypePNG, NSPasteboardTypeFileURL]];
-			// I'm a little worried about this, since NSFilePromiseProvider is not a NSPasteboardItem.
-			// But it seems to work, and I can't figure any other way of doing this.
-			[promise_provider setDataProvider:drag_source_data forTypes:registered_types];
-			return_item = promise_provider;
-		}
-		else
-		{
-			NSPasteboardItem* pasteboard_item = [[NSPasteboardItem alloc] init];
-			[pasteboard_item autorelease];
-			[pasteboard_item setDataProvider:drag_source_data forTypes:registered_types];
-//			dragging_item = [[NSDraggingItem alloc] initWithPasteboardWriter:pasteboard_item];
-//			[dragging_item autorelease];
-			return_item = pasteboard_item;
+    if (!drag_cursor_name)
+    {
+      drag_cursor_name = iupAttribGet(ih, "DRAGCURSOR");
+    }
 
-		}
+    if(drag_cursor_name)
+    {
+      drag_image = (NSImage*)iupImageGetImage(drag_cursor_name, ih, 0, NULL);
+    }
 
+    if(drag_image)
+    {
+      NSRect image_rect = NSMakeRect(0, 0, [drag_image size].width, [drag_image size].height);
+      [dragging_item setDraggingFrame:image_rect contents:drag_image];
+    }
+    else if([drag_source_data useAutoGenerateDragImage])
+    {
+      NSRect bounds_rect = [main_view bounds];
+      NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
+      NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
+      [image_data autorelease];
 
-		
-		// [self beginDraggingSessionWithItems:@[dragging_item, dragging_promise_item] event:the_event source:self];
-
-		return return_item;
-
-	}
-	return nil;
+      [dragging_item setDraggingFrame:bounds_rect contents:image_data];
+    }
+  }
+  return dragging_item;
 }
 
-- (NSDraggingItem*) defaultDraggingItem
+- (NSString *) filePromiseProvider:(NSFilePromiseProvider*)file_promise_provider fileNameForType:(NSString*)file_type
 {
-	IupSourceDragAssociatedData* drag_source_data = self;
-	NSView* main_view = [self mainView];
+  Ihandle* ih = [self ihandle];
+  IFnssi file_promise_name_callback = (IFnssi)IupGetCallback(ih, "DRAGFILECREATENAME_CB");
+  if(NULL == file_promise_name_callback)
+  {
+    return [self defaultFilePromiseName];
+  }
 
-	NSDraggingItem* dragging_item = nil;
-	NSPasteboardItem* pasteboard_item = [self defaultPasteboardItem];
+  char file_buffer[PATH_MAX] = { '\0' };
+  const char* c_file_type = [file_type UTF8String];
+  int ret_val = file_promise_name_callback(ih, (char*)c_file_type, file_buffer, PATH_MAX);
 
-	if(nil != pasteboard_item)
-	{
-		dragging_item = [[NSDraggingItem alloc] initWithPasteboardWriter:pasteboard_item];
-		[dragging_item autorelease];
+  if(IUP_CONTINUE == ret_val)
+  {
+    return [self defaultFilePromiseName];
+  }
 
-
-		if([drag_source_data useAutoGenerateDragImage])
-		{
-			NSRect bounds_rect = [main_view bounds];
-			NSData* pdf_data = [main_view dataWithPDFInsideRect:bounds_rect];
-			NSImage* image_data = [[NSImage alloc] initWithData:pdf_data];
-			[image_data autorelease];
-			
-			//[dragging_item setDraggingFrame:bounds_rect contents:image_data];
-			[dragging_item setDraggingFrame:bounds_rect contents:image_data];
-		}
-		
-		// [self beginDraggingSessionWithItems:@[dragging_item, dragging_promise_item] event:the_event source:self];
-
-		return dragging_item;
-
-	}
-	return nil;
+  return [NSString stringWithUTF8String:file_buffer];
 }
 
-- (NSString *) filePromiseProvider:(NSFilePromiseProvider*)file_promise_provider fileNameForType:(NSString*)file_type
-{
-	Ihandle* ih = [self ihandle];
-	IFnssi file_promise_name_callback = (IFnssi)IupGetCallback(ih, "DRAGFILECREATENAME_CB");
-	if(NULL == file_promise_name_callback)
-	{
-		NSString* default_file_name = [self defaultFilePromiseName];
-		return default_file_name;
-	}
-	
-	char file_buffer[PATH_MAX] = { '\0' };
-	const char* c_file_type = [file_type UTF8String];
-	int ret_val = file_promise_name_callback(ih, (char*)c_file_type, file_buffer, PATH_MAX);
-	
-	// user wants to fallback to default routine
-	if(IUP_CONTINUE == ret_val)
-	{
-		NSString* default_file_name = [self defaultFilePromiseName];
-		return default_file_name;
-	}
-	
-	NSString* ret_string = [NSString stringWithUTF8String:file_buffer];
-	
-	return ret_string;
-//	return @"MyFile123.png";
-}
-
-// TODO: allow optional opt-in for writing files on background thread.
-// User's callback must be thread-safe, which includes any language bindings and VM.
-/*
-- (NSOperationQueue *)operationQueueForFilePromiseProvider:(NSFilePromiseProvider*)filePromiseProvider
-{
-}
-*/
-
 static bool cocoaSourceDragDoDefaultFileCreate(NSFilePromiseProvider* file_promise_provider, NSURL* write_url)
 {
-	// Convention: If userInfo is not nil, then that contains the data we need to write to disk.
-	id the_object = [file_promise_provider userInfo];
-	bool did_handle = false;
-	if(the_object != nil)
-	{
-		did_handle = true;
+  /* Convention: If userInfo contains data, we can use it to write the file. */
+  id the_object = [file_promise_provider userInfo];
+  bool did_handle = false;
+  if(the_object != nil)
+  {
+    did_handle = true;
 
-		if([the_object isKindOfClass:[NSImage class]])
-		{
-			NSImage* the_image = the_object;
-			NSData* tiff_rep = [the_image TIFFRepresentation];
-			NSBitmapImageRep* bitmap_rep = [[NSBitmapImageRep alloc] initWithData:tiff_rep];
-			[bitmap_rep autorelease];
-			NSData* png_rep = [bitmap_rep representationUsingType:NSBitmapImageFileTypePNG properties:@{}];
-			[png_rep writeToURL:write_url atomically:NO];
-		}
-		else if([the_object isKindOfClass:[NSURL class]])
-		{
-			NSURL* ns_url = (NSURL*)the_object;
-			NSString* ns_string = [ns_url absoluteString];
-			[ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
-		}
-		else if([the_object isKindOfClass:[NSAttributedString class]])
-		{
-			NSAttributedString* ns_attributed_string = (NSAttributedString*)the_object;
-			NSData* ns_data = [ns_attributed_string RTFFromRange:NSMakeRange(0, [ns_attributed_string length]) documentAttributes:@{}];
-			[ns_data writeToURL:write_url atomically:NO];
-		}
-		else if([the_object isKindOfClass:[NSString class]])
-		{
-			NSString* ns_string = (NSString*)the_object;
-			[ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
-		}
-		else if([the_object isKindOfClass:[NSData class]])
-		{
-			NSData* ns_data = (NSData*)the_object;
-			[ns_data writeToURL:write_url atomically:NO];
-		}
-		else if([the_object isKindOfClass:[NSFont class]])
-		{
-			NSFont* ns_font = (NSFont*)the_object;
-			// requires 10.13. Probably better to write custom text file any way.
-//			NSData* ns_data = [NSKeyedArchiver archiveRootObject:ns_font requiringSecureCoding:YES error:nil];
-			//+ (BOOL)archiveRootObject:(id)rootObject toFile:(NSString *)path
-			//[ns_data writeToURL:write_url atomically:NO];
-
-			// FIXME: Does not include style
-			NSString* ns_string = [NSString stringWithFormat:@"%@, %lf", [ns_font fontName], [ns_font pointSize]];
-			[ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
-		}
-		else if([the_object isKindOfClass:[NSColor class]])
-		{
-			NSColor* ns_color = (NSColor*)the_object;
-			NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
-			int r = iupROUND([rgb_color redComponent] * 255.0);
-			int g = iupROUND([rgb_color greenComponent] * 255.0);
-			int b = iupROUND([rgb_color blueComponent] * 255.0);
-			int a = iupROUND([rgb_color alphaComponent] * 255.0);
-			NSString* ns_string = [NSString stringWithFormat:@"%d %d %d %d", r, g, b, a];
-			[ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
-		}
-		else
-		{
-			did_handle = false;
-		}
-	}
-	return did_handle;
+    if([the_object isKindOfClass:[NSImage class]])
+    {
+      NSImage* the_image = the_object;
+      NSData* tiff_rep = [the_image TIFFRepresentation];
+      NSBitmapImageRep* bitmap_rep = [[NSBitmapImageRep alloc] initWithData:tiff_rep];
+      [bitmap_rep autorelease];
+      NSData* png_rep = [bitmap_rep representationUsingType:NSBitmapImageFileTypePNG properties:@{}];
+      [png_rep writeToURL:write_url atomically:NO];
+    }
+    else if([the_object isKindOfClass:[NSURL class]])
+    {
+      NSURL* ns_url = (NSURL*)the_object;
+      NSString* ns_string = [ns_url absoluteString];
+      [ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
+    }
+    else if([the_object isKindOfClass:[NSAttributedString class]])
+    {
+      NSAttributedString* ns_attributed_string = (NSAttributedString*)the_object;
+      NSData* ns_data = [ns_attributed_string RTFFromRange:NSMakeRange(0, [ns_attributed_string length]) documentAttributes:@{}];
+      [ns_data writeToURL:write_url atomically:NO];
+    }
+    else if([the_object isKindOfClass:[NSString class]])
+    {
+      NSString* ns_string = (NSString*)the_object;
+      [ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
+    }
+    else if([the_object isKindOfClass:[NSData class]])
+    {
+      NSData* ns_data = (NSData*)the_object;
+      [ns_data writeToURL:write_url atomically:NO];
+    }
+    else if([the_object isKindOfClass:[NSFont class]])
+    {
+      NSFont* ns_font = (NSFont*)the_object;
+      NSString* ns_string = iupcocoaGetFontStringFromFont(ns_font);
+      [ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
+    }
+    else if([the_object isKindOfClass:[NSColor class]])
+    {
+      NSColor* ns_color = (NSColor*)the_object;
+      NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
+      int r = iupROUND([rgb_color redComponent] * 255.0);
+      int g = iupROUND([rgb_color greenComponent] * 255.0);
+      int b = iupROUND([rgb_color blueComponent] * 255.0);
+      int a = iupROUND([rgb_color alphaComponent] * 255.0);
+      NSString* ns_string = [NSString stringWithFormat:@"%d %d %d %d", r, g, b, a];
+      [ns_string writeToURL:write_url atomically:NO encoding:NSUTF8StringEncoding error:nil];
+    }
+    else
+    {
+      did_handle = false;
+    }
+  }
+  return did_handle;
 }
 
-- (void) filePromiseProvider:(NSFilePromiseProvider*)file_promise_provider writePromiseToURL:(NSURL*)write_url completionHandler:(void (^)(NSError * __nullable errorOrNil))completion_handler;
+- (void) filePromiseProvider:(NSFilePromiseProvider*)file_promise_provider writePromiseToURL:(NSURL*)write_url completionHandler:(void (^)(NSError* errorOrNil))completion_handler
 {
-//	NSLog(@"%@, %@", NSStringFromSelector(_cmd), write_url);
-	
+  Ihandle* ih = [self ihandle];
+  IFns file_create_callback = (IFns)IupGetCallback(ih, "DRAGFILECREATE_CB");
 
-#if 0
-	// This doesn't work. File promise provider isn't a NSPasteboardItem.
-	// I don't see any way to fetch an alternative data type from here.
-	// So unfortunately, the user will have to re-implement all that for the file write.
-	NSData* ns_data = [file_promise_provider dataForType:NSPasteboardTypePNG];
-//	NSData* ns_data = [self pasteboard:nil item:file_promise_provider provideDataForType:NSPasteboardTypePNG];
+  if(NULL == file_create_callback)
+  {
+    cocoaSourceDragDoDefaultFileCreate(file_promise_provider, write_url);
+    completion_handler(nil);
+    return;
+  }
 
-	[ns_data writeToURL:write_url atomically:NO];
-#else
+  NSString* file_url = [write_url path];
+  const char* file_path = [file_url fileSystemRepresentation];
+  int ret_val = file_create_callback(ih, (char*)file_path);
 
-	Ihandle* ih = [self ihandle];
-	IFns file_create_callback = (IFns)IupGetCallback(ih, "DRAGFILECREATE_CB");
-	
-	if(NULL == file_create_callback)
-	{
-		cocoaSourceDragDoDefaultFileCreate(file_promise_provider, write_url);
-		completion_handler(nil);
-		return;
-	}
-	
-	NSString* file_url = [write_url path]; // still has file://
-	const char* file_path = [file_url fileSystemRepresentation];
-	// User gets to write the file here.
-	int ret_val = file_create_callback(ih, (char*)file_path);
+  if(IUP_CONTINUE == ret_val)
+  {
+    cocoaSourceDragDoDefaultFileCreate(file_promise_provider, write_url);
+  }
 
-	// user wants to fallback to default routine
-	if(IUP_CONTINUE == ret_val)
-	{
-		cocoaSourceDragDoDefaultFileCreate(file_promise_provider, write_url);
-		completion_handler(nil);
-		return;
-	}
-
-
-#endif
+  completion_handler(nil);
 }
 
-//- (BOOL) ignoreModifierKeysForDraggingSession:(NSDraggingSession *)session;
-
 - (void) draggingSession:(NSDraggingSession*)dragging_session willBeginAtPoint:(NSPoint)screen_point
 {
-//	NSLog(@"%@, %@, %@", NSStringFromSelector(_cmd), dragging_session, NSStringFromPoint(screen_point));
+  /* This method is part of the NSDraggingSource protocol and is called when a drag session begins. */
+  /* At this point, the drag has already been initiated and any pre-drag callbacks */
+  /* (like DRAGBEGIN_CB) should have been called before beginDraggingSessionWithItems. */
+  /* No additional setup is needed here. */
 
-	Ihandle* ih = [self ihandle];
-	IFnii call_back = (IFnii)IupGetCallback(ih, "DRAGBEGIN_CB");
-	if(NULL != call_back)
-	{
-		NSView* main_view = [self mainView];
-		NSWindow* the_window = [main_view window];
-		NSRect screen_rect = NSMakeRect(screen_point.x, screen_point.y, 0, 0);
-		NSRect window_rect = [the_window convertRectFromScreen:screen_rect];
-		
-		NSPoint window_point = window_rect.origin;
-		NSPoint view_point = [main_view convertPoint:window_point fromView:nil];
-		NSRect view_frame = [main_view frame];
-		CGFloat inverted_y = view_frame.size.height - view_point.y;
-		view_point.y = inverted_y;
-		call_back(ih, view_point.x, view_point.y);
-	}
+  (void)dragging_session;
+  (void)screen_point;
 }
-/*
-- (void) draggingSession:(NSDraggingSession*)dragging_session movedToPoint:(NSPoint)screen_point
-{
-//	NSLog(@"%@, %@, %@", NSStringFromSelector(_cmd), dragging_session, NSStringFromPoint(screen_point));
-//	[super draggingSession:dragging_session movedToPoint:screen_point];
-}
-*/
 
 - (void) draggingSession:(NSDraggingSession*)dragging_session endedAtPoint:(NSPoint)screen_point operation:(NSDragOperation)drag_operation
 {
-//	NSLog(@"%@, %@, %@, %d", NSStringFromSelector(_cmd), dragging_session, NSStringFromPoint(screen_point), drag_operation);
-	Ihandle* ih = [self ihandle];
-	IFni call_back = (IFni)IupGetCallback(ih, "DRAGEND_CB");
-	if(NULL != call_back)
-	{
-		NSView* main_view = [self mainView];
-		NSWindow* the_window = [main_view window];
-		NSRect screen_rect = NSMakeRect(screen_point.x, screen_point.y, 0, 0);
-		NSRect window_rect = [the_window convertRectFromScreen:screen_rect];
-		
-		NSPoint window_point = window_rect.origin;
-		NSPoint view_point = [main_view convertPoint:window_point fromView:nil];
-		NSRect view_frame = [main_view frame];
-		CGFloat inverted_y = view_frame.size.height - view_point.y;
-		view_point.y = inverted_y;
-		// action: action performed by the operation (1 = move, 0 = copy, -1 = drag failed or aborted)
-/*
-    NSDragOperationNone		= 0,
-    NSDragOperationCopy		= 1,
-    NSDragOperationLink		= 2,
-    NSDragOperationGeneric	= 4,
-    NSDragOperationPrivate	= 8,
-    NSDragOperationMove		= 16,
-    NSDragOperationDelete	= 32,
-*/
-		int action_val = 0;
-		if(NSDragOperationNone == drag_operation)
-		{
-			action_val = -1;
-		}
-		else if(NSDragOperationCopy == drag_operation)
-		{
-			action_val = 0;
-		}
-		else if(NSDragOperationMove == drag_operation)
-		{
-			action_val = 1;
-		}
-		else
-		{
-			// No idea what to do.
-			action_val = (int)drag_operation;
-		}
-		call_back(ih, action_val);
-	}
+  Ihandle* ih = [self ihandle];
+  IFni call_back = (IFni)IupGetCallback(ih, "DRAGEND_CB");
+  if(NULL != call_back)
+  {
+    /* The action parameter signifies the result of the drag operation. */
+    /* 1 = move, 0 = copy, -1 = drag failed or was aborted. */
+    int action_val = 0;
+    if(NSDragOperationNone == drag_operation)
+    {
+      action_val = -1;
+    }
+    else if(NSDragOperationCopy == drag_operation)
+    {
+      action_val = 0;
+    }
+    else if(NSDragOperationMove == drag_operation)
+    {
+      action_val = 1;
+    }
+    else
+    {
+      /* Unknown or combined operation, report as is. */
+      action_val = (int)drag_operation;
+    }
+    call_back(ih, action_val);
+  }
 }
 
-
 @end
 
 IupTargetDropAssociatedData* cocoaTargetDropCreateAssociatedData(Ihandle* ih, NSView* main_view, NSView* root_view)
 {
-	if(!ih || !ih->handle)
-	{
-		return nil;
-	}
-	IupTargetDropAssociatedData* drag_drop_data = [[IupTargetDropAssociatedData alloc] init];
-	[drag_drop_data autorelease];
-	objc_setAssociatedObject(ih->handle, IUPTARGETDROP_ASSOCIATED_OBJ_KEY, (id)drag_drop_data, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  if(!ih || !ih->handle)
+  {
+    return nil;
+  }
+  IupTargetDropAssociatedData* drag_drop_data = [[IupTargetDropAssociatedData alloc] init];
+  [drag_drop_data autorelease];
+  objc_setAssociatedObject(ih->handle, IUPTARGETDROP_ASSOCIATED_OBJ_KEY, (id)drag_drop_data, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 
-	[drag_drop_data setIhandle:ih];
-	[drag_drop_data setMainView:main_view];
-	[drag_drop_data setRootView:root_view];
-	
-	return drag_drop_data;
+  [drag_drop_data setIhandle:ih];
+  [drag_drop_data setMainView:main_view];
+  [drag_drop_data setRootView:root_view];
+
+  return drag_drop_data;
 }
 
 void cocoaTargetDropDestroyAssociatedData(Ihandle* ih)
 {
-	if(!ih || !ih->handle)
-	{
-		return;
-	}
-	IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
-	[drag_drop_data setIhandle:nil];
-	[drag_drop_data setMainView:nil];
-	[drag_drop_data setRootView:nil];
+  if(!ih || !ih->handle)
+  {
+    return;
+  }
+  IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
+  [drag_drop_data setIhandle:nil];
+  [drag_drop_data setMainView:nil];
+  [drag_drop_data setRootView:nil];
 
-	objc_setAssociatedObject(ih->handle, IUPTARGETDROP_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  objc_setAssociatedObject(ih->handle, IUPTARGETDROP_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 }
 
 IupTargetDropAssociatedData* cocoaTargetDropGetAssociatedData(Ihandle* ih)
 {
-	if(!ih || !ih->handle)
-	{
-		return nil;
-	}
-	IupTargetDropAssociatedData* drag_drop_data = (IupTargetDropAssociatedData*)objc_getAssociatedObject((id)ih->handle, IUPTARGETDROP_ASSOCIATED_OBJ_KEY);
-	return drag_drop_data;
+  if(!ih || !ih->handle)
+  {
+    return nil;
+  }
+  IupTargetDropAssociatedData* drag_drop_data = (IupTargetDropAssociatedData*)objc_getAssociatedObject((id)ih->handle, IUPTARGETDROP_ASSOCIATED_OBJ_KEY);
+  return drag_drop_data;
 }
-/*
-static IupTargetDropAssociatedData* cocoaTargetDropGetOrCreateAssociatedData(Ihandle* ih)
-{
 
-	IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
-	if(nil == drag_drop_data)
-	{
-		drag_drop_data = cocoaTargetDropCreateAssociatedData(ih);
-	}
-	return drag_drop_data;
-}
-*/
-
-static int cocoaTargetDropSetDropTargetAttrib(Ihandle* ih, const char* value)
+static int cocoaTargetDropSetDropTypesAttrib(Ihandle* ih, const char* value)
 {
-//	iupAttribSet(ih, "_IUPCOCOA_DROPTARGET", value);
-	id the_object = ih->handle;
-	IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
-	if(iupStrBoolean(value))
-	{
-		[drag_drop_data setDropTargetEnabled:true];
-		if([the_object respondsToSelector:@selector(registerForDraggedTypes:)])
-		{
-			NSArray* array_of_types = [drag_drop_data dropRegisteredTypes];
-			[the_object registerForDraggedTypes:array_of_types];
-		}
-	}
-	else
-	{
-		[drag_drop_data setDropTargetEnabled:false];
-		if([the_object respondsToSelector:@selector(unregisterDraggedTypes)])
-		{
-			[the_object unregisterDraggedTypes];
-		}
-	}
+  IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
+  id the_object = ih->handle;
 
-	return 0;
+  if(NULL != value)
+  {
+    NSMutableArray* array_of_types = [NSMutableArray array];
+    char value_copy[256];
+    char value_temp1[256];
+    char value_temp2[256];
 
-}
+    strcpy(value_copy, value);
+    while (iupStrToStrStr(value_copy, value_temp1, value_temp2, ',') > 0)
+    {
+      NSString* type_string = [NSString stringWithUTF8String:value_temp1];
+      [array_of_types addObject:type_string];
 
-static int cocoaTargetDropSetDropTypesAttrib(Ihandle* ih, const char* value)
-{
-	
-	IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
-//- (void)registerForDraggedTypes:(NSArray<NSPasteboardType> *)newTypes;
-//- (void)unregisterDraggedTypes;
-	id the_object = ih->handle;
+      if (iupStrEqualNoCase(value_temp2, value_temp1))
+        break;
 
-	if(NULL != value)
-	{
-		NSString* comma_separated_string = [NSString stringWithUTF8String:value];
-		// The Windows version doesn't worry about extra white space, so I won't either.
-		NSArray* array_of_types = [comma_separated_string componentsSeparatedByString:@","];
-		
-		// TODO: Introduce generic strings like TEXT, IMAGE, and map them to the native type, to allow easier cross-platform code.
+      strcpy(value_copy, value_temp2);
+    }
 
-		// Special case: Look for FILEPROMISE and replace with the real values.
-		NSUInteger file_promise_index = [array_of_types indexOfObject:@"FILEPROMISE"];
-		if(NSNotFound != file_promise_index)
-		{
-			NSMutableArray* mutable_array_of_types = [array_of_types mutableCopy];
-			[mutable_array_of_types autorelease];
-			NSRange replace_range = NSMakeRange(file_promise_index, 1);
-			[mutable_array_of_types replaceObjectsInRange:replace_range withObjectsFromArray:[NSFilePromiseReceiver readableDraggedTypes]];
-			array_of_types = mutable_array_of_types;
-		}
+    if ([array_of_types count] > 0)
+    {
+      [drag_drop_data setDropRegisteredTypes:array_of_types];
 
-		[drag_drop_data setDropRegisteredTypes:array_of_types];
+      if([drag_drop_data isDropTargetEnabled])
+      {
+        if([the_object respondsToSelector:@selector(registerForDraggedTypes:)])
+        {
+          [the_object registerForDraggedTypes:array_of_types];
+        }
+      }
+    }
+  }
+  else
+  {
+    if([the_object respondsToSelector:@selector(unregisterDraggedTypes)])
+    {
+      [the_object unregisterDraggedTypes];
+    }
+    [drag_drop_data setDropRegisteredTypes:nil];
+  }
+  return 1;
+}
 
-		if([drag_drop_data isDropTargetEnabled])
-		{
-			if([the_object respondsToSelector:@selector(registerForDraggedTypes:)])
-			{
-				[the_object registerForDraggedTypes:array_of_types];
-			}
-		}
-	}
-	else
-	{
-		if([the_object respondsToSelector:@selector(unregisterDraggedTypes)])
-		{
-			[the_object unregisterDraggedTypes];
-		}
-		[drag_drop_data setDropRegisteredTypes:nil];
-	}
+static int cocoaTargetDropSetDropTargetAttrib(Ihandle* ih, const char* value)
+{
+  id the_object = ih->handle;
+  IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
+  if(iupStrBoolean(value))
+  {
+    [drag_drop_data setDropTargetEnabled:true];
+    if([the_object respondsToSelector:@selector(registerForDraggedTypes:)])
+    {
+      NSArray* array_of_types = [drag_drop_data dropRegisteredTypes];
+      if (array_of_types && [array_of_types count] > 0)
+      {
+        [the_object registerForDraggedTypes:array_of_types];
+      }
+    }
+  }
+  else
+  {
+    [drag_drop_data setDropTargetEnabled:false];
+    if([the_object respondsToSelector:@selector(unregisterDraggedTypes)])
+    {
+      [the_object unregisterDraggedTypes];
+    }
+  }
+  return 1;
+}
 
-	return 0;
+static int cocoaSetDropFilesTargetAttrib(Ihandle* ih, const char* value)
+{
+  if (iupStrBoolean(value))
+  {
+    /* Set DROPTYPES to handle files. */
+    cocoaTargetDropSetDropTypesAttrib(ih, (const char*)NSPasteboardTypeFileURL.UTF8String);
+    /* Enable DROPTARGET. */
+    cocoaTargetDropSetDropTargetAttrib(ih, "YES");
+  }
+  else
+  {
+    cocoaTargetDropSetDropTargetAttrib(ih, "NO");
+  }
+  return 1;
 }
 
 static int cocoaSourceDropSetPasteFromPasteboardAttrib(Ihandle* ih, const char* value)
 {
-	bool is_triggered = iupStrBoolean(value);
-	if(!is_triggered)
-	{
-		return 0;
-	}
-	
-	NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
-	// TODO: Provide user a way to change the drop point value for paste (so they can differentiate from a drop if needed)
-	NSPoint drop_point = {0, 0};
+  if(!iupStrBoolean(value))
+  {
+    return 0;
+  }
 
-	IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
-	id sender_object = [drag_drop_data mainView];
-	cocoaTargetDropBasePerformDropCallback(ih, sender_object, paste_board, drop_point);
-	return 0;
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSPoint drop_point = {0, 0}; /* Paste operations have no specific drop point. */
+
+  IupTargetDropAssociatedData* drag_drop_data = cocoaTargetDropGetAssociatedData(ih);
+  id sender_object = [drag_drop_data mainView];
+  cocoaTargetDropBasePerformDropCallback(ih, sender_object, paste_board, drop_point);
+  return 0;
 }
 
-
 IupSourceDragAssociatedData* cocoaSourceDragCreateAssociatedData(Ihandle* ih, NSView* main_view, NSView* root_view)
 {
-	if(!ih || !ih->handle)
-	{
-		return nil;
-	}
-	IupSourceDragAssociatedData* drag_drop_data = [[IupSourceDragAssociatedData alloc] init];
-	[drag_drop_data autorelease];
-	objc_setAssociatedObject(ih->handle, IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY, (id)drag_drop_data, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
-	[drag_drop_data setIhandle:ih];
-	[drag_drop_data setMainView:main_view];
-	[drag_drop_data setRootView:root_view];
-	return drag_drop_data;
+  if(!ih || !ih->handle)
+  {
+    return nil;
+  }
+  IupSourceDragAssociatedData* drag_drop_data = [[IupSourceDragAssociatedData alloc] init];
+  [drag_drop_data autorelease];
+  objc_setAssociatedObject(ih->handle, IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY, (id)drag_drop_data, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  [drag_drop_data setIhandle:ih];
+  [drag_drop_data setMainView:main_view];
+  [drag_drop_data setRootView:root_view];
+  return drag_drop_data;
 }
 
 void cocoaSourceDragDestroyAssociatedData(Ihandle* ih)
 {
-	if(!ih || !ih->handle)
-	{
-		return;
-	}
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	[drag_drop_data setIhandle:nil];
-	[drag_drop_data setMainView:nil];
-	[drag_drop_data setRootView:nil];
+  if(!ih || !ih->handle)
+  {
+    return;
+  }
+  IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
+  [drag_drop_data setIhandle:nil];
+  [drag_drop_data setMainView:nil];
+  [drag_drop_data setRootView:nil];
 
-	objc_setAssociatedObject(ih->handle, IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  objc_setAssociatedObject(ih->handle, IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 }
 
-
 IupSourceDragAssociatedData* cocoaSourceDragGetAssociatedData(Ihandle* ih)
 {
-	if(!ih || !ih->handle)
-	{
-		return nil;
-	}
-	IupSourceDragAssociatedData* drag_drop_data = (IupSourceDragAssociatedData*)objc_getAssociatedObject((id)ih->handle, IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY);
-	return drag_drop_data;
+  if(!ih || !ih->handle)
+  {
+    return nil;
+  }
+  IupSourceDragAssociatedData* drag_drop_data = (IupSourceDragAssociatedData*)objc_getAssociatedObject((id)ih->handle, IUPSOURCEDRAG_ASSOCIATED_OBJ_KEY);
+  return drag_drop_data;
 }
 
-/*
-static IupSourceDragAssociatedData* cocoaSourceDragGetOrCreateAssociatedData(Ihandle* ih)
-{
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	if(nil == drag_drop_data)
-	{
-		drag_drop_data = cocoaSourceDragCreateAssociatedData(ih);
-	}
-	return drag_drop_data;
-}
-*/
-
 static int cocoaSourceDragSetDragSourceAttrib(Ihandle* ih, const char* value)
 {
-//	iupAttribSet(ih, "_IUPCOCOA_DROPTARGET", value);
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	if(iupStrBoolean(value))
-	{
-		[drag_drop_data setDragSourceEnabled:true];
-		/*
-		if([the_object respondsToSelector:@selector(registerForDraggedTypes:)])
-		{
-			NSArray* array_of_types = [drag_drop_data dropRegisteredTypes];
-			[the_object registerForDraggedTypes:array_of_types];
-		}
-		*/
-	}
-	else
-	{
-		[drag_drop_data setDragSourceEnabled:false];
-		/*
-		if([the_object respondsToSelector:@selector(unregisterDraggedTypes)])
-		{
-			[the_object unregisterDraggedTypes];
-		}
-		*/
-	}
-
-	return 0;
-
+  IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
+  if(iupStrBoolean(value))
+  {
+    [drag_drop_data setDragSourceEnabled:true];
+  }
+  else
+  {
+    [drag_drop_data setDragSourceEnabled:false];
+  }
+  return 0;
 }
 
 static int cocoaSourceDragSetDragTypesAttrib(Ihandle* ih, const char* value)
 {
-//	iupAttribSet(ih, "_IUPCOCOA_DROPTARGET", value);
+  IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
+  if(value)
+  {
+    NSMutableArray* array_of_types = [NSMutableArray array];
+    char value_copy[256];
+    char value_temp1[256];
+    char value_temp2[256];
 
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	if(value)
-	{
-		NSString* comma_separated_string = [NSString stringWithUTF8String:value];
-		// The Windows version doesn't worry about extra white space, so I won't either.
-		NSArray* array_of_types = [comma_separated_string componentsSeparatedByString:@","];
-		
-		// TODO: Introduce generic strings like TEXT, IMAGE, and map them to the native type, to allow easier cross-platform code.
+    strcpy(value_copy, value);
+    while (iupStrToStrStr(value_copy, value_temp1, value_temp2, ',') > 0)
+    {
+      NSString* type_string = [NSString stringWithUTF8String:value_temp1];
 
-		// Special case: Look for FILEPROMISE and replace with the real values.
-		NSUInteger file_promise_index = [array_of_types indexOfObject:@"FILEPROMISE"];
-		if(NSNotFound != file_promise_index)
-		{
-			NSMutableArray* mutable_array_of_types = [array_of_types mutableCopy];
-			[mutable_array_of_types autorelease];
-			NSRange replace_range = NSMakeRange(file_promise_index, 1);
-			[mutable_array_of_types replaceObjectsInRange:replace_range withObjectsFromArray:[NSFilePromiseReceiver readableDraggedTypes]];
-			array_of_types = mutable_array_of_types;
-		}
-		
-		[drag_drop_data setDragRegisteredTypes:array_of_types];
+      if ([type_string isEqualToString:@"FILEPROMISE"])
+      {
+        NSArray* file_promise_types = [NSFilePromiseReceiver readableDraggedTypes];
+        [array_of_types addObjectsFromArray:file_promise_types];
+      }
+      else
+      {
+        [array_of_types addObject:type_string];
+      }
 
-	}
-	else
-	{
-		[drag_drop_data setDragRegisteredTypes:nil];
-	}
+      if (iupStrEqualNoCase(value_temp2, value_temp1))
+        break;
 
-	return 0;
+      strcpy(value_copy, value_temp2);
+    }
 
+    if ([array_of_types count] > 0)
+    {
+      [drag_drop_data setDragRegisteredTypes:array_of_types];
+    }
+  }
+  else
+  {
+    [drag_drop_data setDragRegisteredTypes:nil];
+  }
+  return 1;
 }
 
 static int cocoaSourceDragSetDragAutoImageAttrib(Ihandle* ih, const char* value)
 {
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	bool is_enabled = iupStrBoolean(value);
-	[drag_drop_data setUseAutoGenerateDragImage:is_enabled];
-	return 0;
+  IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
+  [drag_drop_data setUseAutoGenerateDragImage:iupStrBoolean(value)];
+  return 0;
 }
+
 char* cocoaSourceDragGetDragAutoImageAttrib(Ihandle* ih)
 {
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	bool is_enabled = [drag_drop_data useAutoGenerateDragImage];
-	return iupStrReturnBoolean(is_enabled);
+  IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
+  return iupStrReturnBoolean([drag_drop_data useAutoGenerateDragImage]);
 }
 
-/*
-static int cocoaSourceDragSetDragWantsFileCreateAttrib(Ihandle* ih, const char* value)
+static int cocoaSourceDragSetAutoInitiateAttrib(Ihandle* ih, const char* value)
 {
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	bool is_enabled = iupStrBoolean(value);
-	[drag_drop_data setWantsFilePromise:is_enabled];
-	return 0;
+  IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
+  [drag_drop_data setUseAutoBeginDrag:iupStrBoolean(value)];
+  return 0;
 }
-*/
 
-
-static int cocoaSourceDragSetAutoBeginDragAttrib(Ihandle* ih, const char* value)
+char* cocoaSourceDragGetAutoInitiateAttrib(Ihandle* ih)
 {
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	bool is_enabled = iupStrBoolean(value);
-	[drag_drop_data setUseAutoBeginDrag:is_enabled];
-	return 0;
+  IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
+  return iupStrReturnBoolean([drag_drop_data useAutoBeginDrag]);
 }
-char* cocoaSourceDragGetAutoBeginDragAttrib(Ihandle* ih)
-{
-	IupSourceDragAssociatedData* drag_drop_data = cocoaSourceDragGetAssociatedData(ih);
-	bool is_enabled = [drag_drop_data useAutoBeginDrag];
-	return iupStrReturnBoolean(is_enabled);
-}
 
-
-// WARNING: This may be unsupportable.
-// The currentEvent may not be the right kind ad will throw an exception when our code tries to call invalid methods for the wrong type.
-// The one reason I think this may work is If-and-only-if the user calls this in the mouseDragged: callback (mouseDown: might also work),
-// then the currentEvent should (I hope) be the event passed to mouseDragged:.
-// If that is true, this should work.
-// But calling anywhere else will probably not work.
-static int cocoaSourceDragSetBeginDragAttrib(Ihandle* ih, const char* value)
+static int cocoaSourceDragSetDragStartAttrib(Ihandle* ih, const char* value)
 {
-	IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
+  int x, y;
 
-	if([drag_source_data isDragSourceEnabled])
-	{
-		NSDraggingItem* dragging_item = [drag_source_data defaultDraggingItem];
+  if (!iupStrToIntInt(value, &x, &y, ','))
+    return 0;
 
-		NSView* main_view = [drag_source_data mainView];
+  IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
+  if (![drag_source_data isDragSourceEnabled])
+    return 0;
 
-		NSEvent* the_event = [[NSApplication sharedApplication] currentEvent];
-		[main_view beginDraggingSessionWithItems:@[dragging_item] event:the_event source:drag_source_data];
-	}
+  NSView* main_view = [drag_source_data mainView];
+  if (!main_view)
+    return 0;
 
-	return 0;
-}
+  IFnii cbDragBegin = (IFnii)IupGetCallback(ih, "DRAGBEGIN_CB");
+  if (cbDragBegin)
+  {
+    if (cbDragBegin(ih, x, y) == IUP_IGNORE)
+      return 0;
+  }
 
+  NSDraggingItem* dragging_item = [drag_source_data defaultDraggingItem];
+  if (!dragging_item)
+    return 0;
 
+  NSPoint view_point = NSMakePoint(x, y);
 
-static int cocoaSourceDragSetCopyToPasteboardAttrib(Ihandle* ih, const char* value)
-{
-	bool is_triggered = iupStrBoolean(value);
-	if(!is_triggered)
-	{
-		return 0;
-	}
-	
-	IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
+  if (![main_view isFlipped])
+  {
+    NSRect view_bounds = [main_view bounds];
+    view_point.y = view_bounds.size.height - y;
+  }
 
-	NSPasteboardItem* pasteboard_item = [drag_source_data defaultPasteboardItem];
-	NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSPoint window_point = [main_view convertPoint:view_point toView:nil];
 
-	[paste_board clearContents];
-	[paste_board writeObjects:@[pasteboard_item]];
-	return 0;
-}
+  NSEvent* the_event = [[NSApplication sharedApplication] currentEvent];
 
+  if (!the_event ||
+      (the_event.type != NSEventTypeLeftMouseDown &&
+       the_event.type != NSEventTypeLeftMouseDragged &&
+       the_event.type != NSEventTypeRightMouseDown &&
+       the_event.type != NSEventTypeRightMouseDragged))
+  {
+    NSWindow* window = [main_view window];
+    if (!window)
+      return 0;
 
-void iupdrvRegisterDragDropAttrib(Iclass* ic)
-{
-  iupClassRegisterCallback(ic, "DRAGBEGIN_CB", "ii");
-  iupClassRegisterCallback(ic, "DRAGEND_CB", "i");
-  iupClassRegisterCallback(ic, "DRAGDATASIZE_CB", "s");
-  iupClassRegisterCallback(ic, "DRAGDATA_CB", "sCi");
-	
-//	  iupClassRegisterCallback(ic, "DROPFILES_CB", "siii");
+    NSTimeInterval timestamp = [[NSProcessInfo processInfo] systemUptime];
 
-  iupClassRegisterCallback(ic, "DROPDATA_CB", "sCiii");
-  iupClassRegisterCallback(ic, "DROPMOTION_CB", "iis"); // This must be
+    the_event = [NSEvent mouseEventWithType:NSEventTypeLeftMouseDragged
+                                   location:window_point
+                              modifierFlags:0
+                                  timestamp:timestamp
+                               windowNumber:[window windowNumber]
+                                    context:nil
+                                eventNumber:0
+                                 clickCount:1
+                                   pressure:1.0];
+  }
 
+  [main_view beginDraggingSessionWithItems:@[dragging_item] event:the_event source:drag_source_data];
 
-  iupClassRegisterAttribute(ic, "DRAGTYPES",  NULL, cocoaSourceDragSetDragTypesAttrib,  NULL, NULL, IUPAF_NO_INHERIT);
+  return 0;
+}
 
-  iupClassRegisterAttribute(ic, "DRAGSOURCE", NULL, cocoaSourceDragSetDragSourceAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "DRAGSOURCEMOVE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+static int cocoaSourceDragSetCopyToPasteboardAttrib(Ihandle* ih, const char* value)
+{
+  if(!iupStrBoolean(value))
+  {
+    return 0;
+  }
 
+  IupSourceDragAssociatedData* drag_source_data = cocoaSourceDragGetAssociatedData(ih);
+  NSArray* registered_types = [drag_source_data dragRegisteredTypes];
 
-	// NEW API:
-  iupClassRegisterAttribute(ic, "DRAGAUTOIMAGE", cocoaSourceDragGetDragAutoImageAttrib, cocoaSourceDragSetDragAutoImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  if (!registered_types || [registered_types count] == 0)
+  {
+    return 0;
+  }
 
-	// EXPERIMENTAL: This may need to exist on a per-widget basis.
-  iupClassRegisterAttribute(ic, "DRAGAUTOINITIATE", cocoaSourceDragGetAutoBeginDragAttrib, cocoaSourceDragSetAutoBeginDragAttrib, "YES", NULL, IUPAF_NO_INHERIT);
+  NSPasteboard* paste_board = [NSPasteboard generalPasteboard];
+  NSPasteboardItem* pasteboard_item = [[NSPasteboardItem alloc] init];
+  [pasteboard_item autorelease];
 
-	// EXPERIMENTAL: May not work because it uses currentEvent
-  iupClassRegisterAttribute(ic, "DRAGINITIATE", NULL, cocoaSourceDragSetBeginDragAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+  [paste_board clearContents];
 
+  for (NSString* type_name in registered_types)
+  {
+    [drag_source_data pasteboard:paste_board item:pasteboard_item provideDataForType:type_name];
+  }
 
-//  iupClassRegisterAttribute(ic, "DRAGFILECREATE", NULL, cocoaSourceDragSetDragWantsFileCreateAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterCallback(ic, "DRAGFILECREATE_CB", "s");
-  iupClassRegisterCallback(ic, "DRAGFILECREATENAME_CB", "ssi");
+  [paste_board writeObjects:@[pasteboard_item]];
+  return 0;
+}
 
+void iupCocoaDestroyDragDrop(Ihandle* ih)
+{
+  if (!ih || !ih->handle)
+    return;
 
-	// Because we may need to create an IupImage in the DRAGDATA_CB, we need a place to free it.
-	// The DRAGEND_CB is less than ideal because it will not fire for copy/paste and it is kind of ambiguous for multiple-drag.
-	// TODO: Need to add to other platforms
-	iupClassRegisterCallback(ic, "DRAGDATAEND_CB", "s");
+  id the_object = ih->handle;
 
+  IupTargetDropAssociatedData* drop_data = cocoaTargetDropGetAssociatedData(ih);
+  if (drop_data && [drop_data isDropTargetEnabled])
+  {
+    if ([the_object respondsToSelector:@selector(unregisterDraggedTypes)])
+    {
+      [the_object unregisterDraggedTypes];
+    }
+  }
 
-	// Because DROPDATA_CB will fire off multiple callbacks if multiple items are dropped at the same time,
-	// we want a way to know when this starts, and how many items there are.
-	// And when the callbacks stop.
-	// The passed number is a hint. If the data type cannot be supported, a callback may skip firing.
-	// Use the DROPDATAEND_CB to know for sure when you are done and don't rely on the count.
-  iupClassRegisterCallback(ic, "DROPDATABEGIN_CB", "i");
-  iupClassRegisterCallback(ic, "DROPDATAEND_CB", "");
+  cocoaTargetDropDestroyAssociatedData(ih);
+  cocoaSourceDragDestroyAssociatedData(ih);
+}
 
+void iupdrvRegisterDragDropAttrib(Iclass* ic)
+{
+  iupClassRegisterCallback(ic, "DRAGBEGIN_CB", "ii");
+  iupClassRegisterCallback(ic, "DRAGDATA_CB", "sVi");
+  iupClassRegisterCallback(ic, "DRAGDATASIZE_CB", "s");
+  iupClassRegisterCallback(ic, "DRAGEND_CB", "i");
+  iupClassRegisterCallback(ic, "DRAGFILECREATE_CB", "s");
+  iupClassRegisterCallback(ic, "DRAGFILECREATENAME_CB", "ssi");
 
-	// Copy & Paste to Clipboard (Pasteboard)
-	// DD is for Drag & Drop.
-	// We need an API that the user can call to invoke/trigger copying or pasting an item.
-	// Since the data mechanisms are driven by the drag and drop implementation, everything else works through the drag & drop after the trigger.
-	iupClassRegisterAttribute(ic, "DRAGCOPY", NULL, cocoaSourceDragSetCopyToPasteboardAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
-	iupClassRegisterAttribute(ic, "DROPPASTE", NULL, cocoaSourceDropSetPasteFromPasteboardAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+  iupClassRegisterCallback(ic, "DROPFILES_CB", "siii");
+  iupClassRegisterCallback(ic, "DROPDATA_CB", "sViii");
+  iupClassRegisterCallback(ic, "DROPMOTION_CB", "iis");
 
+  iupClassRegisterAttribute(ic, "DRAGAUTOIMAGE", cocoaSourceDragGetDragAutoImageAttrib, cocoaSourceDragSetDragAutoImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGAUTOINITIATE", cocoaSourceDragGetAutoInitiateAttrib, cocoaSourceDragSetAutoInitiateAttrib, "YES", NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGCURSOR", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGCURSORCOPY", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGSTART", NULL, cocoaSourceDragSetDragStartAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGSOURCE", NULL, cocoaSourceDragSetDragSourceAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGSOURCEMOVE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGTYPES", NULL, cocoaSourceDragSetDragTypesAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-
+  iupClassRegisterAttribute(ic, "DRAGDROP", NULL, cocoaSetDropFilesTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DROPFILESTARGET", NULL, cocoaSetDropFilesTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "DROPTARGET", NULL, cocoaTargetDropSetDropTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "DROPTYPES",  NULL, cocoaTargetDropSetDropTypesAttrib,  NULL, NULL, IUPAF_NO_INHERIT);
-//  iupClassRegisterAttribute(ic, "DRAGDROP", NULL, cocoaDragDropSetDropFilesTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-//  iupClassRegisterAttribute(ic, "DROPFILESTARGET", NULL, cocoaDragDropSetDropFilesTargetAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DROPTYPES", NULL, cocoaTargetDropSetDropTypesAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-
-
-#if 0
-	NSLog(@"NSPasteboardTypeString: %@", NSPasteboardTypeString);
-	NSLog(@"NSPasteboardTypePDF: %@", NSPasteboardTypePDF);
-	NSLog(@"NSPasteboardTypeTIFF: %@", NSPasteboardTypeTIFF);
-	NSLog(@"NSPasteboardTypePNG: %@", NSPasteboardTypePNG);
-	NSLog(@"NSPasteboardTypeRTF: %@", NSPasteboardTypeRTF);
-	NSLog(@"NSPasteboardTypeRTFD: %@", NSPasteboardTypeRTFD);
-	NSLog(@"NSPasteboardTypeHTML: %@", NSPasteboardTypeHTML);
-	NSLog(@"NSPasteboardTypeTabularText: %@", NSPasteboardTypeTabularText);
-	NSLog(@"NSPasteboardTypeFont: %@", NSPasteboardTypeFont);
-	NSLog(@"NSPasteboardTypeRuler: %@", NSPasteboardTypeRuler);
-	NSLog(@"NSPasteboardTypeColor: %@", NSPasteboardTypeColor);
-	NSLog(@"NSPasteboardTypeSound: %@", NSPasteboardTypeSound);
-	NSLog(@"NSPasteboardTypeMultipleTextSelection: %@", NSPasteboardTypeMultipleTextSelection);
-	NSLog(@"NSPasteboardTypeTextFinderOptions: %@", NSPasteboardTypeTextFinderOptions);
-	NSLog(@"NSPasteboardTypeURL: %@", NSPasteboardTypeURL);
-	NSLog(@"NSPasteboardTypeFileURL: %@", NSPasteboardTypeFileURL);
-
-	for(NSString* file_promise_type in [NSFilePromiseReceiver readableDraggedTypes])
-	{
-		NSLog(@"readableDraggedTypes: %@", file_promise_type);
-	}
-#endif
-
-
-/*
-NSPasteboardTypeString: public.utf8-plain-text
-NSPasteboardTypePDF: com.adobe.pdf
-NSPasteboardTypeTIFF: public.tiff
-NSPasteboardTypePNG: public.png
-NSPasteboardTypeRTF: public.rtf
-NSPasteboardTypeRTFD: com.apple.flat-rtfd
-NSPasteboardTypeHTML: public.html
-NSPasteboardTypeTabularText: public.utf8-tab-separated-values-text
-NSPasteboardTypeFont: com.apple.cocoa.pasteboard.character-formatting
-NSPasteboardTypeRuler: com.apple.cocoa.pasteboard.paragraph-formatting
-NSPasteboardTypeColor: com.apple.cocoa.pasteboard.color
-NSPasteboardTypeSound: com.apple.cocoa.pasteboard.sound
-NSPasteboardTypeMultipleTextSelection: com.apple.cocoa.pasteboard.multiple-text-selection
-NSPasteboardTypeTextFinderOptions: com.apple.cocoa.pasteboard.find-panel-search-options
-NSPasteboardTypeURL: public.url
-NSPasteboardTypeFileURL: public.file-url
-*/
-
-
-	
+  iupClassRegisterAttribute(ic, "DRAGCOPY", NULL, cocoaSourceDragSetCopyToPasteboardAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DROPPASTE", NULL, cocoaSourceDropSetPasteFromPasteboardAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 }
-
Index: src/cocoa/iupcocoa_draw.h
===================================================================
--- src/cocoa/iupcocoa_draw.h	(revision 5971)
+++ src/cocoa/iupcocoa_draw.h	(working copy)
@@ -1,32 +1,34 @@
-#ifndef __IUPCOCOA_DRAWCANVAS_H 
-#define __IUPCOCOA_DRAWCANVAS_H
+/** \file
+ * \brief Cocoa Draw Functions
+ *
+ * See Copyright Notice in "iup.h"
+ */
 
-#include <stdbool.h>
+#ifndef __IUPCOCOA_DRAW_H
+#define __IUPCOCOA_DRAW_H
 
-@class IupCocoaCanvasView;
-@class NSGraphicsContext;
+#include "iup_export.h"
 
+typedef struct _IdrawCanvas IdrawCanvas;
+
 struct _IdrawCanvas
 {
-	CGContextRef cgContext;
-	IupCocoaCanvasView* canvasView;
-	NSGraphicsContext* graphicsContext;
-	Ihandle* ih;
-	
-	CGFloat w, h;
-	bool useNativeFocusRing;
-/*
-	int draw_focus;
-	int focus_x1;
-	int focus_y1;
-	int focus_x2;
-	int focus_y2;
-*/
-	CGFloat clip_x1;
-	CGFloat clip_y1;
-	CGFloat clip_x2;
-	CGFloat clip_y2;
+  Ihandle* ih;
+  NSView* canvasView;
+
+  CGContextRef cgContext;         /* on-screen view context */
+  CGContextRef image_cgContext;   /* off-screen buffer context for drawing */
+  CGLayerRef cgLayer;             /* off-screen buffer layer */
+  int release_context;            /* tracks if we called lockFocus */
+  CGFloat w, h;                   /* canvas size */
+
+  /* clip region */
+  CGFloat clip_x1, clip_y1, clip_x2, clip_y2;
+  int clip_state;                 /* 0=no clip, 1=clip active */
+
+  /* deferred focus rect drawing */
+  int draw_focus;
+  CGFloat focus_x1, focus_y1, focus_x2, focus_y2;
 };
 
-#endif /* __IUPCOCOA_DRAWCANVAS_H */
-
+#endif /* __IUPCOCOA_DRAW_H */
Index: src/cocoa/iupcocoa_draw.m
===================================================================
--- src/cocoa/iupcocoa_draw.m	(revision 5971)
+++ src/cocoa/iupcocoa_draw.m	(working copy)
@@ -1,5 +1,5 @@
 /** \file
- * \brief Draw Functions
+ * \brief Cocoa Draw Functions
  *
  * See Copyright Notice in "iup.h"
  */
@@ -8,11 +8,11 @@
 #include <stdio.h>
 #include <string.h>
 #include <memory.h>
+#include <math.h>
 
-#include <Cocoa/Cocoa.h>
+#import <Cocoa/Cocoa.h>
 
 #include "iup.h"
-
 #include "iup_attrib.h"
 #include "iup_class.h"
 #include "iup_str.h"
@@ -20,256 +20,593 @@
 #include "iup_image.h"
 #include "iup_drvdraw.h"
 #include "iup_draw.h"
+
+#include "iupcocoa_drv.h"
 #include "iupcocoa_draw.h"
-#include "iupcocoa_canvas.h"
 
 
+static CGColorRef iupCocoaDrawCreateColor(long color)
+{
+  unsigned char r = iupDrawRed(color);
+  unsigned char g = iupDrawGreen(color);
+  unsigned char b = iupDrawBlue(color);
+  unsigned char a = iupDrawAlpha(color);
 
+  CGFloat inv_byte = 1.0/255.0;
+  CGColorRef the_color = CGColorCreateGenericRGB(r*inv_byte, g*inv_byte, b*inv_byte, a*inv_byte);
+  CFAutorelease(the_color);
+  return the_color;
+}
 
-static CGColorRef coregraphicsCreateAutoreleasedColor(unsigned char r, unsigned char g, unsigned char b, unsigned a)
+static void iupCocoaSetLineStyle(CGContextRef cg_context, int style)
 {
-	// What color space should I be using?
-	//	CGColorSpaceRef color_space = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
-	
-	CGFloat inv_byte = 1.0/255.0;
-	CGColorRef the_color = CGColorCreateGenericRGB(r*inv_byte, g*inv_byte, b*inv_byte, a*inv_byte);
-	// Requires 10.9, 7.0
-	CFAutorelease(the_color);
-	return the_color;
+  if (style == IUP_DRAW_STROKE || style == IUP_DRAW_FILL)
+  {
+    CGContextSetLineDash(cg_context, 0, NULL, 0);
+  }
+  else if (style == IUP_DRAW_STROKE_DASH)
+  {
+    CGFloat dashes[2] = { 9.0, 3.0 };
+    CGContextSetLineDash(cg_context, 0, dashes, 2);
+  }
+  else if (style == IUP_DRAW_STROKE_DOT)
+  {
+    CGFloat dashes[2] = { 1.0, 2.0 };
+    CGContextSetLineDash(cg_context, 0, dashes, 2);
+  }
+  else if (style == IUP_DRAW_STROKE_DASH_DOT)
+  {
+    CGFloat dashes[4] = { 7.0, 3.0, 1.0, 3.0 };
+    CGContextSetLineDash(cg_context, 0, dashes, 4);
+  }
+  else if (style == IUP_DRAW_STROKE_DASH_DOT_DOT)
+  {
+    CGFloat dashes[6] = { 7.0, 3.0, 1.0, 3.0, 1.0, 3.0 };
+    CGContextSetLineDash(cg_context, 0, dashes, 6);
+  }
 }
 
-static void coregraphicsSetLineStyle(IdrawCanvas* dc, int style)
+IdrawCanvas* iupdrvDrawCreateCanvas(Ihandle* ih)
 {
-	CGContextRef cg_context = dc->cgContext;
+  IdrawCanvas* dc = calloc(1, sizeof(IdrawCanvas));
+  dc->ih = ih;
+  dc->canvasView = iupcocoaGetMainView(ih);
+  dc->release_context = 0;
+  dc->draw_focus = 0;
 
-	if((IUP_DRAW_STROKE == style) || (IUP_DRAW_FILL==style))
-	{
-		CGContextSetLineDash(cg_context, 0, NULL, 0);
-	}
-	else
-	{
-		if(IUP_DRAW_STROKE_DASH == style)
-		{
-			CGFloat dashes[2] = { 6.0, 2.0 };
-			CGContextSetLineDash(cg_context, 0, dashes, 2);
-		}
-		else // DOTS
-		{
-			CGFloat dots[2] = { 2.0, 2.0 };
-			CGContextSetLineDash(cg_context, 0, dots, 2);
-		}
-	}
+  CGRect bounds_rect = [dc->canvasView bounds];
+  dc->w = bounds_rect.size.width;
+  dc->h = bounds_rect.size.height;
+
+  NSGraphicsContext* graphicsContext = [NSGraphicsContext currentContext];
+
+  /* Check if we're inside drawRect (ACTION callback) */
+  if (graphicsContext && [graphicsContext isDrawingToScreen])
+  {
+    /* Inside drawRect - use current graphics context */
+    dc->cgContext = [graphicsContext CGContext];
+    dc->release_context = 0;
+  }
+  else
+  {
+    /* OpenGL canvases don't use IUP's draw buffer - OpenGL manages its own buffers */
+    if (iupAttribGet(ih, "_IUP_GLCONTROLDATA"))
+    {
+      free(dc);
+      return NULL;
+    }
+
+    /* Outside drawRect (e.g., SCROLL_CB) - use persistent buffer */
+    NSBitmapImageRep* buffer = (NSBitmapImageRep*)iupAttribGet(ih, "_IUPCOCOA_CANVAS_BUFFER");
+
+    if (buffer)
+    {
+      /* Check if size changed - recreate buffer if needed */
+      if ([buffer pixelsWide] != (NSInteger)dc->w || [buffer pixelsHigh] != (NSInteger)dc->h)
+      {
+        [buffer release];
+        buffer = nil;
+      }
+    }
+
+    /* Create new buffer if needed */
+    if (!buffer)
+    {
+      buffer = [[NSBitmapImageRep alloc]
+        initWithBitmapDataPlanes:NULL
+        pixelsWide:(NSInteger)dc->w
+        pixelsHigh:(NSInteger)dc->h
+        bitsPerSample:8
+        samplesPerPixel:4
+        hasAlpha:YES
+        isPlanar:NO
+        colorSpaceName:NSCalibratedRGBColorSpace
+        bytesPerRow:0
+        bitsPerPixel:0];
+
+      iupAttribSet(ih, "_IUPCOCOA_CANVAS_BUFFER", (char*)buffer);
+    }
+
+    /* Create graphics context from bitmap with FLIPPED coordinate system
+     * to match the flipped view coordinate system */
+    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
+
+    /* Use proper CGBitmapInfo for RGBA with premultiplied alpha */
+    CGBitmapInfo bitmapInfo = kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big;
+
+    CGContextRef cgContext = CGBitmapContextCreate(
+      [buffer bitmapData],
+      [buffer pixelsWide],
+      [buffer pixelsHigh],
+      [buffer bitsPerSample],
+      [buffer bytesPerRow],
+      colorSpace,
+      bitmapInfo
+    );
+    CGColorSpaceRelease(colorSpace);
+
+    if (!cgContext)
+    {
+      free(dc);
+      return NULL;
+    }
+
+    graphicsContext = [NSGraphicsContext graphicsContextWithCGContext:cgContext flipped:YES];
+
+    [NSGraphicsContext saveGraphicsState];
+    [NSGraphicsContext setCurrentContext:graphicsContext];
+    dc->cgContext = cgContext;
+    dc->release_context = 1;
+  }
+
+  if (!dc->cgContext)
+  {
+    free(dc);
+    iupcocoaLogError("Failed to get CGContextRef for drawing.");
+    return NULL;
+  }
+
+  dc->cgLayer = CGLayerCreateWithContext(dc->cgContext, bounds_rect.size, NULL);
+  dc->image_cgContext = CGLayerGetContext(dc->cgLayer);
+
+  /* Coordinate system handling:
+   * - DIRECT PATH: View is flipped, context is already top-down - no transform needed
+   * - BUFFER PATH: Manually created CGContext is bottom-up - NEEDS Y-flip transform */
+  if (dc->release_context)
+  {
+    /* Buffer path: Apply Y-flip to convert bottom-up CGContext to top-down */
+    CGContextTranslateCTM(dc->image_cgContext, 0.0, dc->h);
+    CGContextScaleCTM(dc->image_cgContext, 1.0, -1.0);
+  }
+
+  CGContextSetLineCap(dc->image_cgContext, kCGLineCapButt);
+  CGContextSetLineJoin(dc->image_cgContext, kCGLineJoinMiter);
+
+  dc->clip_state = 0;
+
+  iupAttribSet(ih, "DRAWDRIVER", "COCOA");
+  return dc;
 }
 
-/*
-I had a bunch of misunderstandings about the relationship between the IupCanvasView and the IdrawCanvas.
-The two are intertwined to some degree.
-The DC needs the CGContext, the width & height, and info about which focus ring to use.
-But the View can get all sorts of notifications like view size changes, user configuration changes, or there could even possibly be OS level events which change the context.
-So I've tried several different ways to keep the objects in-sync with each other.
-I knew that the DC was created later than the View, which caused some syncing issues.
-However, I just discovered that the DC actually gets created and destroyed on every user callback.
-So this means I need to change my approach. The view should never keep a reference to the DC, and everything in the DC should pull on demand from the View.
-Minor optimizations might allow for caching the variables in the DC if it does indeed just go through one frame without any possibility of system interruption (e.g. a singular call inside drawRect:)
-If this is not true, then we will need to always pull from the NSView.
-*/
-IdrawCanvas* iupdrvDrawCreateCanvas(Ihandle* ih)
+void iupdrvDrawKillCanvas(IdrawCanvas* dc)
 {
-	IdrawCanvas* dc = calloc(1, sizeof(IdrawCanvas));
+  if (!dc) return;
 
+  CGLayerRelease(dc->cgLayer);
 
-	dc->ih = ih;
+  if (dc->release_context)
+  {
+    [NSGraphicsContext restoreGraphicsState];
+    /* Release manually created CGContext for buffer path */
+    if (dc->cgContext)
+    {
+      CGContextRelease(dc->cgContext);
+    }
+  }
 
-	// We'll set the dc directly from here this time, but all other places will set the dc in the IupCanvasView
-	IupCocoaCanvasView* canvas_view =(IupCocoaCanvasView*)ih->handle;
-	CGRect frame_rect = [canvas_view frame];
+  free(dc);
+}
 
-	// Should we retain? It is implied these will outlive our dc, so we shouldn't need to.
-	dc->canvasView = canvas_view;
-	dc->graphicsContext = [canvas_view graphicsContext];
-	dc->cgContext = [canvas_view CGContext];
+void iupdrvDrawUpdateSize(IdrawCanvas* dc)
+{
+  CGRect bounds_rect = [dc->canvasView bounds];
+  CGFloat w = bounds_rect.size.width;
+  CGFloat h = bounds_rect.size.height;
 
-	// [dc->canvasView retain];
-	// [dc->graphicsContext retain];
-	//	CGContextRetain(dc->cgContext);
-	
-	dc->w = frame_rect.size.width;
-	dc->h = frame_rect.size.height;
+  if (w != dc->w || h != dc->h)
+  {
+    dc->w = w;
+    dc->h = h;
 
-//	dc->cgContext = (CGContextRef)IupGetAttribute(ih, "CGCONTEXT");
-//	dc->cgContext = (CGContextRef)IupGetAttribute(ih, "DRAWABLE");
+    iupdrvDrawResetClip(dc);
 
+    CGLayerRelease(dc->cgLayer);
+    dc->cgLayer = CGLayerCreateWithContext(dc->cgContext, bounds_rect.size, NULL);
+    dc->image_cgContext = CGLayerGetContext(dc->cgLayer);
 
+    CGContextSetLineCap(dc->image_cgContext, kCGLineCapButt);
+    CGContextSetLineJoin(dc->image_cgContext, kCGLineJoinMiter);
+  }
+}
 
-	NSCAssert(dc->cgContext != NULL, @"CGContextRef should not be NULL");
+void iupdrvDrawFlush(IdrawCanvas* dc)
+{
+  /* NO transformation needed - view is already flipped, draw layer directly */
+  CGContextDrawLayerAtPoint(dc->cgContext, CGPointZero, dc->cgLayer);
 
-	
-	return dc;
+  if (dc->draw_focus)
+  {
+    /* Only create NSGraphicsContext when focus ring is actually needed */
+    CGRect cocoa_rect = CGRectMake(dc->focus_x1, dc->h - dc->focus_y2 - 1,
+                                   dc->focus_x2 - dc->focus_x1 + 1,
+                                   dc->focus_y2 - dc->focus_y1 + 1);
+    NSGraphicsContext* nsContext = [NSGraphicsContext graphicsContextWithCGContext:dc->cgContext flipped:NO];
+    [NSGraphicsContext saveGraphicsState];
+    [NSGraphicsContext setCurrentContext:nsContext];
+    NSSetFocusRingStyle(NSFocusRingOnly);
+    [[NSBezierPath bezierPathWithRect:cocoa_rect] fill];
+    [NSGraphicsContext restoreGraphicsState];
+
+    dc->draw_focus = 0;
+  }
+
+  CGContextFlush(dc->cgContext);
+
+  /* If drawing to persistent buffer (outside drawRect), trigger widget repaint */
+  if (dc->release_context)
+  {
+    NSBitmapImageRep* buffer = (NSBitmapImageRep*)iupAttribGet(dc->ih, "_IUPCOCOA_CANVAS_BUFFER");
+    if (buffer)
+    {
+      /* Mark buffer as updated so drawRect knows to use it */
+      iupAttribSet(dc->ih, "_IUPCOCOA_BUFFER_DIRTY", "1");
+    }
+
+    /* Trigger widget repaint to copy buffer to screen (in drawRect) */
+    [dc->canvasView setNeedsDisplay:YES];
+  }
 }
 
-void iupdrvDrawKillCanvas(IdrawCanvas* dc)
+void iupdrvDrawGetSize(IdrawCanvas* dc, int *w, int *h)
 {
-	// We are no longer retaining the context
-	//	CGContextRelease(dc->cgContext);
-	// [dc->graphicsContext release];
-	// [dc->canvasView release];
+  if (w) *w = iupROUND(dc->w);
+  if (h) *h = iupROUND(dc->h);
+}
 
-	// Set to NULL defensively in case something breaks my assumptions. I hope to generate an obvious crash.
-	dc->canvasView = NULL;
-	dc->graphicsContext = NULL;
-	dc->cgContext = NULL;
-	dc->w = 0;
-	dc->h = 0;
-	free(dc);
-	dc = NULL;
+void cocoaDrawParentBackground(IdrawCanvas* dc)
+{
+  char* color_str = iupBaseNativeParentGetBgColor(dc->ih);
+  if (!color_str)
+    color_str = "255 255 255";
+
+  long color = iupDrawStrToColor(color_str, 0);
+
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
+
+  CGContextSetFillColorWithColor(cg_context, the_color);
+  CGContextFillRect(cg_context, CGRectMake(0, 0, dc->w, dc->h));
 }
 
+void iupdrvDrawRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
 
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
 
+  CGRect iup_rect = CGRectMake(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
 
+  if (style == IUP_DRAW_FILL)
+  {
+    CGContextSetFillColorWithColor(cg_context, the_color);
+    CGContextFillRect(cg_context, iup_rect);
+  }
+  else
+  {
+    CGContextSetStrokeColorWithColor(cg_context, the_color);
+    CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+    iupCocoaSetLineStyle(cg_context, style);
+
+    if (line_width == 1)
+    {
+      /* Use CGRectInset for pixel-perfect 1px lines */
+      CGContextStrokeRect(cg_context, CGRectInset(iup_rect, 0.5, 0.5));
+    }
+    else
+    {
+      /* Use direct CGContextStrokeRect for wider lines - simpler and faster */
+      CGContextStrokeRect(cg_context, iup_rect);
+    }
+  }
+}
+
+void iupdrvDrawLine(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
+
+  CGContextSetStrokeColorWithColor(cg_context, the_color);
+  CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+  iupCocoaSetLineStyle(cg_context, style);
+
+  CGContextBeginPath(cg_context);
+
+  if (line_width == 1)
+  {
+    if (x1 == x2)
+    {
+      iupDrawCheckSwapCoord(y1, y2);
+      CGContextMoveToPoint(cg_context, x1 + 0.5, y1);
+      CGContextAddLineToPoint(cg_context, x1 + 0.5, y2 + 1);
+    }
+    else if (y1 == y2)
+    {
+      iupDrawCheckSwapCoord(x1, x2);
+      CGContextMoveToPoint(cg_context, x1, y1 + 0.5);
+      CGContextAddLineToPoint(cg_context, x2 + 1, y1 + 0.5);
+    }
+    else
+    {
+      CGContextMoveToPoint(cg_context, x1, y1);
+      CGContextAddLineToPoint(cg_context, x2, y2);
+    }
+  }
+  else
+  {
+    CGContextMoveToPoint(cg_context, x1, y1);
+    CGContextAddLineToPoint(cg_context, x2, y2);
+  }
+
+  CGContextStrokePath(cg_context);
+}
+
 void iupdrvDrawArc(IdrawCanvas* dc, int x1, int y1, int x2, int y2, double a1, double a2, long color, int style, int line_width)
 {
-	unsigned char r = iupDrawRed(color), g = iupDrawGreen(color), b = iupDrawBlue(color), a = iupDrawAlpha(color);
-	CGContextRef cg_context = dc->cgContext;
-	
-	CGColorRef the_color = coregraphicsCreateAutoreleasedColor(r, g, b, a);
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
 
-	if(IUP_DRAW_FILL == style)
-	{
-		CGContextSetFillColorWithColor(cg_context, the_color);
-	}
-	else
-	{
-		CGContextSetStrokeColorWithColor(cg_context, the_color);
-		coregraphicsSetLineStyle(dc, style);
-	}
-	CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
 
-	CGFloat w = x2-x1+1;
-	CGFloat h = y2-y1+1;
-	CGFloat xc = x1 + w/2;
-	CGFloat yc = y1 + h/2;
+  CGFloat w = x2 - x1 + 1;
+  CGFloat h = y2 - y1 + 1;
+  if (w <= 0 || h <= 0) return;
 
-	// Must convert degrees to radians
-	CGFloat rad1 = a1/180.0*M_PI;
-	CGFloat rad2 = a2/180.0*M_PI;
+  CGFloat xc = x1 + w/2.0;
+  CGFloat yc = y1 + h/2.0;
 
-	if (w == h)
-	{
-		CGContextAddArc(cg_context, xc, yc, w, rad1, rad2, 1);
-		if(IUP_DRAW_FILL == style)
-		{
-			CGContextFillPath(cg_context);
-		}
-		else
-		{
-			CGContextStrokePath(cg_context);
-		}
-	}
-	else  /* Ellipse: change the scale to create from the circle */
-	{
-		/* save to use the local transform */
-		CGContextSaveGState(cg_context);
-		
-		CGContextTranslateCTM(cg_context, xc, yc);
-		CGContextScaleCTM(cg_context, w/h, 1.0);
-		CGContextTranslateCTM(cg_context, -xc, -yc);
-	
-		CGContextAddArc(cg_context, xc, yc, 0.5*h, rad1, rad2, 1);
-		
-		if(IUP_DRAW_FILL == style)
-		{
-			CGContextFillPath(cg_context);
-		}
-		else
-		{
-			CGContextStrokePath(cg_context);
-		}
-		
-		/* restore from local */
-		CGContextRestoreGState(cg_context);
-	}
+  if (a2 < a1) a2 += 360.0;
+
+  CGFloat rad1 = -a1 * M_PI / 180.0;
+  CGFloat rad2 = -a2 * M_PI / 180.0;
+  int is_clockwise = 1;
+
+  if (w == h)
+  {
+    CGContextBeginPath(cg_context);
+
+    if (style == IUP_DRAW_FILL)
+    {
+      CGContextSetFillColorWithColor(cg_context, the_color);
+      CGContextMoveToPoint(cg_context, xc, yc);
+      CGContextAddArc(cg_context, xc, yc, 0.5*w, rad1, rad2, is_clockwise);
+      CGContextClosePath(cg_context);
+      CGContextFillPath(cg_context);
+    }
+    else
+    {
+      CGContextSetStrokeColorWithColor(cg_context, the_color);
+      CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+      iupCocoaSetLineStyle(cg_context, style);
+      CGContextAddArc(cg_context, xc, yc, 0.5*w, rad1, rad2, is_clockwise);
+      CGContextStrokePath(cg_context);
+    }
+  }
+  else
+  {
+    if (style == IUP_DRAW_FILL)
+    {
+      CGContextSetFillColorWithColor(cg_context, the_color);
+
+      CGContextSaveGState(cg_context);
+      CGContextTranslateCTM(cg_context, xc, yc);
+      CGContextScaleCTM(cg_context, w/2.0, h/2.0);
+
+      CGContextBeginPath(cg_context);
+      CGContextMoveToPoint(cg_context, 0, 0);
+      CGContextAddArc(cg_context, 0, 0, 1.0, rad1, rad2, is_clockwise);
+      CGContextClosePath(cg_context);
+      CGContextFillPath(cg_context);
+
+      CGContextRestoreGState(cg_context);
+    }
+    else
+    {
+      CGContextSetStrokeColorWithColor(cg_context, the_color);
+      CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+      iupCocoaSetLineStyle(cg_context, style);
+
+      CGMutablePathRef path = CGPathCreateMutable();
+      CGAffineTransform transform = CGAffineTransformMakeTranslation(xc, yc);
+      transform = CGAffineTransformScale(transform, w/2.0, h/2.0);
+
+      CGPathAddArc(path, &transform, 0, 0, 1.0, rad1, rad2, is_clockwise);
+
+      CGContextBeginPath(cg_context);
+      CGContextAddPath(cg_context, path);
+      CGPathRelease(path);
+
+      CGContextStrokePath(cg_context);
+    }
+  }
 }
 
+void iupdrvDrawEllipse(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  CGFloat w = x2 - x1 + 1;
+  CGFloat h = y2 - y1 + 1;
+  if (w <= 0 || h <= 0) return;
+
+  CGRect rect = CGRectMake((CGFloat)x1, (CGFloat)y1, w, h);
+
+  CGContextBeginPath(cg_context);
+  CGContextAddEllipseInRect(cg_context, rect);
+
+  if (style == IUP_DRAW_FILL)
+  {
+    CGContextSetFillColorWithColor(cg_context, the_color);
+    CGContextFillPath(cg_context);
+  }
+  else
+  {
+    CGContextSetStrokeColorWithColor(cg_context, the_color);
+    CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+    iupCocoaSetLineStyle(cg_context, style);
+    CGContextStrokePath(cg_context);
+  }
+}
+
 void iupdrvDrawPolygon(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width)
 {
-	unsigned char r = iupDrawRed(color), g = iupDrawGreen(color), b = iupDrawBlue(color), a = iupDrawAlpha(color);
-	CGContextRef cg_context = dc->cgContext;
-	
-	CGColorRef the_color = coregraphicsCreateAutoreleasedColor(r, g, b, a);
-	CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
 
-	if(IUP_DRAW_FILL == style)
-	{
-		CGContextSetFillColorWithColor(cg_context, the_color);
-	}
-	else
-	{
-		CGContextSetStrokeColorWithColor(cg_context, the_color);
-		coregraphicsSetLineStyle(dc, style);
-	}
-	
-	CGContextMoveToPoint(cg_context, (CGFloat)points[0], (CGFloat)points[1]);
-	
-	for(int i=0; i<count; i++)
-	{
-		CGContextAddLineToPoint(cg_context, (CGFloat)points[2*i], (CGFloat)points[2*i+1]);
-	}
-	
-	if(IUP_DRAW_FILL == style)
-	{
-		CGContextFillPath(cg_context);
-	}
-	else
-	{
-		CGContextStrokePath(cg_context);
-	}
+  if (style == IUP_DRAW_FILL)
+    CGContextSetFillColorWithColor(cg_context, the_color);
+  else
+  {
+    CGContextSetStrokeColorWithColor(cg_context, the_color);
+    CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+    iupCocoaSetLineStyle(cg_context, style);
+  }
+
+  CGContextBeginPath(cg_context);
+  CGContextMoveToPoint(cg_context, (CGFloat)points[0], (CGFloat)points[1]);
+
+  /* Start at i=1 to avoid redundant line to first point */
+  for (int i = 1; i < count; i++)
+    CGContextAddLineToPoint(cg_context, (CGFloat)points[2*i], (CGFloat)points[2*i+1]);
+
+  CGContextClosePath(cg_context);  /* Close polygon by connecting last point to first */
+
+  if (style == IUP_DRAW_FILL)
+    CGContextFillPath(cg_context);
+  else
+    CGContextStrokePath(cg_context);
 }
 
+void iupdrvDrawPixel(IdrawCanvas* dc, int x, int y, long color)
+{
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
 
+  CGContextSetFillColorWithColor(cg_context, the_color);
+  CGContextFillRect(cg_context, CGRectMake((CGFloat)x, (CGFloat)y, 1.0, 1.0));
+}
 
-void iupdrvDrawFocusRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2)
+void iupdrvDrawRoundedRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width)
 {
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
+  CGFloat radius = (CGFloat)corner_radius;
 
-//	IupCocoaCanvasView* canvas_view =(IupCocoaCanvasView*)dc->ih->handle;
-	IupCocoaCanvasView* canvas_view = dc->canvasView;
-	if([canvas_view useNativeFocusRing])
-	{
-		return;
-	}
-#if 1
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
 
+  /* Clamp radius to prevent oversized corners */
+  CGFloat max_radius = ((x2 - x1) < (y2 - y1)) ? (CGFloat)(x2 - x1) / 2.0f : (CGFloat)(y2 - y1) / 2.0f;
+  if (radius > max_radius)
+    radius = max_radius;
 
-//	NSLog(@"iupdrvDrawFocusRect");
-//		NSLog(@"DrawFocus ih:0x%p for View: %@", dc->ih, dc->canvasView);
+  /* Set color and line properties */
+  if (style == IUP_DRAW_FILL)
+    CGContextSetFillColorWithColor(cg_context, the_color);
+  else
+  {
+    CGContextSetStrokeColorWithColor(cg_context, the_color);
+    CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+    iupCocoaSetLineStyle(cg_context, style);
+  }
 
-	CGContextRef cg_context = dc->cgContext;
+  /* Create rounded rectangle path */
+  CGRect rect = CGRectMake((CGFloat)x1, (CGFloat)y1, (CGFloat)(x2 - x1 + 1), (CGFloat)(y2 - y1 + 1));
+  CGPathRef path = CGPathCreateWithRoundedRect(rect, radius, radius, NULL);
 
-//	NSLog(@"draw rect: %d %d %d %d", x1, y1, x2, y2);
-	CGRect the_rect = CGRectMake(x1, y1, x2-x1, y2-y1);
-	// Do I need an inset?
-//	the_rect = CGRectInset(the_rect, 4, 4);
-//	NSLog(@"draw rect: %@", NSStringFromRect(the_rect));
+  /* Draw the path */
+  CGContextBeginPath(cg_context);
+  CGContextAddPath(cg_context, path);
 
-	NSColor* focus_ring_color = [NSColor keyboardFocusIndicatorColor];
-//	NSColor* focus_ring_color = [NSColor greenColor];
-	CGColorRef cg_focus_ring_color = [focus_ring_color CGColor];
-	CGContextSetStrokeColorWithColor(cg_context, cg_focus_ring_color);
-	CGContextSetLineWidth(cg_context, (CGFloat)4.0);
+  if (style == IUP_DRAW_FILL)
+    CGContextFillPath(cg_context);
+  else
+    CGContextStrokePath(cg_context);
 
-	// Requires 10.9
-	CGPathRef path_ref = CGPathCreateWithRoundedRect(the_rect, 4.0, 4.0, NULL);
-	CGContextAddPath(cg_context, path_ref);
-	CGContextStrokePath(cg_context);
+  CGPathRelease(path);
+}
 
-	CGPathRelease(path_ref);
-#endif
+void iupdrvDrawBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width)
+{
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorRef the_color = iupCocoaDrawCreateColor(color);
 
-	
+  /* Set color and line properties */
+  if (style == IUP_DRAW_FILL)
+    CGContextSetFillColorWithColor(cg_context, the_color);
+  else
+  {
+    CGContextSetStrokeColorWithColor(cg_context, the_color);
+    CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+    iupCocoaSetLineStyle(cg_context, style);
+  }
+
+  /* Create cubic Bezier path */
+  CGContextBeginPath(cg_context);
+  CGContextMoveToPoint(cg_context, (CGFloat)x1, (CGFloat)y1);
+  CGContextAddCurveToPoint(cg_context,
+                           (CGFloat)x2, (CGFloat)y2,  /* First control point */
+                           (CGFloat)x3, (CGFloat)y3,  /* Second control point */
+                           (CGFloat)x4, (CGFloat)y4); /* End point */
+
+  /* Draw the path */
+  if (style == IUP_DRAW_FILL)
+    CGContextFillPath(cg_context);
+  else
+    CGContextStrokePath(cg_context);
 }
 
-IUP_SDK_API void iupdrvDrawGetClipRect(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2)
+void iupdrvDrawQuadraticBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width)
 {
+  /* Convert quadratic Bezier to cubic Bezier using the 2/3 formula:
+   * Given quadratic: Q(t) with control points q0, q1, q2
+   * Convert to cubic: C(t) with control points c0, c1, c2, c3
+   *
+   * c0 = q0                        (start point)
+   * c1 = q0 + (2/3) * (q1 - q0)   (first control point)
+   * c2 = q2 + (2/3) * (q1 - q2)   (second control point)
+   * c3 = q2                        (end point)
+   */
+  int cx1, cy1, cx2, cy2;
+
+  /* Calculate cubic control points from quadratic */
+  cx1 = x1 + ((2 * (x2 - x1)) / 3);
+  cy1 = y1 + ((2 * (y2 - y1)) / 3);
+  cx2 = x3 + ((2 * (x2 - x3)) / 3);
+  cy2 = y3 + ((2 * (y2 - y3)) / 3);
+
+  /* Draw as cubic Bezier */
+  iupdrvDrawBezier(dc, x1, y1, cx1, cy1, cx2, cy2, x3, y3, color, style, line_width);
+}
+
+void iupdrvDrawGetClipRect(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2)
+{
   if (x1) *x1 = (int)dc->clip_x1;
   if (y1) *y1 = (int)dc->clip_y1;
   if (x2) *x2 = (int)dc->clip_x2;
@@ -276,205 +613,335 @@
   if (y2) *y2 = (int)dc->clip_y2;
 }
 
-
 void iupdrvDrawSetClipRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2)
 {
-	// This gets called a lot, so print only once.
-	static bool gave_warning = false;
-	if(!gave_warning)
-	{
-		NSLog(@"iupdrvDrawSetClipRect not tested");
-		gave_warning = true;
-	}
-#if 1
-	CGContextRef cg_context = dc->cgContext;
+  if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
+  {
+    iupdrvDrawResetClip(dc);
+    return;
+  }
 
-	CGContextSaveGState(cg_context);
+  if (x1 >= x2) x1 = x2;
+  if (y1 >= y2) y1 = y2;
 
-	CGRect clip_rect = CGRectMake(x1, y1, x2-x1, y2-y1);
-	
-	CGContextClipToRect(cg_context, clip_rect);
-#endif
-	dc->clip_x1 = (CGFloat)x1;
-	dc->clip_y1 = (CGFloat)y1;
-	dc->clip_x2 = (CGFloat)x2;
-	dc->clip_y2 = (CGFloat)y2;
+  iupdrvDrawResetClip(dc);
+
+  CGContextSaveGState(dc->image_cgContext);
+  dc->clip_state = 1;
+
+  CGRect clip_rect = CGRectMake(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+  CGContextClipToRect(dc->image_cgContext, clip_rect);
+
+  dc->clip_x1 = (CGFloat)x1;
+  dc->clip_y1 = (CGFloat)y1;
+  dc->clip_x2 = (CGFloat)x2;
+  dc->clip_y2 = (CGFloat)y2;
 }
 
-// This is supposed to remove the clipping.
-void iupdrvDrawResetClip(IdrawCanvas* dc)
+void iupdrvDrawSetClipRoundedRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius)
 {
-	CGContextRef cg_context = dc->cgContext;
+  CGFloat radius = (CGFloat)corner_radius;
 
-	// Assumption1: The user activated clip and we saved (pushed) the GState.
-	// Assumption2: No other API can save a GState without (popping) Restoring (balancing) it before returning.
-	// QED: When we pop here, we are popping the activated clip, thus removing it.
-	CGContextRestoreGState(cg_context);
+  if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
+  {
+    iupdrvDrawResetClip(dc);
+    return;
+  }
 
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* IUP coordinates: use width + 1 and height + 1 */
+  CGFloat w = (CGFloat)(x2 - x1 + 1);
+  CGFloat h = (CGFloat)(y2 - y1 + 1);
+
+  /* Clamp radius to prevent oversized corners */
+  CGFloat max_radius = (w < h) ? w / 2.0f : h / 2.0f;
+  if (radius > max_radius)
+    radius = max_radius;
+
+  iupdrvDrawResetClip(dc);
+
+  CGContextSaveGState(dc->image_cgContext);
+  dc->clip_state = 1;
+
+  /* Create rounded rectangle path and use as clip */
+  CGRect rect = CGRectMake((CGFloat)x1, (CGFloat)y1, w, h);
+  CGPathRef path = CGPathCreateWithRoundedRect(rect, radius, radius, NULL);
+
+  CGContextBeginPath(dc->image_cgContext);
+  CGContextAddPath(dc->image_cgContext, path);
+  CGContextClip(dc->image_cgContext);
+
+  CGPathRelease(path);
+
+  dc->clip_x1 = (CGFloat)x1;
+  dc->clip_y1 = (CGFloat)y1;
+  dc->clip_x2 = (CGFloat)x2;
+  dc->clip_y2 = (CGFloat)y2;
 }
 
-void iupdrvDrawParentBackground(IdrawCanvas* dc)
+void iupdrvDrawResetClip(IdrawCanvas* dc)
 {
-	NSLog(@"iupdrvDrawParentBackground needs to be verified");
-	// I don't know if this is correct
-	
-	CGContextRef cg_context = dc->cgContext;
-	CGFloat context_width = dc->w;
-	CGFloat context_height = dc->h;
+  if (dc->clip_state == 1)
+  {
+    CGContextRestoreGState(dc->image_cgContext);
+    dc->clip_state = 0;
+  }
 
-	NSColor* the_color = [NSColor controlBackgroundColor];
-//	NSColor* the_color = [NSColor greenColor];
-	CGColorRef cg_color = [the_color CGColor];
-//	CGContextSetStrokeColorWithColor(cg_context, cg_color);
-	CGContextSetFillColorWithColor(cg_context, cg_color);
-	
-	CGRect the_rectangle = CGRectMake(0, 0, context_width, context_height);
-	CGContextAddRect(cg_context, the_rectangle);
-	
-	CGContextFillRect(cg_context, the_rectangle);
+  dc->clip_x1 = 0;
+  dc->clip_y1 = 0;
+  dc->clip_x2 = 0;
+  dc->clip_y2 = 0;
 }
-// TODO: text_orientation was added after this implementation was done but before the merge. We need to implement it.
+
 void iupdrvDrawText(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, const char* font, int flags, double text_orientation)
 {
-	// FIXME: We need to properly implement the font system in order for us to implement this.
-	// FIXME: Need to figure out how to size up the rendered string, and then align it within the specified draw box.
-	// FIXME: I think text may have IUP attributes like bold, underline, etc. Need to properly render.
-//	NSLog(@"iupdrvDrawText not fully implemented");
-	unsigned char r = iupDrawRed(color), g = iupDrawGreen(color), b = iupDrawBlue(color), a = iupDrawAlpha(color);
-	CGContextRef cg_context = dc->cgContext;
-	CGColorRef the_color = coregraphicsCreateAutoreleasedColor(r, g, b, a);
-	CGContextSetStrokeColorWithColor(cg_context, the_color);
-	CGContextSetFillColorWithColor(cg_context, the_color);
-//	NSLog(@"iupdrvDrawText text: %s, len:%d", text, len);
-//	NSLog(@"iupdrvDrawText font: %s", font);
+  if (!text || (len == 0 && text[0] == '\0'))
+    return;
 
-	// Ugh. The CGContext text functions are deprecated. Need to use CoreText or Cocoa.
-//	CGContextSelectFont(cg_context, "Helvetica", 12.0, kCGEncodingMacRoman);
-//    CGContextSetTextDrawingMode(cg_context, kCGTextFill);
-//	CGContextShowTextAtPoint(cg_context, x, y, text, len);
-NSGraphicsContext* nsgc = [NSGraphicsContext graphicsContextWithCGContext:cg_context flipped:YES];
- [NSGraphicsContext saveGraphicsState];
- [NSGraphicsContext setCurrentContext:nsgc];
-	
+  @autoreleasepool {
+    CGContextRef cg_context = dc->image_cgContext;
+    CGContextSaveGState(cg_context);
 
-    NSPoint start_point = { x, y };
- //   startPoint.x = bounds.origin.x + bounds.size.width / 2 - size.width / 2;
- //   startPoint.y = bounds.origin.y + bounds.size.height / 2 - size.height / 2;
-	NSString* ns_string = [NSString stringWithUTF8String:text];
-    [ns_string drawAtPoint:start_point withAttributes: nil];
-	 [NSGraphicsContext restoreGraphicsState];
-}
-void iupdrvDrawSelectRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2)
-{
-	NSLog(@"iupdrvDrawSelectRect not implemented");
-	
-	// I don't know what this function does. I'm guessing at the color
-	
-	CGContextRef cg_context = dc->cgContext;
+    NSGraphicsContext* temp_ns_context = [NSGraphicsContext graphicsContextWithCGContext:cg_context flipped:YES];
+    [NSGraphicsContext saveGraphicsState];
+    [NSGraphicsContext setCurrentContext:temp_ns_context];
 
-//	NSLog(@"draw rect: %d %d %d %d", x1, y1, x2, y2);
-	CGRect the_rect = CGRectMake(x1, y1, x2-x1, y2-y1);
-	// Do I need an inset?
-//	the_rect = CGRectInset(the_rect, 4, 4);
-//	NSLog(@"draw rect: %@", NSStringFromRect(the_rect));
+    IupCocoaFont* iupFont = (font && *font != '\0') ? iupcocoaFindFont(font) : iupcocoaGetFont(dc->ih);
+    if (!iupFont)
+    {
+      [NSGraphicsContext restoreGraphicsState];
+      CGContextRestoreGState(cg_context);
+      return;
+    }
 
-	NSColor* the_color = [NSColor selectedControlColor];
-//	NSColor* the_color = [NSColor greenColor];
-	CGColorRef cg_color = [the_color CGColor];
-//	CGContextSetStrokeColorWithColor(cg_context, cg_color);
-	CGContextSetFillColorWithColor(cg_context, cg_color);
+    NSMutableDictionary* attributes = [[iupFont.attributeDictionary mutableCopy] autorelease];
 
-	// Requires 10.9
-	CGPathRef path_ref = CGPathCreateWithRoundedRect(the_rect, 4.0, 4.0, NULL);
-	CGContextAddPath(cg_context, path_ref);
-	CGContextFillPath(cg_context);
+    unsigned char r = iupDrawRed(color);
+    unsigned char g = iupDrawGreen(color);
+    unsigned char b = iupDrawBlue(color);
+    unsigned char a = iupDrawAlpha(color);
+    NSColor* ns_color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:a/255.0];
+    [attributes setObject:ns_color forKey:NSForegroundColorAttributeName];
 
-	CGPathRelease(path_ref);
+    NSMutableParagraphStyle* pStyle = [[[NSMutableParagraphStyle alloc] init] autorelease];
+    if (flags & IUP_DRAW_RIGHT)
+      pStyle.alignment = NSTextAlignmentRight;
+    else if (flags & IUP_DRAW_CENTER)
+      pStyle.alignment = NSTextAlignmentCenter;
+    else
+      pStyle.alignment = NSTextAlignmentLeft;
+
+    if (flags & IUP_DRAW_WRAP)
+      pStyle.lineBreakMode = NSLineBreakByWordWrapping;
+    else if (flags & IUP_DRAW_ELLIPSIS)
+      pStyle.lineBreakMode = NSLineBreakByTruncatingTail;
+    else
+      pStyle.lineBreakMode = NSLineBreakByClipping;
+
+    [attributes setObject:pStyle forKey:NSParagraphStyleAttributeName];
+
+    NSString* ns_string = len > 0 ?
+      [[[NSString alloc] initWithBytes:text length:len encoding:NSUTF8StringEncoding] autorelease] :
+      [NSString stringWithUTF8String:text];
+
+    int layout_w = w;
+    int layout_h = h;
+    int layout_center = flags & IUP_DRAW_LAYOUTCENTER;
+
+    if (text_orientation && layout_center)
+      iupDrawGetTextSize(dc->ih, text, len, &layout_w, &layout_h, 0);
+
+    NSRect text_rect = NSMakeRect(x, y, layout_w, layout_h);
+
+    if (text_orientation != 0.0)
+    {
+      NSAffineTransform* transform = [NSAffineTransform transform];
+
+      if (layout_center)
+      {
+        NSPoint center = NSMakePoint(x + layout_w / 2.0, y + layout_h / 2.0);
+        [transform translateXBy:center.x yBy:center.y];
+        [transform rotateByDegrees:-text_orientation];
+        [transform translateXBy:-center.x yBy:-center.y];
+        [transform translateXBy:(w - layout_w) / 2.0 yBy:(h - layout_h) / 2.0];
+      }
+      else
+      {
+        [transform translateXBy:x yBy:y];
+        [transform rotateByDegrees:-text_orientation];
+        [transform translateXBy:-x yBy:-y];
+      }
+
+      [transform concat];
+    }
+
+    if (flags & IUP_DRAW_CLIP)
+    {
+      [NSBezierPath clipRect:NSMakeRect(x, y, w, h)];
+    }
+
+    [ns_string drawInRect:text_rect withAttributes:attributes];
+
+    [NSGraphicsContext restoreGraphicsState];
+    CGContextRestoreGState(cg_context);
+  }
 }
 
-void iupdrvDrawLine(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+void iupdrvDrawImage(IdrawCanvas* dc, const char* name, int make_inactive, const char* bgcolor, int x, int y, int w, int h)
 {
-	unsigned char r = iupDrawRed(color), g = iupDrawGreen(color), b = iupDrawBlue(color), a = iupDrawAlpha(color);
-	CGContextRef cg_context = dc->cgContext;
-	
-	CGColorRef the_color = coregraphicsCreateAutoreleasedColor(r, g, b, a);
-	CGContextSetStrokeColorWithColor(cg_context, the_color);
-	coregraphicsSetLineStyle(dc, style);
-	CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+  NSImage* user_image = (NSImage*)iupImageGetImage(name, dc->ih, make_inactive, bgcolor);
+  if (!user_image)
+    return;
 
-	CGContextMoveToPoint(cg_context, (CGFloat)x1, (CGFloat)y1);
-	CGContextAddLineToPoint(cg_context, (CGFloat)x2, (CGFloat)y2);
-	CGContextStrokePath(cg_context);
-}
+  @autoreleasepool {
+    NSSize image_size = [user_image size];
+    if (w == -1 || w == 0) w = image_size.width;
+    if (h == -1 || h == 0) h = image_size.height;
 
+    CGContextRef cg_context = dc->image_cgContext;
+    CGContextSaveGState(cg_context);
 
-void iupdrvDrawRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
-{
-	unsigned char r = iupDrawRed(color), g = iupDrawGreen(color), b = iupDrawBlue(color), a = iupDrawAlpha(color);
-	CGContextRef cg_context = dc->cgContext;
-	
-	CGColorRef the_color = coregraphicsCreateAutoreleasedColor(r, g, b, a);
-	CGContextSetLineWidth(cg_context, (CGFloat)line_width);
+    /* Use flipped NSGraphicsContext to correctly draw image in y-down coordinate system */
+    NSGraphicsContext* temp_ns_context = [NSGraphicsContext graphicsContextWithCGContext:cg_context flipped:YES];
+    [NSGraphicsContext saveGraphicsState];
+    [NSGraphicsContext setCurrentContext:temp_ns_context];
 
-	if(IUP_DRAW_FILL == style)
-	{
-		CGRect the_rectangle = CGRectMake(x1, y1, x2-x1, y2-y1);
-		CGContextAddRect(cg_context, the_rectangle);
-		
-		CGContextSetFillColorWithColor(cg_context, the_color);
-		CGContextFillRect(cg_context, the_rectangle);
-	}
-	else
-	{
-		// The other implementations make the line rect +1
-		CGRect the_rectangle = CGRectMake(x1, y1, x2-x1+1, y2-y1+1);
-		CGContextAddRect(cg_context, the_rectangle);
-		
-		CGContextSetStrokeColorWithColor(cg_context, the_color);
-		coregraphicsSetLineStyle(dc, style);
-		CGContextStrokePath(cg_context);
-	}
+    CGRect target_rect = CGRectMake(x, y, w, h);
+    [user_image drawInRect:target_rect];
+
+    [NSGraphicsContext restoreGraphicsState];
+    CGContextRestoreGState(cg_context);
+  }
 }
 
-void iupdrvDrawGetSize(IdrawCanvas* dc, int *w, int *h)
+void iupdrvDrawSelectRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2)
 {
-  if (w) *w = iupROUND(dc->w);
-  if (h) *h = iupROUND(dc->h);
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  CGRect iup_rect = CGRectMake(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+
+  CGColorRef select_color = iupCocoaDrawCreateColor(iupDrawColor(0, 0, 255, 153));
+  CGContextSetFillColorWithColor(dc->image_cgContext, select_color);
+  CGContextFillRect(dc->image_cgContext, iup_rect);
 }
 
-// NOTE: Searching through the code base, this never seems to get called by anything.
-// So I don't know what this is supposed to do.
-void iupdrvDrawUpdateSize(IdrawCanvas* dc)
+void iupdrvDrawFocusRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2)
 {
-//	NSLog(@"iupdrvDrawUpdateSize not implemented");
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
 
+  if (iupAttribGetBoolean(dc->ih, "NATIVEFOCUSRING"))
+  {
+    /* Defer focus ring drawing to flush for native macOS appearance */
+    dc->draw_focus = 1;
+    dc->focus_x1 = x1;
+    dc->focus_y1 = y1;
+    dc->focus_x2 = x2;
+    dc->focus_y2 = y2;
+  }
+  else
+  {
+    /* Draw a simple dotted rectangle for focus indication */
+    CGContextRef cg_context = dc->image_cgContext;
+    CGContextSaveGState(cg_context);
+
+    CGRect iup_rect = CGRectMake(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+    CGFloat dashes[2] = { 1.0, 1.0 };
+    CGColorRef focus_color = iupCocoaDrawCreateColor(iupDrawColor(0, 0, 0, 224));
+
+    CGContextSetStrokeColorWithColor(cg_context, focus_color);
+    CGContextSetLineWidth(cg_context, 1.0);
+    CGContextSetLineDash(cg_context, 0, dashes, 2);
+    CGContextStrokeRect(cg_context, CGRectInset(iup_rect, 0.5, 0.5));
+
+    CGContextRestoreGState(cg_context);
+  }
 }
 
-void iupdrvDrawFlush(IdrawCanvas* dc)
+void iupdrvDrawLinearGradient(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2)
 {
-//	NSLog(@"iupdrvDrawFlush");
-	// I don't think Apple gives us anything do anything here.
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Create gradient colors */
+  CGFloat components[8] = {
+    iupDrawRed(color1) / 255.0f, iupDrawGreen(color1) / 255.0f, iupDrawBlue(color1) / 255.0f, iupDrawAlpha(color1) / 255.0f,
+    iupDrawRed(color2) / 255.0f, iupDrawGreen(color2) / 255.0f, iupDrawBlue(color2) / 255.0f, iupDrawAlpha(color2) / 255.0f
+  };
+  CGFloat locations[2] = { 0.0, 1.0 };
+
+  CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, components, locations, 2);
+
+  /* Calculate gradient endpoints based on angle */
+  /* 0 = left to right, 90 = top to bottom, 180 = right to left, 270 = bottom to top */
+  CGFloat rad = angle * M_PI / 180.0f;
+
+  /* IUP coordinates: use width + 1 and height + 1 */
+  CGFloat w = (CGFloat)(x2 - x1 + 1);
+  CGFloat h = (CGFloat)(y2 - y1 + 1);
+  CGFloat cx = x1 + w / 2.0f;
+  CGFloat cy = y1 + h / 2.0f;
+
+  CGPoint start = CGPointMake(cx - (w * cos(rad)) / 2.0f, cy - (h * sin(rad)) / 2.0f);
+  CGPoint end = CGPointMake(cx + (w * cos(rad)) / 2.0f, cy + (h * sin(rad)) / 2.0f);
+
+  /* Clip to rectangle */
+  CGContextSaveGState(cg_context);
+  CGContextClipToRect(cg_context, CGRectMake(x1, y1, w, h));
+
+  /* Draw gradient */
+  /* Use kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation
+     to ensure the gradient fills the entire clipped area, otherwise corners that fall
+     outside the projected start/end planes (common in diagonal gradients) will be cut off. */
+  CGContextDrawLinearGradient(cg_context, gradient, start, end, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);
+
+  CGContextRestoreGState(cg_context);
+  CGGradientRelease(gradient);
+  CGColorSpaceRelease(colorSpace);
 }
 
-// TODO: w,h are new parameters added after this implementation, but before the merge. Need to test w,h implementation.
-void iupdrvDrawImage(IdrawCanvas* dc, const char* name, int make_inactive, const char* bgcolor, int x, int y, int w, int h)
+void iupdrvDrawRadialGradient(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge)
 {
-//	NSLog(@"iupdrvDrawImage not implemented");
-	CGContextRef cg_context = dc->cgContext;
-	NSImage* user_image = (NSImage*)iupImageGetImage(name, dc->ih, make_inactive, bgcolor);
-//	[user_image autorelease]; // BAD: Iup is caching the value and returns the same pointer if cached. This results in a double autorelease.
-//	NSImageRep* user_image_rep = nil;
+  CGContextRef cg_context = dc->image_cgContext;
+  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
 
-//	NSSize image_size = [user_image size];
-//	NSRect target_rect = NSMakeRect(x, y, image_size.width, image_size.height);
-	NSRect target_rect = NSMakeRect(x, y, w, h);
-	NSGraphicsContext* nsgc = [NSGraphicsContext graphicsContextWithCGContext:cg_context flipped:YES];
-	[NSGraphicsContext saveGraphicsState];
-	[NSGraphicsContext setCurrentContext:nsgc];
-	
-	[user_image drawInRect:target_rect];
-	[NSGraphicsContext restoreGraphicsState];
-	
-}
+  /* Create gradient colors */
+  CGFloat components[8] = {
+    iupDrawRed(colorCenter) / 255.0f, iupDrawGreen(colorCenter) / 255.0f, iupDrawBlue(colorCenter) / 255.0f, iupDrawAlpha(colorCenter) / 255.0f,
+    iupDrawRed(colorEdge) / 255.0f, iupDrawGreen(colorEdge) / 255.0f, iupDrawBlue(colorEdge) / 255.0f, iupDrawAlpha(colorEdge) / 255.0f
+  };
+  CGFloat locations[2] = { 0.0, 1.0 };
 
+  CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, components, locations, 2);
 
+  CGPoint center = CGPointMake(cx, cy);
+  CGRect circleRect = CGRectMake(cx - radius, cy - radius, 2 * radius, 2 * radius);
+
+  CGContextSaveGState(cg_context);
+
+  /* First draw the circle with solid fill to get anti-aliased edges
+   * Gradients don't anti-alias their edges, but filled paths do.
+   * Use the edge color as the fill color for the circle boundary. */
+  CGContextBeginPath(cg_context);
+  CGContextAddEllipseInRect(cg_context, circleRect);
+  CGContextSetRGBFillColor(cg_context,
+                           iupDrawRed(colorEdge) / 255.0f,
+                           iupDrawGreen(colorEdge) / 255.0f,
+                           iupDrawBlue(colorEdge) / 255.0f,
+                           iupDrawAlpha(colorEdge) / 255.0f);
+  CGContextFillPath(cg_context);
+
+  /* Now draw the gradient on top - it will have smooth edges from the solid fill underneath */
+  CGContextDrawRadialGradient(cg_context, gradient, center, 0, center, radius, 0);
+
+  CGContextRestoreGState(cg_context);
+
+  CGGradientRelease(gradient);
+  CGColorSpaceRelease(colorSpace);
+}
Index: src/cocoa/iupcocoa_drv.h
===================================================================
--- src/cocoa/iupcocoa_drv.h	(revision 5971)
+++ src/cocoa/iupcocoa_drv.h	(working copy)
@@ -1,10 +1,10 @@
 /** \file
- * \brief MAC Driver 
+ * \brief macOS Cocoa Driver
  *
  * See Copyright Notice in "iup.h"
  */
- 
-#ifndef __IUPMAC_DRV_H 
+
+#ifndef __IUPMAC_DRV_H
 #define __IUPMAC_DRV_H
 
 #ifdef __cplusplus
@@ -13,182 +13,138 @@
 
 #include "iup_export.h"
 
-#include <asl.h>
-#if __OBJC__
-	#import <Foundation/Foundation.h>
-	#import "IupCocoaFont.h"
-#endif
+#include <os/log.h>
 
+#import <Foundation/Foundation.h>
+#import <AppKit/AppKit.h>
+
 #include "iup_image.h"
 
-// the point of this is we have a unique memory address for an identifier
+
+/* A unique memory address for an identifier. */
 IUP_DRV_API extern const void* IHANDLE_ASSOCIATED_OBJ_KEY;
-// ih->handle is the root view, but often the main view is lower down, (e.g. scrollview contains the real widget).
-// This pattern turned up enough that it merited adding this key.
-// This was introduced late into the development process so a lot of code may continue to fetch this the hard way.
+/* The main view within a root view (e.g., a scrollview contains the real widget). */
 IUP_DRV_API extern const void* MAINVIEW_ASSOCIATED_OBJ_KEY;
-// Formalize the rootview in case the root object is not a view
+/* The root view, in case the root object is not a view. */
 IUP_DRV_API extern const void* ROOTVIEW_ASSOCIATED_OBJ_KEY;
 
+#define iupcocoaLog(...) os_log(OS_LOG_DEFAULT, __VA_ARGS__)
+#define iupcocoaLogDebug(...) os_log_debug(OS_LOG_DEFAULT, __VA_ARGS__)
+#define iupcocoaLogInfo(...) os_log_info(OS_LOG_DEFAULT, __VA_ARGS__)
+#define iupcocoaLogNotice(...) os_log(OS_LOG_DEFAULT, __VA_ARGS__)
+#define iupcocoaLogWarning(...) os_log_error(OS_LOG_DEFAULT, __VA_ARGS__)
+#define iupcocoaLogError(...) os_log_error(OS_LOG_DEFAULT, __VA_ARGS__)
+#define iupcocoaLogCritical(...) os_log_fault(OS_LOG_DEFAULT, __VA_ARGS__)
 
-	
-// TODO: Move to os_log, but requires Mac 10.12
-#define iupAppleLog(...) asl_log(NULL, NULL, ASL_LEVEL_NOTICE, __VA_ARGS__)
-#define iupAppleLogDebug(...) asl_log(NULL, NULL, ASL_LEVEL_DEBUG, __VA_ARGS__)
-#define iupAppleLogInfo(...) asl_log(NULL, NULL, ASL_LEVEL_INFO, __VA_ARGS__)
-#define iupAppleLogNotice(...) asl_log(NULL, NULL, ASL_LEVEL_NOTICE, __VA_ARGS__)
-#define iupAppleLogWarning(...) asl_log(NULL, NULL, ASL_LEVEL_WARNING, __VA_ARGS__)
-#define iupAppleLogError(...) asl_log(NULL, NULL, ASL_LEVEL_ERR, __VA_ARGS__)
-#define iupAppleLogCritical(...) asl_log(NULL, NULL, ASL_LEVEL_CRIT, __VA_ARGS__)
+#define iupcocoaNSLog(FORMAT, ...) os_log_info(OS_LOG_DEFAULT, "%{public}@", [NSString stringWithFormat:FORMAT, ##__VA_ARGS__])
 
-#if __OBJC__
-#define iupAppleNSLog(...) asl_log(NULL, NULL, ASL_LEVEL_INFO, "%s", [[NSString stringWithFormat:__VA_ARGS__] UTF8String])
-#endif
-	
-IUP_DRV_API NSObject* iupCocoaGetRootObject(Ihandle* ih);
-IUP_DRV_API NSView* iupCocoaGetRootView(Ihandle* ih);
-IUP_DRV_API NSView* iupCocoaGetMainView(Ihandle* ih);
-IUP_DRV_API void iupCocoaSetAssociatedViews(Ihandle* ih, NSView* main_view, NSView* root_view);
+IUP_DRV_API NSObject* iupcocoaGetRootObject(Ihandle* ih);
+IUP_DRV_API NSView* iupcocoaGetRootView(Ihandle* ih);
+IUP_DRV_API NSView* iupcocoaGetMainView(Ihandle* ih);
+IUP_DRV_API void iupcocoaSetAssociatedViews(Ihandle* ih, NSView* main_view, NSView* root_view);
 
-IUP_DRV_API void iupCocoaAddToParent(Ihandle* ih);
-IUP_DRV_API void iupCocoaRemoveFromParent(Ihandle* ih);
-	
-NSView* iupCocoaCommonBaseLayoutGetParentView(Ihandle* ih);
-NSView* iupCocoaCommonBaseLayoutGetChildView(Ihandle* ih);
-NSRect iupCocoaCommonBaseLayoutComputeChildFrameRectFromParentRect(Ihandle* ih, NSRect parent_rect);
-	
-void iupCocoaCommonLoopCallExitCb(void);
+IUP_DRV_API void iupcocoaAddToParent(Ihandle* ih);
+IUP_DRV_API void iupcocoaRemoveFromParent(Ihandle* ih);
 
-	// Cocoa is in Cartesian (a.k.a. math book, aka OpenGL coordinates, aka y increases upwards), but Iup is y increases downwards.
-int iupCocoaComputeCartesianScreenHeightFromIup(int iup_height);
-int iupCocoaComputeIupScreenHeightFromCartesian(int cartesian_height);
+NSView* iupcocoaCommonBaseLayoutGetParentView(Ihandle* ih);
+NSView* iupcocoaCommonBaseLayoutGetChildView(Ihandle* ih);
 
+void iupcocoaCommonLoopCallExitCb(void);
+int iupcocoaMainLoopShouldQuit(void);
 
-int iupCocoaMenuIsApplicationBar(Ihandle* ih);
-void iupCocoaMenuSetApplicationMenu(Ihandle* ih);
-// Note: This only gets the user's Ihandle to the application menu. If the user doesn't set it, the default application will not be returned in its place. NULL will be returned instead.
-Ihandle* iupCocoaMenuGetApplicationMenu(void);
-// My current understanding is that IUP will not clean up our application menu Ihandles. So we need to do it ourselves.
-void iupCocoaMenuCleanupApplicationMenu(void);
+/* Coordinate conversion helpers: Cocoa uses Cartesian (y-up), IUP uses (y-down). */
+int iupcocoaComputeCartesianScreenHeightFromIup(int iup_height);
+int iupcocoaComputeIupScreenHeightFromCartesian(int cartesian_height);
 
+/* Tooltip Functions */
+IUP_DRV_API void cocoaUpdateTip(Ihandle* ih);
+IUP_DRV_API void iupcocoaTipsDestroy(Ihandle* ih);
 
-// Helper functions for implementing the mouseDown/mouseUp, mouseDragged family of functions.
-IUP_DRV_API int iupCocoaCommonBaseIupButtonForCocoaButton(NSInteger which_cocoa_button);
-// mouseDown: and mouseUp: overrides can call this
-// Returns a boolean specifying if the caller_should_not_propagate. (Trying to conform to the iupgtk counterpart.) So if false, call super, otherwise skip.
-IUP_DRV_API bool iupCocoaCommonBaseHandleMouseButtonCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view, bool is_pressed);
-// mouseDragged: overrides can call this
-// Returns a boolean specifying if the caller_should_not_propagate. (Trying to conform to the iupgtk counterpart.) So if false, call super, otherwise skip.
-IUP_DRV_API bool iupCocoaCommonBaseHandleMouseMotionCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view);
+/* Menu Functions */
+int iupcocoaMenuIsApplicationBar(Ihandle* ih);
+void iupcocoaMenuSetApplicationMenu(Ihandle* ih);
+Ihandle* iupcocoaMenuGetApplicationMenu(void);
+void iupcocoaMenuCleanupApplicationMenu(void);
+void iupcocoaEnsureDefaultApplicationMenu(void);
 
-// WHEEL_CB: WARNING: IUP does not support delta-y axis.
-IUP_DRV_API bool iupCocoaCommonBaseScrollWheelCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view);
+/* Helpers for mouse button and motion events. */
+IUP_DRV_API int iupcocoaCommonBaseIupButtonForCocoaButton(NSInteger which_cocoa_button);
+IUP_DRV_API bool iupcocoaCommonBaseHandleMouseButtonCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view, bool is_pressed);
+IUP_DRV_API bool iupcocoaCommonBaseHandleMouseMotionCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view);
 
+/* WHEEL_CB: WARNING: IUP does not support delta-y axis. */
+IUP_DRV_API bool iupcocoaCommonBaseScrollWheelCallback(Ihandle* ih, NSEvent* the_event, NSView* represented_view);
 
-// For Layer Backed Views
-IUP_DRV_API int iupCocoaCommonBaseSetLayerBackedAttrib(Ihandle* ih, const char* value);
+/* For Layer Backed Views. */
+IUP_DRV_API int iupcocoaCommonBaseSetLayerBackedAttrib(Ihandle* ih, const char* value);
 IUP_DRV_API char* iupCocoaCommonBaseGetLayerBackedAttrib(Ihandle* ih);
 
-// This is for NSResponder context menus. (I expect new modules will want to call these.)
-IUP_DRV_API void iupCocoaCommonBaseAppendMenuItems(NSMenu* dst_menu, NSMenu* src_menu);
-IUP_DRV_API void iupCocoaCommonBaseAppendDefaultMenuItemsForClassType(NSMenu* dst_menu, Class class_of_widget);
-IUP_DRV_API void iupCocoaCommonBaseSetContextMenuForWidget(Ihandle* ih, id ih_widget_to_attach_menu_to, Ihandle* menu_ih);
-IUP_DRV_API int iupCocoaCommonBaseSetContextMenuAttrib(Ihandle* ih, const char* value);
-IUP_DRV_API char* iupCocoaCommonBaseGetContextMenuAttrib(Ihandle* ih);
+/* Helpers for NSResponder context menus. */
+IUP_DRV_API void iupcocoaCommonBaseAppendMenuItems(NSMenu* dst_menu, NSMenu* src_menu);
+IUP_DRV_API void iupcocoaCommonBaseAppendDefaultMenuItemsForClassType(NSMenu* dst_menu, Class class_of_widget);
+IUP_DRV_API void iupcocoaCommonBaseSetContextMenuForWidget(Ihandle* ih, id ih_widget_to_attach_menu_to, Ihandle* menu_ih);
+IUP_DRV_API int iupcocoaCommonBaseSetContextMenuAttrib(Ihandle* ih, const char* value);
+IUP_DRV_API char* iupcocoaCommonBaseGetContextMenuAttrib(Ihandle* ih);
 
-// Send an action through the responder chain.
-// @param ih The ih belonging to the widget you want to send to. (IupCocoaGetMainView(ih) must be valid). If ih is NULL, this will send to the first responder (similar to what happens when you select a menu item).
-// @param value Should be the selector name including the colon. Case sensitive. e.g. "undo:", "redo:", "cut:", "copy:", "paste:", "pasteAsPlainText:"
-IUP_DRV_API int iupCocoaCommonBaseSetSendActionAttrib(Ihandle* ih, const char* value);
+/* Send an action through the responder chain (e.g., "undo:", "copy:"). */
+IUP_DRV_API int iupcocoaCommonBaseSetSendActionAttrib(Ihandle* ih, const char* value);
 
-
-// All keyDown: and keyUp: overrides can call this method to handle K_ANY, the Canvas Keypress, and HELP_CB.
-// Returns a boolean specifying if the caller_should_not_propagate. (Trying to conform to the iupgtk counterpart.) So if false, call super, otherwise skip.
-IUP_DRV_API bool iupCocoaKeyEvent(Ihandle *ih, NSEvent* ns_event, int mac_key_code, bool is_pressed);
-// All flagsChanged: overrides can call this function, which in turn calls iupCocoaKeyEvent() internally.
-// Returns a boolean specifying if the caller_should_not_propagate. (Trying to conform to the iupgtk counterpart.) So if false, call super, otherwise skip.
-IUP_DRV_API bool iupCocoaModifierEvent(Ihandle *ih, NSEvent* ns_event, int mac_key_code);
-
+/* Helpers for keyboard events. */
+IUP_DRV_API bool iupcocoaKeyEvent(Ihandle *ih, NSEvent* ns_event, int mac_key_code, bool is_pressed);
+IUP_DRV_API bool iupcocoaModifierEvent(Ihandle *ih, NSEvent* ns_event, int mac_key_code);
+IUP_DRV_API int iupcocoaKeyDecode(CGEventRef event);
 IUP_DRV_API void iupcocoaButtonKeySetStatus(NSEvent* ns_event, char* out_status);
 
+@interface IupCocoaFont : NSObject
 
-IUP_DRV_API IupCocoaFont* iupCocoaGetFont(Ihandle* ih);
+@property(nonatomic, retain) NSFont* nativeFont;
+@property(nonatomic, retain) NSString* iupFontName;
+@property(nonatomic, retain) NSString* typeFace;
+@property(nonatomic, retain) NSMutableDictionary* attributeDictionary;
+@property(nonatomic, assign) BOOL usesAttributes;
+@property(nonatomic, assign) int fontSize;
+@property(nonatomic, assign) int charWidth;
+@property(nonatomic, assign) int charHeight;
+@property(nonatomic, assign) int maxWidth;
+@property(nonatomic, assign) int ascent;
+@property(nonatomic, assign) int descent;
 
+@end
 
-int iupCocoaImageCaluclateBytesPerRow(int width, int bytes_per_pixel);
-NSBitmapImageRep* iupCocoaImageNSBitmapImageRepFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata);
-NSImage* iupCocoaImageNSImageFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata);
+IUP_DRV_API IupCocoaFont* iupcocoaGetFont(Ihandle* ih);
+IUP_DRV_API IupCocoaFont* iupcocoaFindFont(const char *iup_font_name);
 
+IUP_DRV_API void iupdrvTextAddBorders(Ihandle* ih, int *x, int *y);
 
+/* Image conversion helpers. */
+int iupcocoaImageCalculateBytesPerRow(int width, int bytes_per_pixel);
+NSBitmapImageRep* iupcocoaImageNSBitmapImageRepFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata);
+NSImage* iupcocoaImageNSImageFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata);
 
-// Kind of a hack to handle IUP_CLOSE for modal dialogs
-bool cocoaDialogExitModal(void);
+/* Handles IUP_CLOSE for modal dialogs. */
+bool cocoaDialogExitModal(Ihandle* ih);
 
+/* Get dialog window. */
+NSWindow* cocoaDialogGetWindow(Ihandle* ih);
 
-#if 0
-/* global variables, declared in iupmac_globalattrib.c */
-extern int iupmac_utf8autoconvert;         
+IUP_DRV_API void iupdrvDialogSetVisible(Ihandle* ih, int visible);
+IUP_DRV_API int iupdrvDialogIsVisible(Ihandle* ih);
 
+/* Focus control. */
+IUP_DRV_API void iupcocoaSetCanFocus(Ihandle* ih, int can);
+IUP_DRV_API void iupcocoaFocusIn(Ihandle* ih);
+IUP_DRV_API void iupcocoaFocusOut(Ihandle* ih);
 
-/* common */
-gboolean iupmacEnterLeaveEvent(GtkWidget *widget, GdkEventCrossing *evt, Ihandle* ih);
-gboolean iupmacShowHelp(GtkWidget *widget, GtkWidgetHelpType *arg1, Ihandle* ih);
-GtkFixed* iupmacBaseGetFixed(Ihandle* ih);
-void iupmacBaseAddToParent(Ihandle* ih);
-void iupgdkColorSet(GdkColor* color, unsigned char r, unsigned char g, unsigned char b);
-int iupmacSetDragDropAttrib(Ihandle* ih, const char* value);
-int iupmacSetMnemonicTitle(Ihandle* ih, GtkLabel* label, const char* value);
-char* iupmacStrConvertToUTF8(const char* str);
-char* iupmacStrConvertFromUTF8(const char* str);
-void iupmacReleaseConvertUTF8(void);
-char* iupmacStrConvertFromFilename(const char* str);
-char* iupmacStrConvertToFilename(const char* str);
-void iupmacUpdateMnemonic(Ihandle* ih);
-gboolean iupmacMotionNotifyEvent(GtkWidget *widget, GdkEventMotion *evt, Ihandle *ih);
-gboolean iupmacButtonEvent(GtkWidget *widget, GdkEventButton *evt, Ihandle *ih);
-void iupmacBaseSetBgColor(InativeHandle* handle, unsigned char r, unsigned char g, unsigned char b);
-void iupmacBaseSetFgColor(InativeHandle* handle, unsigned char r, unsigned char g, unsigned char b);
-void iupmacBaseSetFgGdkColor(InativeHandle* handle, GdkColor *color);
+/* System information */
+IUP_DRV_API int iupcocoaIsSystemDarkMode(void);
+void iupcocoaSetGlobalColors(void);
 
+/* Tray support */
+int iupcocoaTrayGetLastButton(void);
+int iupcocoaTrayGetLastDclick(void);
 
-/* focus */
-gboolean iupmacFocusInOutEvent(GtkWidget *widget, GdkEventFocus *evt, Ihandle* ih);
-
-
-/* key */
-gboolean iupmacKeyPressEvent(GtkWidget *widget, GdkEventKey *evt, Ihandle* ih);
-gboolean iupmacKeyReleaseEvent(GtkWidget *widget, GdkEventKey *evt, Ihandle* ih);
-void iupmacButtonKeySetStatus(guint state, unsigned int but, char* status, int doubleclick);
-// original code used guint. Not sure what those are; changing to NSUInteger
-// FIXME: file does not compile
-//void iupmacKeyEncode(int key, NSUInteger *keyval, NSUInteger *state);
-
-
-/* font */
-char* iupmacGetPangoFontDescAttrib(Ihandle *ih);
-char* iupmacGetFontIdAttrib(Ihandle *ih);
-PangoFontDescription* iupmacGetPangoFontDesc(const char* value);
-char* iupmacFindPangoFontDesc(PangoFontDescription* fontdesc);
-void iupmacFontUpdatePangoLayout(Ihandle* ih, PangoLayout* layout);
-void iupmacFontUpdateObjectPangoLayout(Ihandle* ih, gpointer object);
-
-
-/* open */
-char* iupmacGetNativeWindowHandle(Ihandle* ih);
-void iupmacPushVisualAndColormap(void* visual, void* colormap);
-void* iupmacGetNativeGraphicsContext(GtkWidget* widget);
-void iupmacReleaseNativeGraphicsContext(GtkWidget* widget, void* gc);
-void iupmacUpdateGlobalColors(GtkStyle* style);
-
-
-/* dialog */
-gboolean iupmacDialogDeleteEvent(GtkWidget *widget, GdkEvent *evt, Ihandle *ih);
-
-
-#endif
-
 #ifdef __cplusplus
 }
 #endif
 
-#endif
+#endif
\ No newline at end of file
Index: src/cocoa/iupcocoa_filedlg.m
===================================================================
--- src/cocoa/iupcocoa_filedlg.m	(revision 5971)
+++ src/cocoa/iupcocoa_filedlg.m	(working copy)
@@ -4,7 +4,8 @@
  * See Copyright Notice in "iup.h"
  */
 
-#include <Cocoa/Cocoa.h>
+#import <Cocoa/Cocoa.h>
+#import <objc/runtime.h>
 
 #include <stdlib.h>
 #include <string.h>
@@ -17,473 +18,622 @@
 #include "iup_object.h"
 #include "iup_attrib.h"
 #include "iup_str.h"
-#include "iup_drvinfo.h"
 #include "iup_dialog.h"
-#include "iup_strmessage.h"
-#include "iup_array.h"
-#include "iup_drvinfo.h"
+#include "iup_key.h"
 
 #include "iupcocoa_drv.h"
 
-#define MAX_FILENAME_SIZE PATH_MAX
-#define IUP_PREVIEWCANVAS 3000
 
 enum {IUP_DIALOGOPEN, IUP_DIALOGSAVE, IUP_DIALOGDIR};
-                           
-/*
-static void macFileDlgGetFolder(Ihandle *ih)
+
+/* Helper to get the next string in a list of null-separated strings. */
+static char* iupCocoaFileDlgGetNextStr(char* str)
 {
-  InativeHandle* parent = iupDialogGetNativeParent(ih);
-//  BROWSEINFO browseinfo;
-  char buffer[PATH_MAX];
+  int len = (int)strlen(str);
+  return str + len + 1;
+}
 
-  NSOpenPanel *op = [NSOpenPanel openPanel];
-  [op setCanChooseFiles:NO];
-  [op setCanChooseDirectories:YES];
-  [op setPrompt:@"Choose folder"];
-  [op setTitle: [NSString stringWithUTF8String:iupAttribGet(ih, "TITLE")]];
+@interface IupPreviewCanvasView : NSView
+@property(nonatomic, assign) Ihandle* ihandle;
+@end
 
-  if([op runModal] == NSOKButton) 
-  {           
-    strcpy(buffer,[[op filename] UTF8String]);                       
-    iupAttribStoreStr(ih, "VALUE", buffer);
-    iupAttribSetStr(ih, "STATUS", "0");	
-  }  
-  else 
+
+@implementation IupPreviewCanvasView
+
+- (BOOL)isFlipped
+{
+  return YES;
+}
+
+- (void)drawRect:(NSRect)dirtyRect
+{
+  Ihandle* ih = [self ihandle];
+  if (!ih) return;
+
+  IFnss cb = (IFnss)IupGetCallback(ih, "FILE_CB");
+  if (cb)
   {
-    iupAttribSetStr(ih, "VALUE", NULL);
-    iupAttribSetStr(ih, "STATUS", "-1");	
-  }  
+    NSSavePanel* file_panel = (NSSavePanel*)[(NSView*)[self superview] window];
+    NSString* path_str = [[file_panel URL] path];
+    BOOL is_dir;
 
-  iupAttribSetStr(ih, "FILEEXIST", NULL);
-  iupAttribSetStr(ih, "FILTERUSED", NULL);
+    if (path_str && [[NSFileManager defaultManager] fileExistsAtPath:path_str isDirectory:&is_dir] && !is_dir)
+    {
+      cb(ih, (char*)[path_str UTF8String], "PAINT");
+    }
+    else
+    {
+      cb(ih, NULL, "PAINT");
+    }
+  }
 }
-*/
-/*
-- (BOOL)panel:(id)sender shouldShowFilename:(NSString*)filename
-{    
-	return YES;
+
+- (void)updateTrackingAreas
+{
+  [super updateTrackingAreas];
+  NSTrackingArea* area = [[NSTrackingArea alloc] initWithRect:[self bounds]
+                                                      options:(NSTrackingMouseEnteredAndExited | NSTrackingMouseMoved | NSTrackingActiveInKeyWindow)
+                                                        owner:self userInfo:nil];
+  [self addTrackingArea:area];
+  [area release];
 }
- */
 
+- (void)mouseMoved:(NSEvent *)theEvent
+{
+  Ihandle* ih = [self ihandle];
+  IFniis cb = (IFniis)IupGetCallback(ih, "MOTION_CB");
+  if (cb)
+  {
+    NSPoint p = [self convertPoint:[theEvent locationInWindow] fromView:nil];
+    char status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+    iupcocoaButtonKeySetStatus(theEvent, status);
 
-// FIXME: NOOVERWRITEPROMPT This is going to require a delegate
-// FIXME: NOCHANGEDIR I don't know to support this. Apple manages this themselves. Maybe panel:didChangeToDirectoryURL:
-// TODO: FILTERUSED FILTERINFO
+    NSUInteger buttons = [NSEvent pressedMouseButtons];
+    if (buttons & (1 << 0)) iupKEY_SETBUTTON1(status);
+    if (buttons & (1 << 1)) iupKEY_SETBUTTON3(status);
+    if (buttons & (1 << 2)) iupKEY_SETBUTTON2(status);
 
-@interface IupOpenFilePanelDelegate : NSObject <NSOpenSavePanelDelegate>
+    cb(ih, (int)p.x, (int)p.y, status);
+  }
+}
 
-@property(nonatomic, assign) Ihandle* ihandle;
+- (void)mouseDown:(NSEvent *)theEvent
+{
+  Ihandle* ih = [self ihandle];
+  IFniiiis cb = (IFniiiis)IupGetCallback(ih, "BUTTON_CB");
+  if (cb)
+  {
+    NSPoint p = [self convertPoint:[theEvent locationInWindow] fromView:nil];
+    char status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+    int doubleclick = ([theEvent clickCount] > 1) ? 1 : 0;
+    int button = 0;
 
-- (BOOL) panel:(id)the_sender shouldEnableURL:(NSURL*)file_url;
+    switch ([theEvent buttonNumber])
+    {
+      case 0: button = IUP_BUTTON1; break;
+      case 1: button = IUP_BUTTON3; break;
+      case 2: button = IUP_BUTTON2; break;
+      default: button = (int)[theEvent buttonNumber] + 1; break;
+    }
 
-@end
+    iupcocoaButtonKeySetStatus(theEvent, status);
+    if(doubleclick) iupKEY_SETDOUBLE(status);
 
-@implementation IupOpenFilePanelDelegate
+    switch(button)
+    {
+      case IUP_BUTTON1: iupKEY_SETBUTTON1(status); break;
+      case IUP_BUTTON2: iupKEY_SETBUTTON2(status); break;
+      case IUP_BUTTON3: iupKEY_SETBUTTON3(status); break;
+      case IUP_BUTTON4: iupKEY_SETBUTTON4(status); break;
+      case IUP_BUTTON5: iupKEY_SETBUTTON5(status); break;
+    }
 
-- (void) dealloc
-{
-	[self setIhandle:nil];
-	[super dealloc];
+    int ret = cb(ih, button, 1, (int)p.x, (int)p.y, status);
+    if (ret == IUP_CLOSE)
+    {
+      IupExitLoop();
+    }
+  }
 }
 
-// This allows us to filter acceptable files.
-// Apple BUG: I'm seeing something that looks like a race condition sometimes where the panel first opens,
-// but this delegate callback does not get invoked.
-// The early entries in the panel do not get filtered as a result.
-// With both NSLog and breakpoints, I see the early entries do not go through this callback.
-// Seen in 10.13.6. I've only noticed under sandboxing so far.
-- (BOOL) panel:(id)the_sender shouldEnableURL:(NSURL*)file_url
+- (void)mouseUp:(NSEvent *)theEvent
 {
-	Ihandle* ih = [self ihandle];
-	
-	
-	
-	char* value = iupAttribGet(ih, "FILTER");
-    if(NULL == value)
+  Ihandle* ih = [self ihandle];
+  IFniiiis cb = (IFniiiis)IupGetCallback(ih, "BUTTON_CB");
+  if (cb)
+  {
+    NSPoint p = [self convertPoint:[theEvent locationInWindow] fromView:nil];
+    char status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+    int button = 0;
+
+    switch ([theEvent buttonNumber])
     {
-		NSLog(@"Matched NULL == value");
-		return YES;
-	}
-	
-	
-	// Check if the URL points to a directory.
-	// We want to say yes to directories otherwise the user can't click on them to change directories.
-	NSNumber* is_directory = nil;
-	BOOL success = [file_url getResourceValue:&is_directory forKey:NSURLIsDirectoryKey error:nil];
-	if(success && [is_directory boolValue])
-	{
-		
-		// Make sure the directory is not a bundle.
-		success = [file_url getResourceValue:&is_directory forKey:NSURLIsPackageKey error:nil];
-		if(success && ![is_directory boolValue])
-		{
-			return YES;
-		}
-	}
+      case 0: button = IUP_BUTTON1; break;
+      case 1: button = IUP_BUTTON3; break;
+      case 2: button = IUP_BUTTON2; break;
+      default: button = (int)[theEvent buttonNumber] + 1; break;
+    }
 
-	NSString* file_path = [file_url path];
-	// We want to filter only against the file name, and not the path.
-	NSString* file_name = [file_path lastPathComponent];
-	
-	NSString* semicolon_separated_string = [NSString stringWithUTF8String:value];
-	// The Windows version doesn't worry about extra white space, so I won't either.
-	NSArray* array_of_filters = [semicolon_separated_string componentsSeparatedByString:@";"];
+    iupcocoaButtonKeySetStatus(theEvent, status);
 
+    switch(button)
+    {
+      case IUP_BUTTON1: iupKEY_SETBUTTON1(status); break;
+      case IUP_BUTTON2: iupKEY_SETBUTTON2(status); break;
+      case IUP_BUTTON3: iupKEY_SETBUTTON3(status); break;
+      case IUP_BUTTON4: iupKEY_SETBUTTON4(status); break;
+      case IUP_BUTTON5: iupKEY_SETBUTTON5(status); break;
+    }
 
-#if 1 // Use NSPredicate
-	// Usually these things are case-insensitive, especially on Mac with its default-case-insensitive file-system.
-	file_name = [file_name lowercaseString];
+    int ret = cb(ih, button, 0, (int)p.x, (int)p.y, status);
+    if (ret == IUP_CLOSE)
+    {
+      IupExitLoop();
+    }
+  }
+}
 
-	for(NSString* match_pattern in array_of_filters)
-	{
-		match_pattern = [match_pattern lowercaseString];
+- (void)scrollWheel:(NSEvent *)theEvent
+{
+  Ihandle* ih = [self ihandle];
+  IFnfiis cb = (IFnfiis)IupGetCallback(ih, "WHEEL_CB");
+  if (cb)
+  {
+    NSPoint p = [self convertPoint:[theEvent locationInWindow] fromView:nil];
+    char status[IUPKEY_STATUS_SIZE] = IUPKEY_STATUS_INIT;
+    iupcocoaButtonKeySetStatus(theEvent, status);
 
-		NSPredicate* ns_predicate = [NSPredicate predicateWithFormat:@"self LIKE %@", match_pattern];
-		BOOL is_match = [ns_predicate evaluateWithObject:file_name];
-		if(YES == is_match)
-		{
-			// NSLog(@"Matched file: %@ to pattern: %@", file_path, match_pattern);
-			return YES;
-		}
-		else
-		{
-			//NSLog(@"NoMatch file: %@ to pattern: %@", file_path, match_pattern);
-		}
-	}
-	
-#else
-	// If the FILTER patterns are supposed to be regex, NSRegularExpression might map a little better than NSPredicate
-	// Oops: I don't think this interpretation is right because . (dot) is supposed to be explicit and not a any-character symbol.
-	// So I think NSPredicate is the correct solution.
+    NSUInteger buttons = [NSEvent pressedMouseButtons];
+    if (buttons & (1 << 0)) iupKEY_SETBUTTON1(status);
+    if (buttons & (1 << 1)) iupKEY_SETBUTTON3(status);
+    if (buttons & (1 << 2)) iupKEY_SETBUTTON2(status);
 
-	NSRange search_range = NSMakeRange(0, [file_name length]);
-	NSError* ns_error = nil;
+    float delta = [theEvent scrollingDeltaY];
+    cb(ih, delta, (int)p.x, (int)p.y, status);
+  }
+}
 
+@end
 
-	for(NSString* match_pattern in array_of_filters)
-	{
-		NSRegularExpression* regex = [NSRegularExpression regularExpressionWithPattern:match_pattern options:NSRegularExpressionCaseInsensitive error:&ns_error];
-		NSArray<NSTextCheckingResult*>* matches = [regex matchesInString:file_name options:0 range:search_range];
-		for(NSTextCheckingResult* match_result in matches)
-		{
-			NSRange match_range = [match_result range];
-			if(NSNotFound != match_range.location)
-			{
-				NSString* matched_text = [file_name substringWithRange:match_range];
-//				NSLog(@"matched_text: %@", matched_text);
-				return YES;
-			}
-		}
 
-	}
+@interface IupFilePanelDelegate : NSObject <NSOpenSavePanelDelegate>
+@property(nonatomic, assign) Ihandle* ihandle;
+@end
 
-#endif
 
+@implementation IupFilePanelDelegate
 
-	// NSLog(@"NoMatch for file: %@", file_path);
+- (void)dealloc
+{
+  Ihandle* ih = [self ihandle];
+  if (ih)
+  {
+    [self setIhandle:nil];
+  }
+  [super dealloc];
+}
 
-	return NO;
+- (BOOL)panel:(id)sender shouldEnableURL:(NSURL*)file_url
+{
+  Ihandle* ih = [self ihandle];
+  char* value = iupAttribGet(ih, "_COCOA_ACTIVE_FILTER");
+  if (NULL == value)
+  {
+    return YES;
+  }
+
+  BOOL is_directory;
+  if ([[NSFileManager defaultManager] fileExistsAtPath:[file_url path] isDirectory:&is_directory] && is_directory)
+  {
+    return YES;
+  }
+
+  NSString* file_name = [[file_url path] lastPathComponent];
+  NSString* semicolon_separated_string = [NSString stringWithUTF8String:value];
+  NSArray* array_of_filters = [semicolon_separated_string componentsSeparatedByString:@";"];
+
+  file_name = [file_name lowercaseString];
+  for (NSString* match_pattern in array_of_filters)
+  {
+    NSString* lower_pattern = [match_pattern lowercaseString];
+    NSPredicate* ns_predicate = [NSPredicate predicateWithFormat:@"self LIKE %@", lower_pattern];
+    if ([ns_predicate evaluateWithObject:file_name])
+    {
+      return YES;
+    }
+  }
+  return NO;
 }
 
-@end
+- (void)panelSelectionDidChange:(id)sender
+{
+  Ihandle* ih = [self ihandle];
+  IFnss cb = (IFnss)IupGetCallback(ih, "FILE_CB");
+  if (cb)
+  {
+    NSURL* url = [(NSSavePanel*)sender URL];
+    const char* path_utf8 = [[url path] UTF8String];
+    BOOL is_dir;
+    if ([[NSFileManager defaultManager] fileExistsAtPath:[url path] isDirectory:&is_dir] && !is_dir)
+    {
+      cb(ih, (char*)path_utf8, "SELECT");
+    }
+    else
+    {
+      cb(ih, (char*)path_utf8, "OTHER");
+    }
+  }
 
+  if (iupAttribGetBoolean(ih, "SHOWPREVIEW"))
+  {
+    NSSavePanel* file_panel = (NSSavePanel*)sender;
+    IupPreviewCanvasView* preview_view = (IupPreviewCanvasView*)[file_panel accessoryView];
+    if (preview_view)
+    {
+      [preview_view setNeedsDisplay:YES];
+    }
+  }
+}
 
+- (BOOL)panel:(id)sender validateURL:(NSURL *)url error:(NSError **)outError
+{
+  Ihandle* ih = [self ihandle];
+  IFnss cb = (IFnss)IupGetCallback(ih, "FILE_CB");
+  if (cb)
+  {
+    const char* path_utf8 = [[url path] UTF8String];
+    int ret = cb(ih, (char*)path_utf8, "OK");
+    if (ret == IUP_IGNORE)
+    {
+      return NO;
+    }
+    else if (ret == IUP_CONTINUE)
+    {
+      char* value = iupAttribGet(ih, "FILE");
+      if (value)
+      {
+        [(NSSavePanel*)sender setNameFieldStringValue:[NSString stringWithUTF8String:value]];
+      }
+      return NO;
+    }
+  }
+  return YES;
+}
 
+- (void)panel:(id)sender userDidClickHelp:(id)help
+{
+  Ihandle* ih = [self ihandle];
+  Icallback cb = (Icallback)IupGetCallback(ih, "HELP_CB");
+  if (cb && cb(ih) == IUP_CLOSE)
+  {
+    [[NSApplication sharedApplication] stopModal];
+  }
+}
 
+@end
+
+
 static int cocoaFileDlgPopup(Ihandle *ih, int x, int y)
 {
+  (void)x;
+  (void)y;
 
-//  InativeHandle* parent = iupDialogGetNativeParent(ih);
   char* value;
   int dialogtype;
-	NSInteger ret_val;
-	
-	// NSSavePanel is the base class for both save and open
-	NSSavePanel* file_panel = nil;
-//	NSSavePanel* save_panel = nil;
-//	NSOpenPanel* open_panel = nil;
 
-	NSMutableArray* extention_array = nil;
+  NSSavePanel* file_panel = nil;
+  NSMutableArray* extention_array = nil;
+  IupFilePanelDelegate* panel_delegate = nil;
 
-
-	NSObject* panel_delegate = nil;
-	
-
-  iupAttribSetInt(ih, "_IUPDLG_X", x);   /* used in iupDialogUpdatePosition */
-  iupAttribSetInt(ih, "_IUPDLG_Y", y);
-
-	// TODO: What does "DIR" mean in Cocoa???
-	// ???  [open_panel setCanChooseDirectories:YES];
-
   value = iupAttribGetStr(ih, "DIALOGTYPE");
   if (iupStrEqualNoCase(value, "SAVE"))
   {
     dialogtype = IUP_DIALOGSAVE;
+    file_panel = [NSSavePanel savePanel];
   }
   else if (iupStrEqualNoCase(value, "DIR"))
   {
-	dialogtype = IUP_DIALOGDIR;
-	NSOpenPanel* open_panel = [NSOpenPanel openPanel];
-	  [open_panel setCanChooseDirectories:YES];
-	  // ???
-	  [open_panel setCanChooseFiles:NO];
-
-	  // Symlinks automatically get resolved by Cocoa which can be nice, but this differs from the other implementions. So try to shut if off.
-	  [open_panel setResolvesAliases:NO];
-	  file_panel = open_panel;
-
-		IupOpenFilePanelDelegate* iup_panel_delegate = [[IupOpenFilePanelDelegate alloc] init];
-		[iup_panel_delegate setIhandle:ih];
-		[open_panel setDelegate:iup_panel_delegate];
-		panel_delegate = iup_panel_delegate;
+    dialogtype = IUP_DIALOGDIR;
+    NSOpenPanel* open_panel = [NSOpenPanel openPanel];
+    [open_panel setCanChooseDirectories:YES];
+    [open_panel setCanChooseFiles:NO];
+    [open_panel setResolvesAliases:NO];
+    file_panel = open_panel;
   }
   else
   {
     dialogtype = IUP_DIALOGOPEN;
-	  NSOpenPanel* open_panel = [NSOpenPanel openPanel];
-	  [open_panel setCanChooseDirectories:NO];
-	  [open_panel setCanChooseFiles:YES];
-	  file_panel = open_panel;
-		IupOpenFilePanelDelegate* iup_panel_delegate = [[IupOpenFilePanelDelegate alloc] init];
-		[iup_panel_delegate setIhandle:ih];
-		[open_panel setDelegate:iup_panel_delegate];
-		panel_delegate = iup_panel_delegate;
+    NSOpenPanel* open_panel = [NSOpenPanel openPanel];
+    [open_panel setCanChooseDirectories:NO];
+    [open_panel setCanChooseFiles:YES];
+    file_panel = open_panel;
   }
-	
-	
-  value = iupAttribGet(ih, "EXTFILTER");
-  if (value)
+
+  IFnss file_cb = (IFnss)IupGetCallback(ih, "FILE_CB");
+  Icallback help_cb = (Icallback)IupGetCallback(ih, "HELP_CB");
+
+  if (file_cb || help_cb)
   {
-	NSArray *arr = [[NSString stringWithUTF8String:value] componentsSeparatedByCharactersInSet:
-		[NSCharacterSet characterSetWithCharactersInString:@"|;"]];  
-	extention_array = [NSMutableArray arrayWithCapacity:[arr count]];
-	for(NSString *str in arr)
-	{
-	  if([str hasPrefix:@"*."]){
-		[extention_array addObject:[str substringFromIndex:2]];
-	  }
+    panel_delegate = [[IupFilePanelDelegate alloc] init];
+    [panel_delegate setIhandle:ih];
+    [file_panel setDelegate:panel_delegate];
+  }
+
+  if (file_cb)
+  {
+    file_cb(ih, NULL, "INIT");
+  }
+
+  (void)help_cb;
+
+  char* extfilter_val = iupAttribGet(ih, "EXTFILTER");
+  char* filter_val = iupAttribGet(ih, "FILTER");
+  iupAttribSet(ih, "_COCOA_ACTIVE_FILTER", NULL);
+  if (extfilter_val)
+  {
+    char* filters_dup = iupStrDup(extfilter_val);
+    int filter_count = iupStrReplace(filters_dup, '|', 0) / 2;
+    int filter_index = iupAttribGetInt(ih, "FILTERUSED");
+    if (filter_index == 0) filter_index = 1;
+
+    if (filter_index > 0 && filter_index <= filter_count)
+    {
+      char* name = filters_dup;
+      char* pattern = NULL;
+      for (int i = 0; i < filter_index; i++)
+      {
+        pattern = iupCocoaFileDlgGetNextStr(name);
+        if (i < filter_index - 1)
+          name = iupCocoaFileDlgGetNextStr(pattern);
+      }
+      iupAttribSetStr(ih, "_COCOA_ACTIVE_FILTER", pattern);
     }
+    free(filters_dup);
   }
-  else 
+  else if (filter_val)
   {
-    value = iupAttribGet(ih, "FILTER");
-    if (value)
+    iupAttribSetStr(ih, "_COCOA_ACTIVE_FILTER", filter_val);
+  }
+
+  char* active_filter = iupAttribGet(ih, "_COCOA_ACTIVE_FILTER");
+  if (active_filter)
+  {
+    NSArray* arr = [[NSString stringWithUTF8String:active_filter] componentsSeparatedByString:@";"];
+    extention_array = [NSMutableArray arrayWithCapacity:[arr count]];
+    for (NSString* str in arr)
     {
-		NSArray *arr = [[NSString stringWithUTF8String:value] componentsSeparatedByCharactersInSet:
-			[NSCharacterSet characterSetWithCharactersInString:@"|;"]];  
-		extention_array = [NSMutableArray arrayWithCapacity:[arr count]];
-		for(NSString *str in arr)
-		{
-		  if([str hasPrefix:@"*."]){
-			[extention_array addObject:[str substringFromIndex:2]];
-		  }
-	    }
+      if ([str hasPrefix:@"*."])
+      {
+        [extention_array addObject:[str substringFromIndex:2]];
+      }
     }
+    if ([extention_array count] > 0)
+    {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+      [file_panel setAllowedFileTypes:extention_array];
+#pragma clang diagnostic pop
+    }
   }
 
-//  openfilename.lpstrFile = (char*)malloc(MAX_FILENAME_SIZE+1);
   value = iupAttribGet(ih, "FILE");
-  if(value && 0!=*value)
+  if (value && *value && strchr(value, '/'))
   {
-	[file_panel setNameFieldStringValue:[NSString stringWithUTF8String:value]];
+    char* dir = iupStrFileGetPath(value);
+    const char* filename = iupStrFileGetTitle(value);
+    iupAttribSetStr(ih, "DIRECTORY", dir);
+    iupAttribSetStr(ih, "FILE", filename);
+    free(dir);
   }
 
-	value = iupAttribGet(ih, "DIRECTORY");
-	if(value && 0!=*value)
-	{
-		NSString* ns_string = [NSString stringWithUTF8String:value];
-		NSURL* ns_url = [NSURL URLWithString:ns_string];
-		[file_panel setDirectoryURL:ns_url];
-	}
+  value = iupAttribGet(ih, "FILE");
+  if (value && *value)
+  {
+    [file_panel setNameFieldStringValue:[NSString stringWithUTF8String:value]];
+  }
 
-	value = iupAttribGet(ih, "TITLE");
-	if(value && 0!=*value)
-	{
-		NSString* ns_string = [NSString stringWithUTF8String:value];
-		[file_panel setTitle:ns_string];
-	}
+  value = iupAttribGet(ih, "DIRECTORY");
+  if (value && *value)
+  {
+    NSURL* ns_url = [NSURL fileURLWithPath:[NSString stringWithUTF8String:value]];
+    [file_panel setDirectoryURL:ns_url];
+  }
 
-	
+  value = iupAttribGet(ih, "TITLE");
+  if (value && *value)
+  {
+    [file_panel setTitle:[NSString stringWithUTF8String:value]];
+  }
 
-	if(iupAttribGetBoolean(ih, "SHOWHIDDEN"))
-	{
-		[file_panel setShowsHiddenFiles:YES];
+  if (iupAttribGetBoolean(ih, "SHOWHIDDEN"))
+  {
+    [file_panel setShowsHiddenFiles:YES];
+  }
 
-	}
+  if (iupAttribGet(ih, "ALLOWNEW"))
+  {
+    [file_panel setCanCreateDirectories:iupAttribGetBoolean(ih, "ALLOWNEW")];
+  }
 
-  value = iupAttribGet(ih, "ALLOWNEW");
-  if(value)
+  if (iupAttribGetBoolean(ih, "SHOWPREVIEW") && file_cb)
   {
-	  
-	  // Should we prevent this for openPanel? No. Example: BlurrrGenProj uses an Open panel to choose a directory to create a project in. Need to be able for the user to create new subdirectories.
-	  // TODO: FIXME: We're going to have to revise the official documentation/API because it says this has no-effect when DIR, but we need it.
-	  int allow_new = iupAttribGetBoolean(ih, "ALLOWNEW");
-	  [file_panel setCanCreateDirectories:allow_new];
+    int width = iupAttribGetInt(ih, "PREVIEWWIDTH");
+    int height = iupAttribGetInt(ih, "PREVIEWHEIGHT");
+    if (width <= 0) width = 200;
+    if (height <= 0) height = 150;
 
-	  
+    IupPreviewCanvasView* preview_view = [[IupPreviewCanvasView alloc] initWithFrame:NSMakeRect(0, 0, width, height)];
+    [preview_view setIhandle:ih];
+    [file_panel setAccessoryView:preview_view];
+    iupAttribSetInt(ih, "PREVIEWWIDTH", width);
+    iupAttribSetInt(ih, "PREVIEWHEIGHT", height);
+
+    ih->handle = (InativeHandle*)preview_view;
+    iupcocoaSetAssociatedViews(ih, preview_view, preview_view);
+
+    [preview_view release];
   }
 
-  if (iupAttribGetBoolean(ih, "MULTIPLEFILES"))
+  if (dialogtype != IUP_DIALOGSAVE && iupAttribGetBoolean(ih, "MULTIPLEFILES"))
   {
-	  // only valid for NSOpenPanel
-	  if(iupStrEqualNoCase(value, "SAVE"))
-	  {
-		  
-	  }
-	  else
-	  {
-		  [(NSOpenPanel*)file_panel setAllowsMultipleSelection:YES];
-		  
-	  }
+    [(NSOpenPanel*)file_panel setAllowsMultipleSelection:YES];
+  }
 
+  NSInteger response = [file_panel runModal];
+
+  if (file_cb)
+  {
+    file_cb(ih, NULL, "FINISH");
   }
-	
-	
-	// FIXME: Supporting PARENTDIALOG might not work.
-	// Iup assumes that this method blocks and is completely modal.
-	// Cocoa doesn't really like modal windows at all.
-	// The modal sheets will only block for a specific window, but in theory, other windows should still be interactive, plus the menu.
-	// Cocoa wants to return immediately from creating a sheet which violates Iup assupmtions.
-	// I have a hack in place to block the executtion flow, but I think it may break down in complex window states.
-	// We may need to disable this feature.
-	value = iupAttribGet(ih, "PARENTDIALOG");
-	if(value)
-	{
-		InativeHandle* parent = iupDialogGetNativeParent(ih);
-//		InativeHandle* parent = IupGetParent(ih);
 
-		NSWindow* parent_window = nil;
-		if([(id)parent isKindOfClass:[NSWindow class]])
-		{
-			parent_window = parent;
-			
-		}
-		else if([(id)parent isKindOfClass:[NSView class]])
-		{
-			parent_window = [(id)parent window];
-		}
-		else
-		{
-		}
-		__block NSInteger up_val_result = -1;
-		__block BOOL up_val_did_complete = NO;
+  iupAttribSet(ih, "FILTERUSED", NULL);
 
-		[file_panel beginSheetModalForWindow:parent_window
-			completionHandler:^(NSInteger the_result)
-			{
-				up_val_result = the_result;
-				up_val_did_complete = YES;
-			}
-		 ];
-		
-		
-		// HACK: Iup wants this method to block, but this method returns immediately (the completion handler blocks).
-		// This spin-blocking might work for the basic case, but I'm worried it's going to be buggy in complex cases.
-		// For example, what if other window buttons are still exposed; the user can interact with those.
-		// Or the user can hit Quit in the menu.
-		while(NO == up_val_did_complete)
-		{
-#if 0
-			NSEvent* ns_event;
-			ns_event = [NSApp
-					 nextEventMatchingMask:NSAnyEventMask
-					 untilDate:[NSDate dateWithTimeIntervalSinceNow:0.0]
-					 inMode:NSDefaultRunLoopMode
-					 dequeue:YES
-			];
-			[NSApp sendEvent:ns_event];
-#else
-			
-			IupLoopStep();
-#endif
-		}
-		
+  if (response == NSModalResponseOK)
+  {
+    if (dialogtype == IUP_DIALOGSAVE)
+    {
+      NSURL* ns_url = [file_panel URL];
+      NSString* path = [ns_url path];
 
-		
-		
-		 ret_val = up_val_result;
-		
-	}
-	else
-	{
-		ret_val = [file_panel runModal];
-	}
-	
-	if(ret_val == NSModalResponseOK)
-	{
-		
-		// Slightly different things for save vs open, so let's split them up
-		if(iupStrEqualNoCase(value, "SAVE"))
-		{
-			NSURL* ns_url = [file_panel URL];
+      char* ext_default = iupAttribGet(ih, "EXTDEFAULT");
+      if (ext_default && strlen(ext_default) > 0 && [[path pathExtension] length] == 0)
+      {
+        path = [path stringByAppendingPathExtension:[NSString stringWithUTF8String:ext_default]];
+      }
 
-			// For STATUS, we must return 1 for a new file, 0 for an existing file.
-			// A delegate callback might allow us to handle this more directly.
-			if([[NSFileManager defaultManager] fileExistsAtPath:[ns_url path]])
-			{
-				iupAttribSetInt(ih, "STATUS", 0);
-				// TODO: maybe not set DIALOGTYPE=DIR or MULTIPLEFILES=YES
-				iupAttribSetInt(ih, "FILEEXIST", 1);
+      iupAttribSetStr(ih, "VALUE", [path UTF8String]);
+      if ([[NSFileManager defaultManager] fileExistsAtPath:path])
+      {
+        iupAttribSet(ih, "STATUS", "0");
+        iupAttribSet(ih, "FILEEXIST", "YES");
+      }
+      else
+      {
+        iupAttribSet(ih, "STATUS", "1");
+        iupAttribSet(ih, "FILEEXIST", "NO");
+      }
+    }
+    else
+    {
+      if (dialogtype != IUP_DIALOGDIR && iupAttribGetBoolean(ih, "MULTIPLEFILES"))
+      {
+        NSArray* array_of_urls = [(NSOpenPanel*)file_panel URLs];
+        int count = (int)[array_of_urls count];
 
-				
-			}
-			else
-			{
-				iupAttribSetInt(ih, "STATUS", 1);
-				// TODO: maybe not set DIALOGTYPE=DIR or MULTIPLEFILES=YES
-				iupAttribSetInt(ih, "FILEEXIST", 0);
-			}
-			
-			iupAttribSetStr(ih, "VALUE", [[[file_panel URL] path] UTF8String]);
-			
-		}
-		else
-		{
-			if(iupAttribGetBoolean(ih, "MULTIPLEFILES") && !iupStrEqualNoCase(value, "SAVE"))
-			{
-				NSArray* array_of_urls = [(NSOpenPanel*)file_panel URLs];
-				
-				 
-				NSMutableArray* array_of_strings = [NSMutableArray arrayWithCapacity:[array_of_urls count]];
-				
-				// TODO: implement MULTIVALUEid
-				for(NSURL* a_url in array_of_urls)
-				{
-					[array_of_strings addObject:[a_url path]];
-				}
-				NSString* joined_path = [array_of_strings componentsJoinedByString:@"|"];
-				joined_path = [joined_path stringByAppendingString:@"|"];
+        if (count == 1)
+        {
+          NSURL* url = [array_of_urls firstObject];
+          const char* filename_utf8 = [[url path] UTF8String];
+          char* dir = iupStrFileGetPath(filename_utf8);
 
-				// Should this be fileSystemRepresentation? Not sure it will work with the | separators.
-				iupAttribSetStr(ih, "VALUE", [joined_path UTF8String]);
-				iupAttribSetInt(ih, "MULTIVALUECOUNT", (int)[array_of_urls count]);
-				
-			}
-			else
-			{
-				// Not using fileSystemRepresentation to be consistent with above
-				iupAttribSetStr(ih, "VALUE", [[[file_panel URL] path] UTF8String]);
-				
-			}
-			
-			
-			// TODO: FILTERUSED
-			iupAttribSetStr(ih, "FILTERUSED", NULL);
+          iupAttribSetStr(ih, "VALUE", filename_utf8);
+          iupAttribSetStr(ih, "DIRECTORY", dir);
+          iupAttribSetStrId(ih, "MULTIVALUE", 0, dir);
 
-		}
-	}
-	else // user cancelled
-	{
-		iupAttribSetStr(ih, "VALUE", NULL);
-		iupAttribSetInt(ih, "STATUS", -1);
-	}
+          int dir_len = (int)strlen(dir);
+          if (iupAttribGetBoolean(ih, "MULTIVALUEPATH"))
+            dir_len = 0;
 
+          iupAttribSetStrId(ih, "MULTIVALUE", 1, filename_utf8 + dir_len);
+          iupAttribSetInt(ih, "MULTIVALUECOUNT", 2);
+          free(dir);
+        }
+        else if (count > 1)
+        {
+          NSURL* first_url = [array_of_urls firstObject];
+          char* dir_with_sep = iupStrFileGetPath([[first_url path] UTF8String]);
 
-	[panel_delegate release];
-	
+          iupAttribSetStr(ih, "DIRECTORY", dir_with_sep);
+          iupAttribSetStrId(ih, "MULTIVALUE", 0, dir_with_sep);
+
+          char* dir_no_sep = iupStrDup(dir_with_sep);
+          int dir_len = (int)strlen(dir_no_sep);
+          if (dir_len > 1 && dir_no_sep[dir_len - 1] == '/')
+          {
+            dir_no_sep[dir_len - 1] = '\0';
+          }
+
+          NSMutableString* value_str = [NSMutableString stringWithUTF8String:dir_no_sep];
+          [value_str appendString:@"|"];
+          free(dir_no_sep);
+
+          BOOL use_full_path = iupAttribGetBoolean(ih, "MULTIVALUEPATH");
+          int multivalue_idx = 1;
+
+          for (NSURL* a_url in array_of_urls)
+          {
+            NSString* path_str = [a_url path];
+
+            if (use_full_path)
+            {
+              /* Append the full path for both VALUE and MULTIVALUE. */
+              [value_str appendString:path_str];
+              [value_str appendString:@"|"];
+              iupAttribSetStrId(ih, "MULTIVALUE", multivalue_idx, [path_str UTF8String]);
+            }
+            else
+            {
+              /* Append just the filename for both VALUE and MULTIVALUE. */
+              NSString* filename_str = [path_str lastPathComponent];
+              [value_str appendString:filename_str];
+              [value_str appendString:@"|"];
+              iupAttribSetStrId(ih, "MULTIVALUE", multivalue_idx, [filename_str UTF8String]);
+            }
+            multivalue_idx++;
+          }
+
+          iupAttribSetStr(ih, "VALUE", [value_str UTF8String]);
+          iupAttribSetInt(ih, "MULTIVALUECOUNT", multivalue_idx);
+
+          free(dir_with_sep);
+        }
+      }
+      else
+      {
+        NSURL* url = [(NSOpenPanel*)file_panel URL];
+        const char* path_utf8 = [[url path] UTF8String];
+        iupAttribSetStr(ih, "VALUE", path_utf8);
+
+        if (dialogtype == IUP_DIALOGDIR)
+        {
+          iupAttribSet(ih, "FILEEXIST", NULL);
+          iupAttribSet(ih, "STATUS", "0");
+        }
+        else
+        {
+          if ([[NSFileManager defaultManager] fileExistsAtPath:[url path]])
+          {
+            iupAttribSet(ih, "FILEEXIST", "YES");
+            iupAttribSet(ih, "STATUS", "0");
+          }
+          else
+          {
+            iupAttribSet(ih, "FILEEXIST", "NO");
+            iupAttribSet(ih, "STATUS", "1");
+          }
+        }
+      }
+    }
+  }
+  else
+  {
+    iupAttribSet(ih, "VALUE", NULL);
+    iupAttribSet(ih, "STATUS", "-1");
+    iupAttribSet(ih, "FILEEXIST", NULL);
+  }
+
+  if (panel_delegate)
+  {
+    [file_panel setDelegate:nil];
+    [panel_delegate release];
+  }
+
+  if (iupAttribGetBoolean(ih, "SHOWPREVIEW"))
+  {
+    ih->handle = NULL;
+  }
+
   return IUP_NOERROR;
-
 }
 
 void iupdrvFileDlgInitClass(Iclass* ic)
@@ -490,8 +640,12 @@
 {
   ic->DlgPopup = cocoaFileDlgPopup;
 
+  /* IupFileDialog common */
   iupClassRegisterAttribute(ic, "EXTFILTER", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FILTERINFO", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FILTERUSED", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "MULTIPLEFILES", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+
+  /* macOS and GTK only */
+  iupClassRegisterAttribute(ic, "PREVIEWWIDTH", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "PREVIEWHEIGHT", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_focus.m
===================================================================
--- src/cocoa/iupcocoa_focus.m	(revision 5971)
+++ src/cocoa/iupcocoa_focus.m	(working copy)
@@ -1,54 +1,126 @@
 /** \file
- * \brief MAC Focus
+ * \brief macOS Focus
  *
  * See Copyright Notice in "iup.h"
  */
 
-#include <Cocoa/Cocoa.h>
+#import <Cocoa/Cocoa.h>
 
 #include <stdio.h>
 
 #include "iup.h"
-
 #include "iup_object.h"
 #include "iup_focus.h"
 #include "iup_attrib.h"
 #include "iup_drv.h"
-#include "iup_assert.h" 
-#include "iup_drv.h" 
+#include "iup_assert.h"
 
 #include "iupcocoa_drv.h"
 
 
+void iupcocoaSetCanFocus(Ihandle* ih, int can)
+{
+  if (!ih)
+    return;
+
+  /* Controls check this in acceptsFirstResponder */
+  if (can)
+    iupAttribSet(ih, "_IUPCOCOA_CANFOCUS", "YES");
+  else
+    iupAttribSet(ih, "_IUPCOCOA_CANFOCUS", "NO");
+}
+
 void iupdrvSetFocus(Ihandle *ih)
-{               
-//  [ih->handle makeFirstResponder: self];
-	id the_object = ih->handle;
-	if([the_object isKindOfClass:[NSWindow class]])
-	{
-		[(NSWindow*)the_object makeKeyAndOrderFront:nil];
-	}
-	else if([the_object isKindOfClass:[NSView class]])
-	{
-		[[(NSView*)the_object window] makeFirstResponder:the_object];
-	}
+{
+  if (!ih || !ih->handle)
+  {
+    return;
+  }
 
+  id native_handle = ih->handle;
+  NSWindow* target_window = nil;
+  NSView* view_to_focus = nil;
 
-	
+  if ([native_handle isKindOfClass:[NSWindow class]])
+  {
+    target_window = (NSWindow*)native_handle;
+    view_to_focus = [target_window contentView];
+  }
+  else
+  {
+    view_to_focus = iupcocoaGetMainView(ih);
+    if (view_to_focus)
+    {
+      target_window = [view_to_focus window];
+    }
+  }
+
+  if (target_window && view_to_focus)
+  {
+    BOOL is_key = [target_window isKeyWindow];
+    if (!is_key)
+    {
+      [target_window makeKeyAndOrderFront:nil];
+    }
+
+    BOOL accepts = [view_to_focus acceptsFirstResponder];
+    if (accepts)
+    {
+      BOOL result = [target_window makeFirstResponder:view_to_focus];
+      if (result)
+      {
+        iupcocoaFocusIn(ih);
+      }
+    }
+  }
 }
 
-// GTK uses this for the Canvas focus callbacks. 
-/*
-void iupcocoaFocusInOutEvent(Ihandle *ih)
+void iupcocoaFocusIn(Ihandle* ih)
 {
+  if (IupGetFocus() == ih)
+  {
+    return;
+  }
 
-  if (evt->in)
+  if (!iupObjectCheck(ih) || !iupdrvIsActive(ih))
   {
-    iupCallGetFocusCb(ih);
+    return;
   }
+
+  Ihandle* dialog = IupGetDialog(ih);
+  if (!dialog)
+    return;
+
+  if (ih != dialog)
+  {
+    iupAttribSet(dialog, "_IUPCOCOA_LASTFOCUS", (char*)ih);
+  }
   else
-    iupCallKillFocusCb(ih);
+  {
+    Ihandle* last_focus = (Ihandle*)iupAttribGet(dialog, "_IUPCOCOA_LASTFOCUS");
 
-  return FALSE; 
+    if (iupObjectCheck(last_focus))
+    {
+      iupCallGetFocusCb(ih);
+
+      if (!iupAttribGetBoolean(ih, "IGNORELASTFOCUS"))
+      {
+        IupSetFocus(last_focus);
+      }
+
+      return;
+    }
+  }
+
+  iupCallGetFocusCb(ih);
 }
-*/
+
+void iupcocoaFocusOut(Ihandle* ih)
+{
+  if (!iupObjectCheck(ih))
+  {
+    return;
+  }
+
+  iupCallKillFocusCb(ih);
+}
Index: src/cocoa/iupcocoa_font.m
===================================================================
--- src/cocoa/iupcocoa_font.m	(revision 5971)
+++ src/cocoa/iupcocoa_font.m	(working copy)
@@ -4,568 +4,447 @@
  * See Copyright Notice in "iup.h"
  */
 
-
+#import <Cocoa/Cocoa.h>
 #include <stdlib.h>
 #include <stdio.h>
 
-#import <Cocoa/Cocoa.h>
-
 #include "iup.h"
 
-#include "iup_str.h"
 #include "iup_array.h"
+#include "iup_assert.h"
 #include "iup_attrib.h"
-#include "iup_object.h"
 #include "iup_drv.h"
 #include "iup_drvfont.h"
-#include "iup_assert.h"
+#include "iup_drvinfo.h"
+#include "iup_object.h"
+#include "iup_str.h"
 
 #include "iupcocoa_drv.h"
 
-//#include "iupmac_info.h"
-#include "IupCocoaFont.h"
-
 @implementation IupCocoaFont
 
-// In manual mode (non-ARC), we are still responsible for releasing sythesized properties, even when there is no explicit ivar.
-- (void) dealloc
+- (void)dealloc
 {
-	[self setNativeFont:nil];
-	[self setIupFontName:nil];
-	[self setTypeFace:nil];
-	[self setAttributeDictionary:nil];
-	[super dealloc];
+  [self setNativeFont:nil];
+  [self setIupFontName:nil];
+  [self setTypeFace:nil];
+  [self setAttributeDictionary:nil];
+  [super dealloc];
 }
 
 @end
 
-// We keep all the fonts in a data structure so we can release them on shutdown because IUP doesn't have an explicit life-cycle for individual fonts.
-// Even though I believe Apple caches NSFont, because we have our own additional object wrapper with additional properties, we might as well do our own caching.
-static NSMutableDictionary<NSString*, IupCocoaFont*>* s_mapOfFonts = nil;
-// This is for easy access to our system font since it is used so often.
-static IupCocoaFont* s_systemFont = nil;
-static IupCocoaFont* s_labelFont = nil;
-#ifdef IUPCOCOA_USE_SEPARATE_DEFAULT_FONT
-	static IupCocoaFont* s_defaultFont = nil;
-#endif
+/* We keep all the fonts in a data structure so we can release them on shutdown. */
+static NSMutableDictionary<NSString *, IupCocoaFont *> *s_mapOfFonts = nil;
+/* This is for easy access to our system font since it is used so often. */
+static IupCocoaFont *s_systemFont = nil;
 
-static IupCocoaFont* cocoaCreateIupCocoaFontFromNSFont(NSFont* ns_font)
+static IupCocoaFont *cocoaCreateIupCocoaFontFromNSFont(NSFont *ns_font)
 {
-	IupCocoaFont* the_font = [[IupCocoaFont alloc] init];
-	[the_font autorelease];
-	
-	
-	NSMutableDictionary* attribute_dict = [[NSMutableDictionary alloc] init];
-	[attribute_dict autorelease];
-	
-	
-	
-	[attribute_dict setValue:ns_font forKey:NSFontAttributeName];
+  IupCocoaFont *the_font = [[IupCocoaFont alloc] init];
+  [the_font autorelease];
 
-	[the_font setNativeFont:ns_font];
-	[the_font setAttributeDictionary:attribute_dict];
+  NSMutableDictionary *attribute_dict = [[NSMutableDictionary alloc] init];
+  [attribute_dict autorelease];
+  [attribute_dict setValue:ns_font forKey:NSFontAttributeName];
 
-	/*
-	familyName: .AppleSystemUIFont
-	fontName: .AppleSystemUIFont
-	displayName: System Font Regular
-	*/
-	int font_size = (int)[ns_font pointSize];
-	NSString* ns_font_name = [ns_font fontName];
-	// Remove leading dot?
-	//ns_font_name = [ns_font_name stringByReplacingOccurrencesOfString:@"." withString:@""];
-	NSString* ns_iup_font_name = [NSString stringWithFormat:@"%@, %d", ns_font_name, font_size];
-//		NSLog(@"ns_iup_font_name: %@", ns_iup_font_name);
-	[the_font setIupFontName:ns_iup_font_name];
-	[the_font setFontSize:font_size];
-	[the_font setTypeFace:ns_font_name];
-//	[the_font setTraitMask:0];
+  [the_font setNativeFont:ns_font];
+  [the_font setAttributeDictionary:attribute_dict];
 
+  int font_size = (int)[ns_font pointSize];
+  NSString *ns_font_name = [ns_font fontName];
+  NSString *ns_iup_font_name = [NSString stringWithFormat:@"%@, %d", ns_font_name, font_size];
 
-	NSLayoutManager *lm = [[NSLayoutManager alloc] init];
-	int char_height = iupROUND([lm defaultLineHeightForFont:ns_font]);
-	[the_font setCharHeight:char_height];
-	[lm release];
+  [the_font setIupFontName:ns_iup_font_name];
+  [the_font setFontSize:font_size];
+  [the_font setTypeFace:ns_font_name];
 
-	// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/Tasks/StringHeight.html#//apple_ref/doc/uid/20001809-CJBGBIBB
-	// defaultLineHeightForFont: 16
-	// boundingRectForFont: (width = 21.099609375, height = 17.6337890625)
-	NSRect rect = [ns_font boundingRectForFont];
-	int char_width = iupROUND(rect.size.width);
-	[the_font setCharWidth:char_width];
+  /* Use NSTextFieldCell to get the actual line height it uses for rendering. */
+  NSTextFieldCell* tempCell = [[NSTextFieldCell alloc] initTextCell:@"Wj"];
+  [tempCell setFont:ns_font];
+  [tempCell setWraps:YES];
+  NSSize singleLineSize = [tempCell cellSizeForBounds:NSMakeRect(0, 0, CGFLOAT_MAX, CGFLOAT_MAX)];
+  [tempCell release];
+  int char_height = iupROUND(singleLineSize.height);
+  [the_font setCharHeight:char_height];
 
+  /* For average char width, use the advancement of a common character like 'x'.
+     This is a better approximation than using the font's bounding box. */
+  NSGlyph x_glyph = [ns_font glyphWithName:@"x"];
+  NSSize x_size = [ns_font advancementForGlyph:x_glyph];
+  int char_width = iupROUND(x_size.width);
+  [the_font setCharWidth:char_width];
 
-	return the_font;
-}
+  /* Get dimensions for iupdrvFontGetFontDim */
+  int max_width = iupROUND([ns_font maximumAdvancement].width);
+  [the_font setMaxWidth:max_width];
 
-static IupCocoaFont* cocoaGetSystemFont()
-{
-	if(nil == s_systemFont)
-	{
-		NSFont* ns_font = [NSFont systemFontOfSize:0];
-		IupCocoaFont* iup_font = cocoaCreateIupCocoaFontFromNSFont(ns_font);
-		s_systemFont = [iup_font retain];
-		
-		// Add to global map
-		NSCAssert(s_mapOfFonts, @"s_mapOfFonts must be initialized");
-		[s_mapOfFonts setObject:s_systemFont forKey:[iup_font iupFontName]];
-	}
-	return s_systemFont;
-}
+  int ascent = iupROUND([ns_font ascender]);
+  [the_font setAscent:ascent];
 
-static IupCocoaFont* cocoaGetLabelFont()
-{
-	if(nil == s_labelFont)
-	{
-		NSFont* ns_font = [NSFont labelFontOfSize:0];
-		IupCocoaFont* iup_font = cocoaCreateIupCocoaFontFromNSFont(ns_font);
-		s_labelFont = [iup_font retain];
-		
-		// Add to global map
-		NSCAssert(s_mapOfFonts, @"s_mapOfFonts must be initialized");
-		[s_mapOfFonts setObject:s_labelFont forKey:[iup_font iupFontName]];
-	}
-	return s_labelFont;
+  /* descender is a negative value */
+  int descent = iupROUND(-[ns_font descender]);
+  [the_font setDescent:descent];
+
+  return the_font;
 }
 
-#ifdef IUPCOCOA_USE_SEPARATE_DEFAULT_FONT
-static IupCocoaFont* cocoaGetDefaultFont()
+static IupCocoaFont *cocoaGetSystemFont()
 {
-	if(nil == s_defaultFont)
-	{
-		NSFont* ns_font = [NSFont systemFontOfSize:0];
-		IupCocoaFont* iup_font = cocoaCreateIupCocoaFontFromNSFont(ns_font);
-		s_defaultFont = [iup_font retain];
-		
-		[iup_font setDefaultFont:true];
-		[iup_font setTypeFace:@"Default"];
-		[iup_font setIupFontName:@"Default, 13"];
+  if (nil == s_systemFont)
+  {
+    NSFont *ns_font;
 
-		// Add to global map
-		NSCAssert(s_mapOfFonts, @"s_mapOfFonts must be initialized");
-		[s_mapOfFonts setObject:s_defaultFont forKey:[iup_font iupFontName]];
-	}
-	return s_defaultFont;
-}
+#if defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
+    /* Use modern API on macOS 11+ */
+    NSOperatingSystemVersion version = {11, 0, 0};
+    if ([[NSProcessInfo processInfo] isOperatingSystemAtLeastVersion:version])
+    {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunguarded-availability-new"
+      ns_font = [NSFont preferredFontForTextStyle:NSFontTextStyleBody options:@{}];
+#pragma clang diagnostic pop
+    }
+    else
 #endif
+    {
+      /* Fall back to legacy API (or when SDK doesn't have macOS 11+ APIs) */
+      ns_font = [NSFont messageFontOfSize:0];
+    }
 
-char* iupdrvGetSystemFont(void)
+    IupCocoaFont *iup_font = cocoaCreateIupCocoaFontFromNSFont(ns_font);
+    s_systemFont = [iup_font retain];
+
+    /* Add to global map */
+    NSCAssert(s_mapOfFonts, @"s_mapOfFonts must be initialized");
+    [s_mapOfFonts setObject:s_systemFont forKey:[iup_font iupFontName]];
+  }
+  return s_systemFont;
+}
+
+IUP_SDK_API char *iupdrvGetSystemFont(void)
 {
-	static char system_font_cstr[200] = "";
-	if(system_font_cstr[0] == '\0')
-	{
-#ifdef IUPCOCOA_USE_SEPARATE_DEFAULT_FONT
-	    // This actually gets the "default font", which is different than the system font (and the label font)
-		if(nil == s_defaultFont)
-		{
-			// make sure font system was initialized
-			iupdrvFontInit();
-			cocoaGetDefaultFont();
-		}
-	    strlcpy(system_font_cstr, [[s_defaultFont iupFontName] UTF8String], 200);
-#else
-		if(nil == s_systemFont)
-		{
-			// make sure font system was initialized
-			iupdrvFontInit();
-			cocoaGetSystemFont();
-		}
-	    strlcpy(system_font_cstr, [[s_systemFont iupFontName] UTF8String], 200);
-#endif
-	}
-	return (char*)system_font_cstr;
+  static char system_font_cstr[200] = "";
+  if (system_font_cstr[0] == '\0')
+  {
+    if (nil == s_systemFont)
+    {
+      /* make sure font system was initialized */
+      iupdrvFontInit();
+      cocoaGetSystemFont();
+    }
+    strlcpy(system_font_cstr, [[s_systemFont iupFontName] UTF8String], 200);
+  }
+  return (char *)system_font_cstr;
 }
 
-static IupCocoaFont* cocoaFindFont(const char* iup_font_name)
+IupCocoaFont *iupcocoaFindFont(const char *iup_font_name)
 {
-	char type_face[50] = "";
-	int font_size = 0;
+  char type_face[50] = "";
+  int font_size = 0;
+  int is_bold = 0;
+  int is_italic = 0;
+  int is_underline = 0;
+  int is_strikeout = 0;
+  CGFloat final_font_size;
 
-	int is_bold = 0;
-	int is_italic = 0;
-    int is_underline = 0;
-	int is_strikeout = 0;
+  if (NULL == iup_font_name)
+  {
+    return NULL;
+  }
 
-	if(NULL == iup_font_name)
-	{
-		// return system font?
-		return NULL;
-	}
+  NSString *ns_iup_font_name = [NSString stringWithUTF8String:iup_font_name];
 
-	NSString* ns_iup_font_name = [NSString stringWithUTF8String:iup_font_name];
+  /* Check our cache first */
+  IupCocoaFont *the_font = [s_mapOfFonts objectForKey:ns_iup_font_name];
+  if (nil != the_font)
+  {
+    return the_font;
+  }
 
-	// Check our cache
-	IupCocoaFont* the_font = [s_mapOfFonts objectForKey:ns_iup_font_name];
-	if(nil != the_font)
-	{
-		return the_font;
-	}
+  if (!iupGetFontInfo(iup_font_name, type_face, &font_size, &is_bold, &is_italic, &is_underline, &is_strikeout))
+  {
+    return NULL;
+  }
 
+  /* In IUP, a negative size indicates a value in pixels.
+     NSFont works with points, which are resolution-independent.
+     Positive sizes are already in points, so we use them directly.
+     Negative sizes (pixels) need conversion to points based on DPI. */
+  if (font_size < 0)
+  {
+    /* Convert pixels to points: (pixels  72) / DPI */
+    double dpi = iupdrvGetScreenDpi();
+    final_font_size = (CGFloat)((-font_size * 72.0) / dpi);
+  }
+  else
+  {
+    final_font_size = (CGFloat)font_size;
+  }
 
-	if(!iupGetFontInfo(iup_font_name, type_face, &font_size, &is_bold, &is_italic, &is_underline, &is_strikeout))
-	{
-		return NULL;
-	}
-	
-	NSString* ns_type_face = [NSString stringWithUTF8String:type_face];
-	NSFont* ns_font = [NSFont fontWithName:ns_type_face size:(CGFloat)font_size];
-	
-	if(nil == ns_font)
-	{
-		return NULL;
-	}
+  /* A size of 0 is invalid for creating a new font. */
+  if (final_font_size == 0)
+  {
+    return NULL;
+  }
 
-	the_font = [[IupCocoaFont alloc] init];
-	[the_font autorelease];
-	
-	[s_mapOfFonts setObject:the_font forKey:ns_iup_font_name];
+  /* Map standard names to native names */
+  const char *mapped_name = iupFontGetMacName(type_face);
+  if (mapped_name)
+  {
+    strlcpy(type_face, mapped_name, sizeof(type_face));
+  }
 
-	
+  NSString *ns_type_face = [NSString stringWithUTF8String:type_face];
+  NSFont *ns_font = [NSFont fontWithName:ns_type_face size:final_font_size];
 
-	NSFontTraitMask trait_mask = 0;
-  	if(is_italic)
-	{
-		trait_mask |= NSItalicFontMask;
-	}
-	if(is_bold)
-	{
-		trait_mask |= NSBoldFontMask;
-	}
-	
-	NSMutableDictionary* attribute_dict = [[NSMutableDictionary alloc] init];
-	[attribute_dict autorelease];
+  /* If the font is not found by name, fall back to the system font with the specified size.
+     This increases robustness, similar to font substitution on Windows and GTK/Pango. */
+  if (nil == ns_font)
+  {
+    ns_font = [NSFont systemFontOfSize:final_font_size];
+    if (nil == ns_font) /* Should not happen with a valid size, but check just in case. */
+    {
+      return NULL;
+    }
+  }
 
-	bool uses_attributes = false;
-	if(is_underline)
-	{
-  		[attribute_dict setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid|NSUnderlineStyleSingle]
-  			forKey:NSUnderlineStyleAttributeName];
-		uses_attributes = true;
-	}
-	if(is_strikeout)
-	{
-  		[attribute_dict setValue:[NSNumber numberWithInt:YES]
-			forKey:NSStrikethroughStyleAttributeName];
-		uses_attributes = true;
-	}
-	
-	ns_font = [[NSFontManager sharedFontManager] convertFont:ns_font toHaveTrait:trait_mask];
-	if(nil == ns_font)
-	{
-	    return NULL;
-	}
-	
- 	[attribute_dict setValue:ns_font forKey:NSFontAttributeName];
+  NSFontTraitMask trait_mask = 0;
+  if (is_italic)
+  {
+    trait_mask |= NSItalicFontMask;
+  }
+  if (is_bold)
+  {
+    trait_mask |= NSBoldFontMask;
+  }
 
-	[the_font setNativeFont:ns_font];
-	[the_font setAttributeDictionary:attribute_dict];
-	[the_font setUsesAttributes:uses_attributes];
-	[the_font setIupFontName:ns_iup_font_name];
-	[the_font setFontSize:font_size];
-	[the_font setTypeFace:ns_type_face];
-//	[the_font setTraitMask:trait_mask];
+  if (trait_mask)
+  {
+    /* Apply bold/italic traits. The font manager will find the correct variant or synthesize one. */
+    ns_font = [[NSFontManager sharedFontManager] convertFont:ns_font toHaveTrait:trait_mask];
+  }
 
+  if (nil == ns_font)
+  {
+    return NULL;
+  }
 
-	NSLayoutManager *lm = [[NSLayoutManager alloc] init];
-	int char_height = iupROUND([lm defaultLineHeightForFont:ns_font]);
-	[the_font setCharHeight:char_height];
-	[lm release];
-	
-	// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/Tasks/StringHeight.html#//apple_ref/doc/uid/20001809-CJBGBIBB
-	// defaultLineHeightForFont: 16
-	// boundingRectForFont: (width = 21.099609375, height = 17.6337890625)
-	NSRect rect = [ns_font boundingRectForFont];
-	int char_width = iupROUND(rect.size.width);
-	[the_font setCharWidth:char_width];
+  /* Create the IupCocoaFont wrapper and compute its properties */
+  the_font = cocoaCreateIupCocoaFontFromNSFont(ns_font);
+  [the_font setIupFontName:ns_iup_font_name]; /* Use original IUP name for the key */
 
+  BOOL uses_attributes = NO;
+  NSMutableDictionary *attribute_dict = [the_font attributeDictionary];
 
-	return the_font;
+  if (is_underline)
+  {
+    [attribute_dict setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid | NSUnderlineStyleSingle] forKey:NSUnderlineStyleAttributeName];
+    uses_attributes = YES;
+  }
+  if (is_strikeout)
+  {
+    [attribute_dict setValue:[NSNumber numberWithInt:YES] forKey:NSStrikethroughStyleAttributeName];
+    uses_attributes = YES;
+  }
+  [the_font setUsesAttributes:uses_attributes];
+
+  /* Add to cache */
+  [s_mapOfFonts setObject:the_font forKey:ns_iup_font_name];
+
+  return the_font;
 }
 
-static IupCocoaFont* cocoaFontCreateNativeFont(Ihandle* ih, const char* value)
+static IupCocoaFont *cocoaFontCreateNativeFont(Ihandle *ih, const char *value)
 {
-	IupCocoaFont* the_font = cocoaFindFont(value);
-	if(nil == the_font)
-	{
-		iupERROR1("Failed to create Font: %s", value);
-		return NULL;
-	}
+  IupCocoaFont *the_font = iupcocoaFindFont(value);
+  if (nil == the_font)
+  {
+    iupERROR1("Failed to create Font: %s", value);
+    return NULL;
+  }
 
-	iupAttribSet(ih, "_IUP_COCOAFONT", (char*)the_font);
-	return the_font;
+  iupAttribSet(ih, "_IUP_COCOAFONT", (char *)the_font);
+  return the_font;
 }
 
-static IupCocoaFont* cocoaFontGet(Ihandle* ih)
+static IupCocoaFont *cocoaFontGet(Ihandle *ih)
 {
-	IupCocoaFont* the_font = (IupCocoaFont*)iupAttribGet(ih, "_IUP_COCOAFONT");
-// I think we should support nil because not all widgets use the default system font. (Some use the label font.)
-// We don't want to accidentally force the system font when it shouldn't have been used.
-// But in practice, I am unable to implement this because IUP wants to set a font in the core.
-// And because IUP computes sizes based on character width & height, we can't leave this undefined.
-#if 1
-	if(nil == the_font)
-	{
-	    the_font = cocoaFontCreateNativeFont(ih, iupGetFontValue(ih));
-		if(nil == the_font)
-		{
-			the_font = cocoaFontCreateNativeFont(ih, IupGetGlobal("DEFAULTFONT"));
-		}
-	}
-#endif
-	return the_font;
+  IupCocoaFont *the_font = (IupCocoaFont *)iupAttribGet(ih, "_IUP_COCOAFONT");
+  if (nil == the_font)
+  {
+    the_font = cocoaFontCreateNativeFont(ih, iupGetFontValue(ih));
+    if (nil == the_font)
+    {
+      the_font = cocoaFontCreateNativeFont(ih, IupGetGlobal("DEFAULTFONT"));
+    }
+  }
+  return the_font;
 }
 
-// version for external files to use
-IupCocoaFont* iupCocoaGetFont(Ihandle* ih)
+IupCocoaFont *iupcocoaGetFont(Ihandle *ih)
 {
-	return cocoaFontGet(ih);
+  return cocoaFontGet(ih);
 }
 
-int iupdrvSetFontAttrib(Ihandle* ih, const char* value)
+IUP_SDK_API int iupdrvSetFontAttrib(Ihandle *ih, const char *value)
 {
-	IupCocoaFont* iup_font = cocoaFontCreateNativeFont(ih, value);
-/*
-	if(nil == iup_font)
-	{
-		return 0;
-	}
-*/
-	/* If FONT is changed, must update the SIZE attribute */
-	iupBaseUpdateAttribFromFont(ih);
-	
-	/* FONT attribute must be able to be set before mapping,
-	 so the font is enable for size calculation. */
-	if (ih->handle && (ih->iclass->nativetype != IUP_TYPEVOID))
-	{
-		id the_widget = (id)ih->handle;
-		if([the_widget respondsToSelector:@selector(setFont:)])
-		{
-			// WARNING: There is a potential bug here.
-			// IUP is forcing us to provide a default font.
-			// But Cocoa uses at least two different fonts depending on circumstances (system & label)
-			// The safest thing would be to setFont:nil, but the way IUP is structured, it is not easy to leave a nil value.
-			// And because IUP computes sizes based on character width & height, we can't leave this undefined.
-			// For now
-#ifdef IUPCOCOA_USE_SEPARATE_DEFAULT_FONT
-			if(![iup_font isDefaultFont])
-			{
-				[the_widget setFont:[iup_font nativeFont]];
-			}
-			else
-			{
-				// This is for trying to detect the DEFAULT font case
-				// While layout might be wrong, the font won't get set so we won't accidentally see the wrong size.
-			}
-#else
-			[the_widget setFont:[iup_font nativeFont]];
-#endif
+  IupCocoaFont *iup_font = cocoaFontCreateNativeFont(ih, value);
+  if (nil == iup_font)
+  {
+    return 0;
+  }
 
-		}
-	}
-	return 1;
+  /* If FONT is changed, must update the SIZE attribute */
+  iupBaseUpdateAttribFromFont(ih);
+
+  /* FONT attribute must be able to be set before mapping,
+     so the font is enable for size calculation. */
+  if (ih->handle && (ih->iclass->nativetype != IUP_TYPEVOID))
+  {
+    id the_widget = (id)ih->handle;
+    if ([the_widget respondsToSelector:@selector(setFont:)])
+    {
+      [the_widget setFont:[iup_font nativeFont]];
+    }
+  }
+  return 1;
 }
 
-
-static void helperFontGetMultiLineStringSize(IupCocoaFont* iup_font, const char* str, int *w, int *h)
+static void cocoaFontGetTextSize(IupCocoaFont *iup_font, const char *str, int len, int *w, int *h)
 {
-	int num_lin;
-	int max_w;
-	int max_h;
-	
-	if(!iup_font)
-	{
-		if (w) *w = 0;
-		if (h) *h = 0;
-		return;
-	}
+  int max_w = 0;
+  int line_count = 1;
 
-	if(!str)
-	{
-		if (w) *w = 0;
-		if (h) *h = [iup_font charHeight];
-		return;
-	}
+  if (!iup_font)
+  {
+    if (w) *w = 0;
+    if (h) *h = 0;
+    return;
+  }
 
-	max_w = 0;
-	max_h = 0;
-	num_lin = 1;
-	if(str[0])
-	{
-		
-		int len;
-		const char *nextstr;
-		const char *curstr = str;
-		NSMutableArray* array_of_nsstring_lines = [[NSMutableArray alloc] init];
-		
-		do
-		{
-			nextstr = iupStrNextLine(curstr, &len);
-			NSString *str = [[NSString alloc] initWithBytes:curstr length:len encoding:NSUTF8StringEncoding];
-			/*
-			 NSSize size = [str sizeWithAttributes: macfont->attributes];
-			 //		NSSize size = [str sizeWithAttributes:[NSDictionary dictionaryWithObjectsAndKeys:[NSFont systemFontOfSize:0], NSFontAttributeName, nil]];
-			 */
-			if(nil != str)
-			{
-				[array_of_nsstring_lines addObject:str];
-				[str release];
-			}
-			else
-			{
-				[array_of_nsstring_lines addObject:@""];
-			}
-			
-			//		max_w = iupMAX(max_w, size.width + 0.5);
-			
-			curstr = nextstr;
-			if (*nextstr)
-			{
-				num_lin++;
-			}
-		} while(*nextstr);
-		
-		NSString* joined_string = [array_of_nsstring_lines componentsJoinedByString:@"\n"];
-		// 10.11+
-		// boundingRectWithSize:options:attributes:context:
-		//
-		// sizeWithFont:constrainedToSize:lineBreakMode: on iOS, but deprecated in iOS7
-		NSSize size = [joined_string sizeWithAttributes:[iup_font attributeDictionary]];
-		
-		max_w = (int)ceil(size.width);
-		max_h = (int)ceil(size.height);
-		
-		[array_of_nsstring_lines release];
-	}
-	
-	if (w)
-	{
-		*w = max_w;
-	}
-	//	if (h) *h = (macfont->charheight*num_lin)+0.5;
-	if (h)
-	{
-		*h = max_h;
-	}
+  if (!str || str[0] == '\0' || len == 0)
+  {
+    if (w) *w = 0;
+    if (h) *h = [iup_font charHeight];
+    return;
+  }
+
+  /* Use iupStrLineCount for accurate line counting (same as GTK driver) */
+  if (h)
+    line_count = iupStrLineCount(str, len);
+
+  if (str[0] && len > 0)
+  {
+    int l_len;
+    const char *nextstr;
+    const char *curstr = str;
+
+    do
+    {
+      nextstr = iupStrNextLine(curstr, &l_len);
+
+      if (l_len > 0)
+      {
+        NSString *line_str = [[NSString alloc] initWithBytes:curstr length:l_len encoding:NSUTF8StringEncoding];
+        NSSize line_size = [line_str sizeWithAttributes:[iup_font attributeDictionary]];
+        int line_w = (int)ceil(line_size.width) + 4;
+        max_w = iupMAX(max_w, line_w);
+        [line_str release];
+      }
+
+      curstr = nextstr;
+    } while (*nextstr);
+  }
+
+  if (w) *w = max_w;
+  if (h) *h = [iup_font charHeight] * line_count;
 }
 
-void iupdrvFontGetMultiLineStringSize(Ihandle* ih, const char* str, int *w, int *h)
+IUP_SDK_API void iupdrvFontGetMultiLineStringSize(Ihandle *ih, const char *str, int *w, int *h)
 {
-	/* This won't work because other callbacks assume the string size and then add padding on top of it.
-	id native_object = ih->handle;
-	if([native_object respondsToSelector:@selector(sizeToFit)])
-   {
-//	   [native_object sizeToFit];
-	   NSRect the_rect = [native_object frame];
-	 
-	   if (w) *w = the_rect.size.width;
-	   if (h) *h = the_rect.size.height;
-	 
-	   return;
-   }
-*/
-	IupCocoaFont* iup_font = cocoaFontGet(ih);
-	helperFontGetMultiLineStringSize(iup_font, str, w, h);
+  IupCocoaFont *iup_font = cocoaFontGet(ih);
+  if (iup_font)
+  {
+    cocoaFontGetTextSize(iup_font, str, str ? (int)strlen(str) : 0, w, h);
+  }
 }
 
-int iupdrvFontGetStringWidth(Ihandle* ih, const char* str)
+IUP_SDK_API void iupdrvFontGetTextSize(const char *font_name, const char *str, int len, int *w, int *h)
 {
-	size_t len;
-	char* line_end;
-	
-	if(!str || str[0]==0)
-	{
-		return 0;
-	}
-	
-	IupCocoaFont* iup_font = cocoaFontGet(ih);
-	if(nil == iup_font)
-	{
-		return 0;
-	}
-	
-	line_end = strchr(str, '\n');
-	if (line_end)
-	{
-		len = line_end-str;
-	}
-	else
-	{
-		len = strlen(str);
-	}
-	
-	NSString* ns_str = [[NSString alloc] initWithBytes:str length:len encoding:NSUTF8StringEncoding];
-	
-	// 10.11+
-	// boundingRectWithSize:options:attributes:context:
-	//
-	// sizeWithFont:constrainedToSize:lineBreakMode: on iOS, but deprecated in iOS7
-	NSSize size = [ns_str sizeWithAttributes:[iup_font attributeDictionary]];
-	[ns_str release];
-	
-	return (int)ceil(size.width);
+  IupCocoaFont *the_font = iupcocoaFindFont(font_name);
+  if (the_font)
+  {
+    cocoaFontGetTextSize(the_font, str, len, w, h);
+  }
 }
 
-void iupdrvFontGetCharSize(Ihandle* ih, int *charwidth, int *charheight)
+IUP_SDK_API void iupdrvFontGetFontDim(const char *font, int *max_width, int *line_height, int *ascent, int *descent)
 {
-	IupCocoaFont* iup_font = cocoaFontGet(ih);
-	if(!iup_font)
-	{
-		if (charwidth)  *charwidth = 0;
-		if (charheight) *charheight = 0;
-		return;
-	}
-	
-	if (charwidth)  *charwidth = [iup_font charWidth];
-	if (charheight) *charheight = [iup_font charHeight];
+  IupCocoaFont *iup_font = iupcocoaFindFont(font);
+  if (iup_font)
+  {
+    if (max_width) *max_width = [iup_font maxWidth];
+    if (line_height) *line_height = [iup_font charHeight];
+    if (ascent) *ascent = [iup_font ascent];
+    if (descent) *descent = [iup_font descent];
+  }
 }
 
-void iupdrvFontGetTextSize(const char* font_name, const char* str, int len, int *w, int *h)
+IUP_SDK_API int iupdrvFontGetStringWidth(Ihandle *ih, const char *str)
 {
-	IupCocoaFont* the_font = cocoaFindFont(font_name);
-	if(the_font)
-	{
-		// FIXME: quick and dirty fix to get around Iup internal API changes
-		helperFontGetMultiLineStringSize(the_font, str, w, h);
-	}
+  int w = 0;
+  if (!str || str[0] == 0)
+  {
+    return 0;
+  }
+
+  IupCocoaFont *iup_font = cocoaFontGet(ih);
+  if (nil == iup_font)
+  {
+    return 0;
+  }
+
+  /* Measure only the first line */
+  const char *line_end = strchr(str, '\n');
+  int len = (line_end) ? (int)(line_end - str) : (int)strlen(str);
+
+  cocoaFontGetTextSize(iup_font, str, len, &w, NULL);
+  return w;
 }
 
-void iupdrvFontInit(void)
+IUP_SDK_API void iupdrvFontGetCharSize(Ihandle *ih, int *charwidth, int *charheight)
 {
-	if(nil == s_mapOfFonts)
-	{
-		s_mapOfFonts = [[NSMutableDictionary alloc] init];
-	}
-	if(nil == s_systemFont)
-	{
-		// this will set s_systemFont
-		cocoaGetSystemFont();
-	}
-	if(nil == s_labelFont)
-	{
-		// this will set s_systemFont
-		cocoaGetLabelFont();
-	}
-#ifdef IUPCOCOA_USE_SEPARATE_DEFAULT_FONT
-	if(nil == s_defaultFont)
-	{
-		// this will set s_systemFont
-		cocoaGetDefaultFont();
-	}
-#endif
+  IupCocoaFont *iup_font = cocoaFontGet(ih);
+  if (!iup_font)
+  {
+    if (charwidth) *charwidth = 0;
+    if (charheight) *charheight = 0;
+    return;
+  }
 
+  if (charwidth) *charwidth = [iup_font charWidth];
+  if (charheight) *charheight = [iup_font charHeight];
 }
 
+void iupdrvFontInit(void)
+{
+  if (nil == s_mapOfFonts)
+  {
+    s_mapOfFonts = [[NSMutableDictionary alloc] init];
+  }
+  if (nil == s_systemFont)
+  {
+    cocoaGetSystemFont();
+  }
+}
+
 void iupdrvFontFinish(void)
 {
- 	// This will release all the fonts we've allocated.
-	[s_mapOfFonts release];
-	s_mapOfFonts = nil;
-	[s_systemFont release];
-	s_systemFont = nil;
-	[s_labelFont release];
-	s_labelFont = nil;
-#ifdef IUPCOCOA_USE_SEPARATE_DEFAULT_FONT
-	[s_defaultFont release];
-	s_defaultFont = nil;
-#endif
+  /* This will release all the fonts we've allocated. */
+  [s_mapOfFonts release];
+  s_mapOfFonts = nil;
+
+  [s_systemFont release];
+  s_systemFont = nil;
 }
Index: src/cocoa/iupcocoa_fontdlg.m
===================================================================
--- src/cocoa/iupcocoa_fontdlg.m	(revision 5971)
+++ src/cocoa/iupcocoa_fontdlg.m	(working copy)
@@ -16,194 +16,231 @@
 #include "iup_str.h"
 #include "iup_dialog.h"
 
+#include "iup_drvfont.h"
 #include "iupcocoa_drv.h"
 
-static NSMutableDictionary *attr = NULL;
-static NSFont *font = NULL;
 
-@interface MyFontPanel : NSFontPanel
-- (void)setPreviewHeight:(CGFloat)height;
-@end
-@implementation MyFontPanel
-- (void)setPreviewHeight:(CGFloat)height
-{
-//_fontPanelPreviewHeight = height;
-}
-@end
-
-@interface IupCocoaMyDelegateForFontDialog : NSResponder <NSWindowDelegate>
-- (void) changeFont:(id)sender;
-- (void) changeAttributes:(id)sender;
+@interface IupCocoaFontDialogDelegate : NSObject <NSWindowDelegate>
+@property (nonatomic, assign) Ihandle* ih;
 - (void) onOkClicked:(id)sender;
 - (void) onCancelClicked:(id)sender;
-- (BOOL)windowShouldClose:(id)sender;
+- (void) onHelpClicked:(id)sender;
+- (void) changeFont:(id)sender;
+- (BOOL) windowShouldClose:(id)sender;
 @end
 
-@implementation IupCocoaMyDelegateForFontDialog
-- (BOOL)windowShouldClose:(id)sender
-{
-  [NSApp stopModalWithCode:-1];
-	return YES; //???
-}
+@implementation IupCocoaFontDialogDelegate
+@synthesize ih;
+
 - (void) onOkClicked:(id)sender
 {
-  NSFontManager *fontManager = [NSFontManager sharedFontManager];
-  NSFontPanel *panel = [fontManager fontPanel:YES];
-  font = [fontManager convertFont:[fontManager selectedFont]];
-  [panel close];
-  [NSApp stopModalWithCode:0];
+  NSFontPanel* panel = [[NSFontManager sharedFontManager] fontPanel:YES];
+  [panel orderOut:nil];
+  [NSApp stopModalWithCode:NSModalResponseOK];
 }
+
 - (void) onCancelClicked:(id)sender
 {
-  NSFontManager *fontManager = [NSFontManager sharedFontManager];
-  NSFontPanel *panel = [fontManager fontPanel:YES];
-  [panel close];
-  [NSApp stopModalWithCode:0];
+  NSFontPanel* panel = [[NSFontManager sharedFontManager] fontPanel:YES];
+  [panel orderOut:nil];
+  [NSApp stopModalWithCode:NSModalResponseCancel];
 }
-- (void) changeAttributes:(id)sender
+
+- (void) onHelpClicked:(id)sender
 {
-  NSFontManager *fontManager = [NSFontManager sharedFontManager];
-  NSDictionary *attr2 = [sender convertAttributes:attr];
-  [attr addEntriesFromDictionary:attr2];
+  if (self.ih)
+  {
+    Icallback cb = IupGetCallback(self.ih, "HELP_CB");
+    if (cb && cb(self.ih) == IUP_CLOSE)
+    {
+      [self onCancelClicked:sender];
+    }
+  }
 }
+
+/* An action must be set for the panel to work. */
 - (void) changeFont:(id)sender
 {
+  (void)sender;
 }
+
+- (BOOL)windowShouldClose:(id)sender
+{
+  [self onCancelClicked:sender];
+  return NO;
+}
 @end
 
 
-static int macFontDlgPopup(Ihandle* ih, int x, int y)
+static int cocoaFontDlgPopup(Ihandle* ih, int x, int y)
 {
-#if 0
-  InativeHandle* parent = iupDialogGetNativeParent(ih);
-  unsigned char r, g, b;
-
-  char* standardfont;
-  int height_pixels;
-  char typeface[50] = "";
-  int height = 8;
-  int is_bold = 0,
-    is_italic = 0, 
-    is_underline = 0,
-    is_strikeout = 0;
-  int res = iupmacGetScreenRes();
-
-  iupAttribSetInt(ih, "_IUPDLG_X", x);   /* used in iupDialogUpdatePosition */
+  iupAttribSetInt(ih, "_IUPDLG_X", x);
   iupAttribSetInt(ih, "_IUPDLG_Y", y);
 
-  standardfont = iupAttribGet(ih, "VALUE");
-  if (!standardfont)
-    standardfont = IupGetGlobal("DEFAULTFONT");
+  char* value = iupAttribGet(ih, "VALUE");
+  if (!value)
+  {
+    value = IupGetGlobal("DEFAULTFONT");
+  }
 
-  /* parse the old format first */
-  if (!iupFontParseWin(standardfont, typeface, &height, &is_bold, &is_italic, &is_underline, &is_strikeout))
+  char typeface[100] = "";
+  int size = 12;
+  int is_bold = 0, is_italic = 0, is_underline = 0, is_strikeout = 0;
+  if (!iupGetFontInfo(value, typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout))
   {
-    if (!iupFontParsePango(standardfont, typeface, &height, &is_bold, &is_italic, &is_underline, &is_strikeout))
-      return IUP_ERROR;
+    iupGetFontInfo(IupGetGlobal("DEFAULTFONT"), typeface, &size, &is_bold, &is_italic, &is_underline, &is_strikeout);
   }
 
-  /* get size in pixels */
-  float factor = [[NSScreen mainScreen] userSpaceScaleFactor];
-  height_pixels = (int)(height * factor);
-  
-  NSFont *hFont = [NSFont fontWithName:[NSString stringWithUTF8String:standardfont] size:height];
-  attr = [[NSMutableDictionary alloc] init];
+  NSFont* font = nil;
 
-  if(is_italic)
-    hFont = [[NSFontManager sharedFontManager] convertFont:hFont 
-          toHaveTrait:NSItalicFontMask];
-  if(is_bold)
-    hFont = [[NSFontManager sharedFontManager] convertFont:hFont 
-        toHaveTrait:NSBoldFontMask];
-  if(is_underline)                           
-  	[attr setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid|NSUnderlineStyleSingle] 
-	forKey:NSUnderlineStyleAttributeName];
-  if(is_strikeout)                           
-	[attr setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid|NSUnderlineStyleSingle] 
-	forKey:NSStrikethroughStyleAttributeName]; 
+  /* System font names starting with '.' are internal and cannot be used with fontWithName:.
+     Use the proper system font API instead. */
+  if (typeface[0] == '.' || strcmp(typeface, "System") == 0 || strlen(typeface) == 0)
+  {
+    font = [NSFont systemFontOfSize:(CGFloat)size];
+  }
+  else
+  {
+    NSString* ns_typeface = [NSString stringWithUTF8String:typeface];
+    font = [NSFont fontWithName:ns_typeface size:(CGFloat)size];
+  }
 
-  NSView *accView = [[NSView alloc] initWithFrame:NSMakeRect(0,0,180,80)];
-  NSButton *button1 = [[NSButton alloc] initWithFrame: NSMakeRect( 0.0, 20.0, 80.0, 50.0 ) ];
-  NSButton *button2 = [[NSButton alloc] initWithFrame: NSMakeRect( 90.0, 20.0, 80.0, 50.0 ) ];
-  [accView addSubview:button1];
-  [accView addSubview:button2];
+  if (!font)
+  {
+    font = [NSFont systemFontOfSize:(CGFloat)size];
+  }
 
-  MyDelegate *delegate = [MyDelegate new];
+  NSFontManager* fontManager = [NSFontManager sharedFontManager];
+  NSFontTraitMask trait_mask = 0;
+  if (is_bold) trait_mask |= NSBoldFontMask;
+  if (is_italic) trait_mask |= NSItalicFontMask;
+  if (trait_mask)
+  {
+    font = [fontManager convertFont:font toHaveTrait:trait_mask];
+  }
 
-  [button1 setBezelStyle:NSRoundedBezelStyle];
-  [button1 setTitle: @"OK" ];
-  [button1 setAction: @selector(onOkClicked:)];
-  [button1 setTarget: delegate];
-  [button2 setBezelStyle:NSRoundedBezelStyle];
-  [button2 setTitle: @"Cancel" ];
-  [button2 setAction: @selector(onCancelClicked:)];
-  [button2 setTarget: delegate];
+  IupCocoaFontDialogDelegate* delegate = [[IupCocoaFontDialogDelegate alloc] init];
+  delegate.ih = ih;
 
-  [NSFontManager setFontPanelFactory:[MyFontPanel class]];
-  NSFontManager *fontManager = [NSFontManager sharedFontManager];
-  [fontManager setTarget: delegate];
-  [fontManager setDelegate: delegate];
-  [fontManager setSelectedFont:hFont isMultiple: NO];
+  [fontManager setTarget:delegate];
+  [fontManager setAction:@selector(changeFont:)];
+  [fontManager setSelectedFont:font isMultiple:NO];
 
-  NSFontPanel *panel = [fontManager fontPanel:YES];
-  [panel setReleasedWhenClosed:YES]; 
-  [panel setAccessoryView: accView];
-  [panel setEnabled:YES];
-  [panel setDefaultButtonCell:[button1 cell]];
-  [panel makeFirstResponder:delegate];
+  NSFontPanel* panel = [fontManager fontPanel:YES];
   [panel setDelegate:delegate];
-  [panel orderFrontRegardless];
-  [fontManager orderFrontFontPanel:delegate];
-  NSInteger result = 0;
 
-	
-	NSModalSession session = [NSApp beginModalSessionForWindow:[self window]];
-	
-for (;;) {
-    result = [NSApp runModalSession:session];
-    if(result != NSRunContinuesResponse)
-      break;
-    NSEvent *event = [NSApp nextEventMatchingMask:NSAnyEventMask
-                untilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]
-                inMode:NSDefaultRunLoopMode
-                dequeue:YES];
-    [NSApp sendEvent:event];
-    //[NSApp updateWindows];
+  char* title_str = iupAttribGet(ih, "TITLE");
+  if (title_str)
+  {
+    [panel setTitle:[NSString stringWithUTF8String:title_str]];
   }
-  [NSApp endModalSession:session];
-  if(result != 0)
+
+  CGFloat view_width = 260;
+  CGFloat button_height = 32;
+  CGFloat ok_button_width = 82;
+  CGFloat cancel_button_width = 82;
+  CGFloat ok_cancel_spacing = 6;
+
+  NSView* accessoryView = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, view_width, button_height)];
+
+  NSButton* okButton = [[NSButton alloc] initWithFrame:NSMakeRect(view_width - ok_button_width, 0, ok_button_width, button_height)];
+  [okButton setBezelStyle:NSBezelStyleRounded];
+  [okButton setTitle:@"OK"];
+  [okButton setKeyEquivalent:@"\r"];
+  [okButton setAction:@selector(onOkClicked:)];
+  [okButton setTarget:delegate];
+
+  NSButton* cancelButton = [[NSButton alloc] initWithFrame:NSMakeRect(view_width - ok_button_width - ok_cancel_spacing - cancel_button_width, 0, cancel_button_width, button_height)];
+  [cancelButton setBezelStyle:NSBezelStyleRounded];
+  [cancelButton setTitle:@"Cancel"];
+  [cancelButton setKeyEquivalent:@"\e"];
+  [cancelButton setAction:@selector(onCancelClicked:)];
+  [cancelButton setTarget:delegate];
+
+  [accessoryView addSubview:okButton];
+  [accessoryView addSubview:cancelButton];
+
+  if (IupGetCallback(ih, "HELP_CB"))
   {
-    iupAttribSetStr(ih, "VALUE", NULL);
-    iupAttribSetStr(ih, "COLOR", NULL);
-    iupAttribSetStr(ih, "STATUS", NULL);
-    return IUP_NOERROR;
+    NSButton* helpButton = [[NSButton alloc] initWithFrame:NSMakeRect(0, 0, 32, 32)];
+    [helpButton setBezelStyle:NSBezelStyleHelpButton];
+    [helpButton setTitle:@""];
+    [helpButton setAction:@selector(onHelpClicked:)];
+    [helpButton setTarget:delegate];
+    [accessoryView addSubview:helpButton];
+    [helpButton release];
   }
-  NSFontTraitMask mask = [fontManager traitsOfFont:font];
-  is_bold = (mask & NSBoldFontMask) ? 1 : 0;
-  is_italic = (mask & NSItalicFontMask) ? 1 : 0;
-  is_underline = [attr valueForKey:NSUnderlineStyleAttributeName] ? 1 : 0;
-  is_strikeout = [attr valueForKey:NSStrikethroughStyleAttributeName] ? 1 : 0;
-  height = [font pointSize];
-  char *faceName = [[font familyName] UTF8String];
-  iupAttribSetStrf(ih, "VALUE", "%s, %s%s%s%s %d", faceName,
-                                                    is_bold?"Bold ":"",
-                                                    is_italic?"Italic ":"",
-                                                    is_underline?"Underline ":"",
-                                                    is_strikeout?"Strikeout ":"",
-                                                    height);
-  NSColor *color = [attr valueForKey:NSForegroundColorAttributeName];
-  CGFloat red=0,green=0,blue=0,alpha=0;
-  if(color)
-	[color getRed:&red green:&green blue:&blue alpha:&alpha];
- 
-  iupAttribSetStrf(ih, "COLOR", "%d %d %d", (int)(red*255),(int)(green*255),(int)(blue*255));
-  iupAttribSetStr(ih, "STATUS", "1");
-#endif
-	
+
+  [panel setAccessoryView:accessoryView];
+
+  [okButton release];
+  [cancelButton release];
+  [accessoryView release];
+
+  NSInteger result = [NSApp runModalForWindow:panel];
+
+  if (result == NSModalResponseOK)
+  {
+    NSFont* finalFont = [fontManager convertFont:[fontManager selectedFont]];
+    NSDictionary* finalAttributes = [fontManager convertAttributes:@{}];
+
+    NSFontTraitMask traits = [fontManager traitsOfFont:finalFont];
+    is_bold = (traits & NSBoldFontMask) != 0;
+    is_italic = (traits & NSItalicFontMask) != 0;
+
+    is_underline = [finalAttributes objectForKey:NSUnderlineStyleAttributeName] != nil;
+    is_strikeout = [finalAttributes objectForKey:NSStrikethroughStyleAttributeName] != nil;
+
+    size = (int)[finalFont pointSize];
+    const char* faceName = [[finalFont familyName] UTF8String];
+
+    iupAttribSetStrf(ih, "VALUE", "%s, %s%s%s%s %d", faceName,
+                      is_bold ? "Bold " : "",
+                      is_italic ? "Italic " : "",
+                      is_underline ? "Underline " : "",
+                      is_strikeout ? "Strikeout " : "",
+                      size);
+
+    if (iupAttribGetBoolean(ih, "SHOWCOLOR"))
+    {
+      NSColor* color = [finalAttributes objectForKey:NSForegroundColorAttributeName];
+      if (color)
+      {
+        color = [color colorUsingColorSpace:[NSColorSpace sRGBColorSpace]];
+        CGFloat red = 0, green = 0, blue = 0;
+        [color getRed:&red green:&green blue:&blue alpha:NULL];
+        iupAttribSetStrf(ih, "COLOR", "%d %d %d", (int)(red * 255), (int)(green * 255), (int)(blue * 255));
+      }
+      else
+      {
+        iupAttribSet(ih, "COLOR", NULL);
+      }
+    }
+    else
+    {
+      iupAttribSet(ih, "COLOR", NULL);
+    }
+    iupAttribSet(ih, "STATUS", "1");
+  }
+  else
+  {
+    iupAttribSet(ih, "VALUE", NULL);
+    iupAttribSet(ih, "COLOR", NULL);
+    iupAttribSet(ih, "STATUS", NULL);
+  }
+
+  [panel setAccessoryView:nil];
+  [panel setDelegate:nil];
+  [fontManager setTarget:nil];
+  [delegate release];
+
   return IUP_NOERROR;
 }
 
 void iupdrvFontDlgInitClass(Iclass* ic)
 {
-  ic->DlgPopup = macFontDlgPopup;
-}
+  ic->DlgPopup = cocoaFontDlgPopup;
+
+  iupClassRegisterAttribute(ic, "COLOR", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SHOWCOLOR", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+}
\ No newline at end of file
Index: src/cocoa/iupcocoa_frame.m
===================================================================
--- src/cocoa/iupcocoa_frame.m	(revision 5971)
+++ src/cocoa/iupcocoa_frame.m	(working copy)
@@ -4,7 +4,7 @@
  * See Copyright Notice in "iup.h"
  */
 
-#include <Cocoa/Cocoa.h>
+#import <Cocoa/Cocoa.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -27,222 +27,316 @@
 #include "iupcocoa_drv.h"
 
 
-
 void iupdrvFrameGetDecorOffset(Ihandle* ih, int *x, int *y)
 {
-	// Drat: The padding will differ depending if there is a title or not (and where the title goes).
-	*x = 0;
-	*y = 0;
+  /* NSBox automatically positions its contentView to accommodate border and title.
+     Children are laid out relative to contentView, so offset is (0,0). */
+  (void)ih;
+  *x = 0;
+  *y = 0;
 }
 
 int iupdrvFrameHasClientOffset(Ihandle* ih)
 {
-	// If I don't set this to true, the y-padding in iupdrvFrameGetDecorOffset does nothing.
-	// And without the padding, the first widget gets placed too high in the box and gets clipped.
-	// Unless...I set the GetInnerNativeContainerHandle callback. Then it seems I can avoid needing iupdrvFrameGetDecorOffset
-	return 0;
+  (void)ih;
+  return 0;
 }
 
 int iupdrvFrameGetTitleHeight(Ihandle* ih, int *h)
 {
-	// The title height uses a smaller font size than the normal system font,
-	// so don't use iupdrvFontGetCharSize() since I don't think that font is stored in the ih. (Maybe that should be fixed.)
-	// Also, it is offset differently depending on mode.
-	// Also, the NSBox size gets bigger if there is no text. This is different than what IUP expects.
-	// FIXME: Need to figure out different sizes. I'm pretty sure 0 is not correct.
-
-/*
-	if (iupAttribGet(ih, "_IUPFRAME_HAS_TITLE") || iupAttribGet(ih, "TITLE"))
-	{
-	
-	}
-	else
-	{
-		
-	}
-*/
-	*h = 0;
+  if (iupAttribGet(ih, "_IUPFRAME_HAS_TITLE") || iupAttribGet(ih, "TITLE"))
+  {
+    if (ih->handle)
+    {
+      NSBox* the_frame = (NSBox*)ih->handle;
+      NSFont* title_font = [the_frame titleFont];
+      if (title_font)
+      {
+        CGFloat font_height = [title_font boundingRectForFont].size.height;
+        *h = (int)(font_height + 4);  /* Add some padding */
+      }
+      else
+      {
+        *h = 16;  /* Default title height */
+      }
+    }
+    else
+    {
+      *h = 16; /* Default/estimate if handle not created yet */
+    }
+  }
+  else
+  {
+    *h = 0;
+  }
   return 1;
 }
 
 int iupdrvFrameGetDecorSize(Ihandle* ih, int *w, int *h)
 {
-	// HACK: Need to make customizable based on whether title is shown or not.
-/*
-	if (iupAttribGet(ih, "_IUPFRAME_HAS_TITLE") || iupAttribGet(ih, "TITLE"))
-	{
-	
-	}
-	else
-	{
-		
-	}
-*/
-	// FIXME: I put 14 as a first guess without measuring. It looked pretty good, but should be measured.
-	*w = 14;
-	// 22 seems to be okay. Testing with a multilist on the bottom of frame...19 clips the scrollbar at the bottom.
-	// 20 doesn't have enough padding pixels under the scrollbar compared to other scrollbars I look at.
-	*h = 22;
+  NSBox* tempBox = [[[NSBox alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)] autorelease];
+
+  [tempBox setBoxType:NSBoxPrimary];
+
+  const char* title = iupAttribGet(ih, "TITLE");
+  if (title && *title)
+  {
+    [tempBox setTitle:[NSString stringWithUTF8String:title]];
+    [tempBox setTitlePosition:NSAtTop];
+
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+    if (iup_font)
+    {
+      NSFont* font = [iup_font nativeFont];
+      if (font)
+        [tempBox setTitleFont:font];
+    }
+  }
+  else
+  {
+    [tempBox setTitle:@""];
+    [tempBox setTitlePosition:NSNoTitle];
+  }
+
+  /* Reduce content view margins to minimize padding */
+  [tempBox setContentViewMargins:NSMakeSize(2.0, 2.0)];
+
+  NSRect boxFrame = [tempBox frame];
+  NSView* contentView = [tempBox contentView];
+  NSRect contentFrame = [contentView frame];
+
+  *w = (int)lroundf(boxFrame.size.width - contentFrame.size.width);
+  *h = (int)lroundf(boxFrame.size.height - contentFrame.size.height);
+
   return 1;
 }
 
-
 static void* cocoaFrameGetInnerNativeContainerHandleMethod(Ihandle* ih, Ihandle* child)
 {
-	(void)child;
-	
-	NSBox* the_frame = ih->handle;
-	
-	return [the_frame contentView];
-//	return (void*)gtk_bin_get_child((GtkBin*)ih->handle);
+  (void)child;
+  NSBox* the_frame = ih->handle;
+  return [the_frame contentView];
 }
 
-static int cocoaFrameSetTitleAttrib(Ihandle* ih, const char* title)
+static int cocoaFrameSetTitleAttrib(Ihandle* ih, const char* value)
 {
-	NSBox* the_frame = (NSBox*)ih->handle;
+  if (!ih->handle)
+    return 0;
 
-	if(title && *title!=0)
-	{
-		NSString* ns_string = [NSString stringWithUTF8String:title];
-		[the_frame setTitle:ns_string];
-		[the_frame setTitlePosition:NSAtTop];
+  if (!iupAttribGetStr(ih, "_IUPFRAME_HAS_TITLE"))
+    return 0;
 
-	}
-	else
-	{
-		[the_frame setTitle:@""];
-		[the_frame setTitlePosition:NSNoTitle];
-		
-	}
-	
-	
-	iupdrvPostRedraw(ih);
-	return 1;
+  NSBox* the_frame = (NSBox*)ih->handle;
+
+  if (value && *value)
+  {
+    NSString* ns_string = [NSString stringWithUTF8String:value];
+    [the_frame setTitle:ns_string];
+    [the_frame setTitlePosition:NSAtTop];
+  }
+  else
+  {
+    [the_frame setTitle:@""];
+    [the_frame setTitlePosition:NSNoTitle];
+  }
+
+  iupdrvPostRedraw(ih);
+  return 1;
 }
 
-static int cocoaFrameMapMethod(Ihandle* ih)
+static int cocoaFrameSetBgColorAttrib(Ihandle* ih, const char* value)
 {
+  if (!ih->handle)
+    return 1;
 
-//	NSBox* the_frame = [[NSBox alloc] initWithFrame:NSZeroRect];
-	NSBox* the_frame = [[NSBox alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)];
+  NSBox* the_frame = (NSBox*)ih->handle;
+  NSView* content_view = [the_frame contentView];
+  unsigned char r, g, b;
+  BOOL has_custom_color = iupAttribGetBoolean(ih, "_IUPFRAME_HAS_BGCOLOR");
 
-	{
-		char* title;
-		title = iupAttribGet(ih, "TITLE");
-		if(title && *title!=0)
-		{
-			NSString* ns_string = [NSString stringWithUTF8String:title];
-			[the_frame setTitle:ns_string];
-		}
-		else
-		{
-			[the_frame setTitle:@""];
-			[the_frame setTitlePosition:NSNoTitle];
+  if (!has_custom_color)
+  {
+    /* No custom BGCOLOR set on this frame.
+       Use system defaults which are dynamic and theme-aware. */
+    [the_frame setBoxType:NSBoxPrimary];
 
-		}
-	}
-	
-	
-	
-	
-	ih->handle = the_frame;
-	
-	iupCocoaSetAssociatedViews(ih, the_frame, the_frame);
+    if (content_view)
+    {
+      if ([content_view wantsLayer])
+      {
+        /* Make the layer transparent so the NSBox background shows through */
+        [[content_view layer] setBackgroundColor:nil];
+      }
+    }
+    return 0; /* Not processed as a user attribute */
+  }
 
-	iupCocoaAddToParent(ih);
-	
+  /* has_custom_color is TRUE */
+  /* value might be NULL if called from Map, so we must fetch it */
+  if (!value)
+    value = iupAttribGet(ih, "BGCOLOR");
+  if (!value)
+    value = iupAttribGet(ih, "BACKCOLOR");
 
-	
-	return IUP_NOERROR;
-}
+  if (!value || !iupStrToRGB(value, &r, &g, &b))
+    return 0;
 
+  NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
 
-static void cocoaFrameUnMapMethod(Ihandle* ih)
-{
-	id the_frame = ih->handle;
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[the_frame release];
-	ih->handle = nil;
+  [the_frame setBoxType:NSBoxCustom];
+  [the_frame setFillColor:color];
+
+  if (content_view)
+  {
+    if (![content_view wantsLayer])
+    {
+      [content_view setWantsLayer:YES];
+    }
+
+    if ([content_view layer])
+    {
+      [[content_view layer] setBackgroundColor:[color CGColor]];
+    }
+  }
+
+  return 1;
 }
 
-#if 0
-/*
-static void cocoaFrameComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)
+static int cocoaFrameSetFgColorAttrib(Ihandle* ih, const char* value)
 {
-	(void)children_expand;
-	
-	*children_expand = 1;
-	
-	NSLog(@"cocoaFrameComputeNaturalSizeMethod: %d, %d, %d, %d", ih->currentwidth, ih->currentheight, *w, *h);
-	
-	NSBox* box_view = (NSBox*)ih->handle;
-	NSView* box_content_view = [box_view contentView];
-	
-	CGFloat diff_width = NSWidth([box_view frame]) - NSWidth([box_content_view frame]);
-	CGFloat diff_height = NSHeight([box_view frame]) - NSHeight([box_content_view frame]);
-	
-//	*w = *w - diff_width;
-//	*h = *h - diff_height;
+  if (!ih->handle)
+    return 1;
 
-	*w = NSWidth([box_content_view frame]);
-	*h = NSHeight([box_content_view frame]);
+  NSBox* the_frame = (NSBox*)ih->handle;
+  NSString* title = [the_frame title];
 
-	
-	//NSBox* the_box = ih->handle;
-	//NSRect content_rect = [[the_box contentView] frame];
+  if (!title || [title length] == 0)
+    return 0;
+
+  unsigned char r, g, b;
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
+
+  NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+
+  NSTextFieldCell* title_cell = [the_frame titleCell];
+  if (title_cell)
+  {
+    [title_cell setTextColor:color];
+    iupdrvPostRedraw(ih);
+    return 1;
+  }
+
+  return 0;
 }
 
+static int cocoaFrameSetFontAttrib(Ihandle* ih, const char* value)
+{
+  if (!iupdrvSetFontAttrib(ih, value))
+  {
+    return 0;
+  }
 
-static void cocoaFrameLayoutUpdate(Ihandle* ih)
+  if (ih->handle)
+  {
+    NSBox* the_frame = (NSBox*)ih->handle;
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+    if(iup_font)
+    {
+      NSFont* font = [iup_font nativeFont];
+      if (font)
+      {
+        [the_frame setTitleFont:font];
+        iupdrvPostRedraw(ih);
+      }
+    }
+  }
+  return 1;
+}
+
+static int cocoaFrameMapMethod(Ihandle* ih)
 {
+  char* title;
 
-	NSLog(@"cocoaFrameLayoutUpdate: %d, %d", ih->currentwidth, ih->currentheight);
-	
-	NSBox* box_view = (NSBox*)ih->handle;
-	NSView* box_content_view = [box_view contentView];
-	
-	CGFloat diff_width = NSWidth([box_view frame]) - NSWidth([box_content_view frame]);
-	CGFloat diff_height = NSHeight([box_view frame]) - NSHeight([box_content_view frame]);
-	
-	//	*w = *w - diff_width;
-	//	*h = *h - diff_height;
+  if (!ih->parent)
+  {
+    return IUP_ERROR;
+  }
 
-	
-//	ih->currentwidth = ih->currentwidth - diff_width;
-//	ih->currentheight = ih->currentheight - diff_height;
-	iupdrvBaseLayoutUpdateMethod(ih);
+  NSBox* the_frame = [[NSBox alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)];
+  ih->handle = the_frame;
 
+  [the_frame setBoxType:NSBoxPrimary];
+
+  title = iupAttribGet(ih, "TITLE");
+  if (title)
+  {
+    iupAttribSet(ih, "_IUPFRAME_HAS_TITLE", "1");
+  }
+  else
+  {
+    if (iupAttribGet(ih, "BGCOLOR") || iupAttribGet(ih, "BACKCOLOR"))
+    {
+      iupAttribSet(ih, "_IUPFRAME_HAS_BGCOLOR", "1");
+    }
+  }
+
+  if (iupAttribGet(ih, "_IUPFRAME_HAS_TITLE"))
+  {
+    /* Show title at top */
+    if (title && *title)
+    {
+      [the_frame setTitle:[NSString stringWithUTF8String:title]];
+    }
+    else
+    {
+      [the_frame setTitle:@""];
+    }
+    [the_frame setTitlePosition:NSAtTop];
+
+    /* Apply font to title if specified */
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+    if (iup_font)
+    {
+      NSFont* font = [iup_font nativeFont];
+      if (font)
+      {
+        [the_frame setTitleFont:font];
+      }
+    }
+  }
+  else
+  {
+    /* Box frame: no title */
+    [the_frame setTitle:@""];
+    [the_frame setTitlePosition:NSNoTitle];
+  }
+
+  /* Reduce content view margins to minimize padding */
+  [the_frame setContentViewMargins:NSMakeSize(2.0, 2.0)];
+
+  iupcocoaSetAssociatedViews(ih, [the_frame contentView], the_frame);
+  iupcocoaAddToParent(ih);
+
+  if (!iupAttribGet(ih, "_IUPFRAME_HAS_BGCOLOR"))
+  {
+    cocoaFrameSetBgColorAttrib(ih, NULL);
+  }
+
+  return IUP_NOERROR;
 }
-*/
-#endif
 
-
 void iupdrvFrameInitClass(Iclass* ic)
 {
-	/* Driver Dependent Class functions */
-	ic->Map = cocoaFrameMapMethod;
-	ic->UnMap = cocoaFrameUnMapMethod;
-	
-	ic->GetInnerNativeContainerHandle = cocoaFrameGetInnerNativeContainerHandleMethod;
+  ic->Map = cocoaFrameMapMethod;
+  ic->GetInnerNativeContainerHandle = cocoaFrameGetInnerNativeContainerHandleMethod;
 
-//	ic->ComputeNaturalSize = cocoaFrameComputeNaturalSizeMethod;
-//	ic->LayoutUpdate = cocoaFrameLayoutUpdate;
+  iupClassRegisterAttribute(ic, "FONT", NULL, cocoaFrameSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
 
-#if 0
-	
-	/* Driver Dependent Attribute functions */
-	
-	/* Overwrite Common */
-	iupClassRegisterAttribute(ic, "STANDARDFONT", NULL, gtkFrameSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);
-	
-	/* Visual */
-	iupClassRegisterAttribute(ic, "BGCOLOR", iupFrameGetBgColorAttrib, gtkFrameSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-	iupClassRegisterAttribute(ic, "SUNKEN", NULL, gtkFrameSetSunkenAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-	
-	/* Special */
-	iupClassRegisterAttribute(ic, "FGCOLOR", NULL, gtkFrameSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
-#endif
-	iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaFrameSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	
+  iupClassRegisterAttribute(ic, "BGCOLOR", iupFrameGetBgColorAttrib, cocoaFrameSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BACKCOLOR", iupFrameGetBgColorAttrib, cocoaFrameSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SUNKEN", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaFrameSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaFrameSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_image.m
===================================================================
--- src/cocoa/iupcocoa_image.m	(revision 5971)
+++ src/cocoa/iupcocoa_image.m	(working copy)
@@ -11,6 +11,7 @@
 #include <memory.h>
 
 #include "iup.h"
+#include "iupcbs.h"
 
 #include "iup_object.h"
 #include "iup_attrib.h"
@@ -20,1048 +21,697 @@
 #include "iupcocoa_drv.h"
 
 
-/* Adapted from SDL (zlib)
- * Calculate the pad-aligned scanline width of a surface
- */
+/* Calculate the pad-aligned scanline width of a surface. Surfaces are 4-byte aligned for performance. */
 static int CalculateBytesPerRow(int width, int bytes_per_pixel)
 {
-	int pitch;
-	int bits_per_pixel = bytes_per_pixel * 8;
-	/* Surface should be 4-byte aligned for speed */
-	pitch = width * bytes_per_pixel;
-	switch (bits_per_pixel) {
-		case 1:
-			pitch = (pitch + 7) / 8;
-			break;
-		case 4:
-			pitch = (pitch + 1) / 2;
-			break;
-		default:
-			break;
-	}
-	pitch = (pitch + 3) & ~3;   /* 4-byte aligning */
-	return (pitch);
+  int pitch = width * bytes_per_pixel;
+  switch (bytes_per_pixel * 8)
+  {
+    case 1:
+      pitch = (pitch + 7) / 8;
+      break;
+    case 4:
+      pitch = (pitch + 1) / 2;
+      break;
+    default:
+      break;
+  }
+  pitch = (pitch + 3) & ~3;   /* 4-byte aligning */
+  return pitch;
 }
 
-static int CalculateRowLength(int width, int bytes_per_pixel)
+int iupcocoaImageCalculateBytesPerRow(int width, int bytes_per_pixel)
 {
-	int pitch = CalculateBytesPerRow(width, bytes_per_pixel);
-	return pitch/bytes_per_pixel;
+  return CalculateBytesPerRow(width, bytes_per_pixel);
 }
 
-int iupCocoaImageCaluclateBytesPerRow(int width, int bytes_per_pixel)
+/* The output format is packed RGB(A), top-down, matching the IUP image data format. */
+void iupdrvImageGetData(void* handle, unsigned char* out_img_data)
 {
-	return CalculateBytesPerRow(width, bytes_per_pixel);
-}
+  if (!handle)
+    return;
 
+  if (![(__bridge id)handle isKindOfClass:[NSImage class]])
+    return;
 
-// The difference between iupdrvImageGetData and iupdrvImageGetRawData is in the output format.
-// The input is the same. But the iupdrvImageGetData (packed RGB, top-down) output used the IUP image data format,
-// and iupdrvImageGetRawData uses the IM image data format for the imImage (separated RGB planes, bottom-up).
-// FIXME: Carried over implementation. Untested.
-void iupdrvImageGetRawData(void* handle, unsigned char* imgdata)
-{
-  int x,y;
-  unsigned char *red,*green,*blue,*alpha;
-  NSImage *image = (__bridge NSImage*)handle;
-  NSBitmapImageRep *bitmap = nil;
-  if([[image representations] count]>0) bitmap = [[image representations] objectAtIndex:0];
-  if(bitmap==nil) return;
-	NSInteger w = [bitmap pixelsWide];
-  NSInteger h = [bitmap pixelsHigh];
-  NSInteger bpp = [bitmap bitsPerPixel];
-  NSInteger planesize = w*h;
-  unsigned char *bits = [bitmap bitmapData]; 
-  red = imgdata;
-  green = imgdata+planesize;
-  blue = imgdata+2*planesize;
-  alpha = imgdata+3*planesize;
-  for(y=0;y<h;y++) {
-    for(x=0;x<w;x++) {
-      if(bpp>=24) {
-        *red++ = *bits++;
-        *green++ = *bits++;
-        *blue++ = *bits++;
-      }
-      if(bpp==32) {
-        *alpha++ = *bits++;
-      }
+  NSImage* ns_image = (__bridge NSImage*)handle;
+  NSBitmapImageRep* bitmap = nil;
+
+  for (NSImageRep* rep in [ns_image representations])
+  {
+    if ([rep isKindOfClass:[NSBitmapImageRep class]])
+    {
+      bitmap = (NSBitmapImageRep*)rep;
+      break;
     }
   }
-}
 
-// The input is the same. But the iupdrvImageGetData (packed RGB, top-down) output used the IUP image data format,
-// and iupdrvImageGetRawData uses the IM image data format for the imImage (separated RGB planes, bottom-up).
+  if (bitmap == nil)
+  {
+    CGImageRef cg_image = [ns_image CGImageForProposedRect:nil context:nil hints:nil];
+    if (cg_image)
+    {
+      bitmap = [[[NSBitmapImageRep alloc] initWithCGImage:cg_image] autorelease];
+    }
+  }
 
+  if (bitmap == nil)
+    return;
 
-// Currently used by Drag & Drop. I'm not sure if the semantics match the original intent of this function.
-// I assume handle is an NSImage (which has a NSBitmapImageRep),
-// and that out_img_data is already allocated to be bytesPerRow*h.
-// This will write the pixel data to out_img_data.
-#if 0
-void iupdrvImageGetData(void* handle, unsigned char* out_img_data)
-{
-	NSImage* ns_image = (__bridge NSImage*)handle;
+  NSInteger w = [bitmap pixelsWide];
+  NSInteger h = [bitmap pixelsHigh];
+  NSInteger samplesPerPixel = [bitmap samplesPerPixel];
+  NSInteger bytesPerRow = [bitmap bytesPerRow];
+  unsigned char* bitmap_data = [bitmap bitmapData];
 
-    NSSize image_size = [ns_image size];
-    NSRect image_rect = NSMakeRect(0, 0, image_size.width, image_size.height);
+  if (samplesPerPixel < 3)
+    return;
 
-	int bpp = 32;
+  int channels = (int)samplesPerPixel;
+  int dest_line_size = (int)w * channels;
 
-	NSBitmapImageRep* bitmap = nil;
-	
-	if([[ns_image representations] count] > 0)
-	{
-		bitmap = (NSBitmapImageRep*)[[ns_image representations] objectAtIndex:0];
-	}
-	
-/*
-	{
-		NSInteger w = [bitmap pixelsWide];
-		NSInteger h = [bitmap pixelsHigh];
-		// NSInteger bpp = [bitmap bitsPerPixel];
-		NSInteger samplesPerPixel = [bitmap samplesPerPixel];
-		NSInteger bytesPerRow = [bitmap bytesPerRow];
-		NSInteger bytesPerPlane = [bitmap bytesPerPlane];
-		NSInteger numberOfPlanes = [bitmap numberOfPlanes];
-		NSLog(@"w: %ld", (long)w);
-		NSLog(@"h: %ld", (long)h);
-		NSLog(@"bpp: %ld", (long)bpp);
-		NSLog(@"samplesPerPixel: %ld", (long)samplesPerPixel);
-		NSLog(@"bytesPerRow: %ld", (long)bytesPerRow);
-		NSLog(@"bytesPerPlane: %ld", (long)bytesPerPlane);
-		NSLog(@"numberOfPlanes: %ld", (long)numberOfPlanes);
- 
- 
-	}
-*/
-	
-	if(bitmap==nil)
-	{
-		bpp = 32;
-	}
-	else
-	{
-		bpp = (int)[bitmap bitsPerPixel];
-	}
-	if(bpp == 32)
-	{
-		CGImageAlphaInfo alpha_info = kCGImageAlphaPremultipliedLast;
+  for (int y = 0; y < h; y++)
+  {
+    unsigned char* src_line = bitmap_data + y * bytesPerRow;
+    unsigned char* dest_line = out_img_data + y * dest_line_size;
+    memcpy(dest_line, src_line, dest_line_size);
+  }
+}
 
-		int bytes_per_row = CalculateBytesPerRow(image_size.width, bpp/8);
+/* The output format is separated RGB(A) planes, bottom-up, matching the IM image data format. */
+IUP_SDK_API void iupdrvImageGetRawData(void* handle, unsigned char* imgdata)
+{
+  if (!handle)
+    return;
 
-		CGColorSpaceRef color_space = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
+  if (![(__bridge id)handle isKindOfClass:[NSImage class]])
+    return;
 
-		// We are going to write directly to out_img_data here instead of passing NULL which will malloc new memory.
-		// this must be sizeof bytes_per_row*h
-		CGContextRef ctx = CGBitmapContextCreate(
-			out_img_data,
-			image_size.width,
-			image_size.height,
-			8,
-			bytes_per_row,
-			color_space,
-			alpha_info
-		);
+  NSImage* image = (__bridge NSImage*)handle;
+  NSBitmapImageRep *bitmap = nil;
 
-		NSGraphicsContext* saved_context = [NSGraphicsContext currentContext];
-	//	[saved_context saveGraphicsState];
+  if ([[image representations] count] > 0)
+  {
+    id rep = [[image representations] objectAtIndex:0];
+    if ([rep isKindOfClass:[NSBitmapImageRep class]])
+    {
+      bitmap = (NSBitmapImageRep*)rep;
+    }
+  }
 
-		// Wrap graphics context
-		NSGraphicsContext* gctx = [NSGraphicsContext graphicsContextWithCGContext:ctx flipped:NO];
+  if (bitmap == nil)
+    return;
 
-		// Make our bitmap context current and render the NSImage into it
-		[NSGraphicsContext setCurrentContext:gctx];
-		[ns_image drawInRect:image_rect];
-		
-		/*
-		 size_t width = CGBitmapContextGetWidth(ctx);
-		 size_t height = CGBitmapContextGetHeight(ctx);
-		 uint32_t* pixel = (uint32_t*)CGBitmapContextGetData(ctx);
-		 
-		 // int bytes_per_row = CGBitmapContextGetBytesPerRow(ctx);
-		 int total_bytes = bytes_per_row*height;
-		 memcpy(out_img_data, pixel, total_bytes);
-	*/
+  NSInteger w = [bitmap pixelsWide];
+  NSInteger h = [bitmap pixelsHigh];
+  NSInteger bpp = [bitmap bitsPerPixel];
+  NSInteger planesize = w * h;
 
-		// Clean up
-		[NSGraphicsContext setCurrentContext:saved_context];
-	//	[saved_context restoreGraphicsState];
+  unsigned char *bits = [bitmap bitmapData];
+  unsigned char *red   = imgdata;
+  unsigned char *green = imgdata + planesize;
+  unsigned char *blue  = imgdata + 2 * planesize;
+  unsigned char *alpha = (bpp == 32) ? imgdata + 3 * planesize : NULL;
 
-		CGContextRelease(ctx);
-		CGColorSpaceRelease(color_space);
-		
-		
-	}
-	else if(bpp == 24)
-	{
-		// Grrr. CGBitmapContextCreate only handles 32-bit.
-		// I'm tempted to change the entire backend to always handle convert to 32-bit images, but that may cause too many problems.
-		
-		
-		
-		int bytes_per_row = CalculateBytesPerRow(image_size.width, bpp/8);
-		int total_bytes = bytes_per_row*image_size.height;
+  NSInteger bytesPerRow = [bitmap bytesPerRow];
+  NSInteger samplesPerPixel = [bitmap samplesPerPixel];
 
-		unsigned char* bitmap_data = [bitmap bitmapData];
-		memcpy(out_img_data, bitmap_data, total_bytes);
+  for (int y = 0; y < h; y++)
+  {
+    unsigned char* src_line = bits + y * bytesPerRow;
+    int dest_line_offset = (int)(h - 1 - y) * (int)w;
 
+    for (int x = 0; x < w; x++)
+    {
+      unsigned char* src_pixel = src_line + x * samplesPerPixel;
+      int dest_offset = dest_line_offset + x;
 
-	}
-	else
-	{
-//		NSLog(@"unsupported bpp: %d", bpp);
-//		return;
+      if (samplesPerPixel >= 3)
+      {
+        red[dest_offset]   = src_pixel[0];
+        green[dest_offset] = src_pixel[1];
+        blue[dest_offset]  = src_pixel[2];
+      }
 
-		
-		int bytes_per_row = CalculateBytesPerRow(image_size.width, bpp/8);
-		int total_bytes = bytes_per_row*image_size.height;
-
-		unsigned char* bitmap_data = [bitmap bitmapData];
-		memcpy(out_img_data, bitmap_data, total_bytes);
-	}
-	
-
-
+      if (alpha && samplesPerPixel == 4)
+      {
+        alpha[dest_offset] = src_pixel[3];
+      }
+    }
+  }
 }
-#else
-// The input is the same. But the iupdrvImageGetData (packed RGB, top-down) output used the IUP image data format,
-// and iupdrvImageGetRawData uses the IM image data format for the imImage (separated RGB planes, bottom-up).
 
-// This implementation assumes there is an NSBitmapImageRep backing the NSImage,
-// and that the pixels are already in the exact order we need.
-// So this makes it a fast memcpy, and is the best implementation we can hope for.
-// So far this seems to work well and I tested on 8-bit GIFs, 24-bit JPEGs, and 32-bit PNGs.
-void iupdrvImageGetData(void* handle, unsigned char* out_img_data)
+static NSBitmapImageRep* iupCocoaImageNSBitmapImageRepFromRawData(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
 {
-	NSImage* ns_image = (__bridge NSImage*)handle;
+  NSBitmapImageRep* bitmap_image = nil;
 
-    NSSize image_size = [ns_image size];
+  if (bpp == 32 || bpp == 8) /* For 8bpp, we create a 32bpp image */
+  {
+    bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
+                                                           pixelsWide:width pixelsHigh:height bitsPerSample:8
+                                                      samplesPerPixel:4 hasAlpha:YES isPlanar:NO
+                                                       colorSpaceName:NSDeviceRGBColorSpace
+                                                         bitmapFormat:NSBitmapFormatAlphaNonpremultiplied
+                                                          bytesPerRow:CalculateBytesPerRow(width, 4)
+                                                         bitsPerPixel:32];
+  }
+  else if (bpp == 24)
+  {
+    bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
+                                                           pixelsWide:width pixelsHigh:height bitsPerSample:8
+                                                      samplesPerPixel:3 hasAlpha:NO isPlanar:NO
+                                                       colorSpaceName:NSDeviceRGBColorSpace
+                                                         bitmapFormat:0
+                                                          bytesPerRow:CalculateBytesPerRow(width, 3)
+                                                         bitsPerPixel:24];
+  }
+  else
+  {
+    return NULL;
+  }
 
-	NSBitmapImageRep* bitmap = nil;
-	
-	if([[ns_image representations] count] > 0)
-	{
-		bitmap = (NSBitmapImageRep*)[[ns_image representations] objectAtIndex:0];
-	}
+  unsigned char *pixels = [bitmap_image bitmapData];
+  NSInteger bytesPerRow = [bitmap_image bytesPerRow];
+  int planesize = width * height;
 
-	if(bitmap == nil)
-	{
-		NSLog(@"Could not find NSBitmapImageRep");
-		return;
-	}
+  if (bpp == 32 || bpp == 24)
+  {
+    unsigned char *r_plane = imgdata;
+    unsigned char *g_plane = imgdata + planesize;
+    unsigned char *b_plane = imgdata + 2 * planesize;
+    unsigned char *a_plane = (bpp == 32) ? imgdata + 3 * planesize : NULL;
+    int channels = (bpp == 32) ? 4 : 3;
 
-	int bpp = (int)[bitmap bitsPerPixel];
+    for (int y = 0; y < height; y++)
+    {
+      /* Source imgdata is bottom-up */
+      int src_line_offset = (height - 1 - y) * width;
+      /* Destination NSBitmapImageRep is top-down */
+      unsigned char* dest_pixel_line = pixels + y * bytesPerRow;
 
-		
-	int bytes_per_row = CalculateBytesPerRow(image_size.width, bpp/8);
-	int total_bytes = bytes_per_row*image_size.height;
+      for (int x = 0; x < width; x++)
+      {
+        unsigned char* dest_pixel = dest_pixel_line + x * channels;
+        dest_pixel[0] = r_plane[src_line_offset + x];
+        dest_pixel[1] = g_plane[src_line_offset + x];
+        dest_pixel[2] = b_plane[src_line_offset + x];
+        if (channels == 4 && a_plane)
+        {
+          dest_pixel[3] = a_plane[src_line_offset + x];
+        }
+      }
+    }
+  }
+  else if (bpp == 8)
+  {
+    for (int y = 0; y < height; y++)
+    {
+      /* Source imgdata is bottom-up */
+      int src_line_offset = (height - 1 - y) * width;
+      /* Destination NSBitmapImageRep is top-down */
+      unsigned char* dest_pixel_line = pixels + y * bytesPerRow;
 
-	unsigned char* bitmap_data = [bitmap bitmapData];
-	memcpy(out_img_data, bitmap_data, total_bytes);
+      for (int x = 0; x < width; x++)
+      {
+        unsigned char* dest_pixel = dest_pixel_line + x * 4;
+        unsigned char index = imgdata[src_line_offset + x];
+        iupColor* c = &colors[index];
+        dest_pixel[0] = c->r;
+        dest_pixel[1] = c->g;
+        dest_pixel[2] = c->b;
+        dest_pixel[3] = 255; /* IM palettes do not have alpha */
+      }
+    }
+  }
 
-
+  return bitmap_image;
 }
-#endif
 
-
-
-
-// FIXME:  Probably wrong. Untested, don't know what calls this, don't know how to test. Started using for drag/drop, but not sure if that usage is the same.
-// Update: I'm now worried this is related to the IM library stuff, and is expecting pixels separate R, G, B, A arrays.
-// This is not how I'm using it.
-NSBitmapImageRep* iupCocoaImageNSBitmapImageRepFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
+static NSImage* iupCocoaImageNSImageFromRawData(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
 {
+  NSBitmapImageRep* bitmap_image = iupCocoaImageNSBitmapImageRepFromRawData(width, height, bpp, colors, colors_count, imgdata);
+  if (nil == bitmap_image)
+  {
+    return nil;
+  }
 
+  NSImage* ns_image = [[NSImage alloc] initWithSize:NSMakeSize(width,height)];
+  if (nil == ns_image)
+  {
+    [bitmap_image release];
+    return nil;
+  }
 
-	
-	NSBitmapImageRep* bitmap_image = nil;
+  [ns_image addRepresentation:bitmap_image];
+  [bitmap_image release];
 
-	
-	if(32 == bpp)
-	{
-		bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
-														 pixelsWide:width pixelsHigh:height bitsPerSample:8
-													samplesPerPixel:4 hasAlpha:YES isPlanar:NO
-													 colorSpaceName:NSDeviceRGBColorSpace
-															// I thought this should be 0 because I thought I want pre-multipled alpha, but some png's I'm testing render better with this flag.
-															 bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
-														bytesPerRow:CalculateBytesPerRow(width, 4)
-													   bitsPerPixel:32
-						];
-	}
-	else if(24 == bpp)
-	{
-		bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
-															   pixelsWide:width pixelsHigh:height bitsPerSample:8
-														  samplesPerPixel:3 hasAlpha:NO isPlanar:NO
-														   colorSpaceName:NSDeviceRGBColorSpace
-															// untested
-															 bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
-															  bytesPerRow:CalculateBytesPerRow(width, 3)
-													   bitsPerPixel:24
-						];
-	}
-	else if(8 == bpp)
-	{
-		
-		// We'll make a full 32-bit image for this case
-		bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
-															   pixelsWide:width pixelsHigh:height bitsPerSample:8
-														  samplesPerPixel:4 hasAlpha:YES isPlanar:NO
-														   colorSpaceName:NSDeviceRGBColorSpace
-															// untested
-															bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
-															  bytesPerRow:CalculateBytesPerRow(width, 4)
-													   bitsPerPixel:32
-						];
-		
-	}
-	else
-	{
-		return NULL;
-	}
-	
-	
-	
-	if(32 == bpp)
-	{
-		//  unsigned char *red,*green,*blue,*alpha;
-		unsigned char* source_pixel;
+  return ns_image;
+}
 
-		//  unsigned char *pixels = malloc(width*height*bpp);
-		unsigned char *pixels = [bitmap_image bitmapData];
-		int row_length = CalculateRowLength(width, 4);
+NSBitmapImageRep* iupcocoaImageNSBitmapImageRepFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
+{
+  NSBitmapImageRep* bitmap_image = nil;
 
+  if (bpp == 32 || bpp == 8)
+  {
+    bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
+                                                           pixelsWide:width pixelsHigh:height bitsPerSample:8
+                                                      samplesPerPixel:4 hasAlpha:YES isPlanar:NO
+                                                       colorSpaceName:NSDeviceRGBColorSpace
+                                                         bitmapFormat:NSBitmapFormatAlphaNonpremultiplied
+                                                          bytesPerRow:CalculateBytesPerRow(width, 4)
+                                                         bitsPerPixel:32];
+  }
+  else if (bpp == 24)
+  {
+    bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
+                                                           pixelsWide:width pixelsHigh:height bitsPerSample:8
+                                                      samplesPerPixel:3 hasAlpha:NO isPlanar:NO
+                                                       colorSpaceName:NSDeviceRGBColorSpace
+                                                         bitmapFormat:0
+                                                          bytesPerRow:CalculateBytesPerRow(width, 3)
+                                                         bitsPerPixel:24];
+  }
+  else
+  {
+    return NULL;
+  }
 
-		
-		source_pixel = imgdata;
+  unsigned char *pixels = [bitmap_image bitmapData];
+  NSInteger bytesPerRow = [bitmap_image bytesPerRow];
 
-		
-		for(int y=0;y<height;y++)
-		{
-			for(int x=0;x<row_length;x++)
-			{
-				unsigned char s_r = *source_pixel;
-				source_pixel++;
-				unsigned char s_g = *source_pixel;
-				source_pixel++;
-				unsigned char s_b = *source_pixel;
-				source_pixel++;
-				unsigned char s_a = *source_pixel;
-				source_pixel++;
+  if (bpp == 32 || bpp == 24)
+  {
+    int channels = (bpp == 32) ? 4 : 3;
+    int src_line_size = width * channels;
 
+    for (int y = 0; y < height; y++)
+    {
+      unsigned char* dest_line = pixels + y * bytesPerRow;
+      unsigned char* src_line = imgdata + y * src_line_size;
+      memcpy(dest_line, src_line, src_line_size);
+    }
+  }
+  else if (bpp == 8)
+  {
+    int has_alpha = 0;
+    for (int i = 0; i < colors_count; i++)
+    {
+      if (colors[i].a < 255)
+      {
+        has_alpha = 1;
+        break;
+      }
+    }
 
-				*pixels = s_r;
-				pixels++;
-				*pixels = s_g;
-				pixels++;
-				*pixels = s_b;
-				pixels++;
-				*pixels = s_a;
-				pixels++;
-			}
-		}
+    for (int y = 0; y < height; y++)
+    {
+      unsigned char* dest_line = pixels + y * bytesPerRow;
+      unsigned char* src_line = imgdata + y * width;
 
-		
-		
-		
-		
-	}
-	else if(24 == bpp)
-	{
-		//  unsigned char *red,*green,*blue,*alpha;
-		unsigned char* source_pixel;
-		
-		//  unsigned char *pixels = malloc(width*height*bpp);
-		unsigned char *pixels = [bitmap_image bitmapData];
-		
-		int row_length = CalculateRowLength(width, 3);
-		
-		source_pixel = imgdata;
-		
-		
+      for (int x = 0; x < width; x++)
+      {
+        unsigned char* dest_pixel = dest_line + x * 4;
+        unsigned char index = src_line[x];
+        iupColor* c = &colors[index];
+        dest_pixel[0] = c->r;
+        dest_pixel[1] = c->g;
+        dest_pixel[2] = c->b;
+        dest_pixel[3] = has_alpha ? c->a : 255;
+      }
+    }
+  }
 
-		for(int y=0;y<height;y++)
-		{
-			for(int x=0;x<row_length;x++)
-			{
-				unsigned char s_r = *source_pixel;
-				source_pixel++;
-				unsigned char s_g = *source_pixel;
-				source_pixel++;
-				unsigned char s_b = *source_pixel;
-				source_pixel++;
+  return bitmap_image;
+}
 
+NSImage* iupcocoaImageNSImageFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
+{
+  NSBitmapImageRep* bitmap_image = iupcocoaImageNSBitmapImageRepFromPixels(width, height, bpp, colors, colors_count, imgdata);
+  if (nil == bitmap_image)
+  {
+    return nil;
+  }
 
+  NSImage* ns_image = [[NSImage alloc] initWithSize:NSMakeSize(width, height)];
+  if (nil == ns_image)
+  {
+    [bitmap_image release];
+    return nil;
+  }
 
-				*pixels = s_r;
-				pixels++;
-				*pixels = s_g;
-				pixels++;
-				*pixels = s_b;
-				pixels++;
-			}
-		}
+  [ns_image addRepresentation:bitmap_image];
+  [bitmap_image release];
 
-		
-		
-
-	}
-	else if(8 == bpp)
-	{
-#if 1
-		//  unsigned char *red,*green,*blue,*alpha;
-		unsigned char* source_pixel;
-		
-		//  unsigned char *pixels = malloc(width*height*bpp);
-		unsigned char *pixels = [bitmap_image bitmapData];
-		
-		int row_length = CalculateRowLength(width, 4);
-
-
-		
-		int has_alpha = 0;
-
-		
-
-		
-		
-		
-		source_pixel = imgdata;
-		
-		
-		for(int y=0;y<height;y++)
-		{
-			for(int x=0;x<row_length;x++)
-			{
-				unsigned char index = *source_pixel;
-				iupColor* c = &colors[index];
-
-				unsigned char s_r = c->r;
-				unsigned char s_g = c->g;
-				unsigned char s_b = c->b;
-				unsigned char s_a;
-
-				if(has_alpha)
-				{
-					s_a = c->a;
-				}
-				else
-				{
-					s_a = 255;
-				}
-
-
-
-				*pixels = s_r;
-				pixels++;
-				*pixels = s_g;
-				pixels++;
-				*pixels = s_b;
-				pixels++;
-				*pixels = s_a;
-				pixels++;
-				
-				source_pixel++;
-			}
-		}
-
-		
-
-		
-#endif
-		
-	}
-	else
-	{
-
-		
-	}
-	
-
-	
-	
-	[bitmap_image autorelease];
-	
-
-
-	// I originally thought I needed to return an autoreleased image, but IUP is putting this into a handle with a destroy hook.
-	// And I was crashing in NSAutoreleasePool drain when autoreleasing this.
-	// Update:
-	// The typical pattern is to call image = iupImageGetImage(),
-	// and then call [foo setImage:image];
-	// This might imply that we should return as autoreleased.
-	// But I think IUP is supposed to run iupdrvImageDestroy() if things are written correctly.
-	// That would mean we want to return with a retain count of 1
-	return bitmap_image;
+  return ns_image;
 }
 
-// FIXME:  Probably wrong. Untested, don't know what calls this, don't know how to test. Started using for drag/drop, but not sure if that usage is the same.
-// Update: I'm now worried this is related to the IM library stuff, and is expecting pixels separate R, G, B, A arrays.
-// This is not how I'm using it.
-NSImage* iupCocoaImageNSImageFromPixels(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
+IUP_SDK_API void* iupdrvImageCreateImageRaw(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
 {
-	NSBitmapImageRep* bitmap_image = iupCocoaImageNSBitmapImageRepFromPixels(width, height, bpp, colors, colors_count, imgdata);
-	
-	if(nil == bitmap_image)
-	{
-		return nil;
-	}
-	
-	NSImage* ns_image = [[NSImage alloc] initWithSize:NSMakeSize(width,height)];
-	if(nil == ns_image)
-	{
-		return nil;
-	}
-	[ns_image autorelease];
-	
-	[ns_image addRepresentation:bitmap_image];
-	
-	return ns_image;
+  NSImage* ns_image = iupCocoaImageNSImageFromRawData(width, height, bpp, colors, colors_count, imgdata);
 
-}
+  if (ns_image)
+  {
+    IFvs cb = (IFvs)IupGetFunction("IMAGECREATE_CB");
+    if (cb)
+      cb(ns_image, "NSImage");
+  }
 
-// FIXME:  Probably wrong. Untested, don't know what calls this, don't know how to test.
-// Update: I'm now worried this is related to the IM library stuff, and is expecting pixels separate R, G, B, A arrays.
-// This is not how I'm using it.
-// At one point, I used it for drag & drop, but I refactored it so it no longer calls this, but uses underlying functions.
-void* iupdrvImageCreateImageRaw(int width, int height, int bpp, iupColor* colors, int colors_count, unsigned char *imgdata)
-{
-	return iupCocoaImageNSImageFromPixels(width, height, bpp, colors, colors_count, imgdata);
+  return ns_image;
 }
 
-int iupdrvImageGetRawInfo(void* handle, int *w, int *h, int *bpp, iupColor* colors, int *colors_count)
+IUP_SDK_API int iupdrvImageGetRawInfo(void* handle, int *w, int *h, int *bpp, iupColor* colors, int *colors_count)
 {
-  /* How to get the pallete? */
+  /* Getting the color palette from a native Cocoa image is not straightforward,
+     as indexed color images are often converted to RGB(A) automatically. */
   (void)colors;
   (void)colors_count;
   return iupdrvImageGetInfo(handle, w, h, bpp);
 }
 
-
-void* iupdrvImageCreateImage(Ihandle *ih, const char* bgcolor, int make_inactive)
+static NSImage* iupCocoaCreateNSImage(Ihandle *ih, const char* bgcolor, int make_inactive)
 {
-  int y, x, bpp, bgcolor_depend = 0,
-      width = ih->currentwidth,
-      height = ih->currentheight;
+  int width = ih->currentwidth;
+  int height = ih->currentheight;
+  int bpp = iupAttribGetInt(ih, "BPP");
   unsigned char *imgdata = (unsigned char*)iupAttribGetStr(ih, "WID");
   unsigned char bg_r=0, bg_g=0, bg_b=0;
-  bpp = iupAttribGetInt(ih, "BPP");
+  int flat_alpha = iupAttribGetBoolean(ih, "FLAT_ALPHA");
+
   iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);
 
-  NSImage* ns_image = [[NSImage alloc] initWithSize:NSMakeSize(width,height)];
-  if (!ns_image)
+  NSBitmapImageRep* bitmap_image = nil;
+
+  /* For 8bpp, we create a 32bpp image for simplicity and to handle alpha. */
+  if (bpp == 32 || bpp == 8)
   {
+    bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
+                                                           pixelsWide:width pixelsHigh:height bitsPerSample:8
+                                                      samplesPerPixel:4 hasAlpha:YES isPlanar:NO
+                                                       colorSpaceName:NSDeviceRGBColorSpace
+                                                         bitmapFormat:NSBitmapFormatAlphaNonpremultiplied
+                                                          bytesPerRow:CalculateBytesPerRow(width, 4)
+                                                         bitsPerPixel:32];
+  }
+  else if (bpp == 24)
+  {
+    bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
+                                                           pixelsWide:width pixelsHigh:height bitsPerSample:8
+                                                      samplesPerPixel:3 hasAlpha:NO isPlanar:NO
+                                                       colorSpaceName:NSDeviceRGBColorSpace
+                                                         bitmapFormat:0
+                                                          bytesPerRow:CalculateBytesPerRow(width, 3)
+                                                         bitsPerPixel:24];
+  }
+  else
+  {
     return NULL;
   }
-	
-	NSBitmapImageRep* bitmap_image = nil;
 
-	
-	if(32 == bpp)
-	{
-		bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
-														 pixelsWide:width pixelsHigh:height bitsPerSample:8
-													samplesPerPixel:4 hasAlpha:YES isPlanar:NO
-													 colorSpaceName:NSDeviceRGBColorSpace
-															// I thought this should be 0 because I thought I want pre-multipled alpha, but some png's I'm testing render better with this flag.
-															 bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
-														bytesPerRow:CalculateBytesPerRow(width, 4)
-													   bitsPerPixel:32
-						];
-	}
-	else if(24 == bpp)
-	{
-		bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
-															   pixelsWide:width pixelsHigh:height bitsPerSample:8
-														  samplesPerPixel:3 hasAlpha:NO isPlanar:NO
-														   colorSpaceName:NSDeviceRGBColorSpace
-															// untested
-															 bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
-															  bytesPerRow:CalculateBytesPerRow(width, 3)
-													   bitsPerPixel:24
-						];
-	}
-	else if(8 == bpp)
-	{
-		
-		// We'll make a full 32-bit image for this case
-		bitmap_image = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:NULL
-															   pixelsWide:width pixelsHigh:height bitsPerSample:8
-														  samplesPerPixel:4 hasAlpha:YES isPlanar:NO
-														   colorSpaceName:NSDeviceRGBColorSpace
-															// untested
-															bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
-															  bytesPerRow:CalculateBytesPerRow(width, 4)
-													   bitsPerPixel:32
-						];
-		
-	}
-	else
-	{
-		[ns_image release];
-		return NULL;
-	}
-	
-	
-	
-	if(32 == bpp)
-	{
-		//  unsigned char *red,*green,*blue,*alpha;
-		unsigned char* source_pixel;
+  if (!bitmap_image)
+  {
+    return NULL;
+  }
 
-		//  unsigned char *pixels = malloc(width*height*bpp);
-		unsigned char *pixels = [bitmap_image bitmapData];
-		int row_length = CalculateRowLength(width, 4);
+  unsigned char *pixels = [bitmap_image bitmapData];
+  NSInteger bytes_per_row = [bitmap_image bytesPerRow];
 
+  if (bpp == 32)
+  {
+    for (int y = 0; y < height; y++)
+    {
+      unsigned char* dest_line = pixels + y * bytes_per_row;
+      unsigned char* src_line = imgdata + y * width * 4;
+      for (int x = 0; x < width; x++)
+      {
+        unsigned char* dest_pixel = dest_line + x * 4;
+        unsigned char* src_pixel = src_line + x * 4;
+        unsigned char s_r = src_pixel[0];
+        unsigned char s_g = src_pixel[1];
+        unsigned char s_b = src_pixel[2];
+        unsigned char s_a = src_pixel[3];
 
-		
-		source_pixel = imgdata;
+        if (flat_alpha && s_a != 255)
+        {
+          s_r = iupALPHABLEND(s_r, bg_r, s_a);
+          s_g = iupALPHABLEND(s_g, bg_g, s_a);
+          s_b = iupALPHABLEND(s_b, bg_b, s_a);
+          s_a = 255;
+        }
 
-		
-		for(int y=0;y<height;y++)
-		{
-			for(int x=0;x<row_length;x++)
-			{
-				unsigned char s_r = *source_pixel;
-				source_pixel++;
-				unsigned char s_g = *source_pixel;
-				source_pixel++;
-				unsigned char s_b = *source_pixel;
-				source_pixel++;
-				unsigned char s_a = *source_pixel;
-				source_pixel++;
+        if (make_inactive)
+        {
+          iupImageColorMakeInactive(&s_r, &s_g, &s_b, bg_r, bg_g, bg_b);
+        }
 
-				if(make_inactive)
-				{
-					iupImageColorMakeInactive(&s_r, &s_g, &s_b, bg_r, bg_g, bg_b);
-				}
+        dest_pixel[0] = s_r;
+        dest_pixel[1] = s_g;
+        dest_pixel[2] = s_b;
+        dest_pixel[3] = s_a;
+      }
+    }
+  }
+  else if (bpp == 24)
+  {
+    for (int y = 0; y < height; y++)
+    {
+      unsigned char* dest_line = pixels + y * bytes_per_row;
+      unsigned char* src_line = imgdata + y * width * 3;
+      for (int x = 0; x < width; x++)
+      {
+        unsigned char* dest_pixel = dest_line + x * 3;
+        unsigned char* src_pixel = src_line + x * 3;
+        unsigned char s_r = src_pixel[0];
+        unsigned char s_g = src_pixel[1];
+        unsigned char s_b = src_pixel[2];
 
-				*pixels = s_r;
-				pixels++;
-				*pixels = s_g;
-				pixels++;
-				*pixels = s_b;
-				pixels++;
-				*pixels = s_a;
-				pixels++;
-			}
-		}
+        if (make_inactive)
+        {
+          iupImageColorMakeInactive(&s_r, &s_g, &s_b, bg_r, bg_g, bg_b);
+        }
 
-		
-		
-		
-		
-	}
-	else if(24 == bpp)
-	{
-		//  unsigned char *red,*green,*blue,*alpha;
-		unsigned char* source_pixel;
-		
-		//  unsigned char *pixels = malloc(width*height*bpp);
-		unsigned char *pixels = [bitmap_image bitmapData];
-		
-		int row_length = CalculateRowLength(width, 3);
-		
-		source_pixel = imgdata;
-		
-		
+        dest_pixel[0] = s_r;
+        dest_pixel[1] = s_g;
+        dest_pixel[2] = s_b;
+      }
+    }
+  }
+  else if (bpp == 8)
+  {
+    int colors_count = 0;
+    iupColor colors[256];
+    int has_alpha = iupImageInitColorTable(ih, colors, &colors_count);
 
-		for(int y=0;y<height;y++)
-		{
-			for(int x=0;x<row_length;x++)
-			{
-				unsigned char s_r = *source_pixel;
-				source_pixel++;
-				unsigned char s_g = *source_pixel;
-				source_pixel++;
-				unsigned char s_b = *source_pixel;
-				source_pixel++;
+    for (int y = 0; y < height; y++)
+    {
+      unsigned char* dest_line = pixels + y * bytes_per_row;
+      unsigned char* src_line = imgdata + y * width;
+      for (int x = 0; x < width; x++)
+      {
+        unsigned char* dest_pixel = dest_line + x * 4;
+        unsigned char index = src_line[x];
+        iupColor* c = &colors[index];
 
-				if(make_inactive)
-				{
-					iupImageColorMakeInactive(&s_r, &s_g, &s_b, bg_r, bg_g, bg_b);
-				}
+        unsigned char s_r = c->r;
+        unsigned char s_g = c->g;
+        unsigned char s_b = c->b;
+        unsigned char s_a = has_alpha ? c->a : 255;
 
-				*pixels = s_r;
-				pixels++;
-				*pixels = s_g;
-				pixels++;
-				*pixels = s_b;
-				pixels++;
-			}
-		}
+        if (flat_alpha && s_a != 255)
+        {
+          s_r = iupALPHABLEND(s_r, bg_r, s_a);
+          s_g = iupALPHABLEND(s_g, bg_g, s_a);
+          s_b = iupALPHABLEND(s_b, bg_b, s_a);
+          s_a = 255;
+        }
 
-		
-		
+        if (make_inactive)
+        {
+          iupImageColorMakeInactive(&s_r, &s_g, &s_b, bg_r, bg_g, bg_b);
+        }
 
-	}
-	else if(8 == bpp)
-	{
-#if 1
-		//  unsigned char *red,*green,*blue,*alpha;
-		unsigned char* source_pixel;
-		
-		//  unsigned char *pixels = malloc(width*height*bpp);
-		unsigned char *pixels = [bitmap_image bitmapData];
-		
-		int row_length = CalculateRowLength(width, 4);
+        dest_pixel[0] = s_r;
+        dest_pixel[1] = s_g;
+        dest_pixel[2] = s_b;
+        dest_pixel[3] = s_a;
+      }
+    }
+  }
 
-		int colors_count = 0;
-		iupColor colors[256];
-		
-		int has_alpha = iupImageInitColorTable(ih, colors, &colors_count);
+  NSImage* ns_image = [[NSImage alloc] initWithSize:NSMakeSize(width, height)];
+  [ns_image addRepresentation:bitmap_image];
+  [bitmap_image release];
 
-		
+  if (make_inactive || flat_alpha)
+  {
+    iupAttribSetStr(ih, "_IUP_BGCOLOR_DEPEND", "1");
+  }
 
-		
-		
-		
-		source_pixel = imgdata;
-		
-		
-		for(int y=0;y<height;y++)
-		{
-			for(int x=0;x<row_length;x++)
-			{
-				unsigned char index = *source_pixel;
-				iupColor* c = &colors[index];
+  return ns_image;
+}
 
-				unsigned char s_r = c->r;
-				unsigned char s_g = c->g;
-				unsigned char s_b = c->b;
-				unsigned char s_a;
+void* iupdrvImageCreateImage(Ihandle *ih, const char* bgcolor, int make_inactive)
+{
+  NSImage* ns_image = iupCocoaCreateNSImage(ih, bgcolor, make_inactive);
 
-				if(has_alpha)
-				{
-					s_a = c->a;
-				}
-				else
-				{
-					s_a = 255;
-				}
+  if (ns_image)
+  {
+    IFvs cb = (IFvs)IupGetFunction("IMAGECREATE_CB");
+    if (cb)
+      cb(ns_image, "NSImage");
+  }
 
-				if(make_inactive)
-				{
-					iupImageColorMakeInactive(&s_r, &s_g, &s_b, bg_r, bg_g, bg_b);
-				}
-
-
-				*pixels = s_r;
-				pixels++;
-				*pixels = s_g;
-				pixels++;
-				*pixels = s_b;
-				pixels++;
-				*pixels = s_a;
-				pixels++;
-				
-				source_pixel++;
-			}
-		}
-
-		
-
-		
-#endif
-		
-	}
-	else
-	{
-
-		
-	}
-	
-
-	
-	
-  [ns_image addRepresentation:bitmap_image];
-	[bitmap_image release];
-  if (bgcolor_depend || make_inactive)
-    iupAttribSetStr(ih, "_IUP_BGCOLOR_DEPEND", "1");
-
-
-	// I originally thought I needed to return an autoreleased image, but IUP is putting this into a handle with a destroy hook.
-	// And I was crashing in NSAutoreleasePool drain when autoreleasing this.
-	// Update:
-	// The typical pattern is to call image = iupImageGetImage(),
-	// and then call [foo setImage:image];
-	// This might imply that we should return as autoreleased.
-	// But I think IUP is supposed to run iupdrvImageDestroy() if things are written correctly.
-	// That would mean we want to return with a retain count of 1
-	return ns_image;
+  return ns_image;
 }
 
 void* iupdrvImageCreateIcon(Ihandle *ih)
 {
-  return iupdrvImageCreateImage(ih, NULL, 0);
+  NSImage* ns_image = iupCocoaCreateNSImage(ih, NULL, 0);
+
+  if (ns_image)
+  {
+    IFvs cb = (IFvs)IupGetFunction("IMAGECREATE_CB");
+    if (cb)
+      cb(ns_image, "ICON");
+  }
+
+  return ns_image;
 }
 
 void* iupdrvImageCreateCursor(Ihandle *ih)
 {
-  int bpp,y,x,hx,hy,
-      width = ih->currentwidth,
-      height = ih->currentheight,
-      line_size = (width+7)/8,
-      size_bytes = line_size*height;
-  unsigned char *imgdata = (unsigned char*)iupAttribGetStr(ih, "WID");
-  char *sbits, *mbits, *sb, *mb;
-  unsigned char r, g, b;
+  int hx=0, hy=0;
+  iupStrToIntInt(iupAttribGet(ih, "HOTSPOT"), &hx, &hy, ':');
 
-  bpp = iupAttribGetInt(ih, "BPP");
-  if (bpp > 8)
+  NSImage *image = iupCocoaCreateNSImage(ih, NULL, 0);
+  if (!image)
+  {
     return NULL;
+  }
 
-  sbits = (char*)malloc(2*size_bytes);
-  if (!sbits) return NULL;
-  memset(sbits, 0, 2*size_bytes);
-  mbits = sbits + size_bytes;
+  NSSize size = [image size];
+  NSPoint hotSpot = NSMakePoint(hx, size.height - 1 - hy);
 
-  sb = sbits;
-  mb = mbits;
-  for (y=0; y<height; y++)
+  NSCursor *cursor = [[NSCursor alloc] initWithImage:image hotSpot:hotSpot];
+  [image release];
+
+  if (cursor)
   {
-    for (x=0; x<width; x++)
-    {
-      int byte = x/8;
-      int bit = x%8;
-      int index = (int)imgdata[y*width+x];
-      /* index==0 is transparent */
-      if (index == 1)
-        sb[byte] = (char)(sb[byte] | (1<<bit));
-      if (index != 0)
-        mb[byte] = (char)(mb[byte] | (1<<bit));
-    }
-
-    sb += line_size;
-    mb += line_size;
+    IFvs cb = (IFvs)IupGetFunction("IMAGECREATE_CB");
+    if (cb)
+      cb(cursor, "CURSOR");
   }
 
-  hx=0; hy=0;
-  iupStrToIntInt(iupAttribGet(ih, "HOTSPOT"), &hx, &hy, ':');
+  return cursor;
+}
 
-  NSData *tiffData = [NSData dataWithBytes:imgdata length:(width*height*(bpp/8))];
-  NSImage *source = [[NSImage alloc] initWithData:tiffData];
-  NSSize size = {width,height};
-  [source setSize:size]; 
+void* iupdrvImageLoad(const char* name, int type)
+{
+  if (!name || (name[0] == '\0'))
+  {
+    return NULL;
+  }
 
-  NSPoint point = {hx,hy};
+  NSImage* the_image = nil;
+  NSString* ns_name = [NSString stringWithUTF8String:name];
 
-  NSCursor *cursor = [[NSCursor alloc] initWithImage:source hotSpot:point];
-	[source release];
-  free(sbits);
+  the_image = [[NSImage alloc] initWithContentsOfFile:ns_name];
 
-	return cursor;
-}
+  if (nil == the_image)
+  {
+    NSString* resource_path = [[NSBundle mainBundle] resourcePath];
+    NSString* the_path = [resource_path stringByAppendingPathComponent:ns_name];
+    the_image = [[NSImage alloc] initWithContentsOfFile:the_path];
+  }
 
-void* iupdrvImageCreateMask(Ihandle *ih)
-{
-  int bpp,y,x,
-      width = ih->currentwidth,
-      height = ih->currentheight,
-      line_size = (width+7)/8,
-      size_bytes = line_size*height;
-  unsigned char *imgdata = (unsigned char*)iupAttribGetStr(ih, "WID");
-  char *bits, *sb;
-  unsigned char colors[256];
+  if (nil == the_image)
+  {
+    NSString* bundle_path = [[NSBundle mainBundle] bundlePath];
+    bundle_path = [bundle_path stringByDeletingLastPathComponent];
+    NSString* the_path = [bundle_path stringByAppendingPathComponent:ns_name];
+    the_image = [[NSImage alloc] initWithContentsOfFile:the_path];
+  }
 
-  bpp = iupAttribGetInt(ih, "BPP");
-  if (bpp > 8)
+  if (nil == the_image)
+  {
     return NULL;
+  }
 
-  bits = (char*)malloc(size_bytes);
-  if (!bits) return NULL;
-  memset(bits, 0, size_bytes);
+  if ([[the_image representations] count] > 0)
+  {
+    id rep = [[the_image representations] objectAtIndex:0];
+    if ([rep isKindOfClass:[NSBitmapImageRep class]])
+    {
+      NSBitmapImageRep* bitmap_rep = (NSBitmapImageRep*)rep;
+      NSSize image_size = NSMakeSize([bitmap_rep pixelsWide], [bitmap_rep pixelsHigh]);
+      [the_image setSize:image_size];
+    }
+  }
 
-  iupImageInitNonBgColors(ih, colors);
-
-  sb = bits;
-  for (y=0; y<height; y++)
+  if (the_image)
   {
-    for (x=0; x<width; x++)
+    IFvs cb = (IFvs)IupGetFunction("IMAGECREATE_CB");
+    if (cb)
     {
-      int byte = x/8;
-      int bit = x%8;
-      int index = (int)imgdata[y*width+x];
-      if (colors[index])
-        sb[byte] = (char)(sb[byte] | (1<<bit));
+      const char* type_str = (type == IUPIMAGE_CURSOR) ? "CURSOR" :
+                             (type == IUPIMAGE_ICON) ? "ICON" : "NSImage";
+      cb(the_image, (char*)type_str);
     }
-
-    sb += line_size;
   }
 
-  NSData *tiffData = [NSData dataWithBytes:imgdata length:(width*height*(bpp/8))];
-  NSImage *mask = [[NSImage alloc] initWithData:tiffData];
-  NSSize size = {width,height};
-  [mask setSize:size]; 
-  free(bits);
-
-	return (void*)mask;
+  return (void*)the_image;
 }
 
-void* iupdrvImageLoad(const char* name, int type)
+int iupdrvImageGetInfo(void* handle, int *w, int *h, int *bpp)
 {
-	if(!name || (name[0] == '\0'))
-	{
-		return NULL;
-	}
-  //int iup2mac[3] = {IMAGE_BITMAP, IMAGE_ICON, IMAGE_CURSOR};
-	NSImage* the_image = nil;
-	NSString* bundle_path = [[NSBundle mainBundle] bundlePath];
+  if (w) *w = 0;
+  if (h) *h = 0;
+  if (bpp) *bpp = 0;
 
-	NSString* ns_name = [NSString stringWithUTF8String:name];
-	
-	// Problem: The path either must be absolute, or it must be in the application bundle.
-	// TODO: We could also try to look elsewhere if we choose to, but beware of Sandboxing.
-	// Do we need to worry about images embedded in the IUP frameworks? (I think not because they are compiled into code.)
-	
-	// First, just try what was given. This could be an absolute path or current working directory.
-	the_image = [[NSImage alloc] initWithContentsOfFile:ns_name];
-	if(nil == the_image)
-	{
-		// Next, let's try the app bundle
-		NSString* resource_path = [[NSBundle mainBundle] resourcePath];
-		NSString* the_path = [resource_path stringByAppendingPathComponent:ns_name];
-		the_image = [[NSImage alloc] initWithContentsOfFile:the_path];
+  if (NULL == handle)
+    return 0;
 
+  if (![(__bridge id)handle isKindOfClass:[NSImage class]])
+    return 0;
 
-	}
-	// if that still failed, let's try the directory where the app bundle resides.
-	// NOTE: Nobody should ship an app like this, but this is mainly for the Iup testing directory
-	if(nil == the_image)
-	{
-		NSString* bundle_path = [[NSBundle mainBundle] bundlePath];
-		// Chop off the Foo.app part
-		bundle_path = [bundle_path stringByDeletingLastPathComponent];
-		
-		NSString* the_path = [bundle_path stringByAppendingPathComponent:ns_name];
-		the_image = [[NSImage alloc] initWithContentsOfFile:the_path];
-	}
-	
-	
-	// giving up
-	if(nil == the_image)
-	{
-		return NULL;
-	}
-	
-	NSBitmapImageRep* bitmap_rep = [[the_image representations] objectAtIndex:0];
-	// If you think you might get something other than a bitmap image representation,
-	// check for it here.
-
-	NSSize image_size = NSMakeSize([bitmap_rep pixelsWide], [bitmap_rep pixelsHigh]);
-	[the_image setSize:image_size];
-
-	return (void*)the_image;
-	
-}
-
-int iupdrvImageGetInfo(void* handle, int *w, int *h, int *bpp)
-{
-  if(w) *w = 0;
-  if(h) *h = 0;
-  if(bpp) *bpp = 0;
-  if(NULL == handle)
-  {
-    return 0;
-  }
   NSImage *image = (__bridge NSImage*)handle;
   NSBitmapImageRep* bitmap = nil;
-	
 
-   for(NSImageRep* image_rep in [image representations])
-   {
-      if([image_rep isKindOfClass:[NSBitmapImageRep class]] )
-      {
- 	     bitmap = (NSBitmapImageRep*)image_rep;
- 	     break;
-      }
-	}
-	
-//  if([[image representations] count]>0) bitmap = [[image representations] objectAtIndex:0];
-  if(bitmap==nil)
+  for(NSImageRep* image_rep in [image representations])
   {
-  	CGImageRef cg_image = [image CGImageForProposedRect:nil context:nil hints:nil];
-	bitmap = [[[NSBitmapImageRep alloc] initWithCGImage:cg_image] autorelease];
+    if ([image_rep isKindOfClass:[NSBitmapImageRep class]])
+    {
+      bitmap = (NSBitmapImageRep*)image_rep;
+      break;
+    }
+  }
 
-
-  
-  
-  }
-  if(bitmap==nil)
+  if (bitmap == nil)
   {
-    return 0;
+    CGImageRef cg_image = [image CGImageForProposedRect:nil context:nil hints:nil];
+    if (cg_image)
+    {
+      bitmap = [[[NSBitmapImageRep alloc] initWithCGImage:cg_image] autorelease];
+    }
   }
-  if(w) *w = [bitmap pixelsWide];
-  if(h) *h = [bitmap pixelsHigh];
-  if(bpp) *bpp = [bitmap bitsPerPixel];
-  return 1;
-}
 
-// [NSApp setApplicationIconImage: [NSImage imageNamed: @"Icon_name.icns"]]
+  if (bitmap == nil)
+    return 0;
 
-void iupdrvImageDestroy(void* handle, int type)
-{
-  switch (type)
-  {
-  case IUPIMAGE_IMAGE:
-    [handle release];
-    break;
-  case IUPIMAGE_ICON:
-    [handle release];
-    break;
-  case IUPIMAGE_CURSOR:
-    [handle release];
-    break;
-	  default:
-	  {
-		  NSLog(@"Warning: unexpected type in in iupdrvImageDestroy");
-		  [handle release];
-	  }
-  }
+  if (w) *w = (int)[bitmap pixelsWide];
+  if (h) *h = (int)[bitmap pixelsHigh];
+  if (bpp) *bpp = (int)[bitmap bitsPerPixel];
+  return 1;
 }
 
-
-
-
-//Use IupImageGetHandle
-/* DEPRECATED: Why doesn't IUP have a Load from file?
-IUP_EXPORT Ihandle* IupImageLoadFile(const char* file_name)
+IUP_SDK_API void iupdrvImageDestroy(void* handle, int type)
 {
-	int w;
-	int h;
-	int bpp;
-	Ihandle* image_ih = NULL;
-	
-	NSImage* ns_image = (NSImage*)iupdrvImageLoad(file_name, IUPIMAGE_IMAGE);
+  const char* type_str = (type == IUPIMAGE_CURSOR) ? "CURSOR" :
+                         (type == IUPIMAGE_ICON) ? "ICON" : "NSImage";
 
-	if(nil == ns_image)
-	{
-		return NULL;
-	}
-	
-	iupdrvImageGetInfo(ns_image, &w, &h, &bpp);
-	int bytes_per_row = iupCocoaImageCaluclateBytesPerRow(w, bpp/8);
-	size_t buffer_size = bytes_per_row*h;
-	unsigned char* img_data = malloc(buffer_size);
-	iupdrvImageGetData(ns_image, img_data);
-	
-	if(bpp == 32)
-	{
-		image_ih = IupImageRGBA(w, h, img_data);
+  IFvs cb = (IFvs)IupGetFunction("IMAGEDESTROY_CB");
+  if (cb)
+    cb(handle, (char*)type_str);
 
-	}
-	else if(bpp == 24)
-	{
-		image_ih = IupImageRGB(w, h, img_data);
-	}
-	else
-	{
-		image_ih = IupImage(w, h, img_data);
-	}
-	[ns_image release];
-
-	return image_ih;
+  [((__bridge id)handle) release];
 }
-*/
Index: src/cocoa/iupcocoa_info.m
===================================================================
--- src/cocoa/iupcocoa_info.m	(revision 5971)
+++ src/cocoa/iupcocoa_info.m	(working copy)
@@ -1,5 +1,5 @@
 /** \file
- * \brief MAC OS System Information
+ * \brief macOS System Information
  *
  * See Copyright Notice in "iup.h"
  */
@@ -8,487 +8,365 @@
 #include <stdlib.h>
 #include <string.h>
 
-/* This module should depend only on IUP core headers and
- Mac OS Carbon system headers. */
-
 #import <Cocoa/Cocoa.h>
-#include <asl.h>
-//#include <Carbon/Carbon.h>
-// For computer name
-#include <SystemConfiguration/SystemConfiguration.h>
+#import <CoreGraphics/CoreGraphics.h>
+#import <SystemConfiguration/SystemConfiguration.h>
+#import <os/log.h>
 
 #include <sys/utsname.h>
 #include <unistd.h>
 #include <limits.h>
-#include <errno.h>
-#include <sys/stat.h>
 #include <langinfo.h>
 
-//#include <gtk/gtk.h>
-
 #include "iup.h"
 #include "iup_varg.h"
-
 #include "iup_str.h"
 #include "iup_drv.h"
 #include "iup_drvinfo.h"
-#include "iup_class.h" // needed for iup_classbase.h
-#include "iup_classbase.h" // iupROUND
+#include "iup_class.h"
+#include "iup_classbase.h"
 
-#define IUP_MAC_ERROR -1
 
-#if 0
-static void iupMacStrToUniChar(const char* buffer, UniChar* outBuf, long length, long* outLen)
+IUP_SDK_API char* iupdrvGetCurrentDirectory(void)
 {
-	CFStringRef stringRef = CFStringCreateWithCString(NULL, buffer, kCFStringEncodingUTF8);
-	
-	CFStringGetCharacters (stringRef, CFRangeMake(0, CFStringGetLength(stringRef)), outBuf);
-	*outLen = (long) CFStringGetLength (stringRef);
-	
-	CFRelease(stringRef);
+  NSString *curDir = [[NSFileManager defaultManager] currentDirectoryPath];
+  const char *dir = [curDir UTF8String];
+  size_t size = strlen(dir) + 1;
+  char *buffer = (char *)iupStrGetMemory(size);
+  strcpy(buffer, dir);
+  return buffer;
 }
-#endif
 
-#if 0
-static int iMacIsFolder(const char* name)
+IUP_SDK_API int iupdrvSetCurrentDirectory(const char* dir)
 {
-	FSRef refName;
-	Boolean isFolder;
-	
-	if(FSPathMakeRef((const UInt8*)name, &refName, &isFolder) != noErr)
-		return IUP_MAC_ERROR;
-	
-	return isFolder;
+  NSString *path = [NSString stringWithUTF8String:dir];
+  BOOL r = [[NSFileManager defaultManager] changeCurrentDirectoryPath:path];
+  return (r ? 1 : 0);
 }
-#endif
 
-int iupdrvGetWindowDecor(void* wnd, int *border, int *caption)
+int cocoaMakeDirectory(const char* name)
 {
-#if 0
-	Rect rect;
-	CGRect cg;
-	int minX, minY;
-	
-	CGDirectDisplayID mainDisplayID = CGMainDisplayID();
-#ifdef OLD_MAC_INFO
-	GDHandle hGDev;
-	DMGetGDeviceByDisplayID((DisplayIDType)mainDisplayID, &hGDev, false);
-	GetAvailableWindowPositioningBounds(hGDev, &rect);
-#else
-	HIWindowGetAvailablePositioningBounds(mainDisplayID, kHICoordSpaceScreenPixel, &rect);
-#endif
-	
-	cg = CGRectMake(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
-	
-	minX = (int)CGRectGetMinX(cg);
-	minY = (int)CGRectGetMinY(cg);
-	
-	if (minX >= 0 && minY >= 0 && (minY >= minX))
-	{
-		*border  = minX;
-		*caption = minY - *border;
-  
-		return 1;
-	}
-	
-	*border  = 0;
-	*caption = 0;
-	
-	return 0;
-#endif
-	return 0;
+  NSString *path = [NSString stringWithUTF8String:name];
+  NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithUnsignedInt:0775], NSFilePosixPermissions, nil];
+  BOOL r = [[NSFileManager defaultManager] createDirectoryAtPath:path withIntermediateDirectories:YES attributes:dic error:NULL];
+  return (r ? 1 : 0);
+}
 
+int cocoaIsFile(const char* name)
+{
+  NSString *path = [NSString stringWithUTF8String:name];
+  BOOL isDir;
+  BOOL r = [[NSFileManager defaultManager] fileExistsAtPath:path isDirectory:&isDir];
+  return (r && !isDir ? 1 : 0);
 }
 
+int cocoaIsDirectory(const char* name)
+{
+  NSString *path = [NSString stringWithUTF8String:name];
+  BOOL isDir;
+  BOOL r = [[NSFileManager defaultManager] fileExistsAtPath:path isDirectory:&isDir];
+  return (r && isDir ? 1 : 0);
+}
+
+int cocoaGetWindowDecor(void* wnd, int *border, int *caption)
+{
+  (void)wnd;
+
+  NSRect contentRect = NSMakeRect(0, 0, 200, 200);
+  NSWindowStyleMask style = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable;
+
+  NSRect frameRect = [NSWindow frameRectForContentRect:contentRect styleMask:style];
+
+  if (border)
+  {
+    *border = iupROUND((frameRect.size.width - contentRect.size.width) / 2.0);
+  }
+  if (caption)
+  {
+    *caption = iupROUND(frameRect.size.height - contentRect.size.height);
+  }
+
+  return 1;
+}
+
 void iupdrvAddScreenOffset(int *x, int *y, int add)
 {
-	/* ?????? */
+  NSScreen *screen = [NSScreen mainScreen];
+  if (screen)
+  {
+    NSRect frame = [screen frame];
+    NSRect visibleFrame = [screen visibleFrame];
+
+    /* In IUP's top-left coordinate system, the offset is the top-left corner of the visible area (work area). */
+    int offset_x = visibleFrame.origin.x;
+    /* The y-offset is the height of the main menu bar. */
+    int offset_y = frame.size.height - (visibleFrame.origin.y + visibleFrame.size.height);
+
+    /* add > 0 means add offset, add < 0 means subtract offset, add == 0 means no change */
+    if (add > 0)
+    {
+      if (x) *x += offset_x;
+      if (y) *y += offset_y;
+    }
+    else if (add < 0)
+    {
+      if (x) *x -= offset_x;
+      if (y) *y -= offset_y;
+    }
+  }
 }
 
-// How is this different than iupdrvGetFullSize? Is this supposed to subtract the menu and dock?
 void iupdrvGetScreenSize(int *width, int *height)
 {
-	NSRect screen_rect = [[NSScreen mainScreen] visibleFrame];
-	
-	// Points vs. Pixels in Cocoa
-	//  int w_size = CGDisplayPixelsWide(kCGDirectMainDisplay);
-	//  int h_size = CGDisplayPixelsHigh(kCGDirectMainDisplay);
-	if (width) *width = screen_rect.size.width;
-	if (height) *height = screen_rect.size.height;
-	
+  /* Returns the usable screen area, excluding the menu bar and dock. */
+  NSRect screen_rect = [[NSScreen mainScreen] visibleFrame];
+  if (width) *width = (int)screen_rect.size.width;
+  if (height) *height = (int)screen_rect.size.height;
 }
 
 void iupdrvGetFullSize(int *width, int *height)
 {
-	/*
-  CGRect rect;
-	 
-  rect = CGDisplayBounds(kCGDirectMainDisplay);
-	 
-  *width  = (int)CGRectGetWidth(rect);
-  *height = (int)CGRectGetHeight(rect);
-	 */
-	NSRect screen_rect = [[NSScreen mainScreen] frame];
-	
-	// Points vs. Pixels in Cocoa
-	//  int w_size = CGDisplayPixelsWide(kCGDirectMainDisplay);
-	//  int h_size = CGDisplayPixelsHigh(kCGDirectMainDisplay);
-	if (width) *width = screen_rect.size.width;
-	if (height) *height = screen_rect.size.height;
+  NSRect screen_rect = [[NSScreen mainScreen] frame];
+  if (width) *width = (int)screen_rect.size.width;
+  if (height) *height = (int)screen_rect.size.height;
 }
 
 int iupdrvGetScreenDepth(void)
 {
-	return CGDisplayBitsPerPixel(kCGDirectMainDisplay);  /* Deprecated in Mac OS X v10.6 */
+  NSScreen* screen = [NSScreen mainScreen];
+  if (screen)
+  {
+    NSDictionary* deviceDescription = [screen deviceDescription];
+    NSNumber* bitsPerSample = [deviceDescription objectForKey:@"NSDeviceBitsPerSample"];
+    if (bitsPerSample)
+    {
+      int bits = [bitsPerSample intValue];
+      return bits * 4;
+    }
+  }
+  return 32;
 }
 
-// I think this is not going to work on Cocoa. Apple does everything in their power to hide this for retina.
 double iupdrvGetScreenDpi(void)
 {
-	CGRect rect = CGDisplayBounds(kCGDirectMainDisplay);
-	int height = (int)CGRectGetHeight(rect);   /* pixels */
-	CGSize size = CGDisplayScreenSize(kCGDirectMainDisplay);  /* millimeters */
-	return ((float)height / size.height) * 25.4f;  /* mm to inch */
+  NSScreen* screen = [NSScreen mainScreen];
+  if (screen != nil)
+  {
+    NSDictionary* deviceDescription = [screen deviceDescription];
+    NSSize resolution = [[deviceDescription objectForKey:NSDeviceResolution] sizeValue];
+    return resolution.height;
+  }
+  return 72.0;
 }
 
 void iupdrvGetCursorPos(int *x, int *y)
 {
-	NSPoint mouse_point;
-	mouse_point = [NSEvent mouseLocation];
-	// We need to invert the y-axis
-	NSRect screen_rect = [[NSScreen mainScreen] frame];
-	CGFloat inverted_y = screen_rect.size.height - mouse_point.y;
+  /* [NSEvent mouseLocation] origin is bottom-left of the primary screen. */
+  NSPoint mouse_point = [NSEvent mouseLocation];
 
-	if (x) *x = iupROUND(mouse_point.x);
-	if (y) *y = iupROUND(inverted_y);
+  /* Invert the y-axis for IUP's top-left origin system. */
+  NSRect screen_rect = [[NSScreen mainScreen] frame];
+  CGFloat inverted_y = screen_rect.size.height - mouse_point.y;
+
+  if (x) *x = iupROUND(mouse_point.x);
+  if (y) *y = iupROUND(inverted_y);
 }
 
 void iupdrvGetKeyState(char* key)
 {
-	// We can't support this. The currentEvent may not be the right kind and will throw an exception when our code tries to call invalid methods for the wrong type.
-	NSEvent* the_event = [[NSApplication sharedApplication] currentEvent];
-	if([the_event modifierFlags] & NSEventModifierFlagShift)
-	{
-		key[0] = 'S';
-	}
-	else
-	{
-		key[0] = ' ';
-	}
-	if([the_event modifierFlags] & NSEventModifierFlagControl)
-	{
-		key[1] = 'C';
-	}
-	else
-	{
-		key[1] = ' ';
-	}
-	if([the_event modifierFlags] & NSEventModifierFlagOption)
-	{
-		key[2] = 'A';
-	}
-	else
-	{
-		key[2] = ' ';
-	}
-	if([the_event modifierFlags] & NSEventModifierFlagCommand)
-	{
-		key[3] = 'Y';
-	}
-	else
-	{
-		key[3] = ' ';
-	}
+  NSEventModifierFlags flags = [NSEvent modifierFlags];
 
-	key[4] = 0;
-
+  key[0] = (flags & NSEventModifierFlagShift)   ? 'S' : ' ';
+  key[1] = (flags & NSEventModifierFlagControl) ? 'C' : ' ';
+  key[2] = (flags & NSEventModifierFlagOption)  ? 'A' : ' '; /* Alt Key */
+  key[3] = (flags & NSEventModifierFlagCommand) ? 'Y' : ' '; /* System Key */
+  key[4] = 0;
 }
 
 char *iupdrvGetSystemName(void)
 {
+  NSOperatingSystemVersion version = [[NSProcessInfo processInfo] operatingSystemVersion];
+  const char* codename = NULL;
 
-	// Ugh. This is too much work to maintain because the name changes every year and there still isn't a Mac port of iup after a decade.
-	// Note: Gestalt is deprecated.
-	// NSProcessInfo only returns numbers.
-	// uname returns kernel info
-	// Reading the plist won't work for sandboxing (Mac App Store requirement)
-	/*
-	 NSDictionary *version = [NSDictionary dictionaryWithContentsOfFile:@"/System/Library/CoreServices/SystemVersion.plist"];
-	 NSString *productVersion = [version objectForKey:@"ProductVersion"];
-	 NSLog (@"productVersion =========== %@", productVersion);
-	 */
-	// Just give up and return "OS X", or should it be "OSX"?
+  /* Starting with macOS 11 (Big Sur), the major version number is the primary identifier. */
+  if (version.majorVersion >= 11)
+  {
+    switch (version.majorVersion)
+    {
+      case 26: codename = "Tahoe"; break;
+      case 15: codename = "Sequoia"; break;
+      case 14: codename = "Sonoma"; break;
+      case 13: codename = "Ventura"; break;
+      case 12: codename = "Monterey"; break;
+      case 11: codename = "Big Sur"; break;
+    }
+  }
+  /* For older macOS versions (10.x), check the minor version. */
+  else if (version.majorVersion == 10)
+  {
+    switch (version.minorVersion)
+    {
+      case 15: codename = "Catalina"; break;
+      case 14: codename = "Mojave"; break;
+      case 13: codename = "High Sierra"; break;
+      case 12: codename = "Sierra"; break;
+      case 11: codename = "El Capitan"; break;
+      case 10: codename = "Yosemite"; break;
+    }
+  }
 
-// return "Mac OS X";
-//	return "OS X";
-	return "macOS";
-	
-#if 0
-	SInt32 systemVersion;
-	
-	if (Gestalt(gestaltSystemVersion, &systemVersion) == noErr)
-	{
-		if (systemVersion >= 0x1060)
-			return "Snow Leopard";
-		else if (systemVersion >= 0x1050)
-			return "Leopard";
-		else if (systemVersion >= 0x1040)
-			return "Tiger";
-		else if (systemVersion >= 0x1030)
-			return "Panther";
-		else if (systemVersion >= 0x1020)
-			return "Jaguar";
-		else if (systemVersion >= 0x1010)
-			return "Puma";
-		else if (systemVersion >= 0x1010)
-			return "Cheetah";
-	}
-	
-	return "MacOS";
-#endif
-	
+  char buffer[100];
+  if (codename)
+  {
+    sprintf(buffer, "macOS %s", codename);
+  }
+  else
+  {
+    strcpy(buffer, "macOS");
+  }
+
+  char* iup_str = iupStrGetMemory((int)strlen(buffer) + 1);
+  strcpy(iup_str, buffer);
+  return iup_str;
 }
 
 char *iupdrvGetSystemVersion(void)
 {
-	
-#if 0
-	char* str = iupStrGetMemory(100);
-	SInt32 systemVersion, versionMajor, versionMinor, versionBugFix, systemArchitecture;
-	
-	if (Gestalt(gestaltSystemVersion, &systemVersion) != noErr)
-		return NULL;
-	
-	if (systemVersion < 0x1040)
-	{
-		/* Major, Minor, Bug fix */
-		sprintf(str, "%ld.%ld.%ld", (((long)systemVersion & 0xF000) >> 12) * 10 + (((long)systemVersion & 0x0F00) >> 8),
-				(((long)systemVersion & 0x00F0) >> 4), ((long)systemVersion & 0x000F));
-	}
-	else  /* MAC_OS_X_VERSION_10_4 or later */
-	{
-		Gestalt(gestaltSystemVersionMajor,  &versionMajor);
-		Gestalt(gestaltSystemVersionMinor,  &versionMinor);
-		Gestalt(gestaltSystemVersionBugFix, &versionBugFix);
-		
-		sprintf(str, "%ld.%ld.%ld", (long)versionMajor, (long)versionMinor, (long)versionBugFix);
-	}
-	
-	if (Gestalt(gestaltSysArchitecture, &systemArchitecture) == noErr)
-	{
-		if (systemArchitecture == gestalt68k)
-			strcat(str, " (Motorola 68k)");
-		else if (systemArchitecture == gestaltPowerPC)
-			strcat(str, " (Power PC)");
-		else /* gestaltIntel */
-			strcat(str, " (Intel)");
-	}
-	
-	return str;
-#else
-	
-	NSString* version_string = nil;
-	version_string = [[NSProcessInfo processInfo] operatingSystemVersionString];
-	
-	const char* c_str = [version_string UTF8String];
-	// don't use [version_string length]...counts characters, not bytes
-	size_t str_len = strlen(c_str);
-	
-	char* iup_str = iupStrGetMemory((int)str_len);
-	strlcpy(iup_str, c_str, str_len+1);
-	
-	return iup_str;
-#endif
+  char* str = iupStrGetMemory(100);
 
-}
+  NSOperatingSystemVersion version = [[NSProcessInfo processInfo] operatingSystemVersion];
+  sprintf(str, "%ld.%ld.%ld", (long)version.majorVersion, (long)version.minorVersion, (long)version.patchVersion);
 
-/*
-Drat. hostName blocks so if the network is down, this function will hang.
+  /* Append architecture info. */
+  struct utsname systemInfo;
+  if (uname(&systemInfo) == 0)
+  {
+    strcat(str, " (");
+    strcat(str, systemInfo.machine);
+    strcat(str, ")");
+  }
 
-Claims are CSCopeMachineName() does not block, but it is deprecated.
- 
-SCDynamicStoreCopyLocalHostName sounds like it might work.
-// https://lists.apple.com/archives/cocoa-dev/2009/Sep/msg00680.html
-  If you're just looking for the mDNS Local Hostname, it's MUCH more efficient to use SCDynamicStoreCopyLocalHostName, which is just a Mach message over to configd running on the local machine. No network delays.
- It's peer function, SCDynamicStoreCopyComputerName might be even better.
-Both require the SystemConfiguration framework
+  return str;
+}
 
-
-gethostname may also work
-// https://lists.apple.com/archives/cocoa-dev/2009/Sep/msg00616.html
- char hostname[_POSIX_HOST_NAME_MAX + 1];
- gethostname(hostname, _POSIX_HOST_NAME_MAX);
- name = [NSString stringWithCString:hostname encoding:NSUTF8StringEncoding];
- */
 char *iupdrvGetComputerName(void)
 {
-/*
-	char* str = iupStrGetMemory(50);
-	CFStringRef computer_name = CSCopyMachineName(); // suspect: should CFRelease?
-	CFStringGetCString(computer_name, str, 50, kCFStringEncodingUTF8);
-	return str;
-*/
-	
-#if 0
+  NSString* computer_name = [(NSString *)SCDynamicStoreCopyComputerName(NULL, NULL) autorelease];
+  if (!computer_name)
+  {
+    return NULL;
+  }
 
-	// hostName is considered good enough for Bonjour names so it is good enough for this
-	NSString* host_name = nil;
-	host_name = [[NSProcessInfo processInfo] hostName];
-	
-	const char* c_str = [host_name UTF8String];
-	// don't use [version_string length]...counts characters, not bytes
-	size_t str_len = strlen(c_str);
-	
-	char* iup_str = iupStrGetMemory((int)str_len);
-	strlcpy(iup_str, c_str, str_len+1);
-	
-	return iup_str;
-#else
-	
-	// Returns NULL/nil if no computer name set, or error occurred. OSX 10.1+
-	NSString* computer_name = [(NSString *)SCDynamicStoreCopyComputerName(NULL, NULL) autorelease];
-	const char* c_str = [computer_name UTF8String];
-	// don't use [version_string length]...counts characters, not bytes
-	size_t str_len = strlen(c_str);
-	
-	char* iup_str = iupStrGetMemory((int)str_len);
-	strlcpy(iup_str, c_str, str_len+1);
-	
-	return iup_str;
-	
-#endif
-	
+  const char* c_str = [computer_name UTF8String];
+  if (!c_str)
+  {
+    return NULL;
+  }
+
+  char* iup_str = iupStrGetMemory((int)strlen(c_str) + 1);
+  strcpy(iup_str, c_str);
+
+  return iup_str;
 }
 
-
 char *iupdrvGetUserName(void)
 {
-#if 0
-	char* str = iupStrGetMemory(50);
-	CFStringRef userName = CSCopyUserName(TRUE);  /* TRUE = login name   FALSE = user name */
-	CFStringGetCString(userName, str, 50, kCFStringEncodingUTF8);
-	return str;
-#else
-	
-	NSString* user_name = nil;
-	// Which one should we use?
-//	user_name = NSUserName();
-	user_name = NSFullUserName();
+  NSString* user_name = NSUserName();
+  if (!user_name)
+  {
+    return NULL;
+  }
 
-	const char* c_str = [user_name UTF8String];
-	// don't use [version_string length]...counts characters, not bytes
-	size_t str_len = strlen(c_str);
-	
-	char* iup_str = iupStrGetMemory((int)str_len);
-	strlcpy(iup_str, c_str, str_len+1);
-	
-	return iup_str;
-#endif
+  const char* c_str = [user_name UTF8String];
+  if (!c_str)
+  {
+    return NULL;
+  }
 
+  char* iup_str = iupStrGetMemory((int)strlen(c_str) + 1);
+  strcpy(iup_str, c_str);
 
-	
+  return iup_str;
 }
 
-int iupdrvGetPreferencePath(char *filename, int use_system)
+int iupdrvGetPreferencePath(char *filename, const char *app_name, int use_system)
 {
-	NSArray* support_paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
-	if([support_paths count] > 0)
-	{
-		BOOL is_dir = NO;
-		NSError* the_error = nil;
-		
-		NSBundle* main_bundle = [NSBundle mainBundle];
-		// Use the Info.plist to get: com.organization.appname so we can create/use a unique subdirectory in ~/Library/Application Support
-		// Note Mac App Sandboxing will give a per-app sandbox with its own private ~/Library/Application Support so everything still works.
-		NSString* bundle_name = [[main_bundle infoDictionary] objectForKey:@"CFBundleIdentifier"];
-		NSString* ns_path = [[support_paths objectAtIndex:0] stringByAppendingPathComponent:bundle_name];
+  if (!app_name || !app_name[0])
+  {
+    filename[0] = '\0';
+    return 0;
+  }
 
-		if(![[NSFileManager defaultManager] fileExistsAtPath:ns_path isDirectory:&is_dir]
-		   && is_dir == NO
-		   )
-		{
-			BOOL did_succeed = [[NSFileManager defaultManager] createDirectoryAtPath:ns_path withIntermediateDirectories:YES attributes:nil error:&the_error];
-			if(NO == did_succeed)
-			{
-				NSLog(@"Create preference directory error: %@", the_error);
-				filename[0] = '\0';
-				return 0;
-			}
-		}
-		
-		const char* c_path = [ns_path fileSystemRepresentation];
-		
-		if(NULL != c_path)
-		{
-			strcpy(filename, c_path);
-			strcat(filename, "/");
-			return 1;
-		}
-		else
-		{
-			filename[0] = '\0';
-			return 0;
-		}
-	}
+  if (use_system)
+  {
+    /* macOS Application Support: ~/Library/Application Support/appname/config */
+    NSArray* support_paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
+    if ([support_paths count] > 0)
+    {
+      NSString* ns_app_name = [NSString stringWithUTF8String:app_name];
+      NSString* ns_path = [[support_paths objectAtIndex:0] stringByAppendingPathComponent:ns_app_name];
 
-	filename[0] = '\0';
-	return 0;
+      /* Create app directory if needed */
+      BOOL is_dir = NO;
+      if (![[NSFileManager defaultManager] fileExistsAtPath:ns_path isDirectory:&is_dir])
+      {
+        [[NSFileManager defaultManager] createDirectoryAtPath:ns_path withIntermediateDirectories:YES attributes:nil error:nil];
+      }
+
+      NSString* ns_config_path = [ns_path stringByAppendingPathComponent:@"config"];
+      const char* c_path = [ns_config_path fileSystemRepresentation];
+      if (c_path != NULL)
+      {
+        strcpy(filename, c_path);
+        return 1;
+      }
+    }
+  }
+  else
+  {
+    /* Legacy: ~/.appname */
+    NSString* home_path = NSHomeDirectory();
+    if (home_path)
+    {
+      NSString* hidden_name = [NSString stringWithFormat:@".%s", app_name];
+      NSString* ns_path = [home_path stringByAppendingPathComponent:hidden_name];
+      const char* c_path = [ns_path fileSystemRepresentation];
+      if (c_path != NULL)
+      {
+        strcpy(filename, c_path);
+        return 1;
+      }
+    }
+  }
+
+  filename[0] = '\0';
+  return 0;
 }
 
-
 char* iupdrvLocaleInfo(void)
 {
-	return iupStrReturnStr(nl_langinfo(CODESET));
+  return iupStrReturnStr(nl_langinfo(CODESET));
 }
 
 void IupLogV(const char* type, const char* format, va_list arglist)
 {
-	int priority = ASL_LEVEL_NOTICE;
-/*
-#define ASL_LEVEL_EMERG   0
-#define ASL_LEVEL_ALERT   1
-#define ASL_LEVEL_CRIT    2
-#define ASL_LEVEL_ERR     3
-#define ASL_LEVEL_WARNING 4
-#define ASL_LEVEL_NOTICE  5
-#define ASL_LEVEL_INFO    6
-#define ASL_LEVEL_DEBUG   7
-*/
-	if (iupStrEqualNoCase(type, "DEBUG"))
-	{
-		priority = ASL_LEVEL_DEBUG;
-	}
-	else if (iupStrEqualNoCase(type, "ERROR"))
-	{
-		priority = ASL_LEVEL_ERR;
-	}
-	else if (iupStrEqualNoCase(type, "WARNING"))
-	{
-		priority = ASL_LEVEL_WARNING;
-	}
-	else if (iupStrEqualNoCase(type, "INFO"))
-	{
-		priority = ASL_LEVEL_INFO;
-	}
-	// Extras: (not officially documented)
-	else if (iupStrEqualNoCase(type, "EMERGENCY"))
-	{
-		priority = ASL_LEVEL_EMERG;
-	}
-	else if (iupStrEqualNoCase(type, "ALERT"))
-	{
-		priority = ASL_LEVEL_ALERT;
-	}
-	else if (iupStrEqualNoCase(type, "CRITICAL"))
-	{
-		priority = ASL_LEVEL_CRIT;
-	}
-	else if (iupStrEqualNoCase(type, "NOTICE"))
-	{
-		priority = ASL_LEVEL_NOTICE;
-	}
+  char buffer[2048];
+  vsnprintf(buffer, sizeof(buffer), format, arglist);
 
-	asl_vlog(NULL, NULL, priority, format, arglist);
+  os_log_type_t log_type = OS_LOG_TYPE_DEFAULT;
+  if (iupStrEqualNoCase(type, "DEBUG"))
+    log_type = OS_LOG_TYPE_DEBUG;
+  else if (iupStrEqualNoCase(type, "INFO"))
+    log_type = OS_LOG_TYPE_INFO;
+  else if (iupStrEqualNoCase(type, "WARNING"))
+    log_type = OS_LOG_TYPE_ERROR;
+  else if (iupStrEqualNoCase(type, "ERROR"))
+    log_type = OS_LOG_TYPE_ERROR;
+  else if (iupStrEqualNoCase(type, "CRITICAL") || iupStrEqualNoCase(type, "ALERT") || iupStrEqualNoCase(type, "EMERGENCY"))
+    log_type = OS_LOG_TYPE_FAULT;
+
+  /* os_log requires a static format string for privacy, so we must mark dynamic content as public. */
+  os_log_with_type(OS_LOG_DEFAULT, log_type, "%{public}s", buffer);
 }
 
 void IupLog(const char* type, const char* format, ...)
Index: src/cocoa/iupcocoa_label.m
===================================================================
--- src/cocoa/iupcocoa_label.m	(revision 5971)
+++ src/cocoa/iupcocoa_label.m	(working copy)
@@ -5,6 +5,7 @@
  */
 
 #include <Cocoa/Cocoa.h>
+#import <objc/runtime.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -29,856 +30,1155 @@
 
 #include "iupcocoa_drv.h"
 
-#import "IUPCocoaVerticalAlignmentTextFieldCell.h"
+#import "IupCocoaVerticalAlignmentTextFieldCell.h"
 
 
+@interface IUPCocoaLabelEventView : NSView
+{
+	NSTrackingArea* _mouseTrackingArea;
+}
+@end
 
-static NSView* cocoaLabelGetRootView(Ihandle* ih)
+@implementation IUPCocoaLabelEventView
+
+- (void)dealloc
 {
-	NSView* root_container_view = (NSView*)ih->handle;
-	return root_container_view;
+	if (_mouseTrackingArea)
+	{
+		[self removeTrackingArea:_mouseTrackingArea];
+		[_mouseTrackingArea release];
+	}
+	[super dealloc];
 }
 
-static NSTextField* cocoaLabelGetTextField(Ihandle* ih)
+- (void)mouseDown:(NSEvent *)theEvent
 {
-	NSTextField* text_field = (NSTextField*)cocoaLabelGetRootView(ih);
-	NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-	return text_field;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupcocoaCommonBaseHandleMouseButtonCallback(ih, theEvent, self, true))
+    [super mouseDown:theEvent];
 }
 
-static NSImageView* cocoaLabelGetImageView(Ihandle* ih)
+- (void)mouseUp:(NSEvent *)theEvent
 {
-	NSView* root_container_view = cocoaLabelGetRootView(ih);
-	NSCAssert([root_container_view isKindOfClass:[NSImageView class]], @"Expected NSImageView");
-	return (NSImageView*)root_container_view;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupcocoaCommonBaseHandleMouseButtonCallback(ih, theEvent, self, false))
+    [super mouseUp:theEvent];
 }
 
+- (void)rightMouseDown:(NSEvent *)theEvent
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupcocoaCommonBaseHandleMouseButtonCallback(ih, theEvent, self, true))
+    [super rightMouseDown:theEvent];
+}
 
-void iupdrvLabelAddExtraPadding(Ihandle* ih, int *x, int *y)
+- (void)rightMouseUp:(NSEvent *)theEvent
 {
-	*x += 4;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupcocoaCommonBaseHandleMouseButtonCallback(ih, theEvent, self, false))
+    [super rightMouseUp:theEvent];
 }
 
+- (void)otherMouseDown:(NSEvent *)theEvent
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupcocoaCommonBaseHandleMouseButtonCallback(ih, theEvent, self, true))
+    [super otherMouseDown:theEvent];
+}
 
-static int cocoaLabelSetPaddingAttrib(Ihandle* ih, const char* value)
+- (void)otherMouseUp:(NSEvent *)theEvent
 {
-	// Our Cocoa iupdrvbaseUpdateLayout contains a special case to handle padding. We just need to make sure the padding values get set here.
-	// Other platforms seem to be skipping separators. We could theoretically support this since we are just manually computing offsets in iupdrvbaseUpdateLayout.
-	if(ih->handle && ih->data->type != IUP_LABEL_SEP_HORIZ && ih->data->type != IUP_LABEL_SEP_VERT)
-	{
-		// I believe this sets the internal data structure values.
-		iupStrToIntInt(value, &ih->data->horiz_padding, &ih->data->vert_padding, 'x');
-		// HACK: I need to force a redraw. iupdrvbaseUpdateLayout queries the PADDING attribute, but it is not immediately set yet. So I'll force it to set now.
-		iupAttribSetStr(ih, "PADDING", value);
-		
-		// Windows always calls iupdrvRedrawNow, and we need to too because the change won't update without it.
-		// But this can require a new layout, so we need IupRefresh.
-		IupRefresh(ih);
-	}
-	return 0;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupcocoaCommonBaseHandleMouseButtonCallback(ih, theEvent, self, false))
+    [super otherMouseUp:theEvent];
 }
 
+- (void)mouseMoved:(NSEvent *)theEvent
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupcocoaCommonBaseHandleMouseMotionCallback(ih, theEvent, self))
+    [super mouseMoved:theEvent];
+}
 
-static int cocoaLabelSetTitleAttrib(Ihandle* ih, const char* value)
+- (void)mouseDragged:(NSEvent *)theEvent
 {
-	NSTextField* the_label = cocoaLabelGetTextField(ih);
-	if(the_label)
+  [self mouseMoved:theEvent];
+}
+
+- (void)rightMouseDragged:(NSEvent *)theEvent
+{
+  [self mouseMoved:theEvent];
+}
+
+- (void)otherMouseDragged:(NSEvent *)theEvent
+{
+  [self mouseMoved:theEvent];
+}
+
+- (void)updateTrackingAreas
+{
+	[super updateTrackingAreas];
+
+	if (_mouseTrackingArea)
 	{
-		// NSImageCells don't accept a stringValue, so bail out if we have a cell
-		if([the_label respondsToSelector:@selector(cell)])
-		{
-			id cell = [the_label cell];
-			if((nil != cell) && [cell isKindOfClass:[NSImageCell class]])
-			{
-				return 0;
-			}
-		}
-	
-	
-		NSString* ns_string = nil;
-		if(value)
-		{
-			char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);   /* remove & */
-			
-			// This will return nil if the string can't be converted.
-			ns_string = [NSString stringWithUTF8String:stripped_str];
-			
-			if(stripped_str && stripped_str != value)
-			{
-				free(stripped_str);
-			}
-		}
-		else
-		{
-			ns_string = @"";
-		}
-		
-	
-		// If the user set font attributes, we should try to use them
-		IupCocoaFont* iup_font = iupCocoaGetFont(ih);
-		if([iup_font usesAttributes]
-			&& [the_label respondsToSelector:@selector(setAttributedStringValue:)]
-		)
-		{
-			NSAttributedString* attr_str = [[NSAttributedString alloc] initWithString:ns_string attributes:[iup_font attributeDictionary]];
-			[the_label setAttributedStringValue:attr_str];
-			[attr_str release];
-			// I think I need to call this. I noticed in another program, when I suddenly set a long string, it seems to use the prior layout. This forces a relayout.
-			IupRefresh(ih);
-		}
-		else if([the_label respondsToSelector:@selector(setStringValue:)])
-		{
-			[the_label setStringValue:ns_string];
-			// I think I need to call this. I noticed in another program, when I suddenly set a long string, it seems to use the prior layout. This forces a relayout.
-			IupRefresh(ih);
-		}
+		[self removeTrackingArea:_mouseTrackingArea];
+		[_mouseTrackingArea release];
+		_mouseTrackingArea = nil;
 	}
-	return 1;
 
+	NSTrackingAreaOptions options = NSTrackingMouseEnteredAndExited |
+                                   NSTrackingMouseMoved |
+                                   NSTrackingActiveInKeyWindow |
+                                   NSTrackingInVisibleRect;
+	_mouseTrackingArea = [[NSTrackingArea alloc] initWithRect:[self bounds]
+	                                                  options:options
+	                                                    owner:self
+	                                                 userInfo:nil];
+	[self addTrackingArea:_mouseTrackingArea];
 }
 
+- (void)mouseEntered:(NSEvent *)theEvent
+{
+  [super mouseEntered:theEvent];
 
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
+  IFn cb = (IFn)IupGetCallback(ih, "ENTERWINDOW_CB");
+  if (cb)
+  {
+    if (cb(ih) == IUP_CLOSE)
+      IupExitLoop();
+  }
+}
 
+- (void)mouseExited:(NSEvent *)theEvent
+{
+  [super mouseExited:theEvent];
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
+
+  IFn cb = (IFn)IupGetCallback(ih, "LEAVEWINDOW_CB");
+  if (cb)
+  {
+    if (cb(ih) == IUP_CLOSE)
+      IupExitLoop();
+  }
+}
+
+@end
+
+
+static NSTextField* cocoaLabelGetTextField(Ihandle* ih)
+{
+  return (NSTextField*)iupcocoaGetMainView(ih);
+}
+
+static NSImageView* cocoaLabelGetImageView(Ihandle* ih)
+{
+  return (NSImageView*)iupcocoaGetMainView(ih);
+}
+
+void iupdrvLabelAddExtraPadding(Ihandle* ih, int *x, int *y)
+{
+  (void)ih;
+  (void)x;
+  (void)y;
+}
+
+static int cocoaLabelSetPaddingAttrib(Ihandle* ih, const char* value)
+{
+  iupStrToIntInt(value, &ih->data->horiz_padding, &ih->data->vert_padding, 'x');
+
+  if (ih->handle && ih->data->type != IUP_LABEL_SEP_HORIZ && ih->data->type != IUP_LABEL_SEP_VERT)
+  {
+    IupRefresh(ih);
+    return 0;
+  }
+
+  return 1;
+}
+
+static int cocoaLabelSetTitleAttrib(Ihandle* ih, const char* value)
+{
+  NSTextField* the_label = cocoaLabelGetTextField(ih);
+  if (!the_label)
+    return 0;
+
+  if ([the_label respondsToSelector:@selector(cell)])
+  {
+    id cell = [the_label cell];
+    if ((nil != cell) && [cell isKindOfClass:[NSImageCell class]])
+      return 0;
+  }
+
+  NSString* ns_string = nil;
+  BOOL has_newlines = NO;
+  if (value)
+  {
+    char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);
+    ns_string = [NSString stringWithUTF8String:stripped_str];
+
+    /* Check if value contains newlines for multi-line support */
+    has_newlines = (strchr(value, '\n') != NULL);
+
+    if (stripped_str && stripped_str != value)
+      free(stripped_str);
+  }
+  else
+  {
+    ns_string = @"";
+  }
+
+  /* Configure multi-line mode if needed */
+  if (has_newlines)
+  {
+    [the_label setUsesSingleLineMode:NO];
+    [[the_label cell] setScrollable:NO];
+    [[the_label cell] setWraps:YES];
+    [[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
+  }
+  else
+  {
+    [the_label setUsesSingleLineMode:YES];
+    [[the_label cell] setScrollable:YES];
+    [[the_label cell] setWraps:NO];
+    [[the_label cell] setLineBreakMode:NSLineBreakByClipping];
+  }
+
+  IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+  char* fgcolor = iupAttribGet(ih, "FGCOLOR");
+  unsigned char r, g, b;
+  BOOL need_attributed = [iup_font usesAttributes] || (fgcolor && iupStrToRGB(fgcolor, &r, &g, &b));
+
+  /* Get alignment setting to apply to paragraph style */
+  NSTextAlignment text_alignment = [the_label alignment];
+
+  if (need_attributed)
+  {
+    NSMutableAttributedString* attr_str;
+
+    if ([iup_font usesAttributes])
+    {
+      attr_str = [[NSMutableAttributedString alloc] initWithString:ns_string
+                                                        attributes:[iup_font attributeDictionary]];
+    }
+    else
+    {
+      NSMutableDictionary* attrs = [NSMutableDictionary dictionary];
+      NSFont* native_font = [iup_font nativeFont];
+      if (native_font)
+        [attrs setObject:native_font forKey:NSFontAttributeName];
+
+      attr_str = [[NSMutableAttributedString alloc] initWithString:ns_string attributes:attrs];
+    }
+
+    if (fgcolor && iupStrToRGB(fgcolor, &r, &g, &b))
+    {
+      NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+      NSRange range = NSMakeRange(0, [attr_str length]);
+      [attr_str addAttribute:NSForegroundColorAttributeName value:color range:range];
+    }
+
+    /* Apply paragraph style for text alignment (required for attributed strings) */
+    NSMutableParagraphStyle* paragraph_style = [[NSMutableParagraphStyle alloc] init];
+    [paragraph_style setAlignment:text_alignment];
+    [attr_str addAttribute:NSParagraphStyleAttributeName value:paragraph_style range:NSMakeRange(0, [ns_string length])];
+    [paragraph_style release];
+
+    [the_label setAttributedStringValue:attr_str];
+    [attr_str release];
+  }
+  else
+  {
+    [the_label setStringValue:ns_string];
+  }
+
+  if (ih->handle)
+    IupRefresh(ih);
+
+  return 1;
+}
+
 static int cocoaLabelSetActiveAttrib(Ihandle* ih, const char* value)
 {
-	NSView* the_view = cocoaLabelGetRootView(ih);
-	BOOL is_active = (BOOL)iupStrBoolean(value);
+  NSView* the_view = iupcocoaGetMainView(ih);
+  if (!the_view)
+    return iupBaseSetActiveAttrib(ih, value);
 
-	if([the_view isKindOfClass:[NSTextField class]])
-	{
-		NSTextField* the_label = (NSTextField*)the_view;
-		[the_label setEnabled:is_active];
-		
-		// For whatever reason, Cocoa doesn't automatically gray out labels when disabled.
-		// But it's a pretty common thing to do, so everybody explicitly sets the color using the Cocoa predefined color constants.
-		if(is_active)
-		{
-			// FIXME: If the user has requested a different text color, we need to use that color instead
-			[the_label setTextColor:[NSColor controlTextColor]];
-		}
-		else
-		{
-			[the_label setTextColor:[NSColor disabledControlTextColor]];
-		}
-	}
-	else if([the_view isKindOfClass:[NSImageView class]])
-	{
-		NSImageView* image_view = (NSImageView*)the_view;
-		[image_view setEnabled:is_active];
-	}
-	else
-	{
-		NSLog(@"Unexpected type in cocoaLabelSetActiveAttrib");
-	}
+  BOOL is_active = (BOOL)iupStrBoolean(value);
 
-	return 1;
+  if ([the_view isKindOfClass:[NSTextField class]])
+  {
+    NSTextField* the_label = (NSTextField*)the_view;
+    [the_label setEnabled:is_active];
 
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+    BOOL uses_attributed_string = ([iup_font usesAttributes] || [[the_label attributedStringValue] length] > 0);
+
+    NSColor* color;
+    if (is_active)
+    {
+      char* user_color = iupAttribGet(ih, "_IUPCOCOA_USER_FGCOLOR");
+      if (user_color)
+      {
+        unsigned char r, g, b;
+        if (iupStrToRGB(user_color, &r, &g, &b))
+          color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+        else
+          color = [NSColor controlTextColor];
+      }
+      else
+      {
+        color = [NSColor controlTextColor];
+      }
+    }
+    else
+    {
+      color = [NSColor disabledControlTextColor];
+    }
+
+    if (uses_attributed_string)
+    {
+      NSMutableAttributedString* attr_str = [[the_label attributedStringValue] mutableCopy];
+      if (attr_str && [attr_str length] > 0)
+      {
+        NSRange range = NSMakeRange(0, [attr_str length]);
+        [attr_str addAttribute:NSForegroundColorAttributeName value:color range:range];
+        [the_label setAttributedStringValue:attr_str];
+        [attr_str release];
+      }
+    }
+    else
+    {
+      [the_label setTextColor:color];
+    }
+  }
+  else if ([the_view isKindOfClass:[NSImageView class]])
+  {
+    NSImageView* image_view = (NSImageView*)the_view;
+
+    char* image_name;
+    int make_inactive = 0;
+
+    if (is_active)
+    {
+      image_name = iupAttribGet(ih, "IMAGE");
+    }
+    else
+    {
+      image_name = iupAttribGet(ih, "IMINACTIVE");
+      if (!image_name)
+      {
+        image_name = iupAttribGet(ih, "IMAGE");
+        make_inactive = 1;
+      }
+    }
+
+    if (image_name)
+    {
+      id the_bitmap = iupImageGetImage(image_name, ih, make_inactive, NULL);
+      [image_view setImage:the_bitmap];
+    }
+  }
+
+  return iupBaseSetActiveAttrib(ih, value);
 }
 
-
 static char* cocoaLabelGetTitleAttrib(Ihandle* ih)
 {
-	NSTextField* the_label = cocoaLabelGetTextField(ih);
-	if(the_label)
-	{
-		// This could be a NSTextField, some kind of image, or something else.
-		
-		if([the_label respondsToSelector:@selector(setStringValue:)])
-		{
-			NSString* ns_string = [the_label stringValue];
-			if(ns_string)
-			{
-				return iupStrReturnStr([ns_string UTF8String]);
-			}
-		}
-	}
-	return NULL;
-	
+  NSTextField* the_label = cocoaLabelGetTextField(ih);
+  if (the_label)
+  {
+    if ([the_label respondsToSelector:@selector(stringValue)])
+    {
+      NSString* ns_string = [the_label stringValue];
+      if (ns_string)
+      {
+        return iupStrReturnStr([ns_string UTF8String]);
+      }
+    }
+  }
+  return NULL;
 }
+
+static char* cocoaLabelGetAlignmentAttrib(Ihandle* ih)
+{
+  if (ih->data->type != IUP_LABEL_SEP_HORIZ && ih->data->type != IUP_LABEL_SEP_VERT)
+  {
+    char* horiz_align2str[3] = {"ALEFT", "ACENTER", "ARIGHT"};
+    char* vert_align2str[3] = {"ATOP", "ACENTER", "ABOTTOM"};
+
+    int horiz = ih->data->horiz_alignment;
+    int vert = ih->data->vert_alignment;
+
+    if (horiz < IUP_ALIGN_ALEFT || horiz > IUP_ALIGN_ARIGHT)
+      horiz = IUP_ALIGN_ACENTER;
+    if (vert < IUP_ALIGN_ATOP || vert > IUP_ALIGN_ABOTTOM)
+      vert = IUP_ALIGN_ACENTER;
+
+    return iupStrReturnStrf("%s:%s", horiz_align2str[horiz], vert_align2str[vert]);
+  }
+
+  return NULL;
+}
+
 static int cocoaLabelSetAlignmentAttrib(Ihandle* ih, const char* value)
 {
-	if(ih->data->type != IUP_LABEL_SEP_HORIZ && ih->data->type != IUP_LABEL_SEP_VERT)
-	{
-		if(ih->data->type == IUP_LABEL_TEXT)
-		{
-			NSTextField* the_label = cocoaLabelGetTextField(ih);
+  if (ih->data->type != IUP_LABEL_SEP_HORIZ && ih->data->type != IUP_LABEL_SEP_VERT)
+  {
+    char value1[30], value2[30];
+    iupStrToStrStr(value, value1, value2, ':');
 
-			// Note: We might be able to get away with any kind of NSControl
-			NSCAssert([the_label isKindOfClass:[NSTextField class]], @"Expected NSTextField");
+    if (ih->data->type == IUP_LABEL_TEXT)
+    {
+      NSTextField* the_label = cocoaLabelGetTextField(ih);
+      NSCAssert([the_label isKindOfClass:[NSTextField class]], @"Expected NSTextField");
 
-			char value1[30], value2[30];
-			
-			iupStrToStrStr(value, value1, value2, ':');
+      if (iupStrEqualNoCase(value1, "ARIGHT"))
+      {
+        [the_label setAlignment:NSTextAlignmentRight];
+        ih->data->horiz_alignment = IUP_ALIGN_ARIGHT;
+      }
+      else if (iupStrEqualNoCase(value1, "ACENTER"))
+      {
+        [the_label setAlignment:NSTextAlignmentCenter];
+        ih->data->horiz_alignment = IUP_ALIGN_ACENTER;
+      }
+      else
+      {
+        [the_label setAlignment:NSTextAlignmentLeft];
+        ih->data->horiz_alignment = IUP_ALIGN_ALEFT;
+      }
 
-			
-			if (iupStrEqualNoCase(value1, "ARIGHT"))
-			{
-				[the_label setAlignment:NSTextAlignmentRight];
-			}
-			else if (iupStrEqualNoCase(value1, "ACENTER"))
-			{
-				[the_label setAlignment:NSTextAlignmentCenter];
-			}
-			else /* "ALEFT" */
-			{
-				[the_label setAlignment:NSTextAlignmentLeft];
+      if (iupStrEqualNoCase(value2, "ABOTTOM"))
+      {
+        NSCAssert([[the_label cell] isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+        IUPCocoaVerticalAlignmentTextFieldCell* vertical_alignment_cell = (IUPCocoaVerticalAlignmentTextFieldCell*)[the_label cell];
+        [vertical_alignment_cell setAlignmentMode:IUPTextVerticalAlignmentBottom];
+        ih->data->vert_alignment = IUP_ALIGN_ABOTTOM;
+      }
+      else if (iupStrEqualNoCase(value2, "ATOP"))
+      {
+        NSCAssert([[the_label cell] isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+        IUPCocoaVerticalAlignmentTextFieldCell* vertical_alignment_cell = (IUPCocoaVerticalAlignmentTextFieldCell*)[the_label cell];
+        [vertical_alignment_cell setAlignmentMode:IUPTextVerticalAlignmentTop];
+        ih->data->vert_alignment = IUP_ALIGN_ATOP;
+      }
+      else
+      {
+        NSCAssert([[the_label cell] isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+        IUPCocoaVerticalAlignmentTextFieldCell* vertical_alignment_cell = (IUPCocoaVerticalAlignmentTextFieldCell*)[the_label cell];
+        [vertical_alignment_cell setAlignmentMode:IUPTextVerticalAlignmentCenter];
+        ih->data->vert_alignment = IUP_ALIGN_ACENTER;
+      }
 
-			}
-			
-			
-			// Vertical alignment is not built into NSTextField.
-			// We implemented our own custom NSTextFieldCell subclass to handle this case.
-			
-			if (iupStrEqualNoCase(value2, "ABOTTOM"))
-			{
-				NSCAssert([[the_label cell] isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-				IUPCocoaVerticalAlignmentTextFieldCell* vertical_alignment_cell = (IUPCocoaVerticalAlignmentTextFieldCell*)[the_label cell];
-				[vertical_alignment_cell setAlignmentMode:IUPTextVerticalAlignmentBottom];
-			}
-			else if (iupStrEqualNoCase(value2, "ATOP"))
-			{
-				NSCAssert([[the_label cell] isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-				IUPCocoaVerticalAlignmentTextFieldCell* vertical_alignment_cell = (IUPCocoaVerticalAlignmentTextFieldCell*)[the_label cell];
-				[vertical_alignment_cell setAlignmentMode:IUPTextVerticalAlignmentTop];
-			}
-			else  /* ACENTER (default) */
-			{
-				NSCAssert([[the_label cell] isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-				IUPCocoaVerticalAlignmentTextFieldCell* vertical_alignment_cell = (IUPCocoaVerticalAlignmentTextFieldCell*)[the_label cell];
-				[vertical_alignment_cell setAlignmentMode:IUPTextVerticalAlignmentCenter];
+      return 1;
+    }
+    else if (ih->data->type == IUP_LABEL_IMAGE)
+    {
+      NSImageView* the_label = cocoaLabelGetImageView(ih);
+      NSCAssert([the_label isKindOfClass:[NSImageView class]], @"Expected NSImageView");
 
-			}
+      if (iupStrEqualNoCase(value1, "ARIGHT"))
+      {
+        ih->data->horiz_alignment = IUP_ALIGN_ARIGHT;
 
-			return 1;
-		}
-		else if(ih->data->type == IUP_LABEL_IMAGE)
-		{
-			NSImageView* the_label = cocoaLabelGetImageView(ih);
-			// Note: We might be able to get away with any kind of NSControl
-			NSCAssert([the_label isKindOfClass:[NSImageView class]], @"Expected NSImageView");
-			
-			char value1[30], value2[30];
-			
-			iupStrToStrStr(value, value1, value2, ':');
-			
-			
-			if(iupStrEqualNoCase(value1, "ARIGHT"))
-			{
-				if(iupStrEqualNoCase(value2, "ABOTTOM"))
-				{
-					[the_label setImageAlignment:NSImageAlignBottomRight];
-				}
-				else if (iupStrEqualNoCase(value2, "ATOP"))
-				{
-					[the_label setImageAlignment:NSImageAlignTopRight];
-				}
-				else  /* ACENTER */
-				{
-					[the_label setImageAlignment:NSImageAlignRight];
-				}
-			}
-			else if (iupStrEqualNoCase(value1, "ACENTER"))
-			{
-				if(iupStrEqualNoCase(value2, "ABOTTOM"))
-				{
-					[the_label setImageAlignment:NSImageAlignBottom];
-				}
-				else if (iupStrEqualNoCase(value2, "ATOP"))
-				{
-					[the_label setImageAlignment:NSImageAlignTop];
-				}
-				else  /* ACENTER */
-				{
-					[the_label setImageAlignment:NSImageAlignCenter];
-				}
-			}
-			else /* "ALEFT" */
-			{
-				if(iupStrEqualNoCase(value2, "ABOTTOM"))
-				{
-					[the_label setImageAlignment:NSImageAlignBottomLeft];
-				}
-				else if (iupStrEqualNoCase(value2, "ATOP"))
-				{
-					[the_label setImageAlignment:NSImageAlignTopLeft];
-				}
-				else  /* ACENTER */
-				{
-					[the_label setImageAlignment:NSImageAlignLeft];
-				}
-			}
-			
-			
-			return 1;
-		}
-	}
-	
-	return 0;
+        if (iupStrEqualNoCase(value2, "ABOTTOM"))
+        {
+          [the_label setImageAlignment:NSImageAlignBottomRight];
+          ih->data->vert_alignment = IUP_ALIGN_ABOTTOM;
+        }
+        else if (iupStrEqualNoCase(value2, "ATOP"))
+        {
+          [the_label setImageAlignment:NSImageAlignTopRight];
+          ih->data->vert_alignment = IUP_ALIGN_ATOP;
+        }
+        else
+        {
+          [the_label setImageAlignment:NSImageAlignRight];
+          ih->data->vert_alignment = IUP_ALIGN_ACENTER;
+        }
+      }
+      else if (iupStrEqualNoCase(value1, "ACENTER"))
+      {
+        ih->data->horiz_alignment = IUP_ALIGN_ACENTER;
+
+        if (iupStrEqualNoCase(value2, "ABOTTOM"))
+        {
+          [the_label setImageAlignment:NSImageAlignBottom];
+          ih->data->vert_alignment = IUP_ALIGN_ABOTTOM;
+        }
+        else if (iupStrEqualNoCase(value2, "ATOP"))
+        {
+          [the_label setImageAlignment:NSImageAlignTop];
+          ih->data->vert_alignment = IUP_ALIGN_ATOP;
+        }
+        else
+        {
+          [the_label setImageAlignment:NSImageAlignCenter];
+          ih->data->vert_alignment = IUP_ALIGN_ACENTER;
+        }
+      }
+      else
+      {
+        ih->data->horiz_alignment = IUP_ALIGN_ALEFT;
+
+        if (iupStrEqualNoCase(value2, "ABOTTOM"))
+        {
+          [the_label setImageAlignment:NSImageAlignBottomLeft];
+          ih->data->vert_alignment = IUP_ALIGN_ABOTTOM;
+        }
+        else if (iupStrEqualNoCase(value2, "ATOP"))
+        {
+          [the_label setImageAlignment:NSImageAlignTopLeft];
+          ih->data->vert_alignment = IUP_ALIGN_ATOP;
+        }
+        else
+        {
+          [the_label setImageAlignment:NSImageAlignLeft];
+          ih->data->vert_alignment = IUP_ALIGN_ACENTER;
+        }
+      }
+
+      return 1;
+    }
+  }
+
+  return 0;
 }
 
-// Warning: The pre-10.10 behavior never behaved well. Maybe it should be removed.
 static int cocoaLabelSetWordWrapAttrib(Ihandle* ih, const char* value)
 {
-	if (ih->data->type == IUP_LABEL_TEXT)
-	{
-		NSTextField* the_label = cocoaLabelGetTextField(ih);
-		// Note: We might be able to get away with any kind of NSControl
-		NSCAssert([the_label isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-		if(iupStrBoolean(value))
-		{
-			// setLineBreakMode Requires 10.10+. Allows for both word wrapping and different ellipsis behaviors.
-			if([the_label respondsToSelector:@selector(setLineBreakMode:)])
-			{
-				[the_label setLineBreakMode:NSLineBreakByWordWrapping];
-				IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-				NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-				[vertical_cell setUseWordWrap:YES];
-				[vertical_cell setUseEllipsis:NO];
-			}
-			else
-			{
+  if (ih->data->type == IUP_LABEL_TEXT)
+  {
+    NSTextField* the_label = cocoaLabelGetTextField(ih);
+    NSCAssert([the_label isKindOfClass:[NSTextField class]], @"Expected NSTextField");
 
-				char* ellipsis_state = iupAttribGet(ih, "ELLIPSIS");
-				if(iupStrBoolean(ellipsis_state))
-				{
-					// Ellipsis only seem to appear when multiline is enabled
-					[the_label setUsesSingleLineMode:NO];
-					[[the_label cell] setScrollable:NO];
-					
-					[[the_label cell] setWraps:YES];
-					[[the_label cell] setLineBreakMode:NSLineBreakByTruncatingTail];
-					[[the_label cell] setTruncatesLastVisibleLine:YES];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:YES];
-					[vertical_cell setUseEllipsis:YES];
+    if (iupStrBoolean(value))
+    {
+      if ([the_label respondsToSelector:@selector(setLineBreakMode:)])
+      {
+        [the_label setLineBreakMode:NSLineBreakByWordWrapping];
+        IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+        NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+        [vertical_cell setUseWordWrap:YES];
+        [vertical_cell setUseEllipsis:NO];
+      }
+      else
+      {
+        char* ellipsis_state = iupAttribGet(ih, "ELLIPSIS");
+        if (iupStrBoolean(ellipsis_state))
+        {
+          [the_label setUsesSingleLineMode:NO];
+          [[the_label cell] setScrollable:NO];
+          [[the_label cell] setWraps:YES];
+          [[the_label cell] setLineBreakMode:NSLineBreakByTruncatingTail];
+          [[the_label cell] setTruncatesLastVisibleLine:YES];
 
-					
-				}
-				else
-				{
-					[the_label setUsesSingleLineMode:NO];
-					[[the_label cell] setScrollable:NO];
-					
-					[[the_label cell] setWraps:YES];
-					[[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
-					[[the_label cell] setTruncatesLastVisibleLine:NO];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:YES];
-					[vertical_cell setUseEllipsis:NO];
-				}
-				
-			}
-			
-		}
-		else
-		{
-			// setLineBreakMode Requires 10.10+. Allows for both word wrapping and different ellipsis behaviors.
-			if([the_label respondsToSelector:@selector(setLineBreakMode:)])
-			{
-				// Wrapping and ellipsis are mutually exclusive
-				char* ellipsis_state = iupAttribGet(ih, "ELLIPSIS");
-				if(iupStrBoolean(ellipsis_state))
-				{
-					[the_label setLineBreakMode:NSLineBreakByTruncatingTail];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:NO];
-					[vertical_cell setUseEllipsis:YES];
-				}
-				else
-				{
-					[the_label setLineBreakMode:NSLineBreakByClipping];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:NO];
-					[vertical_cell setUseEllipsis:NO];
-				}
-			}
-			else
-			{
-				
-				char* ellipsis_state = iupAttribGet(ih, "ELLIPSIS");
-				if(iupStrBoolean(ellipsis_state))
-				{
-					// Ellipsis only seem to appear when multiline is enabled
-					[the_label setUsesSingleLineMode:NO];
-					[[the_label cell] setScrollable:NO];
-					
-					[[the_label cell] setWraps:YES];
-					[[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
-					[[the_label cell] setTruncatesLastVisibleLine:YES];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:NO];
-					[vertical_cell setUseEllipsis:YES];
-				}
-				else
-				{
-					[the_label setUsesSingleLineMode:YES];
-					[[the_label cell] setScrollable:YES];
-					
-					[[the_label cell] setWraps:NO];
-					[[the_label cell] setLineBreakMode:NSLineBreakByClipping];
-					[[the_label cell] setTruncatesLastVisibleLine:NO];
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:YES];
+          [vertical_cell setUseEllipsis:YES];
+        }
+        else
+        {
+          [the_label setUsesSingleLineMode:NO];
+          [[the_label cell] setScrollable:NO];
+          [[the_label cell] setWraps:YES];
+          [[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
+          [[the_label cell] setTruncatesLastVisibleLine:NO];
 
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:NO];
-					[vertical_cell setUseEllipsis:NO];
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:YES];
+          [vertical_cell setUseEllipsis:NO];
+        }
+      }
+    }
+    else
+    {
+      if ([the_label respondsToSelector:@selector(setLineBreakMode:)])
+      {
+        char* ellipsis_state = iupAttribGet(ih, "ELLIPSIS");
+        if (iupStrBoolean(ellipsis_state))
+        {
+          [the_label setLineBreakMode:NSLineBreakByTruncatingTail];
 
-				}
-				
-			}
-		}
-		return 1;
-	}
-	return 0;
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:NO];
+          [vertical_cell setUseEllipsis:YES];
+        }
+        else
+        {
+          [the_label setLineBreakMode:NSLineBreakByClipping];
+
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:NO];
+          [vertical_cell setUseEllipsis:NO];
+        }
+      }
+      else
+      {
+        char* ellipsis_state = iupAttribGet(ih, "ELLIPSIS");
+        if (iupStrBoolean(ellipsis_state))
+        {
+          [the_label setUsesSingleLineMode:NO];
+          [[the_label cell] setScrollable:NO];
+          [[the_label cell] setWraps:YES];
+          [[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
+          [[the_label cell] setTruncatesLastVisibleLine:YES];
+
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:NO];
+          [vertical_cell setUseEllipsis:YES];
+        }
+        else
+        {
+          [the_label setUsesSingleLineMode:YES];
+          [[the_label cell] setScrollable:YES];
+          [[the_label cell] setWraps:NO];
+          [[the_label cell] setLineBreakMode:NSLineBreakByClipping];
+          [[the_label cell] setTruncatesLastVisibleLine:NO];
+
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:NO];
+          [vertical_cell setUseEllipsis:NO];
+        }
+      }
+    }
+
+    if (ih->handle)
+      IupRefresh(ih);
+
+    return 1;
+  }
+  return 0;
 }
 
-
-// Warning: The pre-10.10 behavior never behaved well. Maybe it should be removed.
 static int cocoaLabelSetEllipsisAttrib(Ihandle* ih, const char* value)
 {
-	if (ih->data->type == IUP_LABEL_TEXT)
-	{
-		NSTextField* the_label = cocoaLabelGetTextField(ih);
-		// Note: We might be able to get away with any kind of NSControl
-		NSCAssert([the_label isKindOfClass:[NSTextField class]], @"Expected NSTextField");
+  if (ih->data->type == IUP_LABEL_TEXT)
+  {
+    NSTextField* the_label = cocoaLabelGetTextField(ih);
+    NSCAssert([the_label isKindOfClass:[NSTextField class]], @"Expected NSTextField");
 
+    if (iupStrBoolean(value))
+    {
+      if ([the_label respondsToSelector:@selector(setLineBreakMode:)])
+      {
+        [the_label setUsesSingleLineMode:YES];
+        [the_label setLineBreakMode:NSLineBreakByTruncatingTail];
 
-		if(iupStrBoolean(value))
-		{
-			// setLineBreakMode Requires 10.10+. Allows for both word wrapping and different ellipsis behaviors.
-			if([the_label respondsToSelector:@selector(setLineBreakMode:)])
-			{
-				// Wrapping and ellipsis are mutually exclusive
-				// TODO: Expose different ellipsis modes to public API
-				[the_label setUsesSingleLineMode:YES];
-				[the_label setLineBreakMode:NSLineBreakByTruncatingTail];
+        IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+        NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+        [vertical_cell setUseWordWrap:NO];
+        [vertical_cell setUseEllipsis:YES];
+      }
+      else
+      {
+        [[the_label cell] setScrollable:NO];
+        [[the_label cell] setWraps:YES];
+        [[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
+        [[the_label cell] setTruncatesLastVisibleLine:YES];
 
-				IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-				NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-				[vertical_cell setUseWordWrap:NO];
-				[vertical_cell setUseEllipsis:YES];
+        IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+        NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+        [vertical_cell setUseWordWrap:YES];
+        [vertical_cell setUseEllipsis:YES];
+      }
+    }
+    else
+    {
+      if ([the_label respondsToSelector:@selector(setLineBreakMode:)])
+      {
+        char* wordwrap_state = iupAttribGet(ih, "WORDWRAP");
+        if (iupStrBoolean(wordwrap_state))
+        {
+          [the_label setUsesSingleLineMode:NO];
+          [the_label setLineBreakMode:NSLineBreakByWordWrapping];
 
-			}
-			else
-			{
-				// Ellipsis only seem to appear when multiline is enabled
-				[[the_label cell] setScrollable:NO];
-				
-				[[the_label cell] setWraps:YES];
-				[[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
-				[[the_label cell] setTruncatesLastVisibleLine:YES];
-				
-				IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-				NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-				[vertical_cell setUseWordWrap:YES];
-				[vertical_cell setUseEllipsis:YES];
-				
-			}
-		}
-		else
-		{
-			// setLineBreakMode Requires 10.10+. Allows for both word wrapping and different ellipsis behaviors.
-			if([the_label respondsToSelector:@selector(setLineBreakMode:)])
-			{
-				// Wrapping and ellipsis are mutually exclusive
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:YES];
+          [vertical_cell setUseEllipsis:NO];
+        }
+        else
+        {
+          [the_label setLineBreakMode:NSLineBreakByClipping];
 
-				char* wordwrap_state = iupAttribGet(ih, "WORDWRAP");
-				if(iupStrBoolean(wordwrap_state))
-				{
-					[the_label setUsesSingleLineMode:NO];
-					[the_label setLineBreakMode:NSLineBreakByWordWrapping];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:YES];
-					[vertical_cell setUseEllipsis:NO];
-				}
-				else
-				{
-					[the_label setLineBreakMode:NSLineBreakByClipping];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:NO];
-					[vertical_cell setUseEllipsis:NO];
-				}
-				
-			}
-			else
-			{
-				
-				char* wordwrap_state = iupAttribGet(ih, "WORDWRAP");
-				if(iupStrBoolean(wordwrap_state))
-				{
-					[[the_label cell] setScrollable:NO];
-					
-					[[the_label cell] setWraps:YES];
-					[[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
-					[[the_label cell] setTruncatesLastVisibleLine:YES];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:YES];
-					[vertical_cell setUseEllipsis:NO];
-				}
-				else
-				{
-					[[the_label cell] setScrollable:YES];
-					
-					[[the_label cell] setWraps:NO];
-					[[the_label cell] setLineBreakMode:NSLineBreakByClipping];
-					[[the_label cell] setTruncatesLastVisibleLine:NO];
-					
-					IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
-					NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
-					[vertical_cell setUseWordWrap:NO];
-					[vertical_cell setUseEllipsis:NO];
-				}
-								
-			}
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:NO];
+          [vertical_cell setUseEllipsis:NO];
+        }
+      }
+      else
+      {
+        char* wordwrap_state = iupAttribGet(ih, "WORDWRAP");
+        if (iupStrBoolean(wordwrap_state))
+        {
+          [[the_label cell] setScrollable:NO];
+          [[the_label cell] setWraps:YES];
+          [[the_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
+          [[the_label cell] setTruncatesLastVisibleLine:YES];
 
-		
-		}
-		return 1;
-	}
-	return 0;
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:YES];
+          [vertical_cell setUseEllipsis:NO];
+        }
+        else
+        {
+          [[the_label cell] setScrollable:YES];
+          [[the_label cell] setWraps:NO];
+          [[the_label cell] setLineBreakMode:NSLineBreakByClipping];
+          [[the_label cell] setTruncatesLastVisibleLine:NO];
+
+          IUPCocoaVerticalAlignmentTextFieldCell* vertical_cell = [the_label cell];
+          NSCAssert([vertical_cell isKindOfClass:[IUPCocoaVerticalAlignmentTextFieldCell class]], @"Expected IUPCocoaVerticalAlignmentTextFieldCell");
+          [vertical_cell setUseWordWrap:NO];
+          [vertical_cell setUseEllipsis:NO];
+        }
+      }
+    }
+
+    if (ih->handle)
+      IupRefresh(ih);
+
+    return 1;
+  }
+  return 0;
 }
 
-
 static int cocoaLabelSetImageAttrib(Ihandle* ih, const char* value)
 {
-	
-	if(ih->data->type == IUP_LABEL_IMAGE)
-	{
-		NSImageView* image_view = cocoaLabelGetImageView(ih);
-		if(nil == image_view)
-		{
-			return 0;
-		}
-		
-		char* name;
-		int make_inactive = 0;
-		
-		if (iupdrvIsActive(ih))
-		{
-			make_inactive = 0;
-		}
-		else
-		{
-			name = iupAttribGet(ih, "IMINACTIVE");
-			if (!name)
-			{
-				make_inactive = 1;
-			}
-		}
-		
-		
-		id the_bitmap;
-		the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
-		int width;
-		int height;
-		int bpp;
-		
-		iupdrvImageGetInfo(the_bitmap, &width, &height, &bpp);
-		
-		// FIXME: What if the width and height change? Do we change it or leave it alone?
-		NSSize new_size = NSMakeSize(width, height);
-		NSRect the_frame = [image_view frame];
-		the_frame.size = new_size;
-		[image_view setFrame:the_frame];
+  if (ih->data->type != IUP_LABEL_IMAGE)
+    return 0;
 
-		[image_view setImage:the_bitmap];
-		
-		return 1;
-	}
-	else
-	{
-		return 0;
-	}
-}
+  NSImageView* image_view = cocoaLabelGetImageView(ih);
+  if (!image_view)
+    return 0;
 
+  char* name;
+  int make_inactive = 0;
 
+  if (iupdrvIsActive(ih))
+  {
+    name = (char*)value;
+  }
+  else
+  {
+    name = iupAttribGet(ih, "IMINACTIVE");
+    if (!name)
+    {
+      name = (char*)value;
+      make_inactive = 1;
+    }
+  }
 
-static int cocoaLabelMapMethod(Ihandle* ih)
+  if (name)
+  {
+    id the_bitmap = iupImageGetImage(name, ih, make_inactive, NULL);
+    [image_view setImage:the_bitmap];
+
+    if (ih->handle)
+      IupRefresh(ih);
+  }
+
+  return 1;
+}
+
+static int cocoaLabelSetImInactiveAttrib(Ihandle* ih, const char* value)
 {
-	char* value;
-	// using id because we may be using different types depending on the case
-	id the_label = nil;
-	
-	value = iupAttribGet(ih, "SEPARATOR");
-	if (value)
-	{
-		if (iupStrEqualNoCase(value, "HORIZONTAL"))
-		{
-			ih->data->type = IUP_LABEL_SEP_HORIZ;
+  if (ih->data->type != IUP_LABEL_IMAGE)
+    return 0;
 
-//			NSBox* horizontal_separator= [[NSBox alloc] initWithFrame:NSMakeRect(20.0, 20.0, 250.0, 1.0)];
-			NSBox* horizontal_separator= [[NSBox alloc] initWithFrame:NSMakeRect(0.0, 0.0, 250.0, 1.0)];
-			[horizontal_separator setBoxType:NSBoxSeparator];
-			the_label = horizontal_separator;
-			
-		}
-		else /* "VERTICAL" */
-		{
-			ih->data->type = IUP_LABEL_SEP_VERT;
+  if (iupdrvIsActive(ih))
+    return 1;
 
-//			NSBox* vertical_separator=[[NSBox alloc] initWithFrame:NSMakeRect(20.0, 20.0, 1.0, 250.0)];
-			NSBox* vertical_separator=[[NSBox alloc] initWithFrame:NSMakeRect(0.0, 0.0, 1.0, 250.0)];
-			[vertical_separator setBoxType:NSBoxSeparator];
-			the_label = vertical_separator;
+  NSImageView* image_view = cocoaLabelGetImageView(ih);
+  if (!image_view)
+    return 0;
 
-		}
-	}
-	else
-	{
-		value = iupAttribGet(ih, "IMAGE");
-		if (value)
-		{
-			ih->data->type = IUP_LABEL_IMAGE;
-			
-			char *name;
-			int make_inactive = 0;
-			
-			if (iupdrvIsActive(ih))
-    name = iupAttribGet(ih, "IMAGE");
-			else
-			{
-    name = iupAttribGet(ih, "IMINACTIVE");
+  if (value)
+  {
+    id the_bitmap = iupImageGetImage(value, ih, 0, NULL);
+    [image_view setImage:the_bitmap];
+  }
+  else
+  {
+    char* name = iupAttribGet(ih, "IMAGE");
     if (name)
-	{
-		name = iupAttribGet(ih, "IMAGE");
-		make_inactive = 1;
-	}
-			}
-			
-			
-			id the_bitmap;
-			the_bitmap = iupImageGetImage(name, ih, make_inactive, NULL);
-			int width;
-			int height;
-			int bpp;
-			
-			iupdrvImageGetInfo(the_bitmap, &width, &height, &bpp);
+    {
+      id the_bitmap = iupImageGetImage(name, ih, 1, NULL);
+      [image_view setImage:the_bitmap];
+    }
+  }
 
-//			static int woffset = 0;
-//			static int hoffset = 0;
-			
-			NSImageView* image_view = [[NSImageView alloc] initWithFrame:NSMakeRect(0, 0, width, height)];
-//			NSImageView* image_view = [[NSImageView alloc] initWithFrame:NSMakeRect(woffset, hoffset, width, height)];
-			[image_view setImage:the_bitmap];
-			
-//			woffset += 30;
-//			hoffset += 30;
-			
-			the_label = image_view;
-			
-#if 0
-			if (!the_bitmap)
-					return;
-			
-			/* must use this info, since image can be a driver image loaded from resources */
-			iupdrvImageGetInfo(hBitmap, &width, &height, &bpp);
+  return 1;
+}
 
-			
-			NSBitmapImageRep* bitmap_image = [[NSBitmapImageRep alloc]
-									 initWithBitmapDataPlanes:NULL
-									 pixelsWide: width
-									 pixelsHigh: height
-									 bitsPerSample: 8
-									 samplesPerPixel: 4
-									 hasAlpha: YES
-									 isPlanar: NO
-									 colorSpaceName: NSCalibratedRGBColorSpace
-									 bytesPerRow: width * 4
-									 bitsPerPixel: 32]
-#endif
+static int cocoaLabelSetBgColorAttrib(Ihandle* ih, const char* value)
+{
+  NSView* the_view = iupcocoaGetMainView(ih);
+  NSView* root_view = iupcocoaGetRootView(ih);
+  unsigned char r, g, b;
 
-		}
-		else
-		{
-			ih->data->type = IUP_LABEL_TEXT;
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
 
-			the_label = [[NSTextField alloc] initWithFrame:NSZeroRect];
-//			the_label = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)];
+  NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
 
-#if 1
-			IUPCocoaVerticalAlignmentTextFieldCell* textfield_cell = [[IUPCocoaVerticalAlignmentTextFieldCell alloc] initTextCell:@""];
-			[the_label setCell:textfield_cell];
-			[textfield_cell release];
-			//[textfield_cell setScrollable:NO];
-			
-//			[textfield_cell performClick:nil];
-			
-//			[textfield_cell setAlignmentMode:IUPTextVerticalAlignmentTop];
-			
-#endif
-			
-			
-			[the_label setBezeled:NO];
-			[the_label setDrawsBackground:NO];
-//			[the_label setDrawsBackground:YES]; // sometimes helpful for debugging layout issues
-			[the_label setEditable:NO];
-//			[the_label setSelectable:NO];
-			// TODO: FEATURE: I think this is really convenient for users so it should be the default
-			// FIXME: APPLE BUG: setSelectable:YES completely breaks using our vertical alignment cell subclass.
-			// When clicking the text, the text will snap to a wrong position and stay there.
-//			[the_label setSelectable:YES];
-			
-//			NSFont* the_font = [the_label font];
-//			NSLog(@"font %@", the_font);
-			[the_label setFont:[NSFont systemFontOfSize:0.0]];
+  /* Set background on the inner widget (text field or image view) */
+  if ([the_view isKindOfClass:[NSTextField class]])
+  {
+    NSTextField* text_field = (NSTextField*)the_view;
+    [text_field setBackgroundColor:color];
+    [text_field setDrawsBackground:YES];
+  }
+  else if ([the_view isKindOfClass:[NSImageView class]])
+  {
+    /* For image labels, set background on the wrapper */
+    [root_view setWantsLayer:YES];
+    [[root_view layer] setBackgroundColor:[color CGColor]];
+  }
 
-			
-			
-#if 1
-			if([the_label respondsToSelector:@selector(setLineBreakMode:)])
-			{
-				[the_label setLineBreakMode:NSLineBreakByClipping];
-				
-			}
-			else
-			{
-				
-				[[the_label cell] setTruncatesLastVisibleLine:NO];
+  /* Set background on the wrapper view (event view) */
+  [root_view setWantsLayer:YES];
+  [[root_view layer] setBackgroundColor:[color CGColor]];
 
+  return 1;
+}
 
-				
-				
-				[the_label setUsesSingleLineMode:YES];
-				[[the_label cell] setScrollable:YES];
-				
-				[[the_label cell] setWraps:NO];
-				[[the_label cell] setLineBreakMode:NSLineBreakByClipping];
-				[[the_label cell] setTruncatesLastVisibleLine:NO];
-				
-			}
-			
-			
-	
-#else
-			
-			
-			[the_label setUsesSingleLineMode:NO];
-			[[the_label cell] setWraps:YES];
-			[[the_label cell] setScrollable:NO];
-			
-//			[[the_label cell] setTruncatesLastVisibleLine:YES];
+static int cocoaLabelSetFgColorAttrib(Ihandle* ih, const char* value)
+{
+  int type = iupLabelGetTypeBeforeMap(ih);
+  if (type != IUP_LABEL_SEP_HORIZ && type != IUP_LABEL_SEP_VERT)
+  {
+    unsigned char r, g, b;
+    if (iupStrToRGB(value, &r, &g, &b))
+    {
+      iupAttribSetStr(ih, "_IUPCOCOA_USER_FGCOLOR", value);
 
-			// setLineBreakMode Requires 10.10+. Allows for both word wrapping and different ellipsis behaviors.
-//			[the_label setLineBreakMode:NSLineBreakByWordWrapping];
-#endif
-			
+      if (ih->handle)
+      {
+        NSView* the_view = iupcocoaGetMainView(ih);
+        if ([the_view isKindOfClass:[NSTextField class]])
+        {
+          NSTextField* text_field = (NSTextField*)the_view;
+          if (iupdrvIsActive(ih))
+          {
+            NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
 
-		}
-	}
-	
-	if (!the_label)
-	{
-		return IUP_ERROR;
-	}
-	
-	
-	ih->handle = the_label;
-	iupCocoaSetAssociatedViews(ih, the_label, the_label);
+            NSAttributedString* current_attr_string = [text_field attributedStringValue];
+            if (current_attr_string && [current_attr_string length] > 0)
+            {
+              NSMutableAttributedString* attr_str = [current_attr_string mutableCopy];
+              NSRange range = NSMakeRange(0, [attr_str length]);
+              [attr_str addAttribute:NSForegroundColorAttributeName value:color range:range];
+              [text_field setAttributedStringValue:attr_str];
+              [attr_str release];
+            }
+            else
+            {
+              [text_field setTextColor:color];
+            }
+          }
+        }
+      }
+    }
+  }
+  return 1;
+}
 
-	
-	
-	/* add to the parent, all GTK controls must call this. */
-//	iupgtkAddToParent(ih);
-	
-	
-//	Ihandle* ih_parent = ih->parent;
-//	id parent_native_handle = ih_parent->handle;
-	
-	iupCocoaAddToParent(ih);
-	
-	
-	/* configure for DRAG&DROP of files */
-	if (IupGetCallback(ih, "DROPFILES_CB"))
-	{
-		iupAttribSet(ih, "DROPFILESTARGET", "YES");
-	}
-	
-	return IUP_NOERROR;
+static int cocoaLabelSetFontAttrib(Ihandle* ih, const char* value)
+{
+  if (!value)
+    return 0;
+
+  if (!ih->handle || ih->data->type != IUP_LABEL_TEXT)
+    return 1;
+
+  IupCocoaFont* font = iupcocoaFindFont(value);
+  if (!font || !font.nativeFont)
+    return 0;
+
+  NSTextField* the_label = cocoaLabelGetTextField(ih);
+  if (the_label)
+  {
+    NSAttributedString* current_attr_string = [the_label attributedStringValue];
+
+    if (current_attr_string && [current_attr_string length] > 0)
+    {
+      NSMutableAttributedString* new_attr_string = [current_attr_string mutableCopy];
+      NSRange full_range = NSMakeRange(0, [new_attr_string length]);
+
+      [new_attr_string addAttribute:NSFontAttributeName value:font.nativeFont range:full_range];
+
+      if ([font usesAttributes])
+      {
+        NSDictionary* font_attrs = [font attributeDictionary];
+        for (NSString* attr_key in font_attrs)
+        {
+          if (![attr_key isEqualToString:NSForegroundColorAttributeName])
+          {
+            [new_attr_string addAttribute:attr_key value:[font_attrs objectForKey:attr_key] range:full_range];
+          }
+        }
+      }
+
+      [the_label setAttributedStringValue:new_attr_string];
+      [new_attr_string release];
+    }
+    else
+    {
+      [the_label setFont:font.nativeFont];
+    }
+
+    IupRefresh(ih);
+  }
+
+  return 1;
 }
 
+static int cocoaLabelSetSelectable(Ihandle* ih, const char* value)
+{
+  NSView* the_view = iupcocoaGetMainView(ih);
+  BOOL is_active = (BOOL)iupStrBoolean(value);
 
-static void cocoaLabelUnMapMethod(Ihandle* ih)
+  if ([the_view isKindOfClass:[NSTextField class]])
+  {
+    NSTextField* the_label = (NSTextField*)the_view;
+
+    /* Note: In older macOS versions, setSelectable:YES may cause visual glitches with vertical alignment. */
+    [the_label setSelectable:is_active];
+  }
+  else if ([the_view isKindOfClass:[NSImageView class]])
+  {
+    /* Not supported for image views */
+  }
+
+  return 1;
+}
+
+static char* cocoaLabelGetSelectable(Ihandle* ih)
 {
-	id the_label = ih->handle;
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
+  NSView* the_view = iupcocoaGetMainView(ih);
+  BOOL is_active = NO;
 
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[the_label release];
-	ih->handle = nil;
+  if ([the_view isKindOfClass:[NSTextField class]])
+  {
+    NSTextField* the_label = (NSTextField*)the_view;
+    is_active = [the_label isSelectable];
+  }
+  else if ([the_view isKindOfClass:[NSImageView class]])
+  {
+    /* Not supported for image views */
+  }
 
+  return iupStrReturnBoolean(is_active);
 }
 
+static int cocoaLabelMapMethod(Ihandle* ih)
+{
+  char* value;
+  id the_actual_label = nil;
 
+  value = iupAttribGet(ih, "SEPARATOR");
+  if (value)
+  {
+    if (iupStrEqualNoCase(value, "HORIZONTAL"))
+    {
+      ih->data->type = IUP_LABEL_SEP_HORIZ;
+      NSBox* horizontal_separator = [[NSBox alloc] initWithFrame:NSMakeRect(0.0, 0.0, 250.0, 1.0)];
+      [horizontal_separator setBoxType:NSBoxSeparator];
+      the_actual_label = horizontal_separator;
+    }
+    else
+    {
+      ih->data->type = IUP_LABEL_SEP_VERT;
+      NSBox* vertical_separator = [[NSBox alloc] initWithFrame:NSMakeRect(0.0, 0.0, 1.0, 250.0)];
+      [vertical_separator setBoxType:NSBoxSeparator];
+      the_actual_label = vertical_separator;
+    }
+  }
+  else
+  {
+    value = iupAttribGet(ih, "IMAGE");
+    if (value)
+    {
+      ih->data->type = IUP_LABEL_IMAGE;
+
+      iupAttribSet(ih, "_IUPCOCOA_ACTIVE", "YES");
+
+      char *name;
+      int make_inactive = 0;
+
+      if (iupdrvIsActive(ih))
+      {
+        name = iupAttribGet(ih, "IMAGE");
+      }
+      else
+      {
+        name = iupAttribGet(ih, "IMINACTIVE");
+        if (!name)
+        {
+          name = iupAttribGet(ih, "IMAGE");
+          make_inactive = 1;
+        }
+      }
+
+      id the_bitmap = iupImageGetImage(name, ih, make_inactive, NULL);
+      int width;
+      int height;
+      int bpp;
+
+      iupdrvImageGetInfo(the_bitmap, &width, &height, &bpp);
+
+      NSImageView* image_view = [[NSImageView alloc] initWithFrame:NSMakeRect(0, 0, width, height)];
+      [image_view setImage:the_bitmap];
+
+      the_actual_label = image_view;
+    }
+    else
+    {
+      ih->data->type = IUP_LABEL_TEXT;
+
+      iupAttribSet(ih, "_IUPCOCOA_ACTIVE", "YES");
+
+      the_actual_label = [[NSTextField alloc] initWithFrame:NSZeroRect];
+
+      IUPCocoaVerticalAlignmentTextFieldCell* textfield_cell = [[IUPCocoaVerticalAlignmentTextFieldCell alloc] initTextCell:@""];
+      [the_actual_label setCell:textfield_cell];
+      [textfield_cell release];
+
+      [the_actual_label setBezeled:NO];
+      [the_actual_label setDrawsBackground:NO];
+      [the_actual_label setEditable:NO];
+      [the_actual_label setSelectable:NO];
+      [the_actual_label setFont:[NSFont systemFontOfSize:[NSFont systemFontSize]]];
+
+      /* Set initial alignment based on ALIGNMENT attribute if already set */
+      char* alignment = iupAttribGet(ih, "ALIGNMENT");
+      if (alignment)
+      {
+        char value1[30], value2[30];
+        iupStrToStrStr(alignment, value1, value2, ':');
+
+        if (iupStrEqualNoCase(value1, "ARIGHT"))
+          [the_actual_label setAlignment:NSTextAlignmentRight];
+        else if (iupStrEqualNoCase(value1, "ACENTER"))
+          [the_actual_label setAlignment:NSTextAlignmentCenter];
+        else
+          [the_actual_label setAlignment:NSTextAlignmentLeft];
+      }
+
+      if ([the_actual_label respondsToSelector:@selector(setLineBreakMode:)])
+      {
+        [the_actual_label setLineBreakMode:NSLineBreakByClipping];
+      }
+      else
+      {
+        [[the_actual_label cell] setTruncatesLastVisibleLine:NO];
+        [the_actual_label setUsesSingleLineMode:YES];
+        [[the_actual_label cell] setScrollable:YES];
+        [[the_actual_label cell] setWraps:NO];
+        [[the_actual_label cell] setLineBreakMode:NSLineBreakByClipping];
+        [[the_actual_label cell] setTruncatesLastVisibleLine:NO];
+      }
+
+      char* title = iupAttribGet(ih, "TITLE");
+      if (title)
+      {
+        NSString* ns_string = [NSString stringWithUTF8String:title];
+
+        /* Check if title contains newlines for multi-line support */
+        BOOL has_newlines = (strchr(title, '\n') != NULL);
+
+        if (has_newlines)
+        {
+          /* Configure for multi-line display */
+          [(NSTextField*)the_actual_label setUsesSingleLineMode:NO];
+          [[(NSTextField*)the_actual_label cell] setScrollable:NO];
+          [[(NSTextField*)the_actual_label cell] setWraps:YES];
+          [[(NSTextField*)the_actual_label cell] setLineBreakMode:NSLineBreakByWordWrapping];
+        }
+
+        [(NSTextField*)the_actual_label setStringValue:ns_string];
+      }
+    }
+  }
+
+  if (!the_actual_label)
+  {
+    return IUP_ERROR;
+  }
+
+  IUPCocoaLabelEventView* event_view_wrapper = [[IUPCocoaLabelEventView alloc] initWithFrame:NSZeroRect];
+  [event_view_wrapper addSubview:the_actual_label];
+
+  [(NSView*)the_actual_label setAutoresizingMask:(NSViewWidthSizable | NSViewHeightSizable)];
+  [the_actual_label setFrame:[event_view_wrapper bounds]];
+  [the_actual_label release];
+
+  ih->handle = event_view_wrapper;
+  objc_setAssociatedObject(event_view_wrapper, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+
+  iupcocoaSetAssociatedViews(ih, the_actual_label, event_view_wrapper);
+
+  iupcocoaAddToParent(ih);
+
+  if (IupGetCallback(ih, "DROPFILES_CB"))
+  {
+    iupAttribSet(ih, "DROPFILESTARGET", "YES");
+  }
+
+  return IUP_NOERROR;
+}
+
+static void cocoaLabelUnMapMethod(Ihandle* ih)
+{
+  iupdrvBaseUnMapMethod(ih);
+}
+
 void iupdrvLabelInitClass(Iclass* ic)
 {
-  /* Driver Dependent Class functions */
   ic->Map = cocoaLabelMapMethod;
-	ic->UnMap = cocoaLabelUnMapMethod;
-	
+  ic->UnMap = cocoaLabelUnMapMethod;
 
-
-  /* Driver Dependent Attribute functions */
-
   /* Overwrite Visual */
   iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, cocoaLabelSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-#if 0
 
   /* Visual */
-  iupClassRegisterAttribute(ic, "BGCOLOR", iupBaseNativeParentGetBgColorAttrib, gtkLabelSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BGCOLOR", iupBaseNativeParentGetBgColorAttrib, cocoaLabelSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
 
   /* Special */
-  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, iupdrvBaseSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
-	
-#endif
-	
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaLabelSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FONT", NULL, cocoaLabelSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
+
   iupClassRegisterAttribute(ic, "TITLE", cocoaLabelGetTitleAttrib, cocoaLabelSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+
   /* IupLabel only */
-  iupClassRegisterAttribute(ic, "ALIGNMENT", NULL, cocoaLabelSetAlignmentAttrib, "ALEFT:ACENTER", NULL, IUPAF_NO_INHERIT);  /* force new default value */
+  iupClassRegisterAttribute(ic, "ALIGNMENT", cocoaLabelGetAlignmentAttrib, cocoaLabelSetAlignmentAttrib, IUPAF_SAMEASSYSTEM, "ALEFT:ACENTER", IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "IMAGE", NULL, cocoaLabelSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "PADDING", iupLabelGetPaddingAttrib, cocoaLabelSetPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED);
-#if 0
+
   /* IupLabel GTK and Motif only */
-  iupClassRegisterAttribute(ic, "IMINACTIVE", NULL, gtkLabelSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-#endif
-	
+  iupClassRegisterAttribute(ic, "IMINACTIVE", NULL, cocoaLabelSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+
   /* IupLabel Windows and GTK only */
   iupClassRegisterAttribute(ic, "WORDWRAP", NULL, cocoaLabelSetWordWrapAttrib, NULL, NULL, IUPAF_DEFAULT);
   iupClassRegisterAttribute(ic, "ELLIPSIS", NULL, cocoaLabelSetEllipsisAttrib, NULL, NULL, IUPAF_DEFAULT);
 
-#if 0
-  /* IupLabel GTK only */
-  iupClassRegisterAttribute(ic, "MARKUP", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);
-#endif
-	
+  /* Mac only */
+  iupClassRegisterAttribute(ic, "SELECTABLE", cocoaLabelGetSelectable, cocoaLabelSetSelectable, IUPAF_SAMEASSYSTEM, "NO", IUPAF_DEFAULT|IUPAF_NO_INHERIT);
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, iupCocoaCommonBaseSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
-
+  /* Not supported */
+  iupClassRegisterAttribute(ic, "MARKUP", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_list.m
===================================================================
--- src/cocoa/iupcocoa_list.m	(revision 5971)
+++ src/cocoa/iupcocoa_list.m	(working copy)
@@ -4,10 +4,9 @@
  * See Copyright Notice in "iup.h"
  */
 
-#include <Cocoa/Cocoa.h>
+#import <Cocoa/Cocoa.h>
 #import <objc/runtime.h>
 
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -30,1805 +29,4153 @@
 
 #include "iupcocoa_drv.h"
 
-static const CGFloat kIupCocoaDefaultWidthNSPopUpButton = 1.0;
+
+/* Pasteboard type for internal list reordering (SHOWDRAGDROP=YES). */
+/* It must be a valid UTI string, preferably in reverse-DNS format. */
+static NSPasteboardType const IupListPasteboardType = @"br.puc-rio.tecgraf.iup.list";
+
+/* Pasteboard type for cross-list DND (DRAGDROPLIST=YES), carrying Ihandle pointer. */
+static NSPasteboardType const IupInternalDndType = @"br.puc-rio.tecgraf.iup.dnd.internal.handle";
+
+static const CGFloat kIupCocoaDefaultWidthNSPopUpButton = 100.0;
 static const CGFloat kIupCocoaDefaultHeightNSPopUpButton = 26.0;
-static const CGFloat kIupCocoaDefaultWidthNSComboBox = 1.0;
+static const CGFloat kIupCocoaDefaultWidthNSComboBox = 100.0;
 static const CGFloat kIupCocoaDefaultHeightNSComboBox = 26.0;
-static const CGFloat kIupCocoaDefaultHeightNSTableViewCell = 17.0;
+static const CGFloat kIupCocoaMinColumnWidth = 50.0;
+static const CGFloat kIupCocoaListDefaultPadding = 0.0;
 
-// the point of this is we have a unique memory address for an identifier
-static const void* IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY = "IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY";
-static const void* IUP_COCOA_LIST_COMBOBOX_RECEIVER_OBJ_KEY = "IUP_COCOA_LIST_COMBOBOX_RECEIVER_OBJ_KEY";
-static const void* IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY = "IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY";
+static const void* IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY = @"IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY";
+static const void* IUP_COCOA_LIST_DELEGATE_OBJ_KEY = @"IUP_COCOA_LIST_DELEGATE_OBJ_KEY";
+static const void* IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY = @"IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY";
 
+/* Shared row height for lists */
+static CGFloat s_cocoa_measured_row_height = -1.0;
+
+/* Forward declarations */
+static char* cocoaListGetValueAttrib(Ihandle* ih);
+static int cocoaListSetValueAttrib(Ihandle* ih, const char* value);
+static void cocoaListUpdateDragDrop(Ihandle* ih);
+
+@interface IupCocoaListTableViewReceiver : NSObject <NSTableViewDelegate, NSTableViewDataSource>
+{
+  NSMutableArray* dataArray;
+}
+@property (nonatomic, retain) NSMutableArray* dataArray;
+- (NSInteger) numberOfRowsInTableView:(NSTableView*)table_view;
+- (NSView*) tableView:(NSTableView*)table_view viewForTableColumn:(NSTableColumn*)table_column row:(NSInteger)the_row;
+- (void) tableViewSelectionDidChange:(NSNotification*)the_notification;
+- (CGFloat) tableView:(NSTableView*)table_view heightOfRow:(NSInteger)row;
+- (id<NSPasteboardWriting>)tableView:(NSTableView *)tableView pasteboardWriterForRow:(NSInteger)row;
+- (NSDragOperation)tableView:(NSTableView *)tableView validateDrop:(id <NSDraggingInfo>)info proposedRow:(NSInteger)row proposedDropOperation:(NSTableViewDropOperation)dropOperation;
+- (BOOL)tableView:(NSTableView *)tableView acceptDrop:(id <NSDraggingInfo>)info row:(NSInteger)row dropOperation:(NSTableViewDropOperation)dropOperation;
+- (void)tableView:(NSTableView *)tableView draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint forRowIndexes:(NSIndexSet *)rowIndexes;
+- (void)tableView:(NSTableView *)tableView draggingSession:(NSDraggingSession *)session endedAtPoint:(NSPoint)screenPoint operation:(NSDragOperation)operation;
+@end
+
 typedef enum
 {
-	IUPCOCOALISTSUBTYPE_UNKNOWN = -1,
-	IUPCOCOALISTSUBTYPE_DROPDOWN,
-	IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN,
-	IUPCOCOALISTSUBTYPE_EDITBOX,
-	IUPCOCOALISTSUBTYPE_MULTIPLELIST,
-	IUPCOCOALISTSUBTYPE_SINGLELIST // not official, but could be the basis for mobile-style listviews
+  IUPCOCOALISTSUBTYPE_UNKNOWN = -1,
+  IUPCOCOALISTSUBTYPE_DROPDOWN,
+  IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN,
+  IUPCOCOALISTSUBTYPE_EDITBOX,
+  IUPCOCOALISTSUBTYPE_MULTIPLELIST,
+  IUPCOCOALISTSUBTYPE_SINGLELIST
 } IupCocoaListSubType;
 
-/*
-Each IUP list subtype requires a completely different Cocoa native widget.
-This function provides a consistent and centralized way to distinguish which subtype we need.
-*/
 static IupCocoaListSubType cocoaListGetSubType(Ihandle* ih)
 {
-	if(ih->data->is_dropdown)
-	{
-		if(ih->data->has_editbox)
-		{
-			return IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN;
-		}
-		else
-		{
-			return IUPCOCOALISTSUBTYPE_DROPDOWN;
-		}
-	}
-	else
-	{
-		if(ih->data->has_editbox)
-		{
-			return IUPCOCOALISTSUBTYPE_EDITBOX;
-		}
-		else if(ih->data->is_multiple)
-		{
-			return IUPCOCOALISTSUBTYPE_MULTIPLELIST;
+  if (ih->data->is_dropdown)
+  {
+    if (ih->data->has_editbox)
+      return IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN;
+    else
+      return IUPCOCOALISTSUBTYPE_DROPDOWN;
+  }
+  else
+  {
+    if (ih->data->has_editbox)
+      return IUPCOCOALISTSUBTYPE_EDITBOX;
+    else if (ih->data->is_multiple)
+      return IUPCOCOALISTSUBTYPE_MULTIPLELIST;
+    else
+      return IUPCOCOALISTSUBTYPE_SINGLELIST;
+  }
+  return IUPCOCOALISTSUBTYPE_UNKNOWN;
+}
 
-		}
-		else
-		{
-			return IUPCOCOALISTSUBTYPE_SINGLELIST;
-		}
-	}
-	return IUPCOCOALISTSUBTYPE_UNKNOWN;
+static NSView* cocoaListGetBaseWidget(Ihandle* ih)
+{
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSView* root_widget = (NSView*)ih->handle;
+
+  if (nil == root_widget)
+    return nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSCAssert([root_widget isKindOfClass:[NSPopUpButton class]], @"Expecting a NSPopUpButton");
+        return root_widget;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSCAssert([root_widget isKindOfClass:[NSComboBox class]], @"Expecting a NSComboBox");
+        return root_widget;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        NSTableView* table_view = (NSTableView*)iupAttribGet(ih, "_IUPCOCOA_TABLEVIEW");
+        return table_view;
+      }
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)iupAttribGet(ih, "_IUPCOCOA_TABLEVIEW");
+        if (table_view)
+          return table_view;
+
+        if ([root_widget isKindOfClass:[NSTableView class]])
+          return root_widget;
+        else if ([root_widget isKindOfClass:[NSScrollView class]])
+        {
+          NSView* base_widget = [(NSScrollView*)root_widget documentView];
+          return base_widget;
+        }
+        else
+        {
+          NSCAssert(0, @"Unexpected subtype");
+          return root_widget;
+        }
+      }
+    default:
+      {
+        NSCAssert(0, @"Unexpected subtype");
+        return root_widget;
+      }
+  }
 }
 
-/*
-The normal convention is to put the native widget in ih->handle,
-but because we have to embed NSTableView in NSScrollView for some cases,
-ih->handle is simply the root_view, but not necessarily the base "real" widget.
-So this helper function returns the base widget (e.g. NSTableView instead of NSScrollView)
-in which we can use to invoke all the important methods we need to call.
-IUPCOCOALISTSUBTYPE_DROPDOWN returns NSPopUpButton
-IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN returns NSComboBox
-IUPCOCOALISTSUBTYPE_MULTIPLELIST returns NSTableView
-IUPCOCOALISTSUBTYPE_SINGLELIST returns NSTableView
+static int cocoaListGetMaxWidth(Ihandle* ih)
+{
+  int max_width = 0;
 
-*/
-static NSView* cocoaListGetBaseWidget(Ihandle* ih)
+  if (!ih->handle)
+  {
+    int count = 0;
+    char* value;
+    while ((value = iupAttribGetId(ih, "", count+1)) != NULL)
+    {
+      int width = iupdrvFontGetStringWidth(ih, value);
+      if (width > max_width)
+        max_width = width;
+      count++;
+    }
+    return max_width;
+  }
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+        if (popup_button)
+        {
+          NSMenu* menu = [popup_button menu];
+
+          for (NSMenuItem* item in [menu itemArray])
+          {
+            NSString* title = [item title];
+            if (title)
+            {
+              const char* c_str = [title UTF8String];
+              int width = iupdrvFontGetStringWidth(ih, c_str);
+              if (width > max_width)
+                max_width = width;
+            }
+          }
+        }
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        if (combo_box)
+        {
+          NSInteger count = [combo_box numberOfItems];
+
+          for (NSInteger i = 0; i < count; i++)
+          {
+            id obj = [combo_box itemObjectValueAtIndex:i];
+            NSString* str = nil;
+            if ([obj isKindOfClass:[NSString class]])
+              str = (NSString*)obj;
+            else if ([obj respondsToSelector:@selector(stringValue)])
+              str = [obj stringValue];
+
+            if (str)
+            {
+              const char* c_str = [str UTF8String];
+              int width = iupdrvFontGetStringWidth(ih, c_str);
+              if (width > max_width)
+                max_width = width;
+            }
+          }
+        }
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        if (table_view)
+        {
+          IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+          if(list_receiver)
+          {
+            NSMutableArray* data_array = [list_receiver dataArray];
+
+            for (NSDictionary* item_data in data_array)
+            {
+              NSString* str = [item_data objectForKey:@"text"];
+              if (str)
+              {
+                const char* c_str = [str UTF8String];
+                int width = iupdrvFontGetStringWidth(ih, c_str);
+                if (width > max_width)
+                  max_width = width;
+              }
+            }
+          }
+        }
+        break;
+      }
+    default:
+      break;
+  }
+
+  return max_width;
+}
+
+static NSFont* cocoaGetNativeFont(Ihandle* ih)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	NSView* root_widget = (NSView*)ih->handle;
-	
-	if(nil == root_widget)
-	{
-		NSLog(@"Warning: cocoaListGetBaseWidget is nil");
-		return nil;
-	}
-	 
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSCAssert([root_widget isKindOfClass:[NSPopUpButton class]], @"Expecting a NSPopUpButton");
-			return root_widget;
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSCAssert([root_widget isKindOfClass:[NSComboBox class]], @"Expecting a NSComboBox");
-			return root_widget;
-			break;
-		}
-		// both these cases may have an NSScrollView at the root
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			if([root_widget isKindOfClass:[NSTableView class]])
-			{
-				return root_widget;
-			}
-			else if([root_widget isKindOfClass:[NSScrollView class]])
-			{
-				NSView* base_widget = [(NSScrollView*)root_widget documentView];
-				return base_widget;
-			}
-			else
-			{
-				NSCAssert(0, @"Unexpected subtype");
-				return root_widget;
+  IupCocoaFont *iup_font = NULL;
 
-			}
+  if (ih)
+  {
+    iup_font = iupcocoaGetFont(ih);
+  }
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			return root_widget;
-			break;
-		}
-		default:
-		{
-			NSCAssert(0, @"Unexpected subtype");
-			return root_widget;
-			break;
-		}
-	}
-	
+  if (!iup_font)
+  {
+    /* Fallback to DEFAULTFONT */
+    const char* default_font = IupGetGlobal("DEFAULTFONT");
+    iup_font = iupcocoaFindFont(default_font);
+  }
 
+  return iup_font ? [iup_font nativeFont] : nil;
 }
 
-// The sole reason was subclass NSComboBox is so we can suppor the contextual menu
+static void cocoaListCaretNotification(NSNotification* notification, Ihandle* ih)
+{
+  IFniii cb = (IFniii)IupGetCallback(ih, "CARET_CB");
+  if (!cb) return;
+
+  NSTextField* text_field = [notification object];
+  NSText* field_editor = [[text_field window] fieldEditor:NO forObject:text_field];
+
+  if (field_editor)
+  {
+    NSRange range = [field_editor selectedRange];
+    int pos = (int)range.location;
+    int lin = 1;
+
+    if (pos != ih->data->last_caret_pos)
+    {
+      ih->data->last_caret_pos = pos;
+      cb(ih, lin, pos + 1, pos);
+    }
+  }
+}
+
+static CGFloat cocoaListGetScrollbarSize(void)
+{
+  /* Get the width of a standard vertical scrollbar */
+  NSScroller* scroller = [[NSScroller alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)];
+  [scroller setScrollerStyle:NSScrollerStyleLegacy];
+  CGFloat width = [NSScroller scrollerWidthForControlSize:NSControlSizeRegular
+                                             scrollerStyle:[scroller scrollerStyle]];
+  [scroller release];
+
+  if (width < 15.0)
+    width = 15.0;
+
+  return width;
+}
+
+static void cocoaListUpdateDropExpand(Ihandle* ih)
+{
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  if (!ih->data->is_dropdown)
+    return;
+
+  if (!iupAttribGetBoolean(ih, "DROPEXPAND"))
+    return;
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
+  {
+    NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+    if (!popup_button) return;
+
+    int max_text_width = cocoaListGetMaxWidth(ih);
+    CGFloat scrollbar_width = cocoaListGetScrollbarSize();
+    CGFloat button_width = 22.0;
+    CGFloat padding = 6.0;
+    CGFloat required_width = padding + (CGFloat)max_text_width + button_width + scrollbar_width + padding;
+
+    [[popup_button menu] setMinimumWidth:required_width];
+  }
+  else if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
+  {
+    /* NSComboBox dropdown width is controlled by the combo box frame width.
+       This is a limitation of the Cocoa NSComboBox API. */
+  }
+}
+
+static void cocoaListUpdateColumnWidth(Ihandle* ih)
+{
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST ||
+      sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST ||
+      sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    if (!table_view) return;
+
+    NSArray* columns = [table_view tableColumns];
+    if ([columns count] == 0) return;
+
+    NSTableColumn* column = [columns firstObject];
+    int max_text_width = cocoaListGetMaxWidth(ih);
+
+    CGFloat padding = kIupCocoaListDefaultPadding * 2;
+    if (ih->data->spacing > 0)
+      padding = (CGFloat)(ih->data->spacing * 2);
+
+    CGFloat required_width = (CGFloat)max_text_width + padding;
+
+    if (ih->data->show_image && ih->data->maximg_w > 0)
+      required_width += ih->data->maximg_w + 4;
+
+    if (ih->data->is_multiple)
+      required_width += 20;
+
+    if (required_width < kIupCocoaMinColumnWidth)
+      required_width = kIupCocoaMinColumnWidth;
+
+    [column setWidth:required_width];
+    [table_view sizeToFit];
+    [table_view setNeedsDisplay:YES];
+  }
+}
+
+static void cocoaListCallCaretCbForTextView(Ihandle* ih, NSTextView* textView)
+{
+  IFniii cb = (IFniii)IupGetCallback(ih, "CARET_CB");
+  if (!cb) return;
+
+  NSRange range = [textView selectedRange];
+  int pos = (int)range.location;
+  int lin = 1;
+
+  if (pos != ih->data->last_caret_pos)
+  {
+    ih->data->last_caret_pos = pos;
+    cb(ih, lin, pos + 1, pos);
+  }
+}
+
+@interface IupCocoaListTextField : NSTextField
+@end
+
+@implementation IupCocoaListTextField
+- (NSMenu *)textView:(NSTextView *)text_view menu:(NSMenu *)the_menu forEvent:(NSEvent *)the_event atIndex:(NSUInteger)char_index
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!iupAttribGet(ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    return the_menu;
+  }
+  Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+  if(menu_ih && menu_ih->handle)
+  {
+    return (NSMenu*)menu_ih->handle;
+  }
+  else
+  {
+    return nil;
+  }
+}
+
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    if (iupAttribGet(ih, "_IUPCOCOA_CANFOCUS"))
+      return iupAttribGetBoolean(ih, "_IUPCOCOA_CANFOCUS");
+    return iupAttribGetBoolean(ih, "CANFOCUS");
+  }
+  return [super acceptsFirstResponder];
+}
+
+- (BOOL)becomeFirstResponder
+{
+  BOOL result = [super becomeFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusIn(ih);
+  }
+  return result;
+}
+
+- (BOOL)resignFirstResponder
+{
+  BOOL result = [super resignFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusOut(ih);
+  }
+  return result;
+}
+
+- (void)keyDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    /* iupcocoaKeyEvent will internally bubble the event up to the dialog if needed. */
+    BOOL handled = iupcocoaKeyEvent(ih, event, mac_key_code, true);
+
+    if (!handled)
+    {
+      [super keyDown:event];
+    }
+  }
+  else
+  {
+    [super keyDown:event];
+  }
+}
+
+- (void)keyUp:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    BOOL handled = iupcocoaKeyEvent(ih, event, mac_key_code, false);
+
+    if (!handled)
+      [super keyUp:event];
+  }
+  else
+    [super keyUp:event];
+}
+
+- (void)flagsChanged:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    BOOL handled = iupcocoaModifierEvent(ih, event, mac_key_code);
+
+    if (!handled)
+      [super flagsChanged:event];
+  }
+  else
+    [super flagsChanged:event];
+}
+
+@end
+
+@interface IupCocoaListTableView : NSTableView
+@end
+
+@implementation IupCocoaListTableView
+
+- (NSMenu *)menuForEvent:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (iupAttribGet(ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+    if (menu_ih && menu_ih->handle)
+      return (NSMenu*)menu_ih->handle;
+    else
+      return nil;
+  }
+  return [super menuForEvent:event];
+}
+
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  if (ih)
+  {
+    BOOL canFocus;
+    if (iupAttribGet(ih, "_IUPCOCOA_CANFOCUS"))
+    {
+      canFocus = iupAttribGetBoolean(ih, "_IUPCOCOA_CANFOCUS");
+    }
+    else
+    {
+      canFocus = iupAttribGetBoolean(ih, "CANFOCUS");
+    }
+    return canFocus;
+  }
+
+  BOOL result = [super acceptsFirstResponder];
+  return result;
+}
+
+- (BOOL)becomeFirstResponder
+{
+  BOOL result = [super becomeFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+    if (ih)
+    {
+      iupcocoaFocusIn(ih);
+    }
+  }
+  return result;
+}
+
+- (BOOL)resignFirstResponder
+{
+  BOOL result = [super resignFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+    {
+      iupcocoaFocusOut(ih);
+    }
+  }
+  return result;
+}
+
+- (void)keyDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    BOOL handled = iupcocoaKeyEvent(ih, event, mac_key_code, true);
+    if (!handled)
+    {
+      [super keyDown:event];
+    }
+  }
+  else
+  {
+    [super keyDown:event];
+  }
+}
+
+- (void)keyUp:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    BOOL handled = iupcocoaKeyEvent(ih, event, mac_key_code, false);
+    if (!handled)
+      [super keyUp:event];
+  }
+  else
+    [super keyUp:event];
+}
+
+- (void)flagsChanged:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    BOOL handled = iupcocoaModifierEvent(ih, event, mac_key_code);
+    if (!handled)
+      [super flagsChanged:event];
+  }
+  else
+    [super flagsChanged:event];
+}
+
+@end
+
 @interface IupCocoaComboBox : NSComboBox
 - (NSMenu *)textView:(NSTextView *)text_view menu:(NSMenu *)the_menu forEvent:(NSEvent *)the_event atIndex:(NSUInteger)char_index;
 @end
 
 @implementation IupCocoaComboBox
-// WARNING: This was the only way I could figure out how to correctly override the contextual menu for NSTextField.
-// I tried setting the menu (on demand) of the field editor, but I ended up getting lots of missing items.
-// I tried creating my own field editor and setting a custom delegate for this method on it, but it never got invoked. I think Cocoa may ignore my delegate when used as a field editor.
-// I found a mention on the internet that vaguely suggested subclassing NSTextField and implementing this method.
-// I have not found documentation about this method in NSTextField, only as a delegate protocol for NSTextView.
-// This might mean this is private API so this may have to be disabled.
 - (NSMenu *)textView:(NSTextView *)text_view menu:(NSMenu *)the_menu forEvent:(NSEvent *)the_event atIndex:(NSUInteger)char_index
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
-	Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
-	if(NULL != menu_ih)
-	{
-		NSMenu* user_menu = (NSMenu*)menu_ih->handle;
-		iupCocoaCommonBaseAppendMenuItems(the_menu, user_menu);
-		// It appears that Cocoa may append "Services" after our entries if something is selected, so we want another separator.
-		NSRange selected_range = [text_view selectedRange];
-		if(selected_range.length > 0)
-		{
-			[the_menu addItem:[NSMenuItem separatorItem]];
-		}
-	}
-	return the_menu;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  /* Check if the user has ever configured the CONTEXTMENU attribute. */
+  if (!iupAttribGet(ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    /* If not, allow the default system menu to appear. */
+    return the_menu;
+  }
+
+  /* The attribute has been configured. Check its value. */
+  Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+
+  if(menu_ih && menu_ih->handle)
+  {
+    /* A valid custom menu is set; return it. */
+    return (NSMenu*)menu_ih->handle;
+  }
+  else
+  {
+    /* The attribute was set to NULL; disable the context menu. */
+    return nil;
+  }
 }
-@end
 
+- (BOOL)becomeFirstResponder
+{
+  BOOL result = [super becomeFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusIn(ih);
+  }
+  return result;
+}
 
-@interface IupCocoaListPopupButtonReceiver : NSObject
-- (IBAction) onSelectionChanged:(id)the_sender;
+- (BOOL)resignFirstResponder
+{
+  BOOL result = [super resignFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusOut(ih);
+  }
+  return result;
+}
+
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    if (iupAttribGet(ih, "_IUPCOCOA_CANFOCUS"))
+      return iupAttribGetBoolean(ih, "_IUPCOCOA_CANFOCUS");
+    return iupAttribGetBoolean(ih, "CANFOCUS");
+  }
+  return [super acceptsFirstResponder];
+}
+
+- (void)keyDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    /* iupcocoaKeyEvent will internally bubble the event up to the dialog if needed. */
+    BOOL handled = iupcocoaKeyEvent(ih, event, mac_key_code, true);
+
+    if (!handled)
+      [super keyDown:event];
+  }
+  else
+    [super keyDown:event];
+}
+
+- (void)keyUp:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaKeyEvent(ih, event, mac_key_code, false))
+      [super keyUp:event];
+  }
+  else
+    [super keyUp:event];
+}
+
+- (void)flagsChanged:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaModifierEvent(ih, event, mac_key_code))
+      [super flagsChanged:event];
+  }
+  else
+    [super flagsChanged:event];
+}
+
 @end
 
-@implementation IupCocoaListPopupButtonReceiver
+@interface IupCocoaListPopupButtonReceiver : NSObject
+            - (IBAction) onSelectionChanged:(id)the_sender;
+            @end
 
-/*
-- (void) dealloc
+            @implementation IupCocoaListPopupButtonReceiver
+
+            - (IBAction) onSelectionChanged:(id)the_sender;
 {
-	[super dealloc];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
+        if (cb)
+        {
+          NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+          NSInteger index_of_selected_item = [popup_button indexOfSelectedItem];
+          int adjusted_index = (int)(index_of_selected_item+1);
+          iupListSingleCallActionCb(ih, cb, adjusted_index);
+        }
+        iupBaseCallValueChangedCb(ih);
+        break;
+      }
+    default:
+      break;
+  }
 }
-*/
 
+@end
 
-- (IBAction) onSelectionChanged:(id)the_sender;
+@interface IupCocoaListDelegate : NSObject <NSComboBoxDelegate, NSTextFieldDelegate, NSTextViewDelegate>
+- (void) comboBoxSelectionDidChange:(NSNotification*)the_notification;
+- (void) controlTextDidChange:(NSNotification*)the_notification;
+- (void) controlTextDidEndEditing:(NSNotification*)the_notification;
+- (void) controlTextDidBeginEditing:(NSNotification*)the_notification;
+- (BOOL) control:(NSControl*)control textView:(NSTextView*)textView doCommandBySelector:(SEL)commandSelector;
+- (BOOL) textView:(NSTextView *)textView shouldChangeTextInRange:(NSRange)affectedCharRange replacementString:(NSString *)replacementString;
+@end
+
+@implementation IupCocoaListDelegate
+
+- (void) comboBoxSelectionDidChange:(NSNotification*)the_notification
 {
-//	Icallback callback_function;
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+  NSComboBox* combo_box = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(combo_box, IHANDLE_ASSOCIATED_OBJ_KEY);
 
+  IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
+  if (cb)
+  {
+    NSInteger index_of_selected_item = [combo_box indexOfSelectedItem];
+    int adjusted_index = (int)(index_of_selected_item+1);
+    iupListSingleCallActionCb(ih, cb, adjusted_index);
+  }
+  iupBaseCallValueChangedCb(ih);
+}
 
-	
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
-			if(cb)
-			{
-				NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-				NSInteger index_of_selected_item = [popup_button indexOfSelectedItem];
-				int adjusted_index = (int)(index_of_selected_item+1); /* IUP starts at 1 */
-				iupListSingleCallActionCb(ih, cb, adjusted_index);
-				
-				iupBaseCallValueChangedCb(ih);
+- (void) controlTextDidChange:(NSNotification*)the_notification
+{
+  id text_obj = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_obj, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
-			}
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
+  const char* filter = iupAttribGet(ih, "FILTER");
+  if(filter)
+  {
+    NSTextField* text_field = (NSTextField*)text_obj;
+    NSString* current_text = [text_field stringValue];
+    NSString* modified_text = nil;
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		{
-			iupBaseCallValueChangedCb(ih);
+    if (iupStrEqualNoCase(filter, "LOWERCASE"))
+    {
+      modified_text = [current_text lowercaseString];
+    }
+    else if (iupStrEqualNoCase(filter, "UPPERCASE"))
+    {
+      modified_text = [current_text uppercaseString];
+    }
+    else if (iupStrEqualNoCase(filter, "NUMBER"))
+    {
+      NSCharacterSet* non_digits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
+      modified_text = [[current_text componentsSeparatedByCharactersInSet:non_digits] componentsJoinedByString:@""];
+    }
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			iupBaseCallValueChangedCb(ih);
+    if (modified_text && ![modified_text isEqualToString:current_text])
+    {
+      NSText* field_editor = [[text_field window] fieldEditor:NO forObject:text_field];
+      NSRange selected_range = [field_editor selectedRange];
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
+      [text_field setStringValue:modified_text];
 
+      if(selected_range.location > [modified_text length])
+      {
+        selected_range.location = [modified_text length];
+      }
+      [field_editor setSelectedRange:selected_range];
+    }
+  }
 
+  if (ih->data->nc > 0)
+  {
+    NSTextField* text_field = (NSTextField*)text_obj;
+    NSString* current_text = [text_field stringValue];
+
+    if ([current_text length] > ih->data->nc)
+    {
+      NSString* truncated_text = [current_text substringToIndex:ih->data->nc];
+      NSText* field_editor = [[text_field window] fieldEditor:NO forObject:text_field];
+      NSRange selected_range = [field_editor selectedRange];
+
+      [text_field setStringValue:truncated_text];
+
+      if(selected_range.location > [truncated_text length])
+      {
+        selected_range.location = [truncated_text length];
+      }
+      [field_editor setSelectedRange:selected_range];
+    }
+  }
+
+  cocoaListCaretNotification(the_notification, ih);
+  iupBaseCallValueChangedCb(ih);
 }
 
-@end
+- (void) controlTextDidEndEditing:(NSNotification*)the_notification
+{
+  id text_obj = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_obj, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
+  cocoaListCaretNotification(the_notification, ih);
+}
 
-// We are not using NSComboBoxDataSource
-@interface IupCocoaListComboBoxReceiver : NSObject <NSComboBoxDelegate>
+- (void) controlTextDidBeginEditing:(NSNotification*)the_notification
+{
+  id text_obj = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_obj, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
+  IFn cb = (IFn)IupGetCallback(ih, "EDIT_CB");
+  if (!cb) return;
 
-// NSComboBoxDelegate
-/* Notifications */
-//- (void)comboBoxWillPopUp:(NSNotification *)notification;
-//- (void)comboBoxWillDismiss:(NSNotification *)notification;
-- (void) comboBoxSelectionDidChange:(NSNotification*)the_notification;
-//- (void)comboBoxSelectionIsChanging:(NSNotification *)notification;
+  NSText *fieldEditor = [[text_obj window] fieldEditor:YES forObject:text_obj];
+  if ([fieldEditor isKindOfClass:[NSTextView class]])
+  {
+    [(NSTextView *)fieldEditor setDelegate:self];
+  }
+}
 
+- (void)textViewDidChangeSelection:(NSNotification *)notification
+{
+  NSTextView *textView = [notification object];
 
-@end
+  NSControl *control = nil;
+  for (NSView* view = [textView superview]; view != nil; view = [view superview])
+  {
+    if ([view isKindOfClass:[NSControl class]])
+    {
+      control = (NSControl*)view;
+      break;
+    }
+  }
 
-@implementation IupCocoaListComboBoxReceiver
+  if (!control) return;
 
-/*
- - (void) dealloc
- {
-	[super dealloc];
- }
- */
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(control, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
+  cocoaListCallCaretCbForTextView(ih, textView);
+}
 
-- (void) comboBoxSelectionDidChange:(NSNotification*)the_notification
+- (BOOL) control:(NSControl*)control textView:(NSTextView*)textView doCommandBySelector:(SEL)commandSelector
 {
-	NSComboBox* combo_box = [the_notification object];
-	
-	NSLog(@"combo_box frame: %@", NSStringFromRect([combo_box frame]));
-	
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(combo_box, IHANDLE_ASSOCIATED_OBJ_KEY);
-	
-	IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
-	if(cb)
-	{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(control, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return NO;
 
-		
-		NSInteger index_of_selected_item = [combo_box indexOfSelectedItem];
-		int adjusted_index = (int)(index_of_selected_item+1); /* IUP starts at 1 */
-		iupListSingleCallActionCb(ih, cb, adjusted_index);
+  /* Give IUP key handler first chance at any command key (arrows, page up/down, delete, etc.) */
+  /* This allows K_ANY callbacks to intercept any key, not just text input keys */
+  NSEvent* current_event = [NSApp currentEvent];
+  if (current_event && [current_event type] == NSEventTypeKeyDown)
+  {
+    int mac_key_code = [current_event keyCode];
 
-	}
-	
+    /* First, let the control itself try to handle the key event. */
+    BOOL handled = iupcocoaKeyEvent(ih, current_event, mac_key_code, true);
+    if (handled)
+      return YES; /* Returning YES prevents the default command. */
 
-	/*
-	if (!ih->data->has_editbox)
-	{
-		iupBaseCallValueChangedCb(ih);
-	}
-	
-	*/
-	
-	
+    /* If not handled, allow the parent dialog's K_ANY to intercept it. */
+    /* This is needed because some controls (like NSTextView) consume navigation */
+    /* keys and do not propagate them up the responder chain, preventing the */
+    /* dialog's window-level handler from ever seeing the event. */
+    Ihandle* dialog_ih = IupGetDialog(ih);
+    if (dialog_ih && dialog_ih != ih)
+    {
+      if (iupcocoaKeyEvent(dialog_ih, current_event, mac_key_code, true))
+        return YES; /* Handled by dialog's K_ANY. Prevents default command. */
+    }
+  }
+
+  /* If not handled by IUP, apply NC (max length) constraint for non-deletion commands */
+  if (ih->data->nc > 0)
+  {
+    NSString* current_text = [textView string];
+    if ([current_text length] >= ih->data->nc)
+    {
+      if (commandSelector != @selector(deleteBackward:) &&
+          commandSelector != @selector(deleteForward:) &&
+          commandSelector != @selector(deleteWordBackward:) &&
+          commandSelector != @selector(deleteWordForward:) &&
+          commandSelector != @selector(deleteToBeginningOfLine:) &&
+          commandSelector != @selector(deleteToEndOfLine:))
+      {
+        NSRange selected_range = [textView selectedRange];
+        if (selected_range.length == 0)
+        {
+          return YES;
+        }
+      }
+    }
+  }
+
+  return NO;
 }
 
+- (BOOL) textView:(NSTextView *)textView shouldChangeTextInRange:(NSRange)affectedCharRange replacementString:(NSString *)replacementString
+{
+  NSControl* control = nil;
+
+  for (NSView* view = [textView superview]; view != nil; view = [view superview])
+  {
+    if ([view isKindOfClass:[NSControl class]])
+    {
+      control = (NSControl*)view;
+      break;
+    }
+  }
+
+  if (!control) return YES;
+
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(control, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return YES;
+
+  IFnis cb = (IFnis)IupGetCallback(ih, "EDIT_CB");
+  if (!cb) return YES;
+
+  if (affectedCharRange.length > 0 && [replacementString length] == 0)
+  {
+    int ret = iupEditCallActionCb(ih, cb, NULL, (int)affectedCharRange.location,
+                                   (int)(affectedCharRange.location + affectedCharRange.length),
+                                   ih->data->mask, ih->data->nc, 1, 1);
+    if (ret == 0)
+      return NO;
+  }
+  else if ([replacementString length] > 0)
+  {
+    const char* insert_value = [replacementString UTF8String];
+
+    for (NSUInteger i = 0; i < [replacementString length]; i++)
+    {
+      unichar c = [replacementString characterAtIndex:i];
+      char single_char[5];
+      int len = 0;
+
+      if (c < 0x80)
+      {
+        single_char[0] = (char)c;
+        single_char[1] = 0;
+        len = 1;
+      }
+      else
+      {
+        NSString* singleCharStr = [NSString stringWithCharacters:&c length:1];
+        const char* utf8 = [singleCharStr UTF8String];
+        strncpy(single_char, utf8, 4);
+        single_char[4] = 0;
+        len = (int)strlen(single_char);
+      }
+
+      int pos = (int)(affectedCharRange.location + i);
+      int ret = iupEditCallActionCb(ih, cb, single_char, pos, pos,
+                                     ih->data->mask, ih->data->nc, 0, 1);
+
+      if (ret == 0)
+        return NO;
+      else if (ret > 0 && ret != (int)c)
+      {
+        NSString* replacement = [NSString stringWithFormat:@"%c", ret];
+        [textView insertText:replacement replacementRange:NSMakeRange(pos, 0)];
+        return NO;
+      }
+    }
+  }
+
+  return YES;
+}
+
 @end
 
+@interface IupCocoaListTableCellView : NSTableCellView
+@property (nonatomic, retain) NSColor* customBackgroundColor;
+@property (nonatomic, retain) NSColor* customTextColor;
+@end
 
-// We are not using NSComboBoxDataSource
-@interface IupCocoaListTableViewReceiver : NSObject <NSTableViewDelegate, NSTableViewDataSource>
+@implementation IupCocoaListTableCellView
+@synthesize customBackgroundColor;
+@synthesize customTextColor;
+
+- (instancetype) initWithFrame:(NSRect)frameRect
 {
-	NSMutableArray* dataArray;
+  self = [super initWithFrame:frameRect];
+  if (self)
+  {
+    [self setWantsLayer:YES];
+
+    /* Use standard NSImageView via superclass property.
+       It must be set as non-editable so it does not interfere with dragging. */
+    self.imageView = [[[NSImageView alloc] initWithFrame:NSZeroRect] autorelease];
+    [self.imageView setImageFrameStyle:NSImageFrameNone];
+    [self.imageView setImageAlignment:NSImageAlignCenter];
+    [self.imageView setImageScaling:NSImageScaleProportionallyDown];
+    [self.imageView setEditable:NO];
+    [self.imageView setTranslatesAutoresizingMaskIntoConstraints:NO];
+    [self addSubview:self.imageView];
+
+    /* Use custom NSTextField with controlled text insets.
+       It must be non-editable and non-selectable so it does not interfere with dragging. */
+    NSTextField* textField = [[[IupCocoaListTextField alloc] initWithFrame:NSZeroRect] autorelease];
+    [textField setBezeled:NO];
+    [textField setDrawsBackground:NO];
+    [textField setEditable:NO];
+    [textField setSelectable:NO];
+    [textField setLineBreakMode:NSLineBreakByClipping];
+    [textField setTranslatesAutoresizingMaskIntoConstraints:NO];
+    [self addSubview:textField];
+    [self setTextField:textField];
+  }
+  return self;
 }
 
-- (NSMutableArray*) dataArray;
+- (void) dealloc
+{
+  [customBackgroundColor release];
+  [customTextColor release];
+  [super dealloc];
+}
 
+- (void)setBackgroundStyle:(NSBackgroundStyle)backgroundStyle
+{
+  [super setBackgroundStyle:backgroundStyle];
 
-// NSTableViewDataSource
-- (NSInteger) numberOfRowsInTableView:(NSTableView*)table_view;
-/* This method is required for the "Cell Based" TableView, and is optional for the "View Based" TableView. If implemented in the latter case, the value will be set to the view at a given row/column if the view responds to -setObjectValue: (such as NSControl and NSTableCellView).
- */
-//- (nullable id) tableView:(NSTableView*)table_view objectValueForTableColumn:(nullable NSTableColumn*)table_column row:(NSInteger)the_row;
-- (nullable NSView*) tableView:(NSTableView*)table_view viewForTableColumn:(NSTableColumn*)table_column row:(NSInteger)the_row;
+  if (backgroundStyle == NSBackgroundStyleNormal)
+  {
+    if (self.customBackgroundColor)
+    {
+      self.layer.backgroundColor = [self.customBackgroundColor CGColor];
+    }
+    else
+    {
+      self.layer.backgroundColor = [[NSColor clearColor] CGColor];
+    }
 
+    if (self.customTextColor)
+    {
+      [self.textField setTextColor:self.customTextColor];
+    }
+    else
+    {
+      [self.textField setTextColor:[NSColor controlTextColor]];
+    }
+  }
+  else
+  {
+    self.layer.backgroundColor = [[NSColor clearColor] CGColor]; /* Use system selection color */
+    [self.textField setTextColor:[NSColor selectedControlTextColor]];
+  }
+}
 
-// NSTableViewDelegate
+- (void) updateLayoutWithPadding:(CGFloat)padding showImage:(BOOL)showImage
+{
+  NSMutableArray* constraintsToRemove = [NSMutableArray array];
+  for (NSLayoutConstraint* constraint in [self constraints])
+  {
+    if (constraint.firstItem == self.imageView || constraint.secondItem == self.imageView ||
+        constraint.firstItem == [self textField] || constraint.secondItem == [self textField])
+    {
+      [constraintsToRemove addObject:constraint];
+    }
+  }
+  [self removeConstraints:constraintsToRemove];
 
-- (void) tableViewSelectionDidChange:(NSNotification*)the_notification;
+  NSDictionary* views = @{@"imageView": self.imageView, @"textField": [self textField]};
+  NSDictionary* metrics = @{@"padding": @(padding)};
 
+  if (showImage && ![self.imageView isHidden])
+  {
+    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-padding-[imageView(16)]-4-[textField]-padding-|"
+                 options:NSLayoutFormatAlignAllCenterY
+                 metrics:metrics
+                   views:views]];
+
+    [self addConstraint:[NSLayoutConstraint constraintWithItem:self.imageView
+              attribute:NSLayoutAttributeCenterY
+              relatedBy:NSLayoutRelationEqual
+                 toItem:self
+              attribute:NSLayoutAttributeCenterY
+             multiplier:1.0
+               constant:0.0]];
+
+    [self addConstraint:[NSLayoutConstraint constraintWithItem:self.imageView
+              attribute:NSLayoutAttributeHeight
+              relatedBy:NSLayoutRelationEqual
+                 toItem:nil
+              attribute:NSLayoutAttributeNotAnAttribute
+             multiplier:1.0
+               constant:16.0]];
+  }
+  else
+  {
+    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-padding-[textField]-padding-|"
+                 options:0
+                 metrics:metrics
+                   views:views]];
+  }
+
+  [self addConstraint:[NSLayoutConstraint constraintWithItem:[self textField]
+            attribute:NSLayoutAttributeCenterY
+            relatedBy:NSLayoutRelationEqual
+               toItem:self
+            attribute:NSLayoutAttributeCenterY
+           multiplier:1.0
+             constant:0.0]];
+}
 @end
 
 @implementation IupCocoaListTableViewReceiver
 
+@synthesize dataArray;
+
 - (instancetype) init
 {
-	self = [super init];
-	if(self)
-	{
-		dataArray = [[NSMutableArray alloc] init];
-	}
-	return self;
+  self = [super init];
+  if (self)
+  {
+    dataArray = [[NSMutableArray alloc] init];
+  }
+  return self;
 }
 
 - (void) dealloc
 {
-	[dataArray release];
-	[super dealloc];
+  [dataArray release];
+  [super dealloc];
 }
 
-- (NSMutableArray*) dataArray
+- (NSInteger) numberOfRowsInTableView:(NSTableView*)table_view
 {
-	return dataArray;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  /* Virtual mode: return item_count from ih->data */
+  if (ih && ih->data && ih->data->is_virtual)
+    return ih->data->item_count;
+
+  return [dataArray count];
 }
 
+- (NSView*) tableView:(NSTableView*)table_view viewForTableColumn:(NSTableColumn*)table_column row:(NSInteger)the_row
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY);
 
-- (NSInteger) numberOfRowsInTableView:(NSTableView*)table_view
+  NSString* string_item = nil;
+  NSImage* image_item = nil;
+
+  /* Virtual mode: fetch from VALUE_CB and IMAGE_CB */
+  if (ih && ih->data && ih->data->is_virtual)
+  {
+    if (the_row < 0 || the_row >= ih->data->item_count)
+      return nil;
+
+    char* text = iupListGetItemValueCb(ih, (int)the_row + 1);  /* 1-based */
+    string_item = [NSString stringWithUTF8String:(text ? text : "")];
+
+    /* Query IMAGE_CB for the image if SHOWIMAGE is enabled */
+    if (ih->data->show_image)
+    {
+      char* image_name = iupListGetItemImageCb(ih, (int)the_row + 1);  /* 1-based */
+      if (image_name)
+      {
+        void* handle = iupImageGetImage(image_name, ih, 0, NULL);
+        if (handle)
+          image_item = (NSImage*)handle;
+      }
+    }
+  }
+  else
+  {
+    if (the_row < 0 || the_row >= [dataArray count])
+      return nil;
+
+    NSDictionary* item_data = [dataArray objectAtIndex:the_row];
+    string_item = [item_data objectForKey:@"text"];
+    image_item = [item_data objectForKey:@"image"];
+    if (image_item == (id)[NSNull null])
+      image_item = nil;
+  }
+
+  IupCocoaListTableCellView* cell_view = [table_view makeViewWithIdentifier:@"IupCocoaListTableCellView" owner:self];
+
+  if (nil == cell_view)
+  {
+    cell_view = [[[IupCocoaListTableCellView alloc] initWithFrame:NSZeroRect] autorelease];
+    [cell_view setIdentifier:@"IupCocoaListTableCellView"];
+    [cell_view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+  }
+
+  [cell_view setCustomBackgroundColor:nil];
+  [cell_view setCustomTextColor:nil];
+
+  NSFont* font = nil;
+  if (ih)
+  {
+    font = (NSFont*)cocoaGetNativeFont(ih);
+
+    unsigned char r, g, b;
+    char* color_str = iupAttribGet(ih, "BGCOLOR");
+    if(iupStrToRGB(color_str, &r, &g, &b))
+    {
+      [cell_view setCustomBackgroundColor:[NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0]];
+    }
+
+    color_str = iupAttribGet(ih, "FGCOLOR");
+    if(iupStrToRGB(color_str, &r, &g, &b))
+    {
+      [cell_view setCustomTextColor:[NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0]];
+    }
+  }
+  if (!font)
+  {
+    const char* default_font = IupGetGlobal("DEFAULTFONT");
+    IupCocoaFont* iup_font = iupcocoaFindFont(default_font);
+    font = iup_font ? [iup_font nativeFont] : nil;
+  }
+  if (font)
+  {
+    [[cell_view textField] setFont:font];
+  }
+
+  [[cell_view textField] setStringValue:string_item];
+
+  if (ih && ih->data->show_image && image_item)
+  {
+    /* Set scaling mode based on FITIMAGE attribute */
+    if (ih->data->fit_image)
+      [[cell_view imageView] setImageScaling:NSImageScaleProportionallyDown];
+    else
+      [[cell_view imageView] setImageScaling:NSImageScaleNone];
+
+    [[cell_view imageView] setImage:image_item];
+    [[cell_view imageView] setHidden:NO];
+  }
+  else
+  {
+    [[cell_view imageView] setImage:nil];
+    [[cell_view imageView] setHidden:YES];
+  }
+
+  CGFloat padding = kIupCocoaListDefaultPadding;
+  if (ih && ih->data && ih->data->spacing > 0)
+  {
+    padding = (CGFloat)ih->data->spacing;
+  }
+
+  [cell_view updateLayoutWithPadding:padding showImage:(ih && ih->data->show_image && image_item != nil)];
+
+  return cell_view;
+}
+
+- (CGFloat) tableView:(NSTableView*)table_view heightOfRow:(NSInteger)row
 {
-	IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-	NSMutableArray* data_array = [list_receiver dataArray];
-	
-	return [data_array count];
-	
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  CGFloat row_height;
+  NSFont* font = nil;
+  if (ih)
+    font = cocoaGetNativeFont(ih);
+  if (!font)
+  {
+    const char* default_font = IupGetGlobal("DEFAULTFONT");
+    IupCocoaFont* iup_font = iupcocoaFindFont(default_font);
+    font = iup_font ? [iup_font nativeFont] : [NSFont systemFontOfSize:13];
+  }
+
+  int char_width, char_height;
+  if (ih)
+    iupdrvFontGetCharSize(ih, &char_width, &char_height);
+  else
+    char_height = 16;
+
+  row_height = (CGFloat)char_height;
+
+  int item_space = 0;
+  iupdrvListAddItemSpace(ih, &item_space);
+  row_height += (CGFloat)item_space;
+
+  if (ih && ih->data && ih->data->spacing > 0)
+    row_height += (CGFloat)(ih->data->spacing * 2);
+
+  if (ih && ih->data && ih->data->show_image)
+  {
+    if (row >= 0 && row < [dataArray count])
+    {
+      NSDictionary* item_data = [dataArray objectAtIndex:row];
+      NSImage* image = [item_data objectForKey:@"image"];
+      if (image && image != (id)[NSNull null])
+      {
+        NSSize imageSize = [image size];
+        CGFloat padding = (ih->data->spacing > 0) ? (CGFloat)(ih->data->spacing * 2) : 0;
+        if (imageSize.height + padding > row_height)
+          row_height = imageSize.height + padding;
+      }
+    }
+  }
+
+  return row_height;
 }
 
+- (void) tableViewSelectionDidChange:(NSNotification*)the_notification
+{
+  NSTableView* table_view = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
-- (nullable NSView*) tableView:(NSTableView*)table_view viewForTableColumn:(NSTableColumn*)table_column row:(NSInteger)the_row
+  if (iupAttribGet(ih, "_IUPLIST_IGNORE_ACTION"))
+    return;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    NSInteger selected_row = [table_view selectedRow];
+    if (selected_row >= 0)
+    {
+      if (selected_row < [dataArray count])
+      {
+        NSDictionary* item_data = [dataArray objectAtIndex:selected_row];
+        NSString* selected_text = [item_data objectForKey:@"text"];
+
+        NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        if (text_field)
+        {
+          [text_field setStringValue:selected_text];
+        }
+      }
+    }
+
+    IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
+    if (cb)
+    {
+      NSInteger index_of_selected_item = [table_view selectedRow];
+      int adjusted_index = (int)(index_of_selected_item+1);
+      iupListSingleCallActionCb(ih, cb, adjusted_index);
+    }
+    iupBaseCallValueChangedCb(ih);
+  }
+  else if (sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST)
+  {
+    IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
+    if (cb)
+    {
+      NSInteger index_of_selected_item = [table_view selectedRow];
+      int adjusted_index = (int)(index_of_selected_item+1);
+      iupListSingleCallActionCb(ih, cb, adjusted_index);
+    }
+    iupBaseCallValueChangedCb(ih);
+  }
+  else if (sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST)
+  {
+    IFns multi_cb = (IFns)IupGetCallback(ih, "MULTISELECT_CB");
+    IFnsii cb = (IFnsii) IupGetCallback(ih, "ACTION");
+    if (multi_cb || cb)
+    {
+      NSIndexSet* selected_indexes = [table_view selectedRowIndexes];
+      NSUInteger count = [selected_indexes count];
+
+      if (count == 0)
+      {
+        iupListMultipleCallActionCb(ih, cb, multi_cb, NULL, 0);
+      }
+      else
+      {
+        int* pos = malloc(sizeof(int)*count);
+        if (pos)
+        {
+          NSUInteger idx = [selected_indexes firstIndex];
+          int i = 0;
+          while (idx != NSNotFound)
+          {
+            pos[i] = (int)idx;
+            idx = [selected_indexes indexGreaterThanIndex:idx];
+            i++;
+          }
+          iupListMultipleCallActionCb(ih, cb, multi_cb, pos, (int)count);
+          free(pos);
+        }
+      }
+    }
+    iupBaseCallValueChangedCb(ih);
+  }
+}
+
+- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(NSInteger)row
 {
-	IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-	NSMutableArray* data_array = [list_receiver dataArray];
-	
-	NSString* string_item = [data_array objectAtIndex:the_row];
-	
-	
-	
-	// Get an existing cell with the MyView identifier if it exists
-    NSTextField* the_result = [table_view makeViewWithIdentifier:@"IupCocoaListTableViewCell" owner:self];
- 
-    // There is no existing cell to reuse so create a new one
-    if(nil == the_result)
-	{
- 
-		// Create the new NSTextField with a frame of the {0,0} with the width of the table.
-		// Note that the height of the frame is not really relevant, because the row height will modify the height.
-//		the_result = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, kIupCocoaDefaultWidthNSPopUpButton, kIupCocoaDefaultHeightNSPopUpButton)];
-		the_result = [[NSTextField alloc] initWithFrame:NSZeroRect];
-		[the_result setBezeled:NO];
-		[the_result setDrawsBackground:NO];
-		[the_result setEditable:NO];
-		//			[the_label setSelectable:NO];
-		// TODO: FEATURE: I think this is really convenient for users
-		[the_result setSelectable:YES];
-		
-		// The identifier of the NSTextField instance is set to MyView.
-		// This allows the cell to be reused.
-		[the_result setIdentifier:@"IupCocoaListTableViewCell"];
-		[the_result setFont:[NSFont systemFontOfSize:0.0]];
-	}
- 
-	// result is now guaranteed to be valid, either as a reused cell
-	// or as a new cell, so set the stringValue of the cell to the
-	// nameArray value at row
-	[the_result setStringValue:string_item];
- 
-	// Return the result
-	return the_result;
- 
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(tableView, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    NSWindow* window = [tableView window];
+    if (window && [window firstResponder] != tableView)
+    {
+      [window makeFirstResponder:tableView];
+    }
+  }
+  return YES;
+}
 
-	
-	
-	
+/* Drag Source */
+- (id<NSPasteboardWriting>)tableView:(NSTableView *)tableView pasteboardWriterForRow:(NSInteger)row
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(tableView, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return nil;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  BOOL enable_internal_dnd = ih->data->show_dragdrop && (sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST);
+  BOOL enable_crosslist_dnd = iupAttribGetBoolean(ih, "DRAGDROPLIST");
+
+  if (!enable_internal_dnd && !enable_crosslist_dnd)
+    return nil;
+
+  NSPasteboardItem *pboardItem = [[[NSPasteboardItem alloc] init] autorelease];
+
+  if (enable_internal_dnd)
+  {
+    NSString *rowIndexStr = [NSString stringWithFormat:@"%ld", (long)row];
+    [pboardItem setString:rowIndexStr forType:IupListPasteboardType];
+  }
+
+  if (enable_crosslist_dnd)
+  {
+    int pos = (int)row + 1;
+
+    if (ih->data->is_multiple)
+    {
+      char *buffer = cocoaListGetValueAttrib(ih);
+      int count = iupdrvListGetCount(ih);
+
+      if (buffer && row >= 0 && row < count)
+      {
+        size_t buffer_len = strlen(buffer);
+        if (row < (NSInteger)buffer_len && buffer[row] == '-')
+        {
+          iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+          [tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:row] byExtendingSelection:NO];
+
+          char* new_value = malloc(count + 1);
+          if (new_value)
+          {
+            memset(new_value, '-', count);
+            new_value[row] = '+';
+            new_value[count] = '\0';
+            iupAttribSetStr(ih, "_IUPLIST_OLDVALUE", new_value);
+            free(new_value);
+          }
+          iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+        }
+      }
+    }
+    else
+    {
+      if ([tableView selectedRow] != row)
+      {
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        [tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:row] byExtendingSelection:NO];
+        iupAttribSetInt(ih, "_IUPLIST_OLDVALUE", pos);
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+      }
+    }
+
+    NSData *handleData = [NSData dataWithBytes:&ih length:sizeof(Ihandle*)];
+    [pboardItem setData:handleData forType:IupInternalDndType];
+  }
+
+  if ([[pboardItem types] count] == 0)
+    return nil;
+
+  return pboardItem;
 }
 
+/* Drop Target - VALIDATION */
+- (NSDragOperation)tableView:(NSTableView *)tableView validateDrop:(id <NSDraggingInfo>)info proposedRow:(NSInteger)row proposedDropOperation:(NSTableViewDropOperation)dropOperation
+{
+  if (dropOperation != NSTableViewDropAbove)
+    return NSDragOperationNone;
 
-- (void) tableViewSelectionDidChange:(NSNotification*)the_notification
+  NSPasteboard *pboard = [info draggingPasteboard];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(tableView, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih)
+    return NSDragOperationNone;
+
+  NSEventModifierFlags flags = [NSEvent modifierFlags];
+  int is_shift = (flags & NSEventModifierFlagShift) != 0;
+  int is_copy = (flags & NSEventModifierFlagOption) != 0;
+
+  if ([[pboard types] containsObject:IupListPasteboardType])
+  {
+    if ([info draggingSource] != tableView)
+      return NSDragOperationNone;
+
+    NSString *rowIndexStr = [pboard stringForType:IupListPasteboardType];
+    if (!rowIndexStr) return NSDragOperationNone;
+
+    NSInteger sourceRow = -1;
+    if (![[NSScanner scannerWithString:rowIndexStr] scanInteger:&sourceRow])
+      return NSDragOperationNone;
+
+    if (sourceRow == row || sourceRow + 1 == row)
+      return NSDragOperationNone;
+
+    IFniiii cb = (IFniiii)IupGetCallback(ih, "DRAGDROP_CB");
+    if (cb)
+    {
+      if (cb(ih, (int)sourceRow + 1, (int)row + 1, is_shift, is_copy) == IUP_IGNORE)
+        return NSDragOperationNone;
+    }
+
+    [tableView setDropRow:row dropOperation:NSTableViewDropAbove];
+    return is_copy ? NSDragOperationCopy : NSDragOperationMove;
+  }
+
+  if ([[pboard types] containsObject:IupInternalDndType])
+  {
+    NSData *handleData = [pboard dataForType:IupInternalDndType];
+    if (!handleData || [handleData length] != sizeof(Ihandle*))
+      return NSDragOperationNone;
+
+    Ihandle* ih_source;
+    memcpy(&ih_source, [handleData bytes], sizeof(Ihandle*));
+
+    if (!iupObjectCheck(ih_source) || (!IupClassMatch(ih_source, "list") && !IupClassMatch(ih_source, "flatlist")))
+      return NSDragOperationNone;
+
+    [tableView setDropRow:row dropOperation:NSTableViewDropAbove];
+
+    BOOL source_wants_move = iupAttribGetBoolean(ih_source, "DRAGSOURCEMOVE");
+
+    if (is_copy || !source_wants_move)
+      return NSDragOperationCopy;
+    else
+      return NSDragOperationMove;
+  }
+
+  return NSDragOperationNone;
+}
+
+/* Drop Target - ACCEPTANCE */
+- (BOOL)tableView:(NSTableView *)tableView acceptDrop:(id <NSDraggingInfo>)info row:(NSInteger)row dropOperation:(NSTableViewDropOperation)dropOperation
 {
-	NSTableView* table_view = [the_notification object];
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY);
-	
-	IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
-	if(cb)
-	{
-		
-		
-		NSInteger index_of_selected_item = [table_view selectedRow];
-		int adjusted_index = (int)(index_of_selected_item+1); /* IUP starts at 1 */
-		iupListSingleCallActionCb(ih, cb, adjusted_index);
-		
-	}
-	
-	
-	/*
-	 if (!ih->data->has_editbox)
-	 {
-		iupBaseCallValueChangedCb(ih);
-	 }
-	 
-	 */
-	
-	
+  NSPasteboard *pboard = [info draggingPasteboard];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(tableView, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return NO;
+
+  NSEventModifierFlags flags = [NSEvent modifierFlags];
+  int is_shift = (flags & NSEventModifierFlagShift) != 0;
+  int is_copy = (flags & NSEventModifierFlagOption) != 0;
+
+  if ([[pboard types] containsObject:IupListPasteboardType])
+  {
+    NSString *rowIndexStr = [pboard stringForType:IupListPasteboardType];
+    if (!rowIndexStr) return NO;
+
+    NSInteger sourceRow = -1;
+    if (![[NSScanner scannerWithString:rowIndexStr] scanInteger:&sourceRow])
+      return NO;
+
+    IFniiii cb = (IFniiii)IupGetCallback(ih, "DRAGDROP_CB");
+    if (cb && cb(ih, (int)sourceRow + 1, (int)row + 1, is_shift, is_copy) == IUP_IGNORE)
+      return NO;
+
+    if (sourceRow < 0 || sourceRow >= [self.dataArray count])
+      return NO;
+
+    NSDictionary* sourceItem = [self.dataArray objectAtIndex:sourceRow];
+    NSString* text = [sourceItem objectForKey:@"text"];
+    NSImage* image = [sourceItem objectForKey:@"image"];
+    if (image == (id)[NSNull null]) image = nil;
+
+    iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+
+    if (is_copy)
+    {
+      iupdrvListInsertItem(ih, (int)row, [text UTF8String]);
+      if (image)
+        iupdrvListSetImageHandle(ih, (int)row + 1, image);
+    }
+    else
+    {
+      NSInteger targetRow = row;
+      if (sourceRow < targetRow)
+        targetRow--;
+
+      iupdrvListRemoveItem(ih, (int)sourceRow);
+      iupdrvListInsertItem(ih, (int)targetRow, [text UTF8String]);
+      if (image)
+        iupdrvListSetImageHandle(ih, (int)targetRow + 1, image);
+    }
+
+    NSInteger finalRow = row;
+    if (!is_copy && sourceRow < row)
+      finalRow--;
+
+    if (finalRow >= 0 && finalRow < [tableView numberOfRows])
+    {
+      [tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:finalRow] byExtendingSelection:NO];
+      [tableView scrollRowToVisible:finalRow];
+      iupAttribSetInt(ih, "_IUPLIST_OLDVALUE", (int)finalRow + 1);
+    }
+
+    iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+    return YES;
+  }
+
+  if ([[pboard types] containsObject:IupInternalDndType])
+  {
+    NSData *handleData = [pboard dataForType:IupInternalDndType];
+    if (!handleData || [handleData length] != sizeof(Ihandle*))
+      return NO;
+
+    Ihandle* ih_source;
+    memcpy(&ih_source, [handleData bytes], sizeof(Ihandle*));
+
+    if (!iupObjectCheck(ih_source) || (!IupClassMatch(ih_source, "list") && !IupClassMatch(ih_source, "flatlist")))
+      return NO;
+
+    BOOL is_move = IupGetInt(ih_source, "DRAGSOURCEMOVE") && !is_copy;
+
+    iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+    iupAttribSet(ih_source, "_IUPLIST_IGNORE_ACTION", "1");
+
+    int drop_pos = (int)row;
+
+    if (IupGetInt(ih_source, "MULTIPLE"))
+    {
+      char *value_buffer = IupGetAttribute(ih_source, "VALUE");
+      int count = iupdrvListGetCount(ih_source);
+
+      if (value_buffer && count > 0)
+      {
+        int* items_to_remove = is_move ? malloc(count * sizeof(int)) : NULL;
+        int remove_count = 0;
+
+        for (int i = 0; i < count; i++)
+        {
+          if (i < (int)strlen(value_buffer) && value_buffer[i] == '+')
+          {
+            int src_pos_1based = i + 1;
+            const char* item_text = IupGetAttributeId(ih_source, "", src_pos_1based);
+            void* hImage = iupdrvListGetImageHandle(ih_source, src_pos_1based);
+
+            if (item_text)
+            {
+              iupdrvListInsertItem(ih, drop_pos, item_text);
+              if (hImage && hImage != (void*)[NSNull null])
+                iupdrvListSetImageHandle(ih, drop_pos + 1, hImage);
+
+              drop_pos++;
+
+              if (is_move && items_to_remove)
+                items_to_remove[remove_count++] = src_pos_1based;
+            }
+          }
+        }
+
+        if (is_move && items_to_remove)
+        {
+          for (int i = remove_count - 1; i >= 0; i--)
+            IupSetInt(ih_source, "REMOVEITEM", items_to_remove[i]);
+
+          free(items_to_remove);
+        }
+      }
+    }
+    else
+    {
+      int src_pos_1based = IupGetInt(ih_source, "VALUE");
+      if (src_pos_1based > 0)
+      {
+        const char* item_text = IupGetAttributeId(ih_source, "", src_pos_1based);
+        void* hImage = iupdrvListGetImageHandle(ih_source, src_pos_1based);
+
+        if (item_text)
+        {
+          iupdrvListInsertItem(ih, drop_pos, item_text);
+          if (hImage && hImage != (void*)[NSNull null])
+            iupdrvListSetImageHandle(ih, drop_pos + 1, hImage);
+
+          if (is_move)
+            IupSetInt(ih_source, "REMOVEITEM", src_pos_1based);
+        }
+      }
+    }
+
+    iupAttribSet(ih_source, "_IUPLIST_IGNORE_ACTION", NULL);
+    iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+
+    return YES;
+  }
+
+  return NO;
 }
 
-@end
+- (void)tableView:(NSTableView *)tableView draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint forRowIndexes:(NSIndexSet *)rowIndexes
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(tableView, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
+  NSUInteger sourceRow = [rowIndexes firstIndex];
+  if (sourceRow != NSNotFound)
+  {
+    iupAttribSetInt(ih, "_IUPLIST_DRAGITEM", (int)sourceRow + 1);
+  }
+}
 
-void iupdrvListAddItemSpace(Ihandle* ih, int* h)
+- (void)tableView:(NSTableView *)tableView draggingSession:(NSDraggingSession *)session endedAtPoint:(NSPoint)screenPoint operation:(NSDragOperation)operation
 {
-//	*h += 2;
-	
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			break;
-			
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			break;
-			
-		}
-			
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(tableView, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih) return;
 
+  iupAttribSet(ih, "_IUPLIST_DRAGITEM", NULL);
 }
 
-void iupdrvListAddBorders(Ihandle* ih, int *x, int *y)
+@end
+
+static void cocoaListSortItems(Ihandle* ih)
 {
-//	NSLog(@"iupdrvListAddBorders <%d, %d>", *x, *y);
-#if 0
-  int border_size = 2*10;
-  (*x) += border_size;
-  (*y) += border_size;
+  if (!iupAttribGet(ih, "_IUPLIST_SORT_ENABLED"))
+    return;
 
-  if (ih->data->is_dropdown)
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
   {
-    (*x) += 5; /* extra space for the dropdown button */
+    NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+    NSMenu* menu = [popup_button menu];
+    NSArray* items = [[menu itemArray] sortedArrayUsingComparator:^NSComparisonResult(NSMenuItem* item1, NSMenuItem* item2) {
+      return [[item1 title] localizedCaseInsensitiveCompare:[item2 title]];
+    }];
 
-    if (ih->data->has_editbox)
-	{
-      (*x) += 5; /* another extra space for the dropdown button */
-		(*y) += 7; /* extra padding space */
-	}
-    else
+    for (NSInteger i = [menu numberOfItems] - 1; i >= 0; i--)
     {
-      (*y) += 4; /* extra padding space */
-      (*x) += 4; /* extra padding space */
+      [menu removeItemAtIndex:i];
     }
+
+    for (NSMenuItem* item in items)
+    {
+      [menu addItem:item];
+    }
   }
-  else
+  else if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
   {
-    if (ih->data->is_multiple)
-	{
-		(*x) += 2*80; /* internal border between editbox and list */
+    NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+    NSInteger count = [combo_box numberOfItems];
+    NSMutableArray* items = [NSMutableArray arrayWithCapacity:count];
 
-      (*y) += 2*40; /* internal border between editbox and list */
-		
-		(*x) = 200;
-		(*y) = 200;
-	}
+    for (NSInteger i = 0; i < count; i++)
+    {
+      id obj = [combo_box itemObjectValueAtIndex:i];
+      [items addObject:obj];
+    }
+
+    [items sortUsingComparator:^NSComparisonResult(id obj1, id obj2) {
+      NSString* str1 = [obj1 isKindOfClass:[NSString class]] ? (NSString*)obj1 : [obj1 stringValue];
+      NSString* str2 = [obj2 isKindOfClass:[NSString class]] ? (NSString*)obj2 : [obj2 stringValue];
+      return [str1 localizedCaseInsensitiveCompare:str2];
+    }];
+
+    [combo_box removeAllItems];
+    for (id obj in items)
+    {
+      [combo_box addItemWithObjectValue:obj];
+    }
   }
-#else
-	// WARNING: I discovered this can be called before Map, hence we have no nativehandle. Thus cocoaListGetBaseWidget will return nil.
-	
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-//			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			// Heights are fixed in Interface Builder. You generally aren't supposed to mess with the widget heights or font sizes.
-			if(*y < (int)kIupCocoaDefaultHeightNSPopUpButton)
-			{
-				*y = (int)kIupCocoaDefaultHeightNSPopUpButton;
-			}
-			*x += 4; // a regular label seems to get 2 padding on each size
-			*x += 33; // the difference between a label and popup is 33 in Interface Builder
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-//			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			// Heights are fixed in Interface Builder. You generally aren't supposed to mess with the widget heights or font sizes.
-			if(*y < (int)kIupCocoaDefaultHeightNSComboBox)
-			{
-				*y = (int)kIupCocoaDefaultHeightNSComboBox;
-			}
-			*x += 4; // a regular label seems to get 2 padding on each size
-			*x += 24; // the difference between a label and combobox is 24 in Interface Builder
-			break;
-			
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			// FIXME: cocoaListGetBaseWidget might return nil. Could using NIBs help get us a valie tablie view to get rowHeight and other things?
-			
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			
+  else if (sub_type >= IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+    if (list_receiver)
+    {
+      NSMutableArray* data_array = [list_receiver dataArray];
+      [data_array sortUsingComparator:^NSComparisonResult(NSDictionary* dict1, NSDictionary* dict2) {
+        NSString* str1 = [dict1 objectForKey:@"text"];
+        NSString* str2 = [dict2 objectForKey:@"text"];
+        return [str1 localizedCaseInsensitiveCompare:str2];
+      }];
+      [table_view reloadData];
+    }
+  }
+}
 
-			// rectOfRow would tell us the height of a specific row
-			// The actual -rectOfRow: is equal to the -rowHeight plus the intercellSpacing.height. The default value is 17.0 for applications linked on 10.5 and higher (the height acceptable for [NSFont systemFontSize]). The default value is 16.0 for 10.4 and lower.
-			
-			// I don't know which row we're at, but we'll assume they are all the same height.
-			// rectOfRow is not helpful if the table is empty, so use intercellSpacing.height+rowHeight
-			CGFloat row_height = [table_view rowHeight] + [table_view intercellSpacing].height;
-			
-			
-			int visible_lines = 0; // 5 is the default according to the docs
-			if(iupAttribGet(ih, "VISIBLELINES"))
-			{
-				visible_lines = iupAttribGetInt(ih, "VISIBLELINES");
-			}
-			else
-			{
-				visible_lines = (int)[table_view numberOfRows];
-			}
-			
-			// Note: Don't add any extra padding here or the table will get clipped.
-			CGFloat view_height = row_height * (CGFloat)visible_lines;
-			
-			*y = iupROUND(view_height);
-			
-			
-			*x += 4; // a regular label seems to get 2 padding on each size
-			*x += 17; // the difference between a label and table is 17 in Interface Builder
-			
-			break;
-			
-		}
-			
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-#endif
-	
+void iupdrvListAddItemSpace(Ihandle* ih, int* h)
+{
+  (void)ih;
+  *h += 2;
 }
 
+void iupdrvListAddBorders(Ihandle* ih, int *x, int *y)
+{
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        static int popup_decor_w = -1;
+        static int popup_decor_h = -1;
+
+        if (popup_decor_w == -1)
+        {
+          /* Measure NSPopUpButton decorations dynamically */
+          NSPopUpButton* tempButton = [[NSPopUpButton alloc] initWithFrame:NSZeroRect pullsDown:NO];
+          NSFont* font = cocoaGetNativeFont(ih);
+          if (font)
+            [tempButton setFont:font];
+
+          /* Add a test item to measure with content */
+          [tempButton addItemWithTitle:@"WWWWWWWWWW"];
+
+          NSSize intrinsic_size = [tempButton intrinsicContentSize];
+          popup_decor_h = (int)lroundf(intrinsic_size.height);
+
+          /* Measure the width decoration: intrinsic width for "WWWWWWWWWW" minus text width */
+          int text_width = iupdrvFontGetStringWidth(ih, "WWWWWWWWWW");
+          popup_decor_w = (int)lroundf(intrinsic_size.width) - text_width;
+
+          [tempButton release];
+        }
+
+        if (*y < popup_decor_h)
+          *y = popup_decor_h;
+
+        *x += popup_decor_w;
+
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        static int combo_decor_w = -1;
+        static int combo_decor_h = -1;
+
+        if (combo_decor_w == -1)
+        {
+          /* Measure NSComboBox decorations dynamically */
+          NSComboBox* tempComboBox = [[NSComboBox alloc] initWithFrame:NSZeroRect];
+          NSFont* font = cocoaGetNativeFont(ih);
+          if (font)
+            [tempComboBox setFont:font];
+
+          /* Set test string value to measure with content */
+          [tempComboBox setStringValue:@"WWWWWWWWWW"];
+
+          NSSize intrinsic_size = [tempComboBox intrinsicContentSize];
+          combo_decor_h = (int)lroundf(intrinsic_size.height);
+
+          /* Measure the width decoration: intrinsic width minus text width */
+          int text_width = iupdrvFontGetStringWidth(ih, "WWWWWWWWWW");
+          combo_decor_w = (int)lroundf(intrinsic_size.width) - text_width;
+
+          [tempComboBox release];
+        }
+
+        if (*y < combo_decor_h)
+          *y = combo_decor_h;
+
+        *x += combo_decor_w;
+
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        /* Measure NSScrollView borders dynamically.
+         * We measure the actual border by comparing widget size with content size. */
+        static int cocoa_scroll_border_x = -1;
+        static int cocoa_scroll_border_y = -1;
+
+        if (cocoa_scroll_border_x == -1)
+        {
+          /* Create temporary scroll view to measure borders */
+          NSScrollView* temp_scroll = [[NSScrollView alloc] initWithFrame:NSMakeRect(0, 0, 200, 100)];
+          [temp_scroll setBorderType:NSBezelBorder];
+          [temp_scroll setHasVerticalScroller:NO];
+          [temp_scroll setHasHorizontalScroller:NO];
+
+          NSRect frame_rect = [temp_scroll frame];
+          NSSize content_size = [temp_scroll contentSize];
+
+          cocoa_scroll_border_x = (int)lroundf(frame_rect.size.width - content_size.width);
+          cocoa_scroll_border_y = (int)lroundf(frame_rect.size.height - content_size.height);
+
+          [temp_scroll release];
+        }
+
+        /* Add measured borders */
+        *x += cocoa_scroll_border_x;
+        *y += cocoa_scroll_border_y;
+
+        /* In Cocoa, scrollbars overlay the content (unlike GTK/Windows where they add to width). */
+        if (ih->data->sb)
+        {
+          int sb_size = iupdrvGetScrollbarSize();
+          *x += sb_size;
+        }
+
+        if (ih->data->has_editbox)
+        {
+          int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+
+          if (visiblelines > 0)
+          {
+            /* For EDITBOX with VISIBLELINES: VISIBLELINES includes the entry line.
+             * We need to subtract the content of (visiblelines-1) items and add back the text entry height instead. */
+            int char_width, char_height;
+            iupdrvFontGetCharSize(ih, &char_width, &char_height);
+            int item_height = char_height;
+            iupdrvListAddItemSpace(ih, &item_height);
+
+            /* Subtract one item height (since visiblelines includes the entry) */
+            *y -= item_height;
+
+            /* Add text entry natural height (measured from NSTextField) */
+            NSTextField* temp_text = [[NSTextField alloc] initWithFrame:NSZeroRect];
+            NSSize text_intrinsic = [temp_text intrinsicContentSize];
+            int text_height = (int)lroundf(text_intrinsic.height);
+            [temp_text release];
+
+            *y += text_height;
+          }
+
+          /* Add NSStackView spacing (3px between text and list) */
+          *y += 2*3;
+        }
+
+        break;
+      }
+    default:
+      break;
+  }
+}
+
 int iupdrvListGetCount(Ihandle* ih)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			NSInteger number_of_items = [[popup_button menu] numberOfItems];
-			return (int)number_of_items;
-			
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			NSInteger number_of_items = [combo_box numberOfItems];
-			return (int)number_of_items;
-			
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			NSInteger number_of_items = [table_view numberOfRows];
-			return (int)number_of_items;
-			
-		}
+  if (ih->handle)
+  {
+    IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+    switch(sub_type)
+    {
+      case IUPCOCOALISTSUBTYPE_DROPDOWN:
+        {
+          NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+          NSInteger number_of_items = [[popup_button menu] numberOfItems];
+          return (int)number_of_items;
+        }
+      case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+        {
+          NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+          NSInteger number_of_items = [combo_box numberOfItems];
+          return (int)number_of_items;
+        }
+      case IUPCOCOALISTSUBTYPE_EDITBOX:
+      case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+      case IUPCOCOALISTSUBTYPE_SINGLELIST:
+        {
+          if (ih->data->is_virtual)
+            return ih->data->item_count;
 
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	return 0;
+          NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+          if (!table_view)
+          {
+            return 0;
+          }
 
-	
+          /* Query the data model directly to ensure the count is always accurate, */
+          /* avoiding potential timing issues with NSTableView's numberOfRows property after a reload. */
+          IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+          if (list_receiver)
+          {
+            return (int)[[list_receiver dataArray] count];
+          }
+
+          return 0;
+        }
+       default:
+        break;
+    }
+    return 0;
+  }
+  else
+  {
+    int count = 0;
+    while(iupAttribGetId(ih, "", count+1))
+    {
+      count++;
+    }
+    return count;
+  }
 }
 
 void iupdrvListAppendItem(Ihandle* ih, const char* value)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			[[popup_button menu] addItemWithTitle:ns_string action:nil keyEquivalent:@""];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			[combo_box addItemWithObjectValue:ns_string];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-			NSMutableArray* data_array = [list_receiver dataArray];
-			
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			[data_array addObject:ns_string];
-	
-#if 0
-			// reloadData will do the job, but may lose user's currently selected items
-			// reloadDataForRowIndexes might be better and more optimized,
-			// however, I don't know how IUP's SORT feature interacts with everything. (Append may no longer be put in the last row. (and not to mention that I haven't actually figured out how to make it work.)
-			[table_view reloadData];
-#else
-			NSUInteger data_count = [data_array count];
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:data_count-1];
-			[table_view insertRowsAtIndexes:index_set withAnimation:NSTableViewAnimationEffectNone];
-			
-//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndex:data_count-1] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
-//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, data_count)] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
 
+  if (!value)
+    value = "";
 
+  NSString* ns_string = [NSString stringWithUTF8String:value];
 
-#endif
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+        if (!popup_button) return;
+        NSMenu* menu = [popup_button menu];
 
-	
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        [menu addItemWithTitle:ns_string action:nil keyEquivalent:@""];
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+
+        if (iupAttribGet(ih, "_IUPLIST_SORT_ENABLED"))
+          cocoaListSortItems(ih);
+
+        cocoaListUpdateDropExpand(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        if (!combo_box) return;
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        [combo_box addItemWithObjectValue:ns_string];
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+
+        if (iupAttribGet(ih, "_IUPLIST_SORT_ENABLED"))
+          cocoaListSortItems(ih);
+
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        if (!table_view) return;
+
+        IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+        if (!list_receiver) return;
+        NSMutableArray* data_array = [list_receiver dataArray];
+
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        NSMutableDictionary* item_data = [NSMutableDictionary dictionaryWithObjectsAndKeys:ns_string, @"text", [NSNull null], @"image", nil];
+
+        [data_array addObject:item_data];
+
+        if (iupAttribGet(ih, "_IUPLIST_SORT_ENABLED"))
+          cocoaListSortItems(ih);
+
+        [table_view reloadData];
+        [table_view setNeedsDisplay:YES];
+
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+
+        cocoaListUpdateColumnWidth(ih);
+        break;
+      }
+    default:
+      break;
+  }
 }
 
 void iupdrvListInsertItem(Ihandle* ih, int pos, const char* value)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			[[popup_button menu] insertItemWithTitle:ns_string action:nil keyEquivalent:@"" atIndex:pos];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			[combo_box insertItemWithObjectValue:ns_string atIndex:pos];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-			NSMutableArray* data_array = [list_receiver dataArray];
-			
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			[data_array insertObject:ns_string atIndex:pos];
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
 
-#if 0
-			// reloadData will do the job, but may lose user's currently selected items
-			// reloadDataForRowIndexes might be better and more optimized,
-			// however, I don't know how IUP's SORT feature interacts with everything. (Append may no longer be put in the last row. (and not to mention that I haven't actually figured out how to make it work.)
-			[table_view reloadData];
-#else
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:pos];
-			[table_view insertRowsAtIndexes:index_set withAnimation:NSTableViewAnimationEffectNone];
-			//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndex:data_count-1] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
-//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, data_count)] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
-#endif
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+  if (!value)
+    value = "";
 
-	
+  NSString* ns_string = [NSString stringWithUTF8String:value];
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+        if (!popup_button) return;
+        [[popup_button menu] insertItemWithTitle:ns_string action:nil keyEquivalent:@"" atIndex:pos];
+
+        if (iupAttribGet(ih, "_IUPLIST_SORT_ENABLED"))
+          cocoaListSortItems(ih);
+
+        cocoaListUpdateDropExpand(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        if (!combo_box) return;
+        [combo_box insertItemWithObjectValue:ns_string atIndex:pos];
+
+        if (iupAttribGet(ih, "_IUPLIST_SORT_ENABLED"))
+          cocoaListSortItems(ih);
+
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        if (!table_view) return;
+
+        IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+        if (!list_receiver) return;
+        NSMutableArray* data_array = [list_receiver dataArray];
+
+        if (pos < 0) pos = 0;
+        if (pos > [data_array count]) pos = (int)[data_array count];
+
+        NSMutableDictionary* item_data = [NSMutableDictionary dictionaryWithObjectsAndKeys:ns_string, @"text", [NSNull null], @"image", nil];
+
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        [data_array insertObject:item_data atIndex:pos];
+
+        if (iupAttribGet(ih, "_IUPLIST_SORT_ENABLED"))
+          cocoaListSortItems(ih);
+
+        [table_view reloadData];
+        [table_view setNeedsDisplay:YES];
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+
+        cocoaListUpdateColumnWidth(ih);
+        break;
+      }
+    default:
+      break;
+  }
+  iupListUpdateOldValue(ih, pos, 0);
 }
 
 void iupdrvListRemoveItem(Ihandle* ih, int pos)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			[[popup_button menu] removeItemAtIndex:pos];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			[combo_box removeItemAtIndex:pos];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-			NSMutableArray* data_array = [list_receiver dataArray];
-			
-			[data_array removeObjectAtIndex:pos];
-			
-#if 0
-			// reloadData will do the job, but may lose user's currently selected items
-			// reloadDataForRowIndexes might be better and more optimized,
-			// however, I don't know how IUP's SORT feature interacts with everything. (Append may no longer be put in the last row. (and not to mention that I haven't actually figured out how to make it work.)
-			[table_view reloadData];
-#else
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:pos];
-			[table_view removeRowsAtIndexes:index_set withAnimation:NSTableViewAnimationEffectNone];
-#endif
-			
-//			NSUInteger data_count = [data_array count];
-//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndex:data_count-1] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
-//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, data_count)] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+        if (!popup_button) return;
+        [[popup_button menu] removeItemAtIndex:pos];
+        cocoaListUpdateDropExpand(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        if (!combo_box) return;
+        [combo_box removeItemAtIndex:pos];
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        if (!table_view) return;
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+        IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+        if (!list_receiver) return;
+        NSMutableArray* data_array = [list_receiver dataArray];
 
+        if (pos < 0 || pos >= [data_array count]) return;
+
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        [data_array removeObjectAtIndex:pos];
+        [table_view reloadData];
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+
+        cocoaListUpdateColumnWidth(ih);
+        break;
+      }
+    default:
+      break;
+  }
+  iupListUpdateOldValue(ih, pos, 1);
 }
 
 void iupdrvListRemoveAllItems(Ihandle* ih)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			[[popup_button menu] removeAllItems];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			[combo_box removeAllItems];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-			NSMutableArray* data_array = [list_receiver dataArray];
-			
-			[data_array removeAllObjects];
-			
-			// reloadData will do the job, but may lose user's currently selected items
-			// reloadDataForRowIndexes might be better and more optimized,
-			// however, I don't know how IUP's SORT feature interacts with everything. (Append may no longer be put in the last row. (and not to mention that I haven't actually figured out how to make it work.)
-			[table_view reloadData];
-			
-			//			NSUInteger data_count = [data_array count];
-			//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndex:data_count-1] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
-			//			[table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, data_count)] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+        if (!popup_button) return;
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        [[popup_button menu] removeAllItems];
+        [popup_button selectItemAtIndex:-1];
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+        cocoaListUpdateDropExpand(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        if (!combo_box) return;
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+        [combo_box removeAllItems];
+        iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+      case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        if (!table_view) return;
 
-	
+        IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+        if (!list_receiver) return;
+        NSMutableArray* data_array = [list_receiver dataArray];
+
+        if ([data_array count] > 0)
+        {
+            iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", "1");
+            [data_array removeAllObjects];
+            [table_view reloadData];
+            iupAttribSet(ih, "_IUPLIST_IGNORE_ACTION", NULL);
+        }
+
+        cocoaListUpdateColumnWidth(ih);
+        break;
+      }
+      default:
+      break;
+  }
 }
 
-
 void* iupdrvListGetImageHandle(Ihandle* ih, int id)
 {
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  int pos = id - 1;
 
-	
-    return NULL;
-
+  if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
+  {
+    NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+    NSMenuItem *menu_item = [popup_button itemAtIndex:pos];
+    return [menu_item image];
+  }
+  else if(sub_type >= IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+    NSDictionary* item_data = [[list_receiver dataArray] objectAtIndex:pos];
+    NSImage* image = [item_data objectForKey:@"image"];
+    if (image != nil && ![image isKindOfClass:[NSNull class]])
+    {
+      return image;
+    }
+  }
+  return NULL;
 }
 
 int iupdrvListSetImageHandle(Ihandle* ih, int id, void* hImage)
 {
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  int pos = id - 1;
+  NSImage* image = (NSImage*)hImage;
 
-	
+  if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
+  {
+    NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+    NSMenuItem *menu_item = [popup_button itemAtIndex:pos];
+
+    if (image)
+    {
+      NSSize img_size = [image size];
+      CGFloat target_size = 16.0;
+
+      if (img_size.width > target_size || img_size.height > target_size)
+      {
+        CGFloat scale = target_size / MAX(img_size.width, img_size.height);
+        [image setSize:NSMakeSize(img_size.width * scale, img_size.height * scale)];
+      }
+    }
+
+    [menu_item setImage:image];
+    return 1;
+  }
+  else if(sub_type >= IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+    NSMutableDictionary* item_data = [[list_receiver dataArray] objectAtIndex:pos];
+    if (image)
+    {
+      [item_data setObject:image forKey:@"image"];
+    }
+    else
+    {
+      [item_data setObject:[NSNull null] forKey:@"image"];
+    }
+    [table_view reloadDataForRowIndexes:[NSIndexSet indexSetWithIndex:pos] columnIndexes:[NSIndexSet indexSetWithIndex:0]];
+    return 1;
+  }
   return 0;
 }
 
+void iupdrvListSetItemCount(Ihandle* ih, int count)
+{
+  if (!ih->data->is_virtual)
+    return;
 
-// FIXME: I don't know what this is actually supposed to do and don't know how to trigger it in the tests.
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  if (sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST ||
+      sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST)
+  {
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    if (table_view)
+    {
+      [table_view reloadData];
+    }
+  }
+}
+
 static char* cocoaListGetIdValueAttrib(Ihandle* ih, int id_value)
 {
-	int pos = iupListGetPosAttrib(ih, id_value);
-	if(pos >= 0)
-	{
+  int pos = iupListGetPosAttrib(ih, id_value);
+  if (pos >= 0)
+  {
+    IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+    switch(sub_type)
+    {
+      case IUPCOCOALISTSUBTYPE_DROPDOWN:
+        {
+          NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+          NSString* ns_string = [popup_button itemTitleAtIndex:pos];
+          const char* c_str = [ns_string UTF8String];
+          char* iup_str = iupStrReturnStr(c_str);
+          return iup_str;
+        }
+      case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+        {
+          NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+          id object_value = [combo_box itemObjectValueAtIndex:pos];
+          NSString* ns_string = nil;
 
-		IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-		switch(sub_type)
-		{
-		  case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		  {
-			  NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			  NSString* ns_string = [popup_button itemTitleAtIndex:pos];
-			  
-			  const char* c_str = [ns_string UTF8String];
-			  char* iup_str = iupStrReturnStr(c_str);
-			  return iup_str;
-			  
-			  break;
-		  }
-		  case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		  {
-			  NSComboBox* popup_button = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			  id object_value = [popup_button itemObjectValueAtIndex:pos];
-			  NSString* ns_string = nil;
-			  
-			  if([object_value isKindOfClass:[NSString class]])
-			  {
-				  ns_string = (NSString*)object_value;
-			  }
-			  else
-			  {
-				  ns_string = [object_value stringValue];
-				  
-			  }
-			  
-			  const char* c_str = [ns_string UTF8String];
-			  char* iup_str = iupStrReturnStr(c_str);
-			  return iup_str;
-			  
-			  break;
-		  }
-		  case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		  case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		  {
-			  NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			  IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-			  NSMutableArray* data_array = [list_receiver dataArray];
-			  id object_value = [data_array objectAtIndex:pos];
-			  NSString* ns_string = nil;
-			  
-			  if([object_value isKindOfClass:[NSString class]])
-			  {
-				  ns_string = (NSString*)object_value;
-			  }
-			  else
-			  {
-				  ns_string = [object_value stringValue];
-				  
-			  }
-			  
-			  const char* c_str = [ns_string UTF8String];
-			  char* iup_str = iupStrReturnStr(c_str);
-			  return iup_str;
-			  
-			  break;
-		  }
-		  case IUPCOCOALISTSUBTYPE_EDITBOX:
-		  {
-			  break;
-		  }
-		  default:
-		  {
-			  break;
-		  }
-		}
+          if ([object_value isKindOfClass:[NSString class]])
+            ns_string = (NSString*)object_value;
+          else
+            ns_string = [object_value stringValue];
 
-	}
-	return NULL;
+          const char* c_str = [ns_string UTF8String];
+          char* iup_str = iupStrReturnStr(c_str);
+          return iup_str;
+        }
+      case IUPCOCOALISTSUBTYPE_EDITBOX:
+      case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+      case IUPCOCOALISTSUBTYPE_SINGLELIST:
+        {
+          if (ih->data->is_virtual)
+          {
+            char* text = iupListGetItemValueCb(ih, pos + 1);
+            return text;
+          }
+          else
+          {
+            NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+            IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+            NSMutableArray* data_array = [list_receiver dataArray];
+            NSDictionary* item_data = [data_array objectAtIndex:pos];
+            NSString* ns_string = [item_data objectForKey:@"text"];
+
+            const char* c_str = [ns_string UTF8String];
+            char* iup_str = iupStrReturnStr(c_str);
+            return iup_str;
+          }
+        }
+   default:
+        break;
+    }
+  }
+  return NULL;
 }
 
+static int cocoaListSetImageAttrib(Ihandle* ih, int id, const char* value)
+{
+  int pos = iupListGetPosAttrib(ih, id);
+  if (pos < 0 || !ih->data->show_image)
+    return 0;
 
+  NSImage* image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
+  int result = iupdrvListSetImageHandle(ih, id, image);
+
+  if (result)
+    cocoaListUpdateColumnWidth(ih);
+
+  return result;
+}
+
 static char* cocoaListGetValueAttrib(Ihandle* ih)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-			NSInteger index_of_selected_item = [popup_button indexOfSelectedItem];
-			int adjusted_index = (int)(index_of_selected_item+1); /* IUP starts at 1 */
-			return iupStrReturnInt(adjusted_index);
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			NSString* ns_string = [combo_box stringValue];
-			
-			const char* c_str = [ns_string UTF8String];
-			char* iup_str = iupStrReturnStr(c_str);
-			return iup_str;
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			size_t count;
-			
-			NSCAssert([table_view numberOfRows] == iupdrvListGetCount(ih), @"count is inconsistent");
-			count = (size_t)[table_view numberOfRows];
-			
-			char* ret_str = iupStrGetMemory((int)(count+1));
-			memset(ret_str, '-', count);
-			ret_str[count]='\0';
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+        NSInteger index_of_selected_item = [popup_button indexOfSelectedItem];
+        int adjusted_index = (int)(index_of_selected_item+1);
+        return iupStrReturnInt(adjusted_index);
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        NSString* ns_string = [combo_box stringValue];
+        const char* c_str = [ns_string UTF8String];
+        char* iup_str = iupStrReturnStr(c_str);
+        return iup_str;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        if (text_field)
+        {
+          NSString* ns_string = [text_field stringValue];
+          const char* c_str = [ns_string UTF8String];
+          char* iup_str = iupStrReturnStr(c_str);
+          return iup_str;
+        }
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        size_t count = (size_t)[table_view numberOfRows];
 
+        char* ret_str = iupStrGetMemory((int)(count+1));
+        memset(ret_str, '-', count);
+        ret_str[count] = '\0';
 
-			NSIndexSet* selected_index = [table_view selectedRowIndexes];
-			NSUInteger selected_i = [selected_index firstIndex];
-			while(selected_i != NSNotFound)
-			{
-				ret_str[selected_i] = '+';
-				// get the next index in the set
-				selected_i = [selected_index indexGreaterThanIndex:selected_i];
-			}
-		
-			return ret_str;
-			
+        NSIndexSet* selected_index = [table_view selectedRowIndexes];
+        NSUInteger selected_i = [selected_index firstIndex];
+        while (selected_i != NSNotFound)
+        {
+          ret_str[selected_i] = '+';
+          selected_i = [selected_index indexGreaterThanIndex:selected_i];
+        }
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			NSInteger index_of_selected_item = [table_view selectedRow];
-			int adjusted_index = (int)(index_of_selected_item+1); /* IUP starts at 1 */
-			return iupStrReturnInt(adjusted_index);
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return NULL;
+        return ret_str;
+      }
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        NSInteger index_of_selected_item = [table_view selectedRow];
+        int adjusted_index = (int)(index_of_selected_item+1);
+        return iupStrReturnInt(adjusted_index);
+      }
+    default:
+      break;
+  }
+
+  return NULL;
 }
 
 static int cocoaListSetValueAttrib(Ihandle* ih, const char* value)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+        int iup_pos;
+        if (iupStrToInt(value, &iup_pos) == 1)
+        {
+          NSInteger adjusted_index = (NSInteger)(iup_pos-1);
+          [popup_button selectItemAtIndex:adjusted_index];
+          iupAttribSetInt(ih, "_IUPLIST_OLDVALUE", iup_pos);
+        }
+        else
+        {
+          [popup_button selectItemAtIndex:-1];
+          iupAttribSet(ih, "_IUPLIST_OLDVALUE", NULL);
+        }
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        NSString* ns_string = nil;
+        if (NULL == value)
+          ns_string = @"";
+        else
+          ns_string = [NSString stringWithUTF8String:value];
 
-			int iup_pos;
-			if(iupStrToInt(value, &iup_pos)==1)
-			{
-				NSInteger adjusted_index = (NSInteger)(iup_pos-1); /* IUP starts at 1 */
-				[popup_button selectItemAtIndex:adjusted_index];
-			}
-			else
-			{
-				[popup_button selectItemAtIndex:-1];
-			}
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			NSString* ns_string = nil;
-			if(NULL == value)
-			{
-				ns_string = @"";
-			}
-			else
-			{
-				ns_string = [NSString stringWithUTF8String:value];
-			}
+        [combo_box setStringValue:ns_string];
+        [combo_box selectItemWithObjectValue:ns_string];
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        if (text_field)
+        {
+          NSString* ns_string = nil;
+          if (NULL == value)
+            ns_string = @"";
+          else
+            ns_string = [NSString stringWithUTF8String:value];
+          [text_field setStringValue:ns_string];
+        }
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        [table_view deselectAll:nil];
 
-			[combo_box setStringValue:ns_string];
-			[combo_box selectItemWithObjectValue:ns_string];
-			
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		{
-			
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			
-			/* Clear all selections */
-			[table_view deselectAll:nil];
-			
-			if(NULL != value)
-			{
-				/* User has changed a multiple selection on a simple list. */
-				size_t len;
-				size_t count;
-				
-				count = (size_t)[table_view numberOfRows];
-				len = strlen(value);
-				if(len < count)
-				{
-					count = (NSInteger)len;
-				}
-				
-				/* update selection list */
-				for(size_t i = 0; i<count; i++)
-				{
-					if (value[i]=='+')
-					{
-						[table_view selectRowIndexes:[NSIndexSet indexSetWithIndex:i] byExtendingSelection:YES];
-					}
-				}
-			}
-			
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			
-			/* Clear all selections */
-			[table_view deselectAll:nil];
-			
-			int iup_pos;
-			if(iupStrToInt(value, &iup_pos)==1)
-			{
-				NSInteger adjusted_index = (NSInteger)(iup_pos-1); /* IUP starts at 1 */
-				[table_view selectRowIndexes:[NSIndexSet indexSetWithIndex:adjusted_index] byExtendingSelection:NO];
-			}
-			else
-			{
-				[table_view deselectAll:nil];
-			}
-			
-			
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	
-	return 0;
+        if (NULL != value)
+        {
+          size_t len;
+          size_t count;
+
+          count = (size_t)[table_view numberOfRows];
+          len = strlen(value);
+          if (len < count)
+            count = len;
+
+          for (size_t i = 0; i < count; i++)
+          {
+            if (value[i] == '+')
+            {
+              [table_view selectRowIndexes:[NSIndexSet indexSetWithIndex:i] byExtendingSelection:YES];
+            }
+          }
+          iupAttribSetStr(ih, "_IUPLIST_OLDVALUE", value);
+        }
+        else
+        {
+          iupAttribSet(ih, "_IUPLIST_OLDVALUE", NULL);
+        }
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        [table_view deselectAll:nil];
+
+        int iup_pos;
+        if (iupStrToInt(value, &iup_pos) == 1 && iup_pos > 0)
+        {
+          NSInteger adjusted_index = (NSInteger)(iup_pos-1);
+          [table_view selectRowIndexes:[NSIndexSet indexSetWithIndex:adjusted_index] byExtendingSelection:NO];
+          [table_view scrollRowToVisible:adjusted_index];
+          iupAttribSetInt(ih, "_IUPLIST_OLDVALUE", iup_pos);
+        }
+        else
+        {
+          [table_view deselectAll:nil];
+          iupAttribSet(ih, "_IUPLIST_OLDVALUE", NULL);
+        }
+        break;
+      }
+    default:
+      break;
+  }
+
+  return 0;
 }
 
-static int cocoaListSetShowDropdownAttrib(Ihandle* ih, const char* value)
+static void cocoaListUpdateDragDrop(Ihandle* ih)
 {
-	if (ih->data->is_dropdown)
-	{
-#if 0
-		if (iupStrBoolean(value))
-			gtk_combo_box_popup((GtkComboBox*)ih->handle);
-		else
-			gtk_combo_box_popdown((GtkComboBox*)ih->handle);
-#endif
-	}
-	return 0;
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST ||
+      sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST ||
+      sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    if (!table_view) return;
+
+    BOOL enable_internal_dnd = ih->data->show_dragdrop && (sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST);
+    BOOL enable_crosslist_dnd = iupAttribGetBoolean(ih, "DRAGDROPLIST");
+
+    BOOL enable_drag_source = enable_internal_dnd || (enable_crosslist_dnd && iupAttribGetBoolean(ih, "DRAGSOURCE"));
+    BOOL enable_drop_target = enable_internal_dnd || (enable_crosslist_dnd && iupAttribGetBoolean(ih, "DROPTARGET"));
+
+    if (enable_drag_source)
+    {
+      NSDragOperation source_mask = NSDragOperationMove | NSDragOperationCopy;
+      [table_view setDraggingSourceOperationMask:source_mask forLocal:YES];
+      [table_view setDraggingSourceOperationMask:NSDragOperationNone forLocal:NO];
+      [table_view setVerticalMotionCanBeginDrag:YES];
+    }
+    else
+    {
+      [table_view setDraggingSourceOperationMask:NSDragOperationNone forLocal:YES];
+      [table_view setDraggingSourceOperationMask:NSDragOperationNone forLocal:NO];
+      [table_view setVerticalMotionCanBeginDrag:NO];
+    }
+
+    NSMutableArray* registeredTypes = [NSMutableArray array];
+    if (enable_internal_dnd)
+      [registeredTypes addObject:IupListPasteboardType];
+
+    if (enable_crosslist_dnd && enable_drop_target)
+      [registeredTypes addObject:IupInternalDndType];
+
+    if ([registeredTypes count] > 0 && enable_drop_target)
+    {
+      [table_view registerForDraggedTypes:registeredTypes];
+      [table_view setDraggingDestinationFeedbackStyle:enable_internal_dnd ?
+        NSTableViewDraggingDestinationFeedbackStyleGap :
+        NSTableViewDraggingDestinationFeedbackStyleRegular];
+    }
+    else
+    {
+      [table_view unregisterDraggedTypes];
+    }
+  }
 }
 
+static int cocoaListSetShowDragDropAttrib(Ihandle* ih, const char* value)
+{
+  if (iupStrBoolean(value))
+    ih->data->show_dragdrop = 1;
+  else
+    ih->data->show_dragdrop = 0;
 
+  if (ih->handle)
+  {
+    cocoaListUpdateDragDrop(ih);
+    return 0; /* Applied */
+  }
+  return 1; /* Will be updated in Map */
+}
 
+static int cocoaListSetShowDropdownAttrib(Ihandle* ih, const char* value)
+{
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
+  {
+    NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+    if (iupStrBoolean(value))
+    {
+      [popup_button performClick:nil];
+    }
+  }
+  else if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
+  {
+    /* NSComboBox does not provide a public API to programmatically show or hide
+       the dropdown menu. This is a limitation of NSComboBox on macOS.
+       The SHOWDROPDOWN attribute is only supported for DROPDOWN without EDITBOX. */
+  }
+
+  return 0;
+}
+
 static int cocoaListSetInsertAttrib(Ihandle* ih, const char* value)
 {
-//	gint pos;
-//	GtkEntry* entry;
-	if (!ih->data->has_editbox)
-		return 0;
-	if (!value)
-		return 0;
+  if (!ih->data->has_editbox)
+    return 0;
+  if (!value)
+    return 0;
 
-#if 0
-	iupAttribSet(ih, "_IUPGTK_DISABLE_TEXT_CB", "1");  /* disable callbacks */
-	entry = (GtkEntry*)iupAttribGet(ih, "_IUPGTK_ENTRY");
-	pos = gtk_editable_get_position(GTK_EDITABLE(entry));
-	gtk_editable_insert_text(GTK_EDITABLE(entry), iupgtkStrConvertToSystem(value), -1, &pos);
-	iupAttribSet(ih, "_IUPGTK_DISABLE_TEXT_CB", NULL);
-#endif
-	
-	return 0;
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSText* field_editor = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        field_editor = [[combo_box window] fieldEditor:YES forObject:combo_box];
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        if (text_field)
+        {
+          field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        }
+        break;
+      }
+    default:
+      break;
+  }
+
+  if (field_editor)
+  {
+    NSString* ns_string = [NSString stringWithUTF8String:value];
+    [field_editor insertText:ns_string];
+  }
+
+  return 0;
 }
 
 static int cocoaListSetAppendAttrib(Ihandle* ih, const char* value)
 {
-#if 0
-	if (ih->data->has_editbox)
-	{
-		GtkEntry* entry = (GtkEntry*)iupAttribGet(ih, "_IUPGTK_ENTRY");
-		gint pos = (gint)strlen(gtk_entry_get_text(entry))+1;
-		iupAttribSet(ih, "_IUPGTK_DISABLE_TEXT_CB", "1"); /* disable callbacks */
-		gtk_editable_insert_text(GTK_EDITABLE(entry), iupgtkStrConvertToSystem(value), -1, &pos);
-		iupAttribSet(ih, "_IUPGTK_DISABLE_TEXT_CB", NULL);
-	}
-#endif
-	return 0;
-}
+  if (!ih->data->has_editbox)
+    return 0;
+  if (!value)
+    value = "";
 
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+        NSString* current = [combo_box stringValue];
+        NSString* append = [NSString stringWithUTF8String:value];
+        NSString* new_value = [current stringByAppendingString:append];
+        [combo_box setStringValue:new_value];
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        if (text_field)
+        {
+          NSString* current = [text_field stringValue];
+          NSString* append = [NSString stringWithUTF8String:value];
+          NSString* new_value = [current stringByAppendingString:append];
+          [text_field setStringValue:new_value];
+        }
+        break;
+      }
+    default:
+      break;
+  }
 
+  return 0;
+}
 
 static int cocoaListSetSelectionAttrib(Ihandle* ih, const char* value)
 {
-#if 0
-  int start=1, end=1;
-  GtkEntry* entry;
   if (!ih->data->has_editbox)
     return 0;
-  if (!value)
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (!text_control)
     return 0;
 
-  entry = (GtkEntry*)iupAttribGet(ih, "_IUPGTK_ENTRY");
+  NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+
+  if (!field_editor)
+  {
+    [[text_control window] makeFirstResponder:text_control];
+    field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+    if (!field_editor)
+      return 0;
+  }
+
   if (!value || iupStrEqualNoCase(value, "NONE"))
   {
-    gtk_editable_select_region(GTK_EDITABLE(entry), 0, 0);
+    [field_editor setSelectedRange:NSMakeRange(0, 0)];
     return 0;
   }
 
   if (iupStrEqualNoCase(value, "ALL"))
   {
-    gtk_editable_select_region(GTK_EDITABLE(entry), 0, -1);
+    [field_editor selectAll:nil];
     return 0;
   }
 
-  if (iupStrToIntInt(value, &start, &end, ':')!=2) 
+  int start = 1, end = 1;
+  if (iupStrToIntInt(value, &start, &end, ':') != 2)
     return 0;
 
-  if(start<1 || end<1) 
+  if (start < 1 || end < 1)
     return 0;
 
-  start--; /* IUP starts at 1 */
+  start--;
   end--;
 
-  gtk_editable_select_region(GTK_EDITABLE(entry), start, end);
-#endif
+  NSRange range = NSMakeRange(start, end - start + 1);
+  [field_editor setSelectedRange:range];
+
   return 0;
 }
 
 static char* cocoaListGetSelectionAttrib(Ihandle* ih)
 {
-#if 0
-int start, end;
-  GtkEntry* entry;
   if (!ih->data->has_editbox)
     return NULL;
 
-  entry = (GtkEntry*)iupAttribGet(ih, "_IUPGTK_ENTRY");
-  if (gtk_editable_get_selection_bounds(GTK_EDITABLE(entry), &start, &end))
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
   {
-    start++; /* IUP starts at 1 */
-    end++;
-    return iupStrReturnIntInt((int)start, (int)end, ':');
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return NULL;
   }
-#endif
+
+  if (!text_control)
+    return NULL;
+
+  NSText* field_editor = [[text_control window] fieldEditor:NO forObject:text_control];
+
+  if (!field_editor)
+    return NULL;
+
+  NSRange range = [field_editor selectedRange];
+  if (range.length == 0)
+    return NULL;
+
+  int start = (int)range.location + 1;
+  int end = (int)(range.location + range.length);
+  return iupStrReturnIntInt(start, end, ':');
+}
+
+static int cocoaListSetSelectionPosAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox)
+    return 0;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (!text_control)
+    return 0;
+
+  NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+
+  if (!field_editor)
+  {
+    [[text_control window] makeFirstResponder:text_control];
+    field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+
+    if (!field_editor)
+      return 0;
+  }
+
+  if (!value || iupStrEqualNoCase(value, "NONE"))
+  {
+    [field_editor setSelectedRange:NSMakeRange(0, 0)];
+    return 0;
+  }
+
+  if (iupStrEqualNoCase(value, "ALL"))
+  {
+    [field_editor selectAll:nil];
+    return 0;
+  }
+
+  int start = 0, end = 0;
+  if (iupStrToIntInt(value, &start, &end, ':') != 2)
+    return 0;
+
+  if (start < 0 || end < 0)
+    return 0;
+
+  NSRange range = NSMakeRange(start, end - start);
+  [field_editor setSelectedRange:range];
+
+  return 0;
+}
+
+static char* cocoaListGetSelectionPosAttrib(Ihandle* ih)
+{
+  if (!ih->data->has_editbox)
+    return NULL;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return NULL;
+  }
+
+  if (!text_control)
+    return NULL;
+
+  NSText* field_editor = [[text_control window] fieldEditor:NO forObject:text_control];
+
+  if (!field_editor)
+    return NULL;
+
+  NSRange range = [field_editor selectedRange];
+  if (range.length == 0)
+    return NULL;
+
+  int start = (int)range.location;
+  int end = (int)(range.location + range.length);
+  return iupStrReturnIntInt(start, end, ':');
+}
+
+static int cocoaListSetSelectedTextAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox || !value)
+    return 0;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (!text_control)
+    return 0;
+
+  NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+
+  if (!field_editor)
+    return 0;
+
+  NSRange range = [field_editor selectedRange];
+  if (range.length > 0)
+  {
+    NSString* ns_string = [NSString stringWithUTF8String:value];
+    [field_editor replaceCharactersInRange:range withString:ns_string];
+  }
+
+  return 0;
+}
+
+static char* cocoaListGetSelectedTextAttrib(Ihandle* ih)
+{
+  if (!ih->data->has_editbox)
+    return NULL;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+  NSString* full_string = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        full_string = [(NSComboBox*)text_control stringValue];
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        if (text_control)
+        {
+          full_string = [(NSTextField*)text_control stringValue];
+        }
+        break;
+      }
+    default:
+      return NULL;
+  }
+
+  if (!text_control || !full_string)
+    return NULL;
+
+  NSText* field_editor = [[text_control window] fieldEditor:NO forObject:text_control];
+
+  if (!field_editor)
+    return NULL;
+
+  NSRange range = [field_editor selectedRange];
+  if (range.length == 0)
+    return NULL;
+
+  NSString* selected = [full_string substringWithRange:range];
+  const char* c_str = [selected UTF8String];
+  return iupStrReturnStr(c_str);
+}
+
+static int cocoaListSetCaretAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox || !value)
+    return 0;
+
+  int pos = 1;
+  iupStrToInt(value, &pos);
+  if (pos < 1) pos = 1;
+  pos--;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (text_control)
+  {
+    NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+    if(field_editor)
+    {
+      [field_editor setSelectedRange:NSMakeRange(pos, 0)];
+    }
+  }
+
+  return 0;
+}
+
+static char* cocoaListGetCaretAttrib(Ihandle* ih)
+{
+  if (!ih->data->has_editbox)
+    return NULL;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return NULL;
+  }
+
+  if (!text_control)
+    return NULL;
+
+  NSText* field_editor = [[text_control window] fieldEditor:NO forObject:text_control];
+
+  if (!field_editor)
+    return NULL;
+
+  NSRange range = [field_editor selectedRange];
+  int pos = (int)range.location + 1;
+  return iupStrReturnInt(pos);
+}
+
+static int cocoaListSetCaretPosAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox || !value)
+    return 0;
+
+  int pos = 0;
+  iupStrToInt(value, &pos);
+  if (pos < 0) pos = 0;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (text_control)
+  {
+    NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+    if(field_editor)
+    {
+      [field_editor setSelectedRange:NSMakeRange(pos, 0)];
+    }
+  }
+
+  return 0;
+}
+
+static char* cocoaListGetCaretPosAttrib(Ihandle* ih)
+{
+  if (!ih->data->has_editbox)
+    return NULL;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return NULL;
+  }
+
+  if (!text_control)
+    return NULL;
+
+  NSText* field_editor = [[text_control window] fieldEditor:NO forObject:text_control];
+
+  if (!field_editor)
+    return NULL;
+
+  NSRange range = [field_editor selectedRange];
+  int pos = (int)range.location;
+  return iupStrReturnInt(pos);
+}
+
+static int cocoaListSetScrollToAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox || !value)
+    return 0;
+
+  int pos = 1;
+  iupStrToInt(value, &pos);
+  if (pos < 1) pos = 1;
+  pos--;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (text_control)
+  {
+    NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+    if(field_editor)
+    {
+      [field_editor scrollRangeToVisible:NSMakeRange(pos, 0)];
+    }
+  }
+
+  return 0;
+}
+
+static int cocoaListSetScrollToPosAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox || !value)
+    return 0;
+
+  int pos = 0;
+  iupStrToInt(value, &pos);
+  if (pos < 0) pos = 0;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (text_control)
+  {
+    NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+    if(field_editor)
+    {
+      [field_editor scrollRangeToVisible:NSMakeRange(pos, 0)];
+    }
+  }
+
+  return 0;
+}
+
+static int cocoaListSetFontAttrib(Ihandle* ih, const char* value)
+{
+  if (!iupdrvSetFontAttrib(ih, value))
+    return 0;
+
+  if (ih->handle)
+  {
+    IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+    NSFont* font = cocoaGetNativeFont(ih);
+
+    if (sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST ||
+        sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST ||
+        sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+    {
+      NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+
+      [table_view reloadData];
+      cocoaListUpdateColumnWidth(ih);
+      [table_view setNeedsDisplay:YES];
+    }
+    else if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
+    {
+      NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+      if (popup_button && font)
+        [popup_button setFont:font];
+
+      cocoaListUpdateDropExpand(ih);
+    }
+    else if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
+    {
+      NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+      if (combo_box)
+      {
+        if (font)
+          [combo_box setFont:font];
+
+        NSInteger selected = [combo_box indexOfSelectedItem];
+        [combo_box reloadData];
+        if (selected != NSNotFound)
+          [combo_box selectItemAtIndex:selected];
+      }
+    }
+  }
+  return 1;
+}
+
+static int cocoaListSetReadOnlyAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox)
+    return 0;
+
+  BOOL is_editable = !iupStrBoolean(value);
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+    {
+      NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+      if (combo_box)
+        [combo_box setEditable:is_editable];
+      break;
+    }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    {
+      NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+      if (text_field)
+        [text_field setEditable:is_editable];
+      break;
+    }
+    default:
+      break;
+  }
+
+  return 0;
+}
+
+static char* cocoaListGetReadOnlyAttrib(Ihandle* ih)
+{
+  if (!ih->data->has_editbox)
+    return NULL;
+
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+    {
+      NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+      if (combo_box)
+        return iupStrReturnBoolean(![combo_box isEditable]);
+      break;
+    }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+    {
+      NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+      if (text_field)
+        return iupStrReturnBoolean(![text_field isEditable]);
+      break;
+    }
+    default:
+      break;
+  }
+
   return NULL;
 }
 
-static int cocoaListSetContextMenuAttrib(Ihandle* ih, const char* value)
+static int cocoaListSetClipboardAttrib(Ihandle* ih, const char* value)
 {
-	Ihandle* menu_ih = (Ihandle*)value;
-	
-	
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			// We can't support this. This doesn't work. It replaces the contents of the dropdown menu with the contextual menu.
-			// Official documentation on @property menu:
-			// "Overrides behavior of NSView.  This is the menu for the popup, not a context menu.  PopUpButtons do not have context menus."
-//			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
-//			iupCocoaCommonBaseSetContextMenuForWidget(ih, popup_button, menu_ih);
-			NSLog(@"WARNING: CONTEXTMENU not available for DROPDOWN (NSPopUpButton)");
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			// I don't know how to support this. This gets into the field editor problem.
-			// I only was able to solve the NSTextField by overriding a special method callback directly in a subclass instead of using the field editor's NSTextView delegate (which didn't work for field editors).
-			// I might be able to subclass the NSComboBox because it is a NSTextField, but I'm worried it may intefere with the dropdown part like with NSPopUpButton.
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
-			// We can't use iupCocoaCommonBaseSetContextMenuForWidget() because field editors are shared.
-			// We will override textView:menu:forEvent:atIndex: and inject the menu options there.
-			if(NULL != menu_ih)
-			{
-				// FIXME: The Menu might not be IupMap'd yet. (Presumably because we do not attach it directly to a dialog in this case.)
-				// I think calling IupMap() is the correct thing to do and fixes the problem.
-				// But this should be reviewed.
-				if(NULL == menu_ih->handle)
-				{
-					IupMap(menu_ih);
-				}
-			}
-			
-			// We use the same trick as we do with NSTextField in IupText.
-			// Save the menu_ih so we can access it in the callback
-			iupAttribSet(ih, "_COCOA_CONTEXT_MENU_IH", (const char*)menu_ih);
-			
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		{
-			
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			iupCocoaCommonBaseSetContextMenuForWidget(ih, table_view, menu_ih);
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			iupCocoaCommonBaseSetContextMenuForWidget(ih, table_view, menu_ih);
+  if (!ih->data->has_editbox || !value)
+    return 0;
 
-			
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			NSLog(@"WARNING: CONTEXTMENU not available for EDITBOX");
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return 1;
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  NSControl* text_control = nil;
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        text_control = (NSControl*)cocoaListGetBaseWidget(ih);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        text_control = (NSControl*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        break;
+      }
+    default:
+      return 0;
+  }
+
+  if (!text_control)
+    return 0;
+
+  NSText* field_editor = [[text_control window] fieldEditor:YES forObject:text_control];
+
+  if (!field_editor)
+    return 0;
+
+  if (iupStrEqualNoCase(value, "COPY"))
+  {
+    [field_editor copy:nil];
+  }
+  else if (iupStrEqualNoCase(value, "CUT"))
+  {
+    [field_editor cut:nil];
+  }
+  else if (iupStrEqualNoCase(value, "PASTE"))
+  {
+    [field_editor paste:nil];
+  }
+  else if (iupStrEqualNoCase(value, "CLEAR"))
+  {
+    [field_editor delete:nil];
+  }
+
+  return 0;
 }
 
+static int cocoaListSetNCAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox)
+    return 0;
 
-/*
-// I might be able to avoid using this.
-static void cocoaListLayoutUpdateMethod(Ihandle *ih)
+  if (!iupStrToInt(value, &ih->data->nc))
+    ih->data->nc = 0;
+
+  return 1;
+}
+
+static int cocoaListSetContextMenuAttrib(Ihandle* ih, const char* value)
 {
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+  Ihandle* menu_ih = (Ihandle*)value;
+  id widget_to_attach = nil;
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      return 0;
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		{
-			NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
-			
-			// rectOfRow would tell us the height of a specific row
-			// The actual -rectOfRow: is equal to the -rowHeight plus the intercellSpacing.height. The default value is 17.0 for applications linked on 10.5 and higher (the height acceptable for [NSFont systemFontSize]). The default value is 16.0 for 10.4 and lower.
-			
-			// I don't know which row we're at, but we'll assume they are all the same height.
-			// rectOfRow is not helpful if the table is empty, so use intercellSpacing.height+rowHeight
-			CGFloat row_height = [table_view rowHeight] + [table_view intercellSpacing].height;
-			
-			
-			int visible_lines = 0; // 5 is the default according to the docs
-			if(iupAttribGet(ih, "VISIBLELINES"))
-			{
-				visible_lines = iupAttribGetInt(ih, "VISIBLELINES");
-				
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      widget_to_attach = cocoaListGetBaseWidget(ih);
+      break;
 
-				
-				
-			}
-			else
-			{
-				visible_lines = (int)[table_view numberOfRows];
-			}
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+      case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      widget_to_attach = cocoaListGetBaseWidget(ih);
+      break;
 
-			CGFloat view_height = row_height * (CGFloat)visible_lines;
+      case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        widget_to_attach = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+        if (table_view)
+        {
+          iupcocoaCommonBaseSetContextMenuForWidget(ih, table_view, menu_ih);
+        }
+        break;
+      }
+      default:
+      return 0;
+  }
 
-			
-			{
-				NSRect new_frame = [table_view frame];
-				CGFloat old_height = new_frame.size.height;
-				CGFloat old_y = new_frame.origin.y;
-				
-				CGFloat diff_y = view_height - old_height;
-				
-				
-				
-				
-				//NSRect parent_rect = [parent_view frame];
-				
+  if (widget_to_attach)
+  {
+    iupcocoaCommonBaseSetContextMenuForWidget(ih, widget_to_attach, menu_ih);
+  }
 
-								//			 parent_rect.size.height - ih->y - ih->currentheight,
+  return 1;
+}
 
-				
-				
-				
-				new_frame.origin.y = old_y - diff_y;
+static int cocoaListSetTopItemAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->is_dropdown)
+  {
+    int pos = 1;
+    if (iupStrToInt(value, &pos))
+    {
+      NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+      NSInteger adjusted_pos = pos - 1;
+      if (adjusted_pos >= 0 && adjusted_pos < [table_view numberOfRows])
+      {
+        [table_view scrollRowToVisible:adjusted_pos];
+      }
+    }
+  }
+  return 0;
+}
 
-				new_frame.size.height = view_height;
-				new_frame.size.width = ih->naturalwidth;
+static int cocoaListSetSpacingAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->is_dropdown)
+    return 0;
 
-				
-			[table_view setFrame:new_frame];
-			}
-			
-			if([(NSObject*)ih->handle isKindOfClass:[NSScrollView class]])
-			{
-				NSScrollView* scroll_view = (NSScrollView*)ih->handle;
-				NSRect new_frame = [table_view frame];
-				
-				
-				CGFloat old_height = new_frame.size.height;
-				CGFloat old_y = new_frame.origin.y;
-				
-				CGFloat diff_y = view_height - old_height;
-				
-				
-				new_frame.origin.y = old_y - diff_y;
-				new_frame.size.height = view_height;
-				new_frame.size.width = ih->naturalwidth;
+  if (!iupStrToInt(value, &ih->data->spacing))
+    ih->data->spacing = 0;
 
+  if (ih->handle)
+  {
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    [table_view reloadData];
+    cocoaListUpdateColumnWidth(ih);
+    return 0;
+  }
+  else
+    return 1;
+}
 
-				[scroll_view setFrame:new_frame];
-				
-			}
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-//	iupdrvBaseLayoutUpdateMethod(ih);
+static int cocoaListSetPaddingAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox)
+    return 0;
 
+  iupStrToIntInt(value, &ih->data->horiz_padding, &ih->data->vert_padding, 'x');
+
+  if (ih->handle)
+  {
+    IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+    NSTextField* text_field = nil;
+    if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
+    {
+      text_field = (NSTextField*)cocoaListGetBaseWidget(ih);
+    }
+    else if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+    {
+      text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+    }
+
+    if (text_field)
+    {
+      NSRect currentFrame = [text_field frame];
+      NSRect superBounds = [[text_field superview] bounds];
+
+      if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+      {
+        CGFloat newWidth = superBounds.size.width - (ih->data->horiz_padding * 2);
+        if (newWidth > 0)
+        {
+          currentFrame.origin.x = ih->data->horiz_padding;
+          currentFrame.size.width = newWidth;
+          [text_field setFrame:currentFrame];
+        }
+      }
+    }
+    return 0;
+  }
+  else
+    return 1;
 }
-*/
 
-static int cocoaListMapMethod(Ihandle* ih)
+static int cocoaListSetCueBannerAttrib(Ihandle* ih, const char* value)
 {
+  if (!ih->data->has_editbox)
+    return 0;
 
-	/*
-	Iups "list" has 4 different modes.
-	
-	On Mac, these will need to be 4 completely different widgets.
-	
-	Dropdown:			NSPopUpButton
-	Editbox+Dropdown:	NSComboBox
-	Multiple:			NSTableView
-	Editbox:			No obvious native widget
-	*/
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
 
-	
-	NSView* root_view = nil;
-	NSView* main_view = nil;
-	
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			//NSPopUpButton* popup_button = [[NSPopUpButton alloc] initWithFrame:NSZeroRect pullsDown:NO];
-			NSPopUpButton* popup_button = [[NSPopUpButton alloc] initWithFrame:NSMakeRect(0, 0, kIupCocoaDefaultWidthNSPopUpButton, kIupCocoaDefaultHeightNSPopUpButton) pullsDown:NO];
-			root_view = popup_button;
-			main_view = root_view;
-			
-			// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-			objc_setAssociatedObject(popup_button, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-			// I also need to track the memory of the buttion action receiver.
-			// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-			// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.
-			// This is generally not good Cocoa as Toggles don't retain their receivers, but this seems like the best option.
-			// Be careful of retain cycles.
-			IupCocoaListPopupButtonReceiver* list_receiver = [[IupCocoaListPopupButtonReceiver alloc] init];
-			[popup_button setTarget:list_receiver];
-			[popup_button setAction:@selector(onSelectionChanged:)];
-			// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.
-			// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)
-			// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.
-			objc_setAssociatedObject(popup_button, IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY, (id)list_receiver, OBJC_ASSOCIATION_ASSIGN);
-			
+  if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
+  {
+    NSComboBox* combo_box = (NSComboBox*)cocoaListGetBaseWidget(ih);
+    if (value)
+    {
+      NSString* placeholder = [NSString stringWithUTF8String:value];
+      [[combo_box cell] setPlaceholderString:placeholder];
+    }
+    else
+    {
+      [[combo_box cell] setPlaceholderString:nil];
+    }
+  }
+  else if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+    if (text_field)
+    {
+      if (value)
+      {
+        NSString* placeholder = [NSString stringWithUTF8String:value];
+        [[text_field cell] setPlaceholderString:placeholder];
+      }
+      else
+      {
+        [[text_field cell] setPlaceholderString:nil];
+      }
+    }
+  }
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			// NSComboBox height is very specific. This number (30) plus the stuff going on in iupdrvListAddBorders affects the final height.
-			NSComboBox* combo_box = [[IupCocoaComboBox alloc] initWithFrame:NSMakeRect(0, 0, kIupCocoaDefaultWidthNSComboBox, kIupCocoaDefaultHeightNSComboBox)];
-//			NSComboBox* combo_box = [[NSComboBox alloc] initWithFrame:NSZeroRect];
-			// WEIRD: I am getting a smaller font size (12 instead of 13) when creating programmatically instead of Interface Builder.
-			// Explicitly setting to 13.0 here fixes that. 0.0 is slightly off and causes the vertical alignment to be too low and if you select-drag, the text will scroll by 1 pixel.
-			[combo_box setFont:[NSFont systemFontOfSize:13.0]];
+  return 1;
+}
 
-			
-			
-			root_view = combo_box;
-			main_view = root_view;
+static int cocoaListSetFilterAttrib(Ihandle* ih, const char* value)
+{
+  if (!ih->data->has_editbox)
+    return 0;
 
-			// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-			objc_setAssociatedObject(combo_box, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-			// I also need to track the memory of the buttion action receiver.
-			// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-			// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.
-			// This is generally not good Cocoa as Toggles don't retain their receivers, but this seems like the best option.
-			// Be careful of retain cycles.
-			IupCocoaListComboBoxReceiver* list_receiver = [[IupCocoaListComboBoxReceiver alloc] init];
-			[combo_box setDelegate:list_receiver];
-			
-			// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.
-			// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)
-			// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.
-			objc_setAssociatedObject(combo_box, IUP_COCOA_LIST_COMBOBOX_RECEIVER_OBJ_KEY, (id)list_receiver, OBJC_ASSOCIATION_ASSIGN);
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		{
-//			NSTableView* table_view = [[NSTableView alloc] initWithFrame:NSMakeRect(10, 10, 100, 100)];
-			NSTableView* table_view = [[NSTableView alloc] initWithFrame:NSZeroRect];
-			NSTableColumn* first_column = [[NSTableColumn alloc] initWithIdentifier:@"IupList"];
-			[table_view addTableColumn:first_column];
-			
-			[table_view setHeaderView:nil];
-			
-			// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-			objc_setAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-			// I also need to track the memory of the buttion action receiver.
-			// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-			// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.
-			// This is generally not good Cocoa as Toggles don't retain their receivers, but this seems like the best option.
-			// Be careful of retain cycles.
-			IupCocoaListTableViewReceiver* list_receiver = [[IupCocoaListTableViewReceiver alloc] init];
-			[table_view setDataSource:list_receiver];
-			[table_view setDelegate:list_receiver];
-			
-			[table_view setAllowsMultipleSelection:YES];
-			
-			// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.
-			// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)
-			// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.
-			objc_setAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, (id)list_receiver, OBJC_ASSOCIATION_ASSIGN);
-			
-			
-//			NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSMakeRect(10, 10, 100, 100)];
-			NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
-			[scroll_view setDocumentView:table_view];
-			[table_view release];
-			root_view = scroll_view;
-			main_view = table_view;
-			[scroll_view setHasVerticalScroller:YES];
+  /* Store filter for use in controlTextDidChange: delegate method.
+     The actual filtering is applied in the text change handler. */
+  iupAttribSet(ih, "FILTER", value);
+  return 1;
+}
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-//			NSTableView* table_view = [[NSTableView alloc] initWithFrame:NSMakeRect(10, 10, 100, 100)];
-			NSTableView* table_view = [[NSTableView alloc] initWithFrame:NSZeroRect];
-			NSTableColumn* first_column = [[NSTableColumn alloc] initWithIdentifier:@"IupList"];
-			[table_view addTableColumn:first_column];
-			
-			[table_view setHeaderView:nil];
-			
-			// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-			objc_setAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-			// I also need to track the memory of the buttion action receiver.
-			// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-			// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.
-			// This is generally not good Cocoa as Toggles don't retain their receivers, but this seems like the best option.
-			// Be careful of retain cycles.
-			IupCocoaListTableViewReceiver* list_receiver = [[IupCocoaListTableViewReceiver alloc] init];
-			[table_view setDataSource:list_receiver];
-			[table_view setDelegate:list_receiver];
-			
-			[table_view setAllowsMultipleSelection:NO];
+static char* cocoaListGetScrollVisibleAttrib(Ihandle* ih)
+{
+  NSScrollView* scroll_view = nil;
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
 
-			
-			// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.
-			// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)
-			// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.
-			objc_setAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, (id)list_receiver, OBJC_ASSOCIATION_ASSIGN);
-			
-			
-//			NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSMakeRect(10, 10, 100, 100)];
-			NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
-			[scroll_view setDocumentView:table_view];
-			[table_view release];
-			root_view = scroll_view;
-			main_view = table_view;
-			[scroll_view setHasVerticalScroller:YES];
+  if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN ||
+      sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
+    return NULL;
 
-			
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			NSLog(@"IupList Editbox subtype not available");
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	
-	
-	
-	/* Enable internal drag and drop support */
-	if(ih->data->show_dragdrop && !ih->data->is_dropdown && !ih->data->is_multiple)
-	{
+  if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+    scroll_view = (NSScrollView*)iupAttribGet(ih, "_IUPCOCOA_SCROLLVIEW");
+  else if (sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST ||
+           sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST)
+    scroll_view = (NSScrollView*)ih->handle;
 
-	}
-	
-	if (iupAttribGetBoolean(ih, "SORT"))
-	{
-//		gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store), IUPGTK_LIST_TEXT, GTK_SORT_ASCENDING);
-	}
-	/* add to the parent, all GTK controls must call this. */
-//	iupgtkAddToParent(ih);
-	
-	
-	ih->handle = root_view;
-	iupCocoaSetAssociatedViews(ih, main_view, root_view);
+  if (!scroll_view)
+    return "NO";
 
+  NSView* documentView = [scroll_view documentView];
+  if (!documentView)
+    return "NO";
 
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
+  NSSize contentSize = [scroll_view contentSize];
+  NSRect documentFrame = [documentView frame];
 
-	
+  BOOL has_vert = NO;
+  BOOL has_horiz = NO;
 
-	/* configure for DRAG&DROP */
-	if (IupGetCallback(ih, "DROPFILES_CB"))
-	{
-//		iupAttribSet(ih, "DROPFILESTARGET", "YES");
-	}
-	
-//	IupSetCallback(ih, "_IUP_XY2POS_CB", (Icallback)cocoaListConvertXYToPos);
-	
-	iupListSetInitialItems(ih);
-	
-	/* update a mnemonic in a label if necessary */
-//	iupgtkUpdateMnemonic(ih);
-	
-	return IUP_NOERROR;
+  if ([scroll_view hasVerticalScroller])
+    has_vert = (documentFrame.size.height > contentSize.height);
+
+  if ([scroll_view hasHorizontalScroller])
+    has_horiz = (documentFrame.size.width > contentSize.width);
+
+  if (has_vert && has_horiz)
+    return "BOTH";
+  else if (has_vert)
+    return "VERTICAL";
+  else if (has_horiz)
+    return "HORIZONTAL";
+  else
+    return "NO";
 }
 
+static int cocoaListSetDragDropListAttrib(Ihandle* ih, const char* value)
+{
+  (void)value;
+  if (ih->handle)
+  {
+    cocoaListUpdateDragDrop(ih);
+  }
+  return 1;
+}
 
-static void cocoaListUnMapMethod(Ihandle* ih)
+static char* cocoaListGetImageNativeHandleAttribId(Ihandle* ih, int id)
 {
-	// Some views may have an NSScrollView as the root and the real "base" widget is underneath.
-	// So by convention:
-	//	- Use cocoaListGetBaseWidget() to get the real "base" widget.
-	//	- Only the root_view should be released (we will not hold an extra retain on the base widget)
-	//	- Associated values are tied to the "base" widget
-	
-	NSView* root_view = ih->handle;
-	NSView* base_view = cocoaListGetBaseWidget(ih);
-	id list_receiver = nil;
+  if (!ih->data->show_image)
+    return NULL;
 
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-	
-	
-	IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOALISTSUBTYPE_DROPDOWN:
-		{
-			list_receiver = objc_getAssociatedObject(base_view, IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY);
-			objc_setAssociatedObject(base_view, IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  void* handle = iupdrvListGetImageHandle(ih, id);
+  return (char*)handle;
+}
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
-		{
-			list_receiver = objc_getAssociatedObject(base_view, IUP_COCOA_LIST_COMBOBOX_RECEIVER_OBJ_KEY);
-			objc_setAssociatedObject(base_view, IUP_COCOA_LIST_COMBOBOX_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+static int cocoaListSetAutoRedrawAttrib(Ihandle* ih, const char* value)
+{
+  (void)ih;
+  (void)value;
+  /* NSView handles automatic redrawing, no manual control needed on macOS */
+  return 1;
+}
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
-		{
-			list_receiver = objc_getAssociatedObject(base_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-			objc_setAssociatedObject(base_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+static int cocoaListMapMethod(Ihandle* ih)
+{
+  NSView* root_view = nil;
+  NSView* main_view = nil;
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_SINGLELIST:
-		{
-			list_receiver = objc_getAssociatedObject(base_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
-			objc_setAssociatedObject(base_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = [[NSPopUpButton alloc] initWithFrame:NSMakeRect(0, 0, kIupCocoaDefaultWidthNSPopUpButton, kIupCocoaDefaultHeightNSPopUpButton) pullsDown:NO];
+        root_view = popup_button;
+        main_view = root_view;
 
-			break;
-		}
-		case IUPCOCOALISTSUBTYPE_EDITBOX:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	
-	
-	
+        objc_setAssociatedObject(popup_button, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
 
-	[list_receiver release];
+        IupCocoaListPopupButtonReceiver* list_receiver = [[IupCocoaListPopupButtonReceiver alloc] init];
+        [popup_button setTarget:list_receiver];
+        [popup_button setAction:@selector(onSelectionChanged:)];
+        objc_setAssociatedObject(popup_button, IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY, (id)list_receiver, OBJC_ASSOCIATION_RETAIN);
+        [list_receiver release];
 
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	// Only release the root_view; don't release base_view
-	[root_view release];
-	ih->handle = NULL;
-	
+        if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+        {
+          iupcocoaSetCanFocus(ih, 0);
+        }
+        else
+        {
+          iupcocoaSetCanFocus(ih, 1);
+        }
+
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = [[IupCocoaComboBox alloc] initWithFrame:NSMakeRect(0, 0, kIupCocoaDefaultWidthNSComboBox, kIupCocoaDefaultHeightNSComboBox)];
+
+        root_view = combo_box;
+        main_view = root_view;
+
+        objc_setAssociatedObject(combo_box, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+
+        IupCocoaListDelegate* list_delegate = [[IupCocoaListDelegate alloc] init];
+        [combo_box setDelegate:list_delegate];
+        objc_setAssociatedObject(combo_box, IUP_COCOA_LIST_DELEGATE_OBJ_KEY, (id)list_delegate, OBJC_ASSOCIATION_RETAIN);
+        [list_delegate release];
+
+        int voptions = iupAttribGetInt(ih, "VISIBLEITEMS");
+        if (voptions == 0)
+          voptions = iupAttribGetInt(ih, "VISIBLE_ITEMS");
+        if (voptions <= 0)
+          voptions = 5;
+        [combo_box setNumberOfVisibleItems:voptions];
+
+        if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+        {
+          iupcocoaSetCanFocus(ih, 0);
+        }
+        else
+        {
+          iupcocoaSetCanFocus(ih, 1);
+        }
+
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        NSStackView* stack_view = [[NSStackView alloc] initWithFrame:NSZeroRect];
+        [stack_view setOrientation:NSUserInterfaceLayoutOrientationVertical];
+        [stack_view setAlignment:NSLayoutAttributeLeading];
+        [stack_view setSpacing:3];
+        [stack_view setDistribution:NSStackViewDistributionFill];
+
+        NSTextField* text_field = [[IupCocoaListTextField alloc] initWithFrame:NSZeroRect];
+        objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+
+        IupCocoaListDelegate* text_delegate = [[IupCocoaListDelegate alloc] init];
+        [text_field setDelegate:text_delegate];
+        objc_setAssociatedObject(text_field, IUP_COCOA_LIST_DELEGATE_OBJ_KEY, (id)text_delegate, OBJC_ASSOCIATION_RETAIN);
+        [text_delegate release];
+
+        NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
+        NSTableView* table_view = [[IupCocoaListTableView alloc] initWithFrame:NSZeroRect];
+        objc_setAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+
+        NSTableColumn* first_column = [[NSTableColumn alloc] initWithIdentifier:@"IupList"];
+        [first_column setResizingMask:NSTableColumnAutoresizingMask | NSTableColumnUserResizingMask];
+        [first_column setMinWidth:kIupCocoaMinColumnWidth];
+        [first_column setMaxWidth:10000];
+        [table_view addTableColumn:first_column];
+        [first_column release];
+
+        [table_view setHeaderView:nil];
+        [table_view setAllowsMultipleSelection:NO];
+        [table_view setColumnAutoresizingStyle:NSTableViewUniformColumnAutoresizingStyle];
+
+        IupCocoaListTableViewReceiver* list_receiver = [[IupCocoaListTableViewReceiver alloc] init];
+        objc_setAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, (id)list_receiver, OBJC_ASSOCIATION_RETAIN);
+        [list_receiver release];
+
+        [table_view setDataSource:list_receiver];
+        [table_view setDelegate:list_receiver];
+
+        [scroll_view setDocumentView:table_view];
+        [table_view release];
+
+        BOOL autohide = iupAttribGetBoolean(ih, "AUTOHIDE");
+        if (ih->data->sb)
+        {
+          [scroll_view setHasVerticalScroller:YES];
+          [scroll_view setHasHorizontalScroller:YES];
+          [scroll_view setAutohidesScrollers:autohide];
+        }
+        else
+        {
+          [scroll_view setHasVerticalScroller:NO];
+          [scroll_view setHasHorizontalScroller:NO];
+        }
+
+        [scroll_view setBorderType:NSBezelBorder];
+
+        [stack_view addArrangedSubview:text_field];
+        [stack_view addArrangedSubview:scroll_view];
+        [text_field release];
+        [scroll_view release];
+
+        [[text_field.widthAnchor constraintEqualToAnchor:stack_view.widthAnchor] setActive:YES];
+        [[scroll_view.widthAnchor constraintEqualToAnchor:stack_view.widthAnchor] setActive:YES];
+
+        /* Set height constraint for scroll_view based on VISIBLELINES */
+        int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+        if (visiblelines > 0)
+        {
+          /* Calculate scroll view height: (visiblelines-1) items worth of space.
+           * VISIBLELINES includes the text entry, so subtract 1 for list items. */
+          int char_width, char_height;
+          iupdrvFontGetCharSize(ih, &char_width, &char_height);
+          int item_height = char_height;
+          iupdrvListAddItemSpace(ih, &item_height);
+
+          int num_items_in_list = visiblelines - 1;
+          int list_content_height = num_items_in_list * item_height;
+
+          /* Add borders (NSBezelBorder is 2px total: 1px top + 1px bottom) */
+          int list_total_height = list_content_height + 2;
+
+          [[scroll_view.heightAnchor constraintEqualToConstant:list_total_height] setActive:YES];
+        }
+        else
+        {
+          [scroll_view setContentHuggingPriority:NSLayoutPriorityDefaultLow forOrientation:NSLayoutConstraintOrientationVertical];
+          [scroll_view setContentCompressionResistancePriority:NSLayoutPriorityDefaultLow forOrientation:NSLayoutConstraintOrientationVertical];
+        }
+
+        [text_field setContentHuggingPriority:NSLayoutPriorityRequired forOrientation:NSLayoutConstraintOrientationVertical];
+
+        root_view = stack_view;
+        main_view = text_field;
+
+        iupAttribSet(ih, "_IUPCOCOA_EDITFIELD", (char*)text_field);
+        iupAttribSet(ih, "_IUPCOCOA_TABLEVIEW", (char*)table_view);
+        iupAttribSet(ih, "_IUPCOCOA_SCROLLVIEW", (char*)scroll_view);
+
+        if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+        {
+          iupcocoaSetCanFocus(ih, 0);
+        }
+        else
+        {
+          iupcocoaSetCanFocus(ih, 1);
+        }
+
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = [[IupCocoaListTableView alloc] initWithFrame:NSZeroRect];
+
+        objc_setAssociatedObject(table_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+
+        NSTableColumn* first_column = [[NSTableColumn alloc] initWithIdentifier:@"IupList"];
+        [first_column setResizingMask:NSTableColumnAutoresizingMask | NSTableColumnUserResizingMask];
+        [first_column setMinWidth:kIupCocoaMinColumnWidth];
+        [first_column setMaxWidth:10000];
+        [table_view addTableColumn:first_column];
+        [first_column release];
+
+        [table_view setHeaderView:nil];
+        [table_view setIntercellSpacing:NSMakeSize(0, 0)];
+        [table_view setColumnAutoresizingStyle:NSTableViewUniformColumnAutoresizingStyle];
+        [table_view setAutoresizesSubviews:YES];
+        [table_view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+
+        IupCocoaListTableViewReceiver* list_receiver = [[IupCocoaListTableViewReceiver alloc] init];
+        objc_setAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, (id)list_receiver, OBJC_ASSOCIATION_RETAIN);
+        [list_receiver release];
+
+        [table_view setDataSource:list_receiver];
+        [table_view setDelegate:list_receiver];
+
+        if (sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST)
+          [table_view setAllowsMultipleSelection:YES];
+        else
+          [table_view setAllowsMultipleSelection:NO];
+
+        /* Virtual mode: set fixed row height for better performance */
+        if (ih->data->is_virtual)
+        {
+          int char_height;
+          iupdrvFontGetCharSize(ih, NULL, &char_height);
+          int row_height = char_height + 4;
+          [table_view setRowHeight:row_height];
+        }
+
+        NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
+        [scroll_view setDocumentView:table_view];
+        [table_view release];
+
+        root_view = scroll_view;
+        main_view = table_view;
+
+        iupAttribSet(ih, "_IUPCOCOA_TABLEVIEW", (char*)table_view);
+
+        BOOL autohide = iupAttribGetBoolean(ih, "AUTOHIDE");
+        if (ih->data->sb)
+        {
+          [scroll_view setHasVerticalScroller:YES];
+          [scroll_view setHasHorizontalScroller:YES];
+          [scroll_view setAutohidesScrollers:autohide];
+        }
+        else
+        {
+          [scroll_view setHasVerticalScroller:NO];
+          [scroll_view setHasHorizontalScroller:NO];
+        }
+
+        [scroll_view setBorderType:NSBezelBorder];
+        [scroll_view setAutoresizesSubviews:YES];
+        [scroll_view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+        [[scroll_view contentView] setAutoresizesSubviews:YES];
+
+        if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+        {
+          iupcocoaSetCanFocus(ih, 0);
+        }
+        else
+        {
+          iupcocoaSetCanFocus(ih, 1);
+        }
+
+        break;
+      }
+    default:
+      break;
+  }
+
+  ih->handle = root_view;
+  iupcocoaSetAssociatedViews(ih, main_view, root_view);
+
+  IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+  if (iup_font && [main_view respondsToSelector:@selector(setFont:)])
+  {
+    [(id)main_view setFont:[iup_font nativeFont]];
+  }
+
+  iupcocoaAddToParent(ih);
+
+  if (iupAttribGetBoolean(ih, "SORT"))
+  {
+    IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+    if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
+    {
+      iupAttribSet(ih, "_IUPLIST_SORT_ENABLED", "1");
+    }
+    else if (sub_type == IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN)
+    {
+      iupAttribSet(ih, "_IUPLIST_SORT_ENABLED", "1");
+    }
+    else if (sub_type >= IUPCOCOALISTSUBTYPE_EDITBOX)
+    {
+      NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+      IupCocoaListTableViewReceiver* list_receiver = objc_getAssociatedObject(table_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY);
+      if (list_receiver)
+      {
+        iupAttribSet(ih, "_IUPLIST_SORT_ENABLED", "1");
+      }
+    }
+  }
+
+  /* Don't populate items in virtual mode */
+  if (!ih->data->is_virtual)
+    iupListSetInitialItems(ih);
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_DROPDOWN)
+  {
+    NSPopUpButton* popup_button = (NSPopUpButton*)cocoaListGetBaseWidget(ih);
+    [popup_button selectItemAtIndex:-1];
+  }
+
+  cocoaListUpdateDropExpand(ih);
+
+  if (sub_type == IUPCOCOALISTSUBTYPE_MULTIPLELIST ||
+      sub_type == IUPCOCOALISTSUBTYPE_SINGLELIST ||
+      sub_type == IUPCOCOALISTSUBTYPE_EDITBOX)
+  {
+    cocoaListUpdateColumnWidth(ih);
+
+    /* Disable drag-drop in virtual mode */
+    if (!ih->data->is_virtual)
+      cocoaListUpdateDragDrop(ih);
+
+    NSTableView* table_view = (NSTableView*)cocoaListGetBaseWidget(ih);
+    if (table_view)
+    {
+      [table_view reloadData];
+    }
+  }
+
+  return IUP_NOERROR;
 }
 
+static void cocoaListUnMapMethod(Ihandle* ih)
+{
+  NSView* root_view = ih->handle;
+  if (!root_view) return;
 
+  NSView* base_view = cocoaListGetBaseWidget(ih);
+  IupCocoaListSubType sub_type = cocoaListGetSubType(ih);
+
+  switch(sub_type)
+  {
+    case IUPCOCOALISTSUBTYPE_DROPDOWN:
+      {
+        NSPopUpButton* popup_button = (NSPopUpButton*)base_view;
+        [popup_button setTarget:nil];
+        objc_setAssociatedObject(base_view, IUP_COCOA_LIST_POPUPBUTTON_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOXDROPDOWN:
+      {
+        NSComboBox* combo_box = (NSComboBox*)base_view;
+        [combo_box setDelegate:nil];
+        objc_setAssociatedObject(base_view, IUP_COCOA_LIST_DELEGATE_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_EDITBOX:
+      {
+        NSTextField* text_field = (NSTextField*)iupAttribGet(ih, "_IUPCOCOA_EDITFIELD");
+        NSTableView* table_view = (NSTableView*)iupAttribGet(ih, "_IUPCOCOA_TABLEVIEW");
+        if(text_field)
+        {
+          [text_field setDelegate:nil];
+          objc_setAssociatedObject(text_field, IUP_COCOA_LIST_DELEGATE_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+        }
+        if(table_view)
+        {
+          [table_view setDataSource:nil];
+          [table_view setDelegate:nil];
+        }
+        objc_setAssociatedObject(base_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+        break;
+      }
+    case IUPCOCOALISTSUBTYPE_MULTIPLELIST:
+    case IUPCOCOALISTSUBTYPE_SINGLELIST:
+      {
+        NSTableView* table_view = (NSTableView*)base_view;
+        [table_view setDataSource:nil];
+        [table_view setDelegate:nil];
+        objc_setAssociatedObject(base_view, IUP_COCOA_LIST_TABLEVIEW_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+        break;
+      }
+    default:
+      break;
+  }
+
+  Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+  if (menu_ih)
+  {
+    IupDestroy(menu_ih);
+    iupAttribSet(ih, "_COCOA_CONTEXT_MENU_IH", NULL);
+  }
+
+  objc_setAssociatedObject(base_view, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+
+  iupcocoaRemoveFromParent(ih);
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+  [root_view release];
+  ih->handle = NULL;
+}
+
 void iupdrvListInitClass(Iclass* ic)
 {
   /* Driver Dependent Class functions */
-	ic->Map = cocoaListMapMethod;
-	ic->UnMap = cocoaListUnMapMethod;
-//	ic->LayoutUpdate = cocoaListLayoutUpdateMethod;
+  ic->Map = cocoaListMapMethod;
+  ic->UnMap = cocoaListUnMapMethod;
 
-#if 0
+  iupClassRegisterAttribute(ic, "FONT", NULL, cocoaListSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, iupdrvBaseSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTFGCOLOR", IUPAF_DEFAULT);
 
-  /* Driver Dependent Attribute functions */
-
-  /* Overwrite Common */
-	
-	iupClassRegisterAttribute(ic, "FONT", NULL, winListSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
-	
-	/* Visual */
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, winListSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTBGCOLOR", IUPAF_NOT_MAPPED);
-	
-	/* Special */
-	iupClassRegisterAttribute(ic, "FGCOLOR", NULL, NULL, IUPAF_SAMEASSYSTEM, "TXTFGCOLOR", IUPAF_NOT_MAPPED);
-	
-
-#endif
-  /* IupList only */
-
-	
   iupClassRegisterAttributeId(ic, "IDVALUE", cocoaListGetIdValueAttrib, iupListSetIdValueAttrib, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "VALUE", cocoaListGetValueAttrib, cocoaListSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SHOWDRAGDROP", NULL, cocoaListSetShowDragDropAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DRAGDROPLIST", NULL, cocoaListSetDragDropListAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "SHOWDROPDOWN", NULL, cocoaListSetShowDropdownAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-#if 0
+  iupClassRegisterAttribute(ic, "TOPITEM", NULL, cocoaListSetTopItemAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SPACING", iupListGetSpacingAttrib, cocoaListSetSpacingAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED);
 
-	iupClassRegisterAttribute(ic, "VISIBLEITEMS", NULL, NULL, IUPAF_SAMEASSYSTEM, "5", IUPAF_DEFAULT);
-	/*OLD*/iupClassRegisterAttribute(ic, "VISIBLE_ITEMS", NULL, NULL, IUPAF_SAMEASSYSTEM, "5", IUPAF_DEFAULT);
-	iupClassRegisterAttribute(ic, "DROPEXPAND", NULL, NULL, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "SPACING", iupListGetSpacingAttrib, winListSetSpacingAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED);
-	
-	
-	iupClassRegisterAttribute(ic, "TOPITEM", NULL, cocoaListSetTopItemAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-
   iupClassRegisterAttribute(ic, "PADDING", iupListGetPaddingAttrib, cocoaListSetPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED);
   iupClassRegisterAttribute(ic, "SELECTEDTEXT", cocoaListGetSelectedTextAttrib, cocoaListSetSelectedTextAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-#endif
-	
   iupClassRegisterAttribute(ic, "SELECTION", cocoaListGetSelectionAttrib, cocoaListSetSelectionAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-#if 0
   iupClassRegisterAttribute(ic, "SELECTIONPOS", cocoaListGetSelectionPosAttrib, cocoaListSetSelectionPosAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "CARET", cocoaListGetCaretAttrib, cocoaListSetCaretAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "CARETPOS", cocoaListGetCaretPosAttrib, cocoaListSetCaretPosAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NO_SAVE|IUPAF_NO_INHERIT);
-#endif
-	
   iupClassRegisterAttribute(ic, "INSERT", NULL, cocoaListSetInsertAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "APPEND", NULL, cocoaListSetAppendAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-#if 0
   iupClassRegisterAttribute(ic, "READONLY", cocoaListGetReadOnlyAttrib, cocoaListSetReadOnlyAttrib, NULL, NULL, IUPAF_DEFAULT);
   iupClassRegisterAttribute(ic, "NC", iupListGetNCAttrib, cocoaListSetNCAttrib, NULL, NULL, IUPAF_NOT_MAPPED);
   iupClassRegisterAttribute(ic, "CLIPBOARD", NULL, cocoaListSetClipboardAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "SCROLLTO", NULL, cocoaListSetScrollToAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "SCROLLTOPOS", NULL, cocoaListSetScrollToPosAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "CONTEXTMENU", iupcocoaCommonBaseGetContextMenuAttrib, cocoaListSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "CUEBANNER", NULL, cocoaListSetCueBannerAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "FILTER", NULL, cocoaListSetFilterAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DROPEXPAND", NULL, NULL, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", cocoaListGetScrollVisibleAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "AUTOREDRAW", NULL, cocoaListSetAutoRedrawAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 
   iupClassRegisterAttributeId(ic, "IMAGE", NULL, cocoaListSetImageAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "CUEBANNER", NULL, winListSetCueBannerAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "FILTER", NULL, winListSetFilterAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-}
-  /* Not Supported */
-  iupClassRegisterAttribute(ic, "AUTOREDRAW", NULL, NULL, IUPAF_SAMEASSYSTEM, "Yes", IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-#endif
+  iupClassRegisterAttributeId(ic, "IMAGENATIVEHANDLE", cocoaListGetImageNativeHandleAttribId, NULL, IUPAF_NO_STRING|IUPAF_READONLY|IUPAF_NO_INHERIT);
 
-	/* New API for view specific contextual menus (Mac only) */
-	// FIXME: NSTableView is going to require some work.
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, cocoaListSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
+  iupClassRegisterAttribute(ic, "VISIBLEITEMS", NULL, NULL, IUPAF_SAMEASSYSTEM, "5", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "VISIBLE_ITEMS", NULL, NULL, IUPAF_SAMEASSYSTEM, "5", IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_loop.m
===================================================================
--- src/cocoa/iupcocoa_loop.m	(revision 5971)
+++ src/cocoa/iupcocoa_loop.m	(working copy)
@@ -1,11 +1,12 @@
 /** \file
- * \brief MAC Message Loop
+ * \brief macOS Message Loop
  *
  * See Copyright Notice in "iup.h"
  */
 
-#include <stdio.h>    
-#include <string.h>    
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
 
 #import <Cocoa/Cocoa.h>
 
@@ -12,222 +13,191 @@
 #include "iup.h"
 #include "iupcbs.h"
 #include "iup_str.h"
+#include "iup_loop.h"
 #include "iupcocoa_drv.h"
 
 static IFidle mac_idle_cb = NULL;
-static int mac_main_loop = 0;
-extern NSMutableArray* g_stackOfModals;
+static int mac_main_loop_should_quit = 0;
+static int mac_main_loop_level = 0;
 
-
 void iupdrvSetIdleFunction(Icallback f)
 {
   mac_idle_cb = (IFidle)f;
 }
 
+static int macLoopCallIdle(void)
+{
+  int ret = mac_idle_cb();
+  if (ret == IUP_CLOSE)
+  {
+    mac_idle_cb = NULL;
+    IupExitLoop();
+    return IUP_CLOSE;
+  }
+  if (ret == IUP_IGNORE)
+    mac_idle_cb = NULL;
+  return ret;
+}
+
 void IupExitLoop(void)
 {
-	if([NSApp isRunning])
-	{
-		// This is trickier than it should be (2)...
-		// IUP_CLOSE in callbacks is a big problem. I think the other implementations assume that modal loops are driven by nested calls to Loop.
-		// But modal dialogs really don't work like that on Mac.
-		// So I think to exit a modal dialog via IupPopup, typically you have a control (e.g. button) callback return IUP_CLOSE.
-		// This on other platforms calls IupExitLoop.
-		// And there is a nested counter that unrolls.
-		// But since modal dialogs here don't work like this, we end up quiting the program.
-		// I'm not sure how to handle this. I think I need to talk to Scuri about this. This may require API verification and maybe a redesign.
-		// But for now, I can add a hack that looks for if a modal window is present. If so, this will stop the modal call.
-		bool was_in_modal = cocoaDialogExitModal();
-		if(was_in_modal)
-		{
-			return;
-		}
+  char* exit_loop = IupGetGlobal("EXITLOOP");
+  if (!exit_loop || iupStrBoolean(exit_loop))
+  {
+    mac_main_loop_should_quit = 1;
 
-
-		// This is trickier than it should be (1)...
-		// If IUP triggered the exit by calling IupExitLoop (via IUP_CLOSE directive)
-		// then this branch is taken and we need to call [NSApp stop:nil] to quit.
-		// But if the user quits naturally, e.g. Quit menu,
-		// then applicationWillTerminate is invoked and [NSApp isRunning] is false, and the else case hits instead.
-		if(mac_main_loop <= 1)
-		{
-			//  [NSApp terminate:nil];
-			iupCocoaCommonLoopCallExitCb();
-			[NSApp stop:nil];
-		}
-		else
-		{
-			mac_main_loop--;
-
-		}
-	}
-	else
-	{
-		// This path could be invoked when the application is quit normally (e.g. Quit menu).
-		mac_main_loop--;
-
-	}
+    NSEvent* event = [NSEvent otherEventWithType:NSEventTypeApplicationDefined
+                                        location:NSMakePoint(0, 0)
+                                   modifierFlags:0
+                                       timestamp:0
+                                    windowNumber:0
+                                         context:nil
+                                         subtype:0
+                                           data1:0
+                                           data2:0];
+    [NSApp postEvent:event atStart:NO];
+  }
 }
 
-static int macLoopProcessMessage(NSEvent *event)
+static int macLoopProcessMessage(NSEvent* event)
 {
-    [NSApp sendEvent:event];
-    return IUP_DEFAULT;
+  [NSApp sendEvent:event];
+  return IUP_DEFAULT;
 }
 
 int IupMainLoopLevel(void)
 {
-  return mac_main_loop;
+  return mac_main_loop_level;
 }
 
-#if 1
-int IupMainLoop(void)
+int iupcocoaMainLoopShouldQuit(void)
 {
-	if(![NSApp isRunning])
-	{
-		mac_main_loop++;
-		[NSApp run];
-		// [NSApp run] blocks until the event loop is stopped
-		mac_main_loop--;
+  return mac_main_loop_should_quit;
+}
 
-	}
-	else
-	{
-		NSLog(@"IupMainLoop called again");
-		mac_main_loop++;
-	}
-	
-	// Unfortunately, applicationWillTerminate: will not always be called depending how the quit was invoked.
-	// Let's try to guard against calling the exit callback too often.
-	if(0 == mac_main_loop)
-	{
-		iupCocoaCommonLoopCallExitCb();
-	}
-	return IUP_NOERROR;
-
-}
-#else
 int IupMainLoop(void)
 {
-  NSEvent *event;
-  int ret;
+  static int has_done_entry = 0;
 
-  mac_main_loop++;
+  mac_main_loop_level++;
 
-  do 
+  if (0 == has_done_entry)
   {
-    if (mac_idle_cb)
-    {
-      ret = 1;          
-	  event = [NSApp
-	                nextEventMatchingMask:NSAnyEventMask
-	                untilDate:[NSDate dateWithTimeIntervalSinceNow:0.0]
-	                inMode:NSDefaultRunLoopMode
-	                dequeue:YES];
-	  if(event != nil)
-	  {
-        if (macLoopProcessMessage(event) == IUP_CLOSE)
+    has_done_entry = 1;
+    iupLoopCallEntryCb();
+  }
+
+  mac_main_loop_should_quit = 0;
+
+  while (!mac_main_loop_should_quit)
+  {
+    @autoreleasepool {
+      if (mac_idle_cb)
+      {
+        NSEvent* event = [NSApp nextEventMatchingMask:NSEventMaskAny
+                                            untilDate:[NSDate dateWithTimeIntervalSinceNow:0.0]
+                                               inMode:NSDefaultRunLoopMode
+                                              dequeue:YES];
+        if (event != nil)
         {
-          mac_main_loop--;
-          return IUP_CLOSE;
+          macLoopProcessMessage(event);
         }
+        else
+        {
+          macLoopCallIdle();
+        }
       }
       else
       {
-        int ret = mac_idle_cb();
-        if (ret == IUP_CLOSE)
+        NSEvent* event = [NSApp nextEventMatchingMask:NSEventMaskAny
+                                            untilDate:[NSDate distantFuture]
+                                               inMode:NSDefaultRunLoopMode
+                                              dequeue:YES];
+        if (event != nil)
         {
-          mac_idle_cb = NULL;
-          mac_main_loop--;
-          return IUP_CLOSE;
+          macLoopProcessMessage(event);
         }
-        if (ret == IUP_IGNORE) 
-          mac_idle_cb = NULL;
       }
     }
-    else
-    {          
-	 	event = [NSApp
-		                nextEventMatchingMask:NSAnyEventMask
-		                untilDate:[NSDate distantFuture]
-		                inMode:NSDefaultRunLoopMode
-		                dequeue:YES];
-      if (macLoopProcessMessage(event) == IUP_CLOSE)  
-      {
-        mac_main_loop--;
-        return IUP_NOERROR;
-      }
-    }
-  } while (ret);
+  }
 
-  mac_main_loop--;
+  /* If we are exiting a nested loop, reset the quit flag so the parent loop can continue execution. */
+  if (mac_main_loop_level > 1 && mac_main_loop_should_quit)
+  {
+    mac_main_loop_should_quit = 0;
+  }
+
+  mac_main_loop_level--;
+
+  if (mac_main_loop_level == 0)
+  {
+    iupLoopCallExitCb();
+  }
+
   return IUP_NOERROR;
 }
-#endif
 
-
 int IupLoopStepWait(void)
 {
-  NSEvent *event; 
-  event = [NSApp
-	                nextEventMatchingMask:NSAnyEventMask
-	                untilDate:[NSDate distantFuture]
-	                inMode:NSDefaultRunLoopMode
-	                dequeue:YES];
-  if (macLoopProcessMessage(event) == IUP_CLOSE)  
+  NSEvent* event = [NSApp nextEventMatchingMask:NSEventMaskAny
+                                      untilDate:[NSDate distantFuture]
+                                         inMode:NSDefaultRunLoopMode
+                                        dequeue:YES];
+  if (event != nil)
+    macLoopProcessMessage(event);
+
+  if (mac_main_loop_should_quit)
     return IUP_CLOSE;
+
   return IUP_DEFAULT;
 }
 
 int IupLoopStep(void)
 {
-  NSEvent *event; 
-  event = [NSApp
-	                nextEventMatchingMask:NSAnyEventMask
-	                untilDate:[NSDate dateWithTimeIntervalSinceNow:0.0]
-	                inMode:NSDefaultRunLoopMode
-	                dequeue:YES];
-  if(event != nil)
-    return macLoopProcessMessage(event);
+  NSEvent* event = [NSApp nextEventMatchingMask:NSEventMaskAny
+                                      untilDate:[NSDate dateWithTimeIntervalSinceNow:0.0]
+                                         inMode:NSDefaultRunLoopMode
+                                        dequeue:YES];
+  if (event != nil)
+    macLoopProcessMessage(event);
+  else if (mac_idle_cb)
+    macLoopCallIdle();
 
+  if (mac_main_loop_should_quit)
+    return IUP_CLOSE;
+
   return IUP_DEFAULT;
 }
 
 void IupFlush(void)
 {
-  int post_quit = 0;
-  NSEvent *event;
-  while(1) { 
-    event = [NSApp
-	                nextEventMatchingMask:NSAnyEventMask
-	                untilDate:[NSDate dateWithTimeIntervalSinceNow:0.0]
-	                inMode:NSDefaultRunLoopMode
-	                dequeue:YES];
-	if (event==nil) break;
-	if (macLoopProcessMessage(event) == IUP_CLOSE)
-    {
-      post_quit = 1;
+  while (YES)
+  {
+    NSEvent* event = [NSApp nextEventMatchingMask:NSEventMaskAny
+                                        untilDate:[NSDate dateWithTimeIntervalSinceNow:0.0]
+                                           inMode:NSDefaultRunLoopMode
+                                          dequeue:YES];
+    if (event == nil)
       break;
-    }  
+
+    macLoopProcessMessage(event);
+
+    if (mac_main_loop_should_quit)
+      break;
   }
-  
-  /* re post the quit message if still inside MainLoop */
-  if (post_quit && mac_main_loop>0)
-	[NSApp terminate:nil];
 }
 
 void IupPostMessage(Ihandle* ih, const char* s, int i, double d, void* p)
 {
-	char* s_copy = iupStrDup(s);
-	dispatch_async(dispatch_get_main_queue(),
-		^{
-			//NSLog(@"dispatch_async fired on main_queue");
-			IFnsidv cb = (IFnsidv)IupGetCallback(ih, "POSTMESSAGE_CB");
-			if (cb)
-			{
-				cb(ih, s_copy, i, d, p);
-			}
-			free(s_copy);
-		}
-	);
+  char* s_copy = iupStrDup(s);
+  dispatch_async(dispatch_get_main_queue(),
+      ^{
+      IFnsidv cb = (IFnsidv)IupGetCallback(ih, "POSTMESSAGE_CB");
+      if (cb)
+      {
+        cb(ih, s_copy, i, d, p);
+      }
+        free(s_copy);
+      }
+      );
 }
Index: src/cocoa/iupcocoa_menu.m
===================================================================
--- src/cocoa/iupcocoa_menu.m	(revision 5971)
+++ src/cocoa/iupcocoa_menu.m	(working copy)
@@ -1,16 +1,17 @@
 /** \file
- * \brief Menu Resources
+ * \brief Menu Resources for Cocoa
  *
  * See Copyright Notice in "iup.h"
  */
 
 #import <Cocoa/Cocoa.h>
+#import <objc/runtime.h>
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <memory.h>
-#include <stdarg.h>
+#include <ctype.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -24,1240 +25,1395 @@
 #include "iup_drv.h"
 #include "iup_drvfont.h"
 #include "iup_image.h"
+#include "iup_key.h"
 #include "iup_menu.h"
 
 #include "iupcocoa_drv.h"
 
-/*
-For a menu bar:
 
-AppleIcon File Edit Window
-               ----
-			   Copy
- 
- In Cocoa:
- NSMenu (menubar)
- -> addItem: NSMenuItem (for Edit, but not named)
-    -> setSubmenu: NSMenu ("Edit", this is the thing that sets the name)
-       -> addItem: NSMenuItem (for "Paste")
- 
- In IUP:
- IupMenu (menubar)
- -> IupSubmenu (this is the part that gets named "Edit")
-    -> IupMenu  (for Edit, but this is not named)
-       -> IupItem (for "Paste")
- 
- Notice that Submenu is an NSMenuItem. And the naming must be done on the NSMenu attached below it, not on the NSMenuItem itself.
- 
-*/
+/* Global application menu reference (IUP managed) */
+static Ihandle* s_currentIupApplicationMenu = NULL;
+/* Global default application menu (Native, created if no IUP menu is provided) */
+static NSMenu* s_defaultApplicationMenu = NULL;
 
+static const void* MENUITEM_TARGET_ASSOCIATED_OBJ_KEY = &MENUITEM_TARGET_ASSOCIATED_OBJ_KEY;
+static const void* MENU_DELEGATE_ASSOCIATED_OBJ_KEY = &MENU_DELEGATE_ASSOCIATED_OBJ_KEY;
+/* Used when an IupItem is placed directly on the menu bar, which requires wrapping it in a submenu on macOS. */
+static const void* MENUBAR_ITEM_WRAPPER_KEY = &MENUBAR_ITEM_WRAPPER_KEY;
 
-// This is for keeping a pointer to the Ihandle to the current set IupMenu for the application menu.
-static Ihandle* s_currentIupMainMenu = NULL;
+static void cocoaMenuUpdateImage(Ihandle* ih);
+static void cocoaItemUpdateRadioGroup(Ihandle* ih);
+static char* cocoaItemGetActiveAttrib(Ihandle* ih);
 
+/*******************************************************************************************/
+/* Helper Objects                                                                          */
+/*******************************************************************************************/
 
-static void cocoaCreateDefaultApplicationMenu()
+@interface IupCocoaMenuDelegate : NSObject<NSMenuDelegate>
 {
-		id app_name = [[NSProcessInfo processInfo] processName];
-#if 0
-	
-	NSBundle* framework_bundle = [NSBundle bundleWithIdentifier:@"br.puc-rio.tecgraf.iup"];
+  Ihandle* _ih;
+}
+@property (nonatomic, assign) Ihandle* ih;
+- (instancetype) initWithIhandle:(Ihandle*)ih;
+@end
 
-	/* Note: I discovered that some menus use private/magic capabilites which are not accessible through public API.
-	 The Services menu and Window are two major examples. They have a extra field in the XIB data as systemMenu="services" and systemMenu="window"
-	 The Help and App menu also have systemMenu entries.
-	 So the only solution is to use Interface Builder files to provide these.
-	 The debate is whether to just target the individual pieces or provide a single monolithic XIB with everything.
-	 */
-	
-	id app_menu = [[[NSMenu alloc] init] autorelease];
-	
-	id about_menu_item = [[[NSMenuItem alloc] initWithTitle:[[NSLocalizedString(@"About", @"About") stringByAppendingString:@" "] stringByAppendingString:app_name] action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@""] autorelease];
-	id preferences_menu_item = [[[NSMenuItem alloc] initWithTitle:[NSLocalizedString(@"Preferences", @"Preferences") stringByAppendingString:@""] action:nil keyEquivalent:@","] autorelease];
-//	id services_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Services", @"Services") action:nil keyEquivalent:@""] autorelease];
-	//	id services_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Services", @"Services") action:nil keyEquivalent:@""] autorelease];
-	NSNib* services_menu_item_nib = [[[NSNib alloc] initWithNibNamed:@"CanonicalServiceMenu" bundle:framework_bundle] autorelease];
-	NSArray* top_level_objects = nil;
-	id services_menu_item = nil;
-	if([services_menu_item_nib instantiateWithOwner:nil topLevelObjects:&top_level_objects])
-	{
-		for(id current_object in top_level_objects)
-		{
-			if([current_object isKindOfClass:[NSMenuItem class]])
-			{
-				services_menu_item = current_object;
-				break;
-			}
-		}
-	}
-	
-	id hide_menu_item = [[[NSMenuItem alloc] initWithTitle:[[NSLocalizedString(@"Hide", @"Hide") stringByAppendingString:@" "] stringByAppendingString:app_name] action:@selector(hide:) keyEquivalent:@"h"] autorelease];
-	id hideothers_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Hide Others", @"Hide Others") action:@selector(hideOtherApplications:) keyEquivalent:@"h"] autorelease];
-	[hideothers_menu_item setKeyEquivalentModifierMask:NSEventModifierFlagOption|NSEventModifierFlagCommand];
-	id showall_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Show All", @"Show All") action:@selector(unhideAllApplications:) keyEquivalent:@""] autorelease];
-	id quit_title = [[NSLocalizedString(@"Quit", @"Quit") stringByAppendingString:@" "] stringByAppendingString:app_name];
-	id quit_menu_item = [[[NSMenuItem alloc] initWithTitle:quit_title action:@selector(terminate:) keyEquivalent:@"q"] autorelease];
+@implementation IupCocoaMenuDelegate
+@synthesize ih = _ih;
 
+- (instancetype) initWithIhandle:(Ihandle*)ih
+{
+  self = [super init];
+  if (self)
+  {
+    _ih = ih;
+  }
+  return self;
+}
 
-	[app_menu addItem:about_menu_item];
-	[app_menu addItem:[NSMenuItem separatorItem]];
-	[app_menu addItem:preferences_menu_item];
-	[app_menu addItem:[NSMenuItem separatorItem]];
-	[app_menu addItem:services_menu_item];
-	[app_menu addItem:[NSMenuItem separatorItem]];
-	[app_menu addItem:hide_menu_item];
-	[app_menu addItem:hideothers_menu_item];
-	[app_menu addItem:showall_menu_item];
-	[app_menu addItem:[NSMenuItem separatorItem]];
-	[app_menu addItem:quit_menu_item];
-	
-//	id services_sub_menu = [[[NSMenu alloc] init] autorelease];
-//	[services_menu_item setSubmenu:services_sub_menu];
+- (void) dealloc
+{
+  _ih = NULL;
+  [super dealloc];
+}
 
+- (void) menuWillOpen:(NSMenu*)menu
+{
+  static const void* TRAYMENU_TRAY_IHANDLE_KEY = @"TRAYMENU_TRAY_IHANDLE_KEY";
+  Ihandle* tray_ih = (Ihandle*)objc_getAssociatedObject(menu, TRAYMENU_TRAY_IHANDLE_KEY);
+  if (tray_ih && iupObjectCheck(tray_ih))
+  {
+    IFniii tray_cb = (IFniii)IupGetCallback(tray_ih, "TRAYCLICK_CB");
+    if (tray_cb)
+    {
+      int button = iupcocoaTrayGetLastButton();
+      int dclick = iupcocoaTrayGetLastDclick();
+      int ret = tray_cb(tray_ih, button, 1, dclick);
+      if (ret == IUP_CLOSE)
+      {
+        IupExitLoop();
+      }
+    }
+  }
 
-	id app_menu_category = [[[NSMenuItem alloc] init] autorelease];
-	[app_menu_category setSubmenu:app_menu];
-	// This is supposed to do nothing. This is a cheat so I can look up this menu item later and try to reuse it.
-	[app_menu_category setTitle:@"ApplicationMenu"];
-	
-	
-	
-	
-	
-//	id print_title = [NSLocalizedString(@"Print", @"Print") stringByAppendingString:@""];
-//	id print_menu_item = [[[NSMenuItem alloc] initWithTitle:print_title action:@selector(print:) keyEquivalent:@"p"] autorelease];
-	
-	id file_menu = [[[NSMenu alloc] init] autorelease];
-	[file_menu setTitle:NSLocalizedString(@"File", @"File")];
-	
-//	[file_menu addItem:print_menu_item];
+  if (!_ih) return;
 
-	
-	
-	id file_menu_category = [[[NSMenuItem alloc] init] autorelease];
-	[file_menu_category setSubmenu:file_menu];
-	// This is supposed to do nothing. This is a cheat so I can look up this menu item later and try to reuse it.
-	[file_menu_category setTitle:NSLocalizedString(@"File", @"File")];
+  Icallback cb = IupGetCallback(_ih, "OPEN_CB");
+  if (!cb && _ih->parent)
+    cb = (Icallback)IupGetCallback(_ih->parent, "OPEN_CB");
 
-	
-	
-	
-	id cut_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Cut", @"Cut") action:@selector(cut:) keyEquivalent:@"x"] autorelease];
-	id copy_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Copy", @"Copy") action:@selector(copy:) keyEquivalent:@"c"] autorelease];
-	id paste_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Paste", @"Paste") action:@selector(paste:) keyEquivalent:@"v"] autorelease];
-	id selectall_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Select All", @"Select All") action:@selector(selectAll:) keyEquivalent:@"a"] autorelease];
-	id findroot_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Find", @"Find") action:nil keyEquivalent:@""] autorelease];
+  if (cb) cb(_ih);
+}
 
-	
-	id edit_menu = [[[NSMenu alloc] init] autorelease];
-	[edit_menu setTitle:NSLocalizedString(@"Edit", @"Edit")];
+- (void) menuDidClose:(NSMenu*)menu
+{
+  if (!_ih) return;
 
-	[edit_menu addItem:cut_menu_item];
-	[edit_menu addItem:copy_menu_item];
-	[edit_menu addItem:paste_menu_item];
-	[edit_menu addItem:selectall_menu_item];
-	[edit_menu addItem:[NSMenuItem separatorItem]];
-	[edit_menu addItem:findroot_menu_item];
+  Icallback cb = IupGetCallback(_ih, "MENUCLOSE_CB");
+  /* Check also in the Submenu parent */
+  if (!cb && _ih->parent)
+    cb = (Icallback)IupGetCallback(_ih->parent, "MENUCLOSE_CB");
 
-	
+  if (cb) cb(_ih);
+}
 
-	id find_sub_menu = [[[NSMenu alloc] init] autorelease];
-	[find_sub_menu setTitle:NSLocalizedString(@"Find", @"Find")];
-	[findroot_menu_item setSubmenu:find_sub_menu];
-	
-	id find_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Find", @"Find") action:@selector(performFindPanelAction:) keyEquivalent:@"f"] autorelease];
-	id findreplace_menu_item = [[[NSMenuItem alloc] initWithTitle:[NSLocalizedString(@"Find and Replace", @"Find and Replace") stringByAppendingString:@""] action:@selector(performFindPanelAction:) keyEquivalent:@"f"] autorelease];
-	[findreplace_menu_item setKeyEquivalentModifierMask:NSEventModifierFlagOption|NSEventModifierFlagCommand];
-	id findnext_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Find Next", @"Find Next") action:@selector(performFindPanelAction:) keyEquivalent:@"g"] autorelease];
-	id findprevious_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Find Previous", @"Find Previous") action:@selector(performFindPanelAction:) keyEquivalent:@"G"] autorelease];
-	id useselection_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Use Selection for Find", @"Use Selection for Find") action:@selector(performFindPanelAction:) keyEquivalent:@"e"] autorelease];
-	id jumpselection_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Jump to Selection", @"Jump to Selection") action:@selector(centerSelectionInVisibleArea:) keyEquivalent:@"j"] autorelease];
+- (void) menuWillHighlightItem:(NSMenuItem*)item
+{
+  if (!item) return;
 
-	
-	
-	[find_sub_menu addItem:find_menu_item];
-	[find_sub_menu addItem:findreplace_menu_item];
-	[find_sub_menu addItem:findnext_menu_item];
-	[find_sub_menu addItem:findprevious_menu_item];
-	[find_sub_menu addItem:useselection_menu_item];
-	[find_sub_menu addItem:jumpselection_menu_item];
+  Ihandle* item_ih = (Ihandle*)objc_getAssociatedObject(item, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!item_ih) return;
 
+  Icallback cb = IupGetCallback(item_ih, "HIGHLIGHT_CB");
+  if (cb) cb(item_ih);
+}
 
-	id edit_menu_category = [[[NSMenuItem alloc] init] autorelease];
-	[edit_menu_category setSubmenu:edit_menu];
-	// This is supposed to do nothing. This is a cheat so I can look up this menu item later and try to reuse it.
-	[edit_menu_category setTitle:NSLocalizedString(@"Edit", @"Edit")];
+@end
 
-	
-/*
-	id minimize_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Minimize", @"Minimize") action:@selector(performMiniaturize:) keyEquivalent:@"m"] autorelease];
-	id zoom_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Zoom", @"Zoom") action:@selector(performZoom:) keyEquivalent:@""] autorelease];
-	id bringallfront_menu_item = [[[NSMenuItem alloc] initWithTitle:NSLocalizedString(@"Bring All to Front", @"Bring All to Front") action:@selector(arrangeInFront:) keyEquivalent:@""] autorelease];
 
+@interface IupCocoaMenuItemTarget : NSObject<NSMenuItemValidation>
+{
+  Ihandle* _ih;
+}
+@property (nonatomic, assign) Ihandle* ih;
+- (instancetype) initWithIhandle:(Ihandle*)ih;
+- (void) onMenuItemAction:(id)sender;
+- (BOOL) validateMenuItem:(NSMenuItem*)menuItem;
+@end
 
-	id window_menu = [[[NSMenu alloc] init] autorelease];
-	[window_menu setTitle:NSLocalizedString(@"Window", @"Window")];
-	
-	[window_menu addItem:minimize_menu_item];
-	[window_menu addItem:zoom_menu_item];
-	[window_menu addItem:[NSMenuItem separatorItem]];
-	[window_menu addItem:bringallfront_menu_item];
+@implementation IupCocoaMenuItemTarget
+@synthesize ih = _ih;
 
-	id window_menu_category = [[[NSMenuItem alloc] init] autorelease];
-	[window_menu_category setSubmenu:window_menu];
-	// This is supposed to do nothing. This is a cheat so I can look up this menu item later and try to reuse it.
-	[window_menu_category setTitle:NSLocalizedString(@"Window", @"Window")];
-*/
-	NSNib* window_menu_category_nib = [[[NSNib alloc] initWithNibNamed:@"CanonicalWindowMenu" bundle:framework_bundle] autorelease];
-	top_level_objects = nil;
-	id window_menu_category = nil;
-	if([window_menu_category_nib instantiateWithOwner:nil topLevelObjects:&top_level_objects])
-	{
-		for(id current_object in top_level_objects)
-		{
-			if([current_object isKindOfClass:[NSMenuItem class]])
-			{
-				window_menu_category = current_object;
-				break;
-			}
-		}
-	}
-	// This is supposed to do nothing. This is a cheat so I can look up this menu item later and try to reuse it.
-	[window_menu_category setTitle:NSLocalizedString(@"Window", @"Window")];
-	
-	
-	id help_menu_item = [[[NSMenuItem alloc] initWithTitle:[[app_name stringByAppendingString:@" "] stringByAppendingString:NSLocalizedString(@"Help", @"Help")] action:@selector(showHelp:) keyEquivalent:@"?"] autorelease];
-	id help_menu = [[[NSMenu alloc] init] autorelease];
-	[help_menu setTitle:NSLocalizedString(@"Help", @"Help")];
-	
-	[help_menu addItem:help_menu_item];
+- (instancetype) initWithIhandle:(Ihandle*)ih
+{
+  self = [super init];
+  if (self)
+  {
+    _ih = ih;
+  }
+  return self;
+}
 
-	id help_menu_category = [[[NSMenuItem alloc] init] autorelease];
-	[help_menu_category setSubmenu:help_menu];
-	// This is supposed to do nothing. This is a cheat so I can look up this menu item later and try to reuse it.
-	[help_menu_category setTitle:NSLocalizedString(@"Window", @"Window")];
-	
-	
-	id menu_bar = [[[NSMenu alloc] init] autorelease];
-	[NSApp setMainMenu:menu_bar];
-	
-	[menu_bar addItem:app_menu_category];
-	[menu_bar addItem:file_menu_category];
-	[menu_bar addItem:edit_menu_category];
-	[menu_bar addItem:window_menu_category];
-	[menu_bar addItem:help_menu_category];
-#else
-	
-	NSNib* main_menu_nib = nil;
+- (void) dealloc
+{
+  _ih = NULL;
+  [super dealloc];
+}
 
-	// If the user supplies a MainMenu.xib in their own application bundle, allow the user to override our default one.
+- (void) onMenuItemAction:(id)sender
+{
+  if (!_ih) return;
 
-	// initWithNibNamed will throw an exception if not found. I could catch the exception, but I would rather avoid the whole exception mechanism if possible.
-	// I've read claims we only need to check for nib (and not also xib) since these are always supposed to be compiled to nib.
-	if([[NSBundle mainBundle] pathForResource:@"MainMenu" ofType:@"nib"] != nil)
-	{
-		main_menu_nib = [[[NSNib alloc] initWithNibNamed:@"MainMenu" bundle:nil] autorelease];
-	}
-	else
-	{
-		NSBundle* framework_bundle = [NSBundle bundleWithIdentifier:@"br.puc-rio.tecgraf.iup"];
-		main_menu_nib = [[[NSNib alloc] initWithNibNamed:@"IupMainMenu" bundle:framework_bundle] autorelease];
-	}
+  if (iupStrEqual(_ih->iclass->name, "submenu"))
+    return;
 
-	NSMenu* menu_bar = nil;
+  NSMenuItem* menu_item = (NSMenuItem*)sender;
 
-	NSArray* top_level_objects = nil;
-	if([main_menu_nib instantiateWithOwner:nil topLevelObjects:&top_level_objects])
-	{
-		for(id current_object in top_level_objects)
-		{
-			if([current_object isKindOfClass:[NSMenu class]])
-			{
-				menu_bar = current_object;
-				[NSApp setMainMenu:current_object];
-				break;
-			}
-		}
-	}
-	// Go through the items and replace the hardcoded MacCocoaAppTemplate with the real app name.
-	for(NSMenuItem* current_top_item in [menu_bar itemArray])
-	{
+  if (iupAttribGetBoolean(_ih->parent, "RADIO"))
+  {
+    cocoaItemUpdateRadioGroup(_ih);
+  }
+  else if (iupAttribGetBoolean(_ih, "AUTOTOGGLE"))
+  {
+    NSInteger current_state = [menu_item state];
+    BOOL new_state = (current_state != NSControlStateValueOn);
 
-		{
-			NSString* title_string = [current_top_item title];
-			NSString* fixed_string = [title_string stringByReplacingOccurrencesOfString:@"MacCocoaAppTemplate" withString:app_name];
-			if(![title_string isEqualToString:fixed_string])
-			{
-				[current_top_item setTitle:fixed_string];
-			}
-		}
-		
-		NSMenu* current_menu = [current_top_item submenu];
-		// Note: This does not recurse down submenus of the primary submenu
-		for(NSMenuItem* current_menu_item in [current_menu itemArray])
-		{
-			NSString* title_string = [current_menu_item title];
-			NSString* fixed_string = [title_string stringByReplacingOccurrencesOfString:@"MacCocoaAppTemplate" withString:app_name];
-			if(![title_string isEqualToString:fixed_string])
-			{
-				[current_menu_item setTitle:fixed_string];
-			}
-		}
-	}
+    iupAttribSet(_ih, "VALUE", new_state ? "ON" : "OFF");
+    [menu_item setState:new_state ? NSControlStateValueOn : NSControlStateValueOff];
 
-#endif
+    cocoaMenuUpdateImage(_ih);
+  }
+
+  Icallback cb = IupGetCallback(_ih, "ACTION");
+  if (cb && cb(_ih) == IUP_CLOSE)
+    IupExitLoop();
 }
-@interface IupCocoaMenuItemRepresentedObject : NSObject
+
+- (BOOL) validateMenuItem:(NSMenuItem*)menuItem
 {
-	Ihandle* _ih;
+  if (!_ih) return YES;
+
+  char* active = cocoaItemGetActiveAttrib(_ih);
+  return (BOOL)iupStrBoolean(active);
 }
-- (instancetype) initWithIhandle:(Ihandle*)ih;
-- (Ihandle*) ih;
+
 @end
 
-@implementation IupCocoaMenuItemRepresentedObject
 
-- (instancetype) initWithIhandle:(Ihandle*)ih
+/*******************************************************************************************/
+/* Helper Functions                                                                        */
+/*******************************************************************************************/
+
+static void cocoaItemUpdateRadioGroup(Ihandle* ih)
 {
-	self = [super init];
-	if(nil == self)
-	{
-		return nil;
-	}
-	_ih = ih;
-	return self;
+  if (!ih || !ih->parent) return;
+  if (!iupAttribGetBoolean(ih->parent, "RADIO")) return;
+
+  Ihandle* child;
+
+  /* Set the selected item to ON and all others to OFF */
+  for (child = ih->parent->firstchild; child; child = child->brother)
+  {
+    if (iupStrEqual(child->iclass->name, "item") && child->handle)
+    {
+      BOOL shouldBeOn = (child == ih);
+      NSInteger desiredState = shouldBeOn ? NSControlStateValueOn : NSControlStateValueOff;
+      [(NSMenuItem*)child->handle setState:desiredState];
+      iupAttribSet(child, "VALUE", shouldBeOn ? "ON" : "OFF");
+    }
+  }
+
+  /* Update images for all items to reflect the new state */
+  for (child = ih->parent->firstchild; child; child = child->brother)
+  {
+    if (iupStrEqual(child->iclass->name, "item") && child->handle)
+    {
+      cocoaMenuUpdateImage(child);
+    }
+  }
 }
 
-- (Ihandle*) ih
+static int cocoaMenuSetBgColorAttrib(Ihandle* ih, const char* value)
 {
-	return _ih;
+  /* NSMenu does not support custom background colors on macOS.
+     Menu appearance is controlled by the system. */
+  (void)ih;
+  (void)value;
+  return 0;
 }
 
-- (IBAction) onMenuItemAction:(id)the_sender
+/* Checks if a given menu contains the standard "Quit" application item. */
+static BOOL cocoaMenuContainsQuitItem(NSMenu* menu)
 {
-	Ihandle* ih = [self ih];
-	Icallback call_back;
-	
-	call_back = IupGetCallback(ih, "ACTION");
-	if(call_back)
-	{
-		int ret_val = call_back(ih);
-		if(IUP_CLOSE == ret_val)
-		{
-			IupExitLoop();
-			
-		}
-	}
-	
+  if (!menu) return NO;
+  for (NSMenuItem* item in [menu itemArray])
+  {
+    if ([item action] == @selector(terminate:))
+    {
+      return YES;
+    }
+  }
+  return NO;
 }
 
-// setEnabled: won't work unless we disable autoenablesItems, which I don't want to do because it disables a lot of useful automatic behavior for default menu items.
-// So we must use validateMenuItem.
-// The trick we can use is that our custom (non-default) menu items use this IupCocoMenuItemRepresentedObject.
-// So we can just query the attribute for ACTIVE on the ih, to see if the user turned it on or off and use that for the result for validateMenuItem
-- (BOOL) validateMenuItem:(NSMenuItem*)menu_item
+/* Finds an NSMenuItem with a specific title (case-insensitive) within a menu. */
+static NSMenuItem* cocoaMenuFindTitledItem(NSMenu* menu, NSString* title)
 {
-	Ihandle* ih = [self ih];
+  if (!menu || !title) return nil;
+  for (NSMenuItem* item in [menu itemArray])
+  {
+    NSString* itemTitle = [item title];
 
-	//	NSLog(@"param menu_item: %@", menu_item);
-	//	NSMenuItem* ih_menu_item = (NSMenuItem*)ih->handle;
-	//	NSLog(@"ih_menu_item: %@", ih_menu_item);
+    /* If the item title is empty (common for the App Menu wrapper at index 0, or IupItem wrappers), check the submenu title. */
+    if ((!itemTitle || [itemTitle length] == 0) && [item submenu]) {
+      itemTitle = [[item submenu] title];
+    }
 
-	// It appears that the initial default value is NULL, and not explicit YES or NO.
-	// We must use IupGetAttribute instead of IupGetInt to detect the NULL value.
-	// If NULL, we treat as ACTIVE.
-	char* active_value = IupGetAttribute(ih, "ACTIVE");
-//	NSLog(@"active_value: %s", active_value);
-	if(NULL == active_value)
-	{
-		return YES;
-	}
-	else
-	{
-		int is_enabled = IupGetInt(ih, "ACTIVE");
-		return is_enabled;
-	}
-	
+    if (itemTitle && [itemTitle caseInsensitiveCompare:title] == NSOrderedSame)
+    {
+      return item;
+    }
+  }
+  return nil;
+}
 
+static void cocoaMenuUpdateImage(Ihandle* ih)
+{
+  NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
+  if (!menu_item) return;
+
+  int active = iupAttribGetBoolean(ih, "ACTIVE");
+  const char* inactive_suffix = active ? NULL : "IMINACTIVE";
+
+  char* icon_name = iupAttribGet(ih, "TITLEIMAGE");
+  if (icon_name)
+  {
+    NSImage* image = (NSImage*)iupImageGetImage(icon_name, ih, 0, inactive_suffix);
+    [menu_item setImage:image];
+  }
+  else
+  {
+    if (iupStrEqual(ih->iclass->name, "submenu"))
+    {
+      char* image_name = iupAttribGet(ih, "IMAGE");
+      if (image_name)
+      {
+        NSImage* image = (NSImage*)iupImageGetImage(image_name, ih, 0, inactive_suffix);
+        [menu_item setImage:image];
+      }
+      else
+      {
+        [menu_item setImage:nil];
+      }
+    }
+    else
+    {
+      [menu_item setImage:nil];
+    }
+  }
+
+  if (iupStrEqual(ih->iclass->name, "item"))
+  {
+    char* image_off = iupAttribGet(ih, "IMAGE");
+    char* image_on = iupAttribGet(ih, "IMPRESS");
+
+    if (iupAttribGetBoolean(ih, "HIDEMARK") && !iupAttribGetBoolean(ih->parent, "RADIO"))
+    {
+      [menu_item setOnStateImage:nil];
+      [menu_item setOffStateImage:nil];
+      [menu_item setMixedStateImage:nil];
+    }
+    else if (image_off || image_on)
+    {
+      NSImage* ns_image_off = nil;
+      if (image_off)
+      {
+        ns_image_off = (NSImage*)iupImageGetImage(image_off, ih, 0, inactive_suffix);
+      }
+
+      NSImage* ns_image_on = nil;
+      if (image_on)
+      {
+        ns_image_on = (NSImage*)iupImageGetImage(image_on, ih, 0, inactive_suffix);
+      }
+      else if (image_off)
+      {
+        ns_image_on = ns_image_off;
+      }
+
+      [menu_item setOffStateImage:ns_image_off];
+      [menu_item setOnStateImage:ns_image_on];
+    }
+    else
+    {
+      NSImage* checkmark = [NSImage imageNamed:NSImageNameMenuOnStateTemplate];
+      if (checkmark)
+      {
+        [menu_item setOnStateImage:checkmark];
+      }
+      [menu_item setOffStateImage:nil];
+
+      NSImage* mixedmark = [NSImage imageNamed:NSImageNameMenuMixedStateTemplate];
+      if (mixedmark)
+      {
+        [menu_item setMixedStateImage:mixedmark];
+      }
+    }
+  }
 }
 
-@end
+static void cocoaMenuSetTitle(Ihandle* ih, id handle, const char* value)
+{
+  if (!handle) return;
 
-@interface IupCocoaMenuDelegate : NSObject<NSMenuDelegate>
+  if (!value || value[0] == 0)
+  {
+    value = "     ";
+  }
 
-// Use for HIGHLIGHT_CB?
-//- (void) menu:(NSMenu*)the_menu willHighlightItem:(NSMenuItem*)menu_item;
-@end
+  char* title_str = iupStrProcessMnemonic(value, NULL, 0);
 
+  NSString* ns_title = nil;
+  if (title_str)
+  {
+    ns_title = [NSString stringWithUTF8String:title_str];
+  }
 
-@implementation IupCocoaMenuDelegate
+  if (!ns_title)
+  {
+    ns_title = @"";
+  }
 
+  if ([handle isKindOfClass:[NSMenuItem class]])
+  {
+    NSMenuItem* item = (NSMenuItem*)handle;
 
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+    NSDictionary* attributes = nil;
+    if (iup_font)
+    {
+      attributes = [iup_font attributeDictionary];
+    }
 
-// Use for HIGHLIGHT_CB?
-/*
-- (void) menu:(NSMenu*)the_menu willHighlightItem:(NSMenuItem*)menu_item
-{
+    void (^applyTitle)(NSMenuItem*) = ^(NSMenuItem* targetItem) {
+      if (attributes && [attributes count] > 0)
+      {
+        NSAttributedString* newAttributedTitle = [[NSAttributedString alloc] initWithString:ns_title attributes:attributes];
+        [targetItem setAttributedTitle:newAttributedTitle];
+        [newAttributedTitle release];
+      }
+      else
+      {
+        [targetItem setAttributedTitle:nil];
+        [targetItem setTitle:ns_title];
+      }
+    };
+
+    applyTitle(item);
+
+    NSMenuItem* wrapperItem = (NSMenuItem*)objc_getAssociatedObject(item, MENUBAR_ITEM_WRAPPER_KEY);
+    if (wrapperItem)
+    {
+      applyTitle(wrapperItem);
+
+      NSMenu* submenu = [wrapperItem submenu];
+      if (submenu)
+      {
+        [submenu setTitle:ns_title];
+      }
+    }
+  }
+  else if ([handle respondsToSelector:@selector(setTitle:)])
+  {
+    [handle setTitle:ns_title];
+  }
+
+  if (title_str && title_str != value)
+    free(title_str);
 }
-*/
 
+static int cocoaMenuItemSetFontAttrib(Ihandle* ih, const char* value)
+{
+  if (!iupdrvSetFontAttrib(ih, value))
+    return 0;
 
-@end
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
 
+  if (!item) return 1;
 
+  char* title = iupAttribGet(ih, "TITLE");
+  if (!title) title = "";
+
+  cocoaMenuSetTitle(ih, item, title);
+
+  return 1;
+}
+
+/*******************************************************************************************/
+/* Driver Functions                                                                        */
+/*******************************************************************************************/
+
 int iupdrvMenuPopup(Ihandle* ih, int x, int y)
 {
-	NSWindow* key_window = [[NSApplication sharedApplication] keyWindow];
-	NSInteger window_number = [key_window windowNumber];
-	NSView* content_view = [key_window contentView];
+  NSMenu* menu = (NSMenu*)ih->handle;
+  if (!menu) {
+    return IUP_ERROR;
+  }
 
-	// The y passed in is inverted (IUP coordinate system). We need to flip back to cartesian.
-	NSRect screen_rect = [[NSScreen mainScreen] frame];
-	CGFloat cartesian_y = screen_rect.size.height - y;
-	
-	NSRect absolute_menu_rect = { x, cartesian_y, 0, 0 };
-	NSRect converted_window_rect = [key_window convertRectFromScreen:absolute_menu_rect];
+  NSPoint location = NSMakePoint(x, iupcocoaComputeCartesianScreenHeightFromIup(y));
 
+  char* align_value = iupAttribGet(ih, "POPUPALIGN");
+  if (align_value)
+  {
+    char value1[30], value2[30];
+    iupStrToStrStr(align_value, value1, value2, ':');
 
-	NSPoint converted_point = converted_window_rect.origin;
-	
-//		NSPoint converted_point = [self convertPoint:the_point fromView:nil];
-	
-    NSEvent* the_event = [NSEvent otherEventWithType:NSEventTypeApplicationDefined
-		location:converted_point
-		modifierFlags:(NSEventModifierFlags)0
-		timestamp:(NSTimeInterval)0
-		windowNumber:window_number
-		context:[NSGraphicsContext currentContext]
-		subtype:0
-		data1:0
-		data2:0
-	];
+    NSSize menu_size = [menu size];
 
-	// IMPORTANT: popUpContentMenu blocks until the menu is dismissed.
-	// This actually works to our advantage because IUP's API design seems to implicitly assume this and the example in menu.c
-	// immediately calls IupDestroy(menu) right after
-	// IupPopup(menu, IUP_MOUSEPOS, IUP_MOUSEPOS);
-	// Destroying the menu before we are done would be very bad news
-	// because we need a valid ih to look up the user's callback functions for the menu items they created.
-    [NSMenu popUpContextMenu:ih->handle withEvent:the_event forView:content_view];
-	return IUP_NOERROR;
+    if (iupStrEqualNoCase(value1, "ARIGHT"))
+      location.x -= menu_size.width;
+    else if (iupStrEqualNoCase(value1, "ACENTER"))
+      location.x -= menu_size.width / 2;
+
+    if (iupStrEqualNoCase(value2, "ABOTTOM"))
+      location.y += menu_size.height;
+    else if (iupStrEqualNoCase(value2, "ACENTER"))
+      location.y += menu_size.height / 2;
+  }
+
+  [menu popUpMenuPositioningItem:nil atLocation:location inView:nil];
+
+  return IUP_NOERROR;
 }
 
 int iupdrvMenuGetMenuBarSize(Ihandle* ih)
 {
-	CGFloat menu_bar_height = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
-	return iupROUND(menu_bar_height);
+  (void)ih;
+  /* Standard macOS menu bar height approximation. */
+  return 24;
 }
 
-/*
-static void cocoaReleaseMenuClass(Iclass* ic)
+
+/*******************************************************************************************/
+/* Application Menu Functions                                                              */
+/*******************************************************************************************/
+
+/* Creates the standard macOS "Application" menu (About, Services, Hide, Quit) */
+static void cocoaMenuCreateAppMenu(NSMenu* main_menu)
 {
-	// Not sure if I should tear this down. Typically apps just quit and leave all this stuff.
-	[NSApp setMainMenu:nil];
+  NSString* app_name = [[NSProcessInfo processInfo] processName];
+  if (!app_name || [app_name length] == 0) app_name = @"Application";
 
+  NSMenuItem* app_item = [[NSMenuItem alloc] initWithTitle:@"" action:nil keyEquivalent:@""];
+  NSMenu* app_menu = [[NSMenu alloc] initWithTitle:app_name];
+
+  [app_menu addItemWithTitle:[NSString stringWithFormat:@"About %@", app_name] action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@""];
+
+  [app_menu addItem:[NSMenuItem separatorItem]];
+
+  NSMenuItem* services_item = [app_menu addItemWithTitle:@"Services" action:nil keyEquivalent:@""];
+  NSMenu* services_menu = [[NSMenu alloc] initWithTitle:@"Services"];
+  [services_item setSubmenu:services_menu];
+  [[NSApplication sharedApplication] setServicesMenu:services_menu];
+  [services_menu release];
+
+  [app_menu addItem:[NSMenuItem separatorItem]];
+
+  [app_menu addItemWithTitle:[NSString stringWithFormat:@"Hide %@", app_name] action:@selector(hide:) keyEquivalent:@"h"];
+
+  NSMenuItem* hide_others = [app_menu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"];
+  [hide_others setKeyEquivalentModifierMask: NSEventModifierFlagCommand | NSEventModifierFlagOption];
+
+  [app_menu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""];
+
+  [app_menu addItem:[NSMenuItem separatorItem]];
+
+  [app_menu addItemWithTitle:[NSString stringWithFormat:@"Quit %@", app_name] action:@selector(terminate:) keyEquivalent:@"q"];
+
+
+  /* Attach the submenu and insert into the main menu at the beginning */
+  [app_item setSubmenu:app_menu];
+  [main_menu insertItem:app_item atIndex:0];
+
+  [app_menu release];
+  [app_item release];
 }
-*/
 
+/* Creates a placeholder "File" menu. */
+static void cocoaMenuCreateFileMenu(NSMenu* main_menu)
+{
+  NSMenuItem* file_item = [[NSMenuItem alloc] initWithTitle:@"File" action:nil keyEquivalent:@""];
+  NSMenu* file_menu = [[NSMenu alloc] initWithTitle:@"File"];
 
-int iupCocoaMenuIsApplicationBar(Ihandle* ih)
+  [file_menu addItemWithTitle:@"New" action:@selector(newDocument:) keyEquivalent:@"n"];
+  [file_menu addItemWithTitle:@"Open..." action:@selector(openDocument:) keyEquivalent:@"o"];
+  [file_menu addItem:[NSMenuItem separatorItem]];
+  [file_menu addItemWithTitle:@"Close" action:@selector(performClose:) keyEquivalent:@"w"];
+  [file_menu addItemWithTitle:@"Save..." action:@selector(saveDocument:) keyEquivalent:@"s"];
+
+  [file_item setSubmenu:file_menu];
+  [main_menu addItem:file_item];
+
+  [file_menu release];
+  [file_item release];
+}
+
+/* Creates a standard macOS "Edit" menu (Undo, Redo, Cut, Copy, Paste). */
+static void cocoaMenuCreateEditMenu(NSMenu* main_menu)
 {
-	if (ih->iclass->nativetype == IUP_TYPEMENU)
-	{
-		int is_app_menu = IupGetInt(ih, "_IUPMAC_APPMENU");
-		if(is_app_menu)
-		{
-			return 1;
-		}
-	}
+  NSMenuItem* edit_item = [[NSMenuItem alloc] initWithTitle:@"Edit" action:nil keyEquivalent:@""];
+  NSMenu* edit_menu = [[NSMenu alloc] initWithTitle:@"Edit"];
 
-	return 0;
+  [edit_menu addItemWithTitle:@"Undo" action:@selector(undo:) keyEquivalent:@"z"];
+  [edit_menu addItemWithTitle:@"Redo" action:@selector(redo:) keyEquivalent:@"Z"];
+  [edit_menu addItem:[NSMenuItem separatorItem]];
+  [edit_menu addItemWithTitle:@"Cut" action:@selector(cut:) keyEquivalent:@"x"];
+  [edit_menu addItemWithTitle:@"Copy" action:@selector(copy:) keyEquivalent:@"c"];
+  [edit_menu addItemWithTitle:@"Paste" action:@selector(paste:) keyEquivalent:@"v"];
+  [edit_menu addItemWithTitle:@"Select All" action:@selector(selectAll:) keyEquivalent:@"a"];
+
+  [edit_item setSubmenu:edit_menu];
+  [main_menu addItem:edit_item];
+
+  [edit_menu release];
+  [edit_item release];
 }
 
-// Note: This only gets the user's Ihandle to the application menu. If the user doesn't set it, the default application will not be returned in its place. NULL will be returned instead.
-Ihandle* iupCocoaMenuGetApplicationMenu()
+/* Creates the standard macOS "Window" menu (Minimize, Zoom, etc.) */
+static void cocoaMenuCreateWindowMenu(NSMenu* main_menu)
 {
-	return s_currentIupMainMenu;
+  NSMenuItem* window_item = [[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""];
+  NSMenu* window_menu = [[NSMenu alloc] initWithTitle:@"Window"];
+
+  [window_menu addItemWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"];
+  [window_menu addItemWithTitle:@"Zoom" action:@selector(performZoom:) keyEquivalent:@""];
+  [window_menu addItem:[NSMenuItem separatorItem]];
+  [window_menu addItemWithTitle:@"Bring All to Front" action:@selector(arrangeInFront:) keyEquivalent:@""];
+
+  [window_item setSubmenu:window_menu];
+  [main_menu addItem:window_item];
+
+  [window_menu release];
+  [window_item release];
 }
 
-// My current understanding is that IUP will not clean up our application menu Ihandles. So we need to do it ourselves.
-void iupCocoaMenuCleanupApplicationMenu()
+/* Creates a standard macOS "Help" menu. */
+static void cocoaMenuCreateHelpMenu(NSMenu* main_menu)
 {
-	// I believe (hope) this goes through all submenus and items and cleans up everything the user may have created for the main menu.
-	// (Remember, the app menu merges default items. So this only cleans up things users explicitly create.
-	IupDestroy(s_currentIupMainMenu);
+  NSMenuItem* help_item = [[NSMenuItem alloc] initWithTitle:@"Help" action:nil keyEquivalent:@""];
+  NSMenu* help_menu = [[NSMenu alloc] initWithTitle:@"Help"];
 
-	// remember to reset the pointer in case the user keeps going and calls IupOpen again.
-	s_currentIupMainMenu = NULL;
-	
+  NSString* app_name = [[NSProcessInfo processInfo] processName];
+  if (!app_name || [app_name length] == 0) app_name = @"Application";
+  [help_menu addItemWithTitle:[NSString stringWithFormat:@"%@ Help", app_name] action:@selector(showHelp:) keyEquivalent:@"?"];
 
-	// Let's try not to leave anything behind to avoid accidental leaks in the NSAutoreleasePool drain.
-	[NSApp setMainMenu:nil];
+  [help_item setSubmenu:help_menu];
+  [main_menu addItem:help_item];
 
+  [help_menu release];
+  [help_item release];
 }
 
+/* Synchronizes the NSApplication's standard Window and Help menus with the provided menu bar. */
+static void cocoaMenuSynchronizeStandardMenus(NSMenu* menuBar)
+{
+  if (!menuBar) {
+    [[NSApplication sharedApplication] setWindowsMenu:nil];
+    [[NSApplication sharedApplication] setHelpMenu:nil];
+    return;
+  }
 
-// Helper to set the menu.
-void iupCocoaMenuSetApplicationMenu(Ihandle* ih)
+  NSMenuItem* windowItem = cocoaMenuFindTitledItem(menuBar, @"Window");
+  if (windowItem && [windowItem hasSubmenu]) {
+    [[NSApplication sharedApplication] setWindowsMenu:[windowItem submenu]];
+  } else {
+    [[NSApplication sharedApplication] setWindowsMenu:nil];
+  }
+
+  NSMenuItem* helpItem = cocoaMenuFindTitledItem(menuBar, @"Help");
+  if (helpItem && [helpItem hasSubmenu]) {
+    [[NSApplication sharedApplication] setHelpMenu:[helpItem submenu]];
+  } else {
+    [[NSApplication sharedApplication] setHelpMenu:nil];
+  }
+}
+
+
+/* Ensures that a default application menu exists and is set if no other menu is active. */
+void iupcocoaEnsureDefaultApplicationMenu(void)
 {
-	
+  if (s_defaultApplicationMenu == nil)
+  {
+    s_defaultApplicationMenu = [[NSMenu alloc] initWithTitle:@"DefaultMainMenu"];
+    [s_defaultApplicationMenu setAutoenablesItems:NO];
 
-	
-	if(NULL == ih)
-	{
-		// remove the existing menu?
+    if (s_defaultApplicationMenu)
+    {
+      cocoaMenuCreateAppMenu(s_defaultApplicationMenu);
+      cocoaMenuCreateFileMenu(s_defaultApplicationMenu);
+      cocoaMenuCreateEditMenu(s_defaultApplicationMenu);
+      cocoaMenuCreateWindowMenu(s_defaultApplicationMenu);
+      cocoaMenuCreateHelpMenu(s_defaultApplicationMenu);
+    }
+  }
 
-		// We need a way to know if there was a previous MainMenu set. If so, we need to UnMap that object.
-		if(NULL != s_currentIupMainMenu)
-		{
-			IupUnmap(s_currentIupMainMenu);
-			s_currentIupMainMenu = NULL;
-		}
-		
-		[NSApp setMainMenu:nil];
-		
-		// We just removed everything in the menu. We want to restore the default menu.
-		cocoaCreateDefaultApplicationMenu();
+  if ([[NSApplication sharedApplication] mainMenu] == nil)
+  {
+    if (s_defaultApplicationMenu)
+    {
+      cocoaMenuSynchronizeStandardMenus(s_defaultApplicationMenu);
+      [[NSApplication sharedApplication] setMainMenu:s_defaultApplicationMenu];
+    }
+  }
+}
 
-	}
-	else
-	{
-		// add the menu
-		
-		// identify this is a app menu
-		IupSetInt(ih, "_IUPMAC_APPMENU", 1);
-		
-		// User error?
-		if(ih->iclass->nativetype != IUP_TYPEMENU)
-		{
-			// call IUPASSERT?
-			return;
-		}
-		
-		// We need a way to know if there was a previous MainMenu set. If so, we need to UnMap that object.
-		if(NULL != s_currentIupMainMenu)
-		{
-			// check if the user has already set this menu before and is the current menu
-			if(ih->handle == s_currentIupMainMenu)
-			{
-				// we don't need to do anything since this is the same menu
-				return;
-			}
-			else
-			{
-				// this is a different menu so we want to remove the old one
-				IupUnmap(s_currentIupMainMenu);
-				s_currentIupMainMenu = NULL;
-			}
-		}
-		
-		
-		// I don't think it is possible to have an already Mapped menu, but just in case, I'll check. (Maybe this should be an assert)
-		if(ih->handle)
-		{
-			// don't call Map since it already is created
-		}
-		else
-		{
-			IupMap(ih);
-		}
-		[NSApp setMainMenu:(NSMenu*)ih->handle];
-		s_currentIupMainMenu = ih;
-	}
-	
-	
+Ihandle* iupcocoaMenuGetApplicationMenu(void)
+{
+  return s_currentIupApplicationMenu;
+}
 
-	
-#if 0
-	if (!ih->handle)
-	{
-		Ihandle* menu = IupGetHandle(value);
-		ih->data->menu = menu;
-		return 1;
-	}
-	
-	if (!value)
-	{
-		if (ih->data->menu && ih->data->menu->handle)
-		{
-			ih->data->ignore_resize = 1;
-			IupUnmap(ih->data->menu);  /* this will remove the menu from the dialog */
-			ih->data->ignore_resize = 0;
-			
-			ih->data->menu = NULL;
-		}
-	}
-	else
-	{
-		Ihandle* menu = IupGetHandle(value);
-		if (!menu || menu->iclass->nativetype != IUP_TYPEMENU || menu->parent)
-			return 0;
-		
-		/* already the current menu and it is mapped */
-		if (ih->data->menu && ih->data->menu==menu && menu->handle)
-			return 1;
-		
-		/* the current menu is mapped, so unmap it */
-		if (ih->data->menu && ih->data->menu->handle && ih->data->menu!=menu)
-		{
-			ih->data->ignore_resize = 1;
-			IupUnmap(ih->data->menu);   /* this will remove the menu from the dialog */
-			ih->data->ignore_resize = 0;
-		}
-		
-		ih->data->menu = menu;
-		
-		menu->parent = ih;    /* use this to create a menu bar instead of a popup menu */
-		
-		ih->data->ignore_resize = 1;
-		IupMap(menu);     /* this will automatically add the menu to the dialog */
-		ih->data->ignore_resize = 0;
-	}
-	return 1;
-	
-#endif
-	
+/* Checks if the given Ihandle is the currently active application menu bar. */
+int iupcocoaMenuIsApplicationBar(Ihandle* ih)
+{
+  int result = (ih != NULL && ih == s_currentIupApplicationMenu);
+  return result;
 }
 
+/* Called during iupdrvClose to clean up resources. */
+void iupcocoaMenuCleanupApplicationMenu(void)
+{
+  s_currentIupApplicationMenu = NULL;
 
+  if (s_defaultApplicationMenu)
+  {
+    if ([[NSApplication sharedApplication] mainMenu] == s_defaultApplicationMenu)
+    {
+      [[NSApplication sharedApplication] setMainMenu:nil];
+    }
+    [s_defaultApplicationMenu release];
+    s_defaultApplicationMenu = nil;
+  }
+}
 
-static int cocoaMenuMapMethod(Ihandle* ih)
+/* Sets the given Ihandle (IupMenu) as the application's main menu bar.
+   This is the central function for switching the application menu. */
+void iupcocoaMenuSetApplicationMenu(Ihandle* ih)
 {
-	if(iupMenuIsMenuBar(ih))
-	{
-		return IUP_ERROR;
-#if 0
-		/* top level menu used for MENU attribute in IupDialog (a menu bar) */
-		NSLog(@"cocoaMenuMapMethod iupMenuIsMenuBar %@", ih->parent->handle);
+  if (ih && s_currentIupApplicationMenu == ih) {
+    return;
+  }
 
-		NSMenu* main_menu = [NSApp mainMenu];
-		
-		ih->handle = main_menu;
-		
-		// not sure if I should retain it because I don't know if this is going to ever get released, but probably should to obey normal patterns.
-		[main_menu retain];
-#endif
-	}
-	else if(iupCocoaMenuIsApplicationBar(ih))
-	{
-		/* top level menu used for MENU attribute in IupDialog (a menu bar) */
+  /* Restore the default menu. */
+  if (!ih)
+  {
+    iupcocoaEnsureDefaultApplicationMenu(); /* Ensure it exists */
+    if ([[NSApplication sharedApplication] mainMenu] != s_defaultApplicationMenu)
+    {
+      cocoaMenuSynchronizeStandardMenus(s_defaultApplicationMenu);
+      [[NSApplication sharedApplication] setMainMenu:s_defaultApplicationMenu];
+    }
+    s_currentIupApplicationMenu = NULL; /* Update IUP tracking */
+    return;
+  }
 
-		NSMenu* main_menu = [NSApp mainMenu];
-		
-		ih->handle = main_menu;
+  /* Set a new IUP menu. */
+  if (!ih->handle) {
+    IupMap(ih);
+  }
 
-		// not sure if I should retain it because I don't know if this is going to ever get released, but probably should to obey normal patterns.
-		[main_menu retain];
-		
+  if (ih->handle && [(id)ih->handle isKindOfClass:[NSMenu class]])
+  {
+    NSMenu* menu = (NSMenu*)ih->handle;
 
+    NSMenuItem* appMenuItem = ([menu numberOfItems] > 0) ? [menu itemAtIndex:0] : nil;
+    if (!appMenuItem || ![appMenuItem hasSubmenu] || !cocoaMenuContainsQuitItem([appMenuItem submenu]))
+    {
+      cocoaMenuCreateAppMenu(menu);
+    }
 
-	}
-	else
-	{
-		if(ih->parent)
-		{
+    if (!cocoaMenuFindTitledItem(menu, @"Window"))
+    {
+      cocoaMenuCreateWindowMenu(menu);
+    }
 
-//			NSLog(@"cocoaMenuMapMethod ih->parent %@", ih->parent->handle);
-		/* parent is a submenu, it is created here */
+    if (!cocoaMenuFindTitledItem(menu, @"Help"))
+    {
+      cocoaMenuCreateHelpMenu(menu);
+    }
 
+    cocoaMenuSynchronizeStandardMenus(menu);
 
-			NSMenuItem* parent_menu = (NSMenuItem*)(ih->parent->handle);
-			NSString* parent_menu_title = [parent_menu title];
-			
-			NSMenu* the_menu = [parent_menu submenu];
+    [[NSApplication sharedApplication] setMainMenu:menu];
+    s_currentIupApplicationMenu = ih;
+  }
+  else {
+    iupcocoaMenuSetApplicationMenu(NULL);
+  }
+}
 
-			// Try searching for an existing menu by this name and only create is not there.
-			if(nil == [parent_menu submenu])
-			{
-				the_menu = [[NSMenu alloc] init];
-				ih->handle = the_menu;
-				
-				[parent_menu setSubmenu:the_menu];
-				// In Cocoa, the name (e.g. "Edit") goes on the NSMenu, not the above NSMenuItem.
-				// I earlier set the name on the parent (which isn't visible), and now set it on the correct widget.
-				// Not sure if I should unset the title on the NSMenuItem afterwards.
-				[the_menu setTitle:parent_menu_title];
-//				NSLog(@"cocoaMenuMapMethod created NSMenu %@", the_menu);
-			}
-			else
-			{
-				// Already exists. Let's try reusing the existing one.
-				[the_menu retain];
-				ih->handle = the_menu;
-				
-//				NSLog(@"cocoaMenuMapMethod reused NSMenu %@", the_menu);
+/*******************************************************************************************/
+/* MENU (IupMenu)                                                                          */
+/*******************************************************************************************/
 
-			}
-			
-			
+static int cocoaMenuMapMethod(Ihandle* ih)
+{
+  NSMenu* menu = nil;
 
-//			NSLog(@"cocoaMenuMapMethod [parent_menu setSubmenu:the_menu]");
-		}
-		else
-		{
-			/* top level menu used for IupPopup */
+  if (iupMenuIsMenuBar(ih))
+  {
+    menu = [[NSMenu alloc] initWithTitle:@"MainMenu"];
+    if (!menu) return IUP_ERROR;
+    [menu setAutoenablesItems:NO];
+    ih->handle = menu;
 
-			NSMenu* the_menu = [[NSMenu alloc] init];
-			ih->handle = the_menu;
+    if ([menu numberOfItems] == 0 || ![[menu itemAtIndex:0] hasSubmenu] || !cocoaMenuContainsQuitItem([[menu itemAtIndex:0] submenu]))
+    {
+      cocoaMenuCreateAppMenu(menu);
+    }
+  }
+  else
+  {
+    menu = [[NSMenu alloc] initWithTitle:@""];
+    if (!menu) return IUP_ERROR;
+    ih->handle = menu;
 
-//			NSLog(@"else cocoaMenuMapMethod created NSMenu %@", the_menu);
+    if (ih->parent)
+    {
+      if (!ih->parent->handle)
+      {
+        [menu release];
+        ih->handle = NULL;
+        return IUP_ERROR;
+      }
 
-			
-			//iupAttribSet(ih, "_IUPWIN_POPUP_MENU", "1");
-		}
-	}
+      NSMenuItem* parent_item = (NSMenuItem*)ih->parent->handle;
+      if ([parent_item isKindOfClass:[NSMenuItem class]])
+      {
+        [parent_item setSubmenu:menu];
+        [menu setTitle:[parent_item title]];
+      }
+      else
+      {
+        [menu release];
+        ih->handle = NULL;
+        return IUP_ERROR;
+      }
+    }
+  }
 
-	
-	
+  IupCocoaMenuDelegate* delegate = [[IupCocoaMenuDelegate alloc] initWithIhandle:ih];
+  [menu setDelegate:delegate];
 
-	
-	return IUP_NOERROR;
+  objc_setAssociatedObject(menu, MENU_DELEGATE_ASSOCIATED_OBJ_KEY, delegate, OBJC_ASSOCIATION_RETAIN);
+  [delegate release];
+
+  objc_setAssociatedObject(menu, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+
+  return IUP_NOERROR;
 }
 
 static void cocoaMenuUnMapMethod(Ihandle* ih)
 {
-	NSMenu* the_menu = (NSMenu*)ih->handle;
-	// do I need to remove it from the parent???
-	ih->handle = NULL;
-	[the_menu release];
+  if (iupcocoaMenuIsApplicationBar(ih))
+  {
+    iupcocoaMenuSetApplicationMenu(NULL);
+  }
+
+  NSMenu* menu = (NSMenu*)ih->handle;
+  if (!menu) return;
+
+  if (iupMenuIsMenuBar(ih))
+  {
+    ih->parent = NULL;
+  }
+
+  [menu setDelegate:nil];
+  objc_setAssociatedObject(menu, MENU_DELEGATE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+  objc_setAssociatedObject(menu, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+
+  if (!iupMenuIsMenuBar(ih) && ih->parent && ih->parent->handle)
+  {
+    NSMenuItem* parent_item = (NSMenuItem*)ih->parent->handle;
+    if ([parent_item isKindOfClass:[NSMenuItem class]] && [parent_item submenu] == menu)
+    {
+      [parent_item setSubmenu:nil];
+    }
+  }
+
+  [menu release];
+  ih->handle = NULL;
 }
 
 void iupdrvMenuInitClass(Iclass* ic)
 {
-	cocoaCreateDefaultApplicationMenu();
-	
-//	ic->Release = cocoaReleaseMenuClass;
+  ic->Map = cocoaMenuMapMethod;
+  ic->UnMap = cocoaMenuUnMapMethod;
+  iupClassRegisterAttribute(ic, "FONT", NULL, NULL, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, cocoaMenuSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+}
 
-	/* Driver Dependent Class functions */
-	ic->Map = cocoaMenuMapMethod;
-	ic->UnMap = cocoaMenuUnMapMethod;
-#if 0
+/*******************************************************************************************/
+/* SEPARATOR (IupSeparator)                                                                */
+/*******************************************************************************************/
 
-	/* Used by iupdrvMenuGetMenuBarSize */
-	iupClassRegisterAttribute(ic, "FONT", NULL, NULL, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
-	
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, NULL, NULL, IUPAF_DEFAULT);
+static int cocoaSeparatorMapMethod(Ihandle* ih)
+{
+  if (!ih->parent || !ih->parent->handle)
+    return IUP_ERROR;
 
-#endif
+  NSMenu* parent_menu = (NSMenu*)ih->parent->handle;
+  if (![parent_menu isKindOfClass:[NSMenu class]])
+    return IUP_ERROR;
+
+  NSMenuItem* item = [NSMenuItem separatorItem];
+  [item retain]; /* Retain it because ih->handle owns it. */
+  ih->handle = item;
+  ih->serial = iupMenuGetChildId(ih);
+  [item setTag:ih->serial];
+
+  int pos = IupGetChildPos(ih->parent, ih);
+  if (iupMenuIsMenuBar(ih->parent))
+  {
+    pos++;
+  }
+
+  [parent_menu insertItem:item atIndex:pos];
+  objc_setAssociatedObject(item, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+  return IUP_NOERROR;
 }
 
+static void cocoaSeparatorUnMapMethod(Ihandle* ih)
+{
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return;
+  NSMenu* parent_menu = [item menu];
+  if (parent_menu)
+    [parent_menu removeItem:item];
+  objc_setAssociatedObject(item, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  [item release];
+  ih->handle = NULL;
+}
 
+void iupdrvSeparatorInitClass(Iclass* ic)
+{
+  ic->Map = cocoaSeparatorMapMethod;
+  ic->UnMap = cocoaSeparatorUnMapMethod;
+}
 
 
+/*******************************************************************************************/
+/* ITEM (IupItem)                                                                          */
+/*******************************************************************************************/
+
+static void cocoaItemSetShortcutFromString(NSMenuItem* item, const char* shortcut_string)
+{
+    if (!item) return;
+
+    if (!shortcut_string || shortcut_string[0] == '\0')
+    {
+        [item setKeyEquivalent:@""];
+        [item setKeyEquivalentModifierMask:0];
+        return;
+    }
+
+    NSUInteger mask = 0;
+    char key_char = 0;
+    char* current_part = iupStrDup(shortcut_string);
+    char* next_token = current_part;
+
+    while(next_token)
+    {
+        char* plus_pos = strchr(next_token, '+');
+        if (plus_pos) {
+            *plus_pos = '\0';
+        }
+
+        if (iupStrEqualNoCase(next_token, "Ctrl"))
+            mask |= NSEventModifierFlagCommand;
+        else if (iupStrEqualNoCase(next_token, "Shift"))
+            mask |= NSEventModifierFlagShift;
+        else if (iupStrEqualNoCase(next_token, "Alt"))
+            mask |= NSEventModifierFlagOption;
+        else if (iupStrEqualNoCase(next_token, "Sys"))
+            mask |= NSEventModifierFlagCommand;
+        else if (strlen(next_token) == 1) {
+            key_char = next_token[0];
+        }
+
+        if (plus_pos) {
+            next_token = plus_pos + 1;
+        } else {
+            next_token = NULL;
+        }
+    }
+    free(current_part);
+
+    if (key_char)
+    {
+        NSString* key_str = [[NSString stringWithFormat:@"%c", key_char] lowercaseString];
+        [item setKeyEquivalent:key_str];
+        [item setKeyEquivalentModifierMask:mask];
+    }
+    else
+    {
+        [item setKeyEquivalent:@""];
+        [item setKeyEquivalentModifierMask:0];
+    }
+}
+
 static int cocoaItemSetTitleAttrib(Ihandle* ih, const char* value)
 {
-//	char *str;
-	
-	/* check if the submenu handle was created in winSubmenuAddToParent */
-/*
-	if (ih->handle == (InativeHandle*)-1)
-		return 1;
-*/
-	NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
+    NSMenuItem* item = (NSMenuItem*)ih->handle;
+    if (!item) return 0;
 
-	NSString* ns_string = nil;
-	if(!value)
-	{
-		ns_string = @"";
-	}
-	else
-	{
-		ns_string = [NSString stringWithUTF8String:value];
+    if (!value) value = "";
 
-	}
-	
-	// Mnemonic is not actually supported on Mac. Maybe it does something on GNUStep?
-	// However it does seem to strip the & from being displayed in the menu, so it is useful.
-	[menu_item setTitleWithMnemonic:ns_string];
-	//[menu_item setTitle:ns_string];
+    const char* tab_pos = strchr(value, '\t');
+    char* title_part;
+    const char* shortcut_part = NULL;
 
-	
-	// Try to extract the Mnemonic
-	
-	
-	NSRange search_result_range = [ns_string rangeOfString:@"&"];
-	if(NSNotFound != search_result_range.location)
-	{
-		NSRange character_range = NSMakeRange(search_result_range.location+1, 1);
-		
-		// Make sure the & isn't at the end of the string
-		if(character_range.location + character_range.length <= [ns_string length])
-		{
-			NSString* mnemonic_char = [ns_string substringWithRange:character_range];
-			// Drat. If the user is doing something like "&Print", uppercase P makes you press CMD-SHIFT-p. Most likely they just wanted CMD-p
-			// Make lowercase to avoid this, but we need a better system to allow specifying command characters in case they did want SHIFT
-			mnemonic_char = [mnemonic_char lowercaseString];
-			[menu_item setKeyEquivalent:mnemonic_char];
-		}
+    if (tab_pos)
+    {
+        int len = tab_pos - value;
+        title_part = (char*)malloc(len + 1);
+        strncpy(title_part, value, len);
+        title_part[len] = '\0';
+        shortcut_part = tab_pos + 1;
+    }
+    else
+    {
+        title_part = iupStrDup(value);
+    }
 
+    cocoaMenuSetTitle(ih, item, title_part);
+    free(title_part);
 
-	}
-	
-	
-	
-	
-	return 1;
+    if (tab_pos)
+    {
+        cocoaItemSetShortcutFromString(item, shortcut_part);
+    }
+
+    return 1;
 }
 
-/*
- // Drat: These don't work because I have to also disable autoenablesItems in the NSMenu's.
- // But that will also disable a lot of items we might like automatic behavior for.
+static int cocoaItemSetValueAttrib(Ihandle* ih, const char* value)
+{
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return 0;
 
- [menu_item setAutoenablesItems:NO];	}
-char* cocoaItemGetActiveAttrib(Ihandle *ih)
+  if (iupAttribGetBoolean(ih->parent, "RADIO"))
+  {
+    cocoaItemUpdateRadioGroup(ih);
+  }
+  else
+  {
+    BOOL desired_checked = iupStrBoolean(value);
+    NSInteger desiredState = desired_checked ? NSControlStateValueOn : NSControlStateValueOff;
+    [item setState:desiredState];
+    iupAttribSet(ih, "VALUE", desired_checked ? "ON" : "OFF");
+    cocoaMenuUpdateImage(ih);
+  }
+
+  return 1;
+}
+
+static char* cocoaItemGetValueAttrib(Ihandle* ih)
 {
-	NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
-	BOOL is_enabled = [menu_item isEnabled];
-	return iupStrReturnBoolean(is_enabled);
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return "OFF";
+  return iupStrReturnBoolean([item state] == NSControlStateValueOn);
 }
 
 static int cocoaItemSetActiveAttrib(Ihandle* ih, const char* value)
 {
-	BOOL is_enabled = (BOOL)iupStrBoolean(value);
-	NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
-	[menu_item setEnabled:is_enabled];
-	return 1;
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return 0;
+
+  iupBaseSetActiveAttrib(ih, value);
+
+  BOOL enabled = (BOOL)iupStrBoolean(value);
+  [item setEnabled:enabled];
+
+  cocoaMenuUpdateImage(ih);
+  return 1;
 }
-*/
 
+static char* cocoaItemGetActiveAttrib(Ihandle* ih)
+{
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item)
+    return iupBaseGetActiveAttrib(ih);
+
+  return iupStrReturnBoolean([item isEnabled]);
+}
+
+static int cocoaItemSetImageAttrib(Ihandle* ih, const char* value)
+{
+  (void)value;
+  cocoaMenuUpdateImage(ih);
+  return 1;
+}
+
+static int cocoaItemSetHideMarkAttrib(Ihandle* ih, const char* value)
+{
+  (void)value;
+  cocoaMenuUpdateImage(ih);
+  return 1;
+}
+
+static int cocoaItemSetKeyAttrib(Ihandle* ih, const char* value)
+{
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return 0;
+
+  cocoaItemSetShortcutFromString(item, value);
+
+  return 1;
+}
+
 static int cocoaItemMapMethod(Ihandle* ih)
 {
+  if (!ih->parent || !ih->parent->handle) return IUP_ERROR;
+  NSMenu* parent_menu = (NSMenu*)ih->parent->handle;
+  if (![parent_menu isKindOfClass:[NSMenu class]]) return IUP_ERROR;
 
-	if(!ih->parent)
-	{
-		NSLog(@"IUP_ERROR cocoaItemMapMethod !ih->parent");
-		return IUP_ERROR;
-	}
-	
-	
-	
+  BOOL isMenuBar = iupMenuIsMenuBar(ih->parent);
+  NSMenu* insertionMenu = parent_menu;
+  NSMenuItem* menuBarWrapperItem = nil;
 
-	
-	if (iupMenuIsMenuBar(ih))
-	{
-		/* top level menu used for MENU attribute in IupDialog (a menu bar) */
-		
-//		NSLog(@"cocoaItemMapMethod iupMenuIsMenuBar %@", ih->parent->handle);
-		
-	}
-	else
-	{
-		if(ih->parent)
-		{
-			/* parent is a submenu, it is created here */
-//			NSLog(@"cocoaItemMapMethod ih->parent %@", ih->parent->handle);
-			
-		}
-		else
-		{
-//			NSLog(@"cocoaItemMapMethod else");
-		}
-	}
-	
-	
-	
-	NSMenu* parent_menu = (NSMenu*)(ih->parent->handle);
-	const char* c_title = IupGetAttribute(ih, "TITLE");
-	NSString* ns_string = nil;
-	NSMenuItem* menu_item = nil;
-	if(!c_title)
-	{
-		ns_string = @"";
-	}
-	else
-	{
-		ns_string = [NSString stringWithUTF8String:c_title];
-		
-	}
-	// search through parent to see if this item already exists
-	for(NSMenuItem* current_menu_item in [parent_menu itemArray])
-	{
-		if([[current_menu_item title] isEqualToString:ns_string])
-		{
-			menu_item = current_menu_item;
-			break;
-		}
-	}
-	
-	if(nil == menu_item)
-	{
-		// create new item
-		menu_item = [[NSMenuItem alloc] init];
-		ih->handle = menu_item;
-		[parent_menu addItem:menu_item];
-		
-		// RepresentedObject is to handle the callbacks
-		IupCocoaMenuItemRepresentedObject* represented_object = [[IupCocoaMenuItemRepresentedObject alloc] initWithIhandle:ih];
-		[menu_item setRepresentedObject:represented_object];
-		[represented_object release];
-		[menu_item setTarget:represented_object];
-		[menu_item setAction:@selector(onMenuItemAction:)];
-	}
-	else
-	{
-		ih->handle = menu_item;
-		[menu_item retain];
+  if (isMenuBar)
+  {
+    menuBarWrapperItem = [[NSMenuItem alloc] initWithTitle:@"" action:nil keyEquivalent:@""];
+    NSMenu* submenu = [[NSMenu alloc] initWithTitle:@""];
+    [menuBarWrapperItem setSubmenu:submenu];
+    [submenu release];
+    insertionMenu = submenu;
+  }
 
-		// For built-in XIB menu items, we may not have setup the represented object stuff, so do that now.
-		if([menu_item representedObject] == nil)
-		{
-			// RepresentedObject is to handle the callbacks
-			IupCocoaMenuItemRepresentedObject* represented_object = [[IupCocoaMenuItemRepresentedObject alloc] initWithIhandle:ih];
-			[menu_item setRepresentedObject:represented_object];
-			[represented_object release];
-			[menu_item setTarget:represented_object];
-			[menu_item setAction:@selector(onMenuItemAction:)];
-		}
-		
-	}
-	
-	
+  NSMenuItem* item = [[NSMenuItem alloc] initWithTitle:@"" action:@selector(onMenuItemAction:) keyEquivalent:@""];
+  ih->handle = item;
+  ih->serial = iupMenuGetChildId(ih);
 
-	return IUP_NOERROR;
+  IupCocoaMenuItemTarget* target = [[IupCocoaMenuItemTarget alloc] initWithIhandle:ih];
+  [item setTarget:target];
+  [item setTag:ih->serial];
+  objc_setAssociatedObject(item, MENUITEM_TARGET_ASSOCIATED_OBJ_KEY, target, OBJC_ASSOCIATION_RETAIN);
+  objc_setAssociatedObject(item, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+  [target release];
+
+  if (isMenuBar)
+  {
+    objc_setAssociatedObject(item, MENUBAR_ITEM_WRAPPER_KEY, menuBarWrapperItem, OBJC_ASSOCIATION_RETAIN);
+    int pos = IupGetChildPos(ih->parent, ih) + 1;
+    [parent_menu insertItem:menuBarWrapperItem atIndex:pos];
+    [menuBarWrapperItem release];
+    [insertionMenu insertItem:item atIndex:0];
+  }
+  else
+  {
+    int pos = IupGetChildPos(ih->parent, ih);
+    [insertionMenu insertItem:item atIndex:pos];
+  }
+  return IUP_NOERROR;
 }
 
 static void cocoaItemUnMapMethod(Ihandle* ih)
 {
-	NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
-	// do I need to remove it from the parent???
-	ih->handle = NULL;
-	[menu_item release];
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return;
+
+  NSMenuItem* menuBarWrapperItem = (NSMenuItem*)objc_getAssociatedObject(item, MENUBAR_ITEM_WRAPPER_KEY);
+  if (menuBarWrapperItem)
+  {
+    [[menuBarWrapperItem menu] removeItem:menuBarWrapperItem];
+    [[item menu] removeItem:item];
+    objc_setAssociatedObject(item, MENUBAR_ITEM_WRAPPER_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+  }
+  else
+  {
+    [[item menu] removeItem:item];
+  }
+
+  [item setTarget:nil];
+  objc_setAssociatedObject(item, MENUITEM_TARGET_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+  objc_setAssociatedObject(item, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  [item release];
+  ih->handle = NULL;
 }
 
-
 void iupdrvItemInitClass(Iclass* ic)
 {
-  /* Driver Dependent Class functions */
   ic->Map = cocoaItemMapMethod;
   ic->UnMap = cocoaItemUnMapMethod;
-#if 0
+  iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "VALUE", cocoaItemGetValueAttrib, cocoaItemSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "FONT", NULL, cocoaMenuItemSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
+  iupClassRegisterAttribute(ic, "ACTIVE", cocoaItemGetActiveAttrib, cocoaItemSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, NULL, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "KEY", NULL, cocoaItemSetKeyAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMAGE", NULL, cocoaItemSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMPRESS", NULL, cocoaItemSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TITLEIMAGE", NULL, cocoaItemSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "HIDEMARK", NULL, cocoaItemSetHideMarkAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "AUTOTOGGLE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+}
 
-	/* Common */
-	iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
-	
-	/* Visual */
-#endif
-	// Drat: These don't work because I have to also disable autoenablesItems in the NSMenu's.
-//	iupClassRegisterAttribute(ic, "ACTIVE", cocoaItemGetActiveAttrib, cocoaItemSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-#if 0
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-	
-	/* IupItem only */
-	iupClassRegisterAttribute(ic, "VALUE", gtkItemGetValueAttrib, gtkItemSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-#endif
-	iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-#if 0
-	iupClassRegisterAttribute(ic, "TITLEIMAGE", NULL, gtkItemSetTitleImageAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "IMAGE", NULL, gtkItemSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "IMPRESS", NULL, gtkItemSetImpressAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	
+/*******************************************************************************************/
+/* SUBMENU (IupSubmenu)                                                                    */
+/*******************************************************************************************/
 
+static int cocoaSubmenuSetTitleAttrib(Ihandle* ih, const char* value)
+{
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return 0;
 
+  if (!value) value = "";
 
-  /* IupItem GTK and Motif only */
-  iupClassRegisterAttribute(ic, "HIDEMARK", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED);
-#endif
+  const char* tab_pos = strchr(value, '\t');
+  char* title_part;
+
+  if (tab_pos)
+  {
+      int len = tab_pos - value;
+      title_part = (char*)malloc(len + 1);
+      strncpy(title_part, value, len);
+      title_part[len] = '\0';
+  }
+  else
+  {
+      title_part = iupStrDup(value);
+  }
+
+  cocoaMenuSetTitle(ih, item, title_part);
+
+  if ([item hasSubmenu])
+  {
+    NSString* ns_title = [item title];
+    if (!ns_title) ns_title = @"";
+    [[item submenu] setTitle:ns_title];
+  }
+
+  free(title_part);
+  return 1;
 }
 
+static int cocoaSubmenuSetActiveAttrib(Ihandle* ih, const char* value)
+{
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return 0;
 
-static int cocoaSubmenuSetTitleAttrib(Ihandle* ih, const char* value)
+  iupBaseSetActiveAttrib(ih, value);
+
+  BOOL enabled = (BOOL)iupStrBoolean(value);
+  [item setEnabled:enabled];
+
+  cocoaMenuUpdateImage(ih);
+  return 1;
+}
+
+static char* cocoaSubmenuGetActiveAttrib(Ihandle* ih)
 {
-	//	char *str;
-	
-	/* check if the submenu handle was created in winSubmenuAddToParent */
-	/*
-	 if (ih->handle == (InativeHandle*)-1)
-		return 1;
-	 */
-	
-#if 0
-	NSMenu* the_menu = (NSMenu*)ih->handle;
-	
-	NSString* ns_string = nil;
-	if(!value)
-	{
-		ns_string = @"";
-	}
-	else
-	{
-		ns_string = [NSString stringWithUTF8String:value];
-		
-	}
-	
-	[the_menu setTitle:ns_string];
-#else
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item)
+    return iupBaseGetActiveAttrib(ih);
 
-	
-	
-	NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
-	
-	
-	NSString* ns_string = nil;
-	if(!value)
-	{
-		ns_string = @"";
-	}
-	else
-	{
-		ns_string = [NSString stringWithUTF8String:value];
-		
-	}
-	
-	[menu_item setTitle:ns_string];
-#endif
-	
-	return 1;
+  return iupStrReturnBoolean([item isEnabled]);
 }
 
+static int cocoaSubmenuSetImageAttrib(Ihandle* ih, const char* value)
+{
+  (void)value;
+  cocoaMenuUpdateImage(ih);
+  return 1;
+}
 
 static int cocoaSubmenuMapMethod(Ihandle* ih)
 {
-	if(!ih->parent)
-	{
-		NSLog(@"IUP_ERROR cocoaSubmenuMapMethod !ih->parent");
-		return IUP_ERROR;
-	}
-	
-	
-	if (iupMenuIsMenuBar(ih->parent))
-	{
-		/* top level menu used for MENU attribute in IupDialog (a menu bar) */
-		
-//		NSLog(@"cocoaSubmenuMapMethod iupMenuIsMenuBar %@", ih->parent->handle);
-		
-	}
-	else
-	{
-		if(ih->parent)
-		{
-			/* parent is a submenu, it is created here */
-//			NSLog(@"cocoaSubmenuMapMethod ih->parent %@", ih->parent->handle);
-			
-		}
-		else
-		{
-//			NSLog(@"cocoaSubmenuMapMethod else");
-		}
-	}
-	
-	
-	
-	
-	NSObject* parent_object = (NSObject*)ih->parent->handle;
-	if([parent_object isKindOfClass:[NSMenuItem class]])
-	{
-		/* parent is a submenu, it is created here */
-		NSMenu* the_menu = [[NSMenu alloc] init];
-		ih->handle = the_menu;
-		
-		NSMenuItem* parent_menu = (NSMenuItem*)(ih->parent->handle);
-		[parent_menu setSubmenu:the_menu];
-		
-/*
-		NSLog(@"cocoaSubmenuMapMethod iupMenuIsMenuBar %@", ih->parent->handle);
-		NSLog(@"cocoaSubmenuMapMethod created NSMenu %@", the_menu);
-		NSLog(@"[parent_menu setSubmenu:the_menu]");
-*/
-		
-		
-	}
-	else if([parent_object isKindOfClass:[NSMenu class]])
-	{
-		
+  if (!ih->parent || !ih->parent->handle) return IUP_ERROR;
+  NSMenu* parent_menu = (NSMenu*)ih->parent->handle;
+  if (![parent_menu isKindOfClass:[NSMenu class]]) return IUP_ERROR;
 
-		
-#if 0
-		NSMenu* the_menu = [[NSMenu alloc] init];
-		ih->handle = the_menu;
-		
-			NSMenu* parent_menu = (NSMenu*)(ih->parent->handle);
-			NSMenuItem* replacement_parent_menu_item = [[NSMenuItem alloc] initWithTitle:[parent_menu title] action:nil keyEquivalent:@""];
-			[parent_menu release];
-			ih->parent->handle = replacement_parent_menu_item;
-#else
-		
-		NSMenu* parent_menu = (NSMenu*)(ih->parent->handle);
-		NSArray* list_of_menu_items = [parent_menu itemArray];
-//		NSInteger number_of_items = [parent_menu numberOfItems];
-		NSMenuItem* found_menu_item = nil;
-		
-		const char* c_title = IupGetAttribute(ih, "TITLE");
-		NSString* ns_string = nil;
-		if(!c_title)
-		{
-			ns_string = @"";
-		}
-		else
-		{
-			ns_string = [NSString stringWithUTF8String:c_title];
-			
-		}
-		
-		for(NSMenuItem* menu_item in list_of_menu_items)
-		{
-			NSString* menu_item_title = [menu_item title];
-			if([menu_item_title isEqualToString:ns_string])
-			{
-				found_menu_item = menu_item;
-				break;
-			}
-		}
-		
-		if(found_menu_item)
-		{
-//			NSLog(@"found menu item for Submenu");
-			ih->handle = found_menu_item;
-			[found_menu_item retain];
-			
-		}
-		else
-		{
-			//		NSMenuItem* menu_item_for_submenu = [[NSMenuItem alloc] initWithTitle:[parent_menu title] action:nil keyEquivalent:@""];
-//			NSMenuItem* menu_item_for_submenu = [[NSMenuItem alloc] initWithTitle:@"" action:@selector(onMenuItemAction:) keyEquivalent:@""];
-			NSMenuItem* menu_item_for_submenu = [[NSMenuItem alloc] init];
-			
-			
-			/* 
-			Okay, now we're going to get tricky.
-			Cocoa has strong conventions about what should be in the menu and where.
-			Currently I'm operating on the assumption that we are going to pre-populate a default menu for IUP and the user is going to add (and maybe remove) items.
-			So we need to search through the existing menu and determine where things go.
-			Current assumption: All normal menu categories are already in the menu. So if the user adds a new one, we must put it in the right place.
-			The Apple Human User Interface Guidelines (HIG) state that new menu entries appear between the View and Window items.
-			View is also sometimes optional, so for robustness, we should scan for Window and insert right before Window. 
-			(This also handles the case where user entries have already been added since we will add after those entries which is expected behavior.)
-			*/
-			NSInteger index_to_insert_at = -1; // start at -1 because we are 1 slot before our stopping marker
-			BOOL found_window_slot = NO;
-			for(NSMenuItem* current_menu_item in [parent_menu itemArray])
-			{
-//				NSLog(@"current_menu_item.title %@", [current_menu_item title]);
-				index_to_insert_at = index_to_insert_at + 1;
-				if(([[current_menu_item title] isEqualToString:NSLocalizedString(@"Window", @"Window")]) || ([[current_menu_item title] isEqualToString:@"Window"]))
-				{
-					found_window_slot = YES;
-					break;
-				}
-			}
-			
-			if(found_window_slot)
-			{
-				[parent_menu insertItem:menu_item_for_submenu atIndex:index_to_insert_at];
-			}
-			else
-			{
-				NSLog(@"Warning: Did not find Window menu to insert category in");
-				[parent_menu addItem:menu_item_for_submenu];
-			}
-			
-			ih->handle = menu_item_for_submenu;
-//			[menu_item_for_submenu setTitle:ns_string];
-			[menu_item_for_submenu setTitleWithMnemonic:ns_string];
+  NSMenuItem* item = [[NSMenuItem alloc] initWithTitle:@"" action:nil keyEquivalent:@""];
+  ih->handle = item;
+  ih->serial = iupMenuGetChildId(ih);
 
-			/*
-			// RepresentedObject is to handle the callbacks
-			IupCocoaMenuItemRepresentedObject* represented_object = [[IupCocoaMenuItemRepresentedObject alloc] initWithIhandle:ih];
-			[menu_item_for_submenu setRepresentedObject:represented_object];
-			[represented_object release];
-			[menu_item_for_submenu setTarget:represented_object];
-			[menu_item setAction:@selector(onMenuItemAction:)];
-*/
+  IupCocoaMenuItemTarget* target = [[IupCocoaMenuItemTarget alloc] initWithIhandle:ih];
+  [item setTarget:target];
+  [item setTag:ih->serial];
+  objc_setAssociatedObject(item, MENUITEM_TARGET_ASSOCIATED_OBJ_KEY, target, OBJC_ASSOCIATION_RETAIN);
+  objc_setAssociatedObject(item, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+  [target release];
 
-/*
-			NSLog(@"cocoaSubmenuMapMethod parent_menu %@", parent_menu);
-			NSLog(@"cocoaSubmenuMapMethod replacement_parent_menu_item %@", menu_item_for_submenu);
-			NSLog(@"[parent_menu setSubmenu:the_menu]");
-*/
-		
-		}
-		//[replacement_parent_menu_item setSubmenu:the_menu];
-		
-		
-#endif
-		
-		
-		
-//		NSLog(@"NSMenu swap");
-		//NSCAssert(0==1, @"NSMenu");
-		
-		
-//		return iupBaseTypeVoidMapMethod(ih);
+  int pos = IupGetChildPos(ih->parent, ih);
+  if (iupMenuIsMenuBar(ih->parent)) pos++;
 
-		
-		return IUP_NOERROR;
-	}
-	else
-	{
-		NSLog(@"What menu thing is this?");
-		NSCAssert(0==1, @"What is this?");
-		return IUP_ERROR;
-
-	}
-
-	
-	return IUP_NOERROR;
+  [parent_menu insertItem:item atIndex:pos];
+  return IUP_NOERROR;
 }
 
 static void cocoaSubmenuUnMapMethod(Ihandle* ih)
 {
-	NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
-	// do I need to remove it from the parent???
-	ih->handle = NULL;
-	[menu_item release];
+  NSMenuItem* item = (NSMenuItem*)ih->handle;
+  if (!item) return;
+  [[item menu] removeItem:item];
+  [item setTarget:nil];
+  [item setSubmenu:nil];
+  objc_setAssociatedObject(item, MENUITEM_TARGET_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+  objc_setAssociatedObject(item, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  [item release];
+  ih->handle = NULL;
 }
 
-
-
 void iupdrvSubmenuInitClass(Iclass* ic)
 {
-  /* Driver Dependent Class functions */
   ic->Map = cocoaSubmenuMapMethod;
   ic->UnMap = cocoaSubmenuUnMapMethod;
-#if 0
+  iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaSubmenuSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "FONT", NULL, cocoaMenuItemSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
+  iupClassRegisterAttribute(ic, "ACTIVE", cocoaSubmenuGetActiveAttrib, cocoaSubmenuSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, NULL, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "IMAGE", NULL, cocoaSubmenuSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TITLEIMAGE", NULL, cocoaSubmenuSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+}
 
-	/* Common */
-	iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
-	
-	/* Visual */
-	iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-	
-	/* IupSubmenu only */
-#endif
-	iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaSubmenuSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-#if 0
-	iupClassRegisterAttribute(ic, "IMAGE", NULL, gtkSubmenuSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-#endif
+
+/*******************************************************************************************/
+/* Recent Menu Support                                                                     */
+/*******************************************************************************************/
+
+static const void* RECENT_MENU_ASSOCIATED_OBJ_KEY = &RECENT_MENU_ASSOCIATED_OBJ_KEY;
+
+@interface IupCocoaRecentMenuItemTarget : NSObject
+{
+  Ihandle* _menu;
+  int _index;
 }
+@property (nonatomic, assign) Ihandle* menu;
+@property (nonatomic, assign) int index;
+- (instancetype) initWithMenu:(Ihandle*)menu index:(int)index;
+- (void) onRecentItemAction:(id)sender;
+@end
 
+@implementation IupCocoaRecentMenuItemTarget
+@synthesize menu = _menu;
+@synthesize index = _index;
 
-static int cocoaSeparatorMapMethod(Ihandle* ih)
+- (instancetype) initWithMenu:(Ihandle*)menu index:(int)index
 {
-	NSMenu* parent_menu = (NSMenu*)(ih->parent->handle);
+  self = [super init];
+  if (self)
+  {
+    _menu = menu;
+    _index = index;
+  }
+  return self;
+}
 
-	// create new item
-	NSMenuItem* menu_item = [NSMenuItem separatorItem];
-	[menu_item retain];
-	ih->handle = menu_item;
-	[parent_menu addItem:menu_item];
-	
-	return IUP_NOERROR;
+- (void) dealloc
+{
+  _menu = NULL;
+  [super dealloc];
 }
 
-static void cocoaSeparatorUnMapMethod(Ihandle* ih)
+- (void) onRecentItemAction:(id)sender
 {
-	NSMenuItem* menu_item = (NSMenuItem*)ih->handle;
-	// do I need to remove it from the parent???
-	ih->handle = NULL;
-	[menu_item release];
+  if (!_menu) return;
+
+  Icallback recent_cb = (Icallback)iupAttribGet(_menu, "_IUP_RECENT_CB");
+  Ihandle* config = (Ihandle*)iupAttribGet(_menu, "_IUP_CONFIG");
+
+  if (recent_cb && config)
+  {
+    char attr_name[32];
+    const char* filename;
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", _index);
+    filename = iupAttribGet(_menu, attr_name);
+
+    if (filename)
+    {
+      IupSetStrAttribute(config, "RECENTFILENAME", filename);
+      IupSetStrAttribute(config, "TITLE", filename);
+      config->parent = _menu;
+
+      if (recent_cb(config) == IUP_CLOSE)
+        IupExitLoop();
+
+      config->parent = NULL;
+      IupSetAttribute(config, "RECENTFILENAME", NULL);
+      IupSetAttribute(config, "TITLE", NULL);
+    }
+  }
 }
 
-void iupdrvSeparatorInitClass(Iclass* ic)
+@end
+
+int iupdrvRecentMenuInit(Ihandle* menu, int max_recent, Icallback recent_cb)
 {
-#if 1
-  /* Driver Dependent Class functions */
-  ic->Map = cocoaSeparatorMapMethod;
-  ic->UnMap = cocoaSeparatorUnMapMethod;
-#endif
-	
+  iupAttribSetInt(menu, "_IUP_RECENT_MAX", max_recent);
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", 0);
+  return 0;
 }
+
+int iupdrvRecentMenuUpdate(Ihandle* menu, const char** filenames, int count, Icallback recent_cb)
+{
+  NSMenu* nsmenu;
+  int max_recent, existing, i;
+
+  if (!menu || !menu->handle)
+    return -1;
+
+  nsmenu = (NSMenu*)menu->handle;
+  max_recent = iupAttribGetInt(menu, "_IUP_RECENT_MAX");
+  existing = iupAttribGetInt(menu, "_IUP_RECENT_COUNT");
+
+  if (count > max_recent)
+    count = max_recent;
+
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+
+  for (i = 0; i < count; i++)
+  {
+    char attr_name[32];
+    NSString* title = [NSString stringWithUTF8String:filenames[i]];
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
+    iupAttribSetStr(menu, attr_name, filenames[i]);
+
+    if (i < existing)
+    {
+      NSMenuItem* item = [nsmenu itemAtIndex:i];
+      [item setTitle:title];
+    }
+    else
+    {
+      IupCocoaRecentMenuItemTarget* target = [[IupCocoaRecentMenuItemTarget alloc] initWithMenu:menu index:i];
+      NSMenuItem* item = [[NSMenuItem alloc] initWithTitle:title
+                                                    action:@selector(onRecentItemAction:)
+                                             keyEquivalent:@""];
+      [item setTarget:target];
+      [item setTag:i];
+      objc_setAssociatedObject(item, RECENT_MENU_ASSOCIATED_OBJ_KEY, target, OBJC_ASSOCIATION_RETAIN);
+      [target release];
+
+      [nsmenu insertItem:item atIndex:i];
+      [item release];
+    }
+  }
+
+  while ([nsmenu numberOfItems] > count && existing > count)
+  {
+    NSMenuItem* item = [nsmenu itemAtIndex:count];
+    [item setTarget:nil];
+    objc_setAssociatedObject(item, RECENT_MENU_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN);
+    [nsmenu removeItemAtIndex:count];
+    existing--;
+
+    char attr_name[32];
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", existing);
+    iupAttribSet(menu, attr_name, NULL);
+  }
+
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", count);
+  return 0;
+}
\ No newline at end of file
Index: src/cocoa/iupcocoa_messagedlg.m
===================================================================
--- src/cocoa/iupcocoa_messagedlg.m	(revision 5971)
+++ src/cocoa/iupcocoa_messagedlg.m	(working copy)
@@ -1,10 +1,11 @@
 /** \file
- * \brief MAC IupMessageDlg pre-defined dialog
+ * \brief Cocoa IupMessageDlg pre-defined dialog
  *
  * See Copyright Notice in "iup.h"
  */
 
 #import <Cocoa/Cocoa.h>
+#import <objc/runtime.h>
 
 #include "iup.h"
 
@@ -11,74 +12,227 @@
 #include "iup_object.h"
 #include "iup_attrib.h"
 #include "iup_str.h"
-#include "iup_dialog.h"       
+#include "iup_dialog.h"
 #include "iup_strmessage.h"
+#include "iup_drv.h"
+#include "iup_drvinfo.h"
 
 #include "iupcocoa_drv.h"
 
 
-static int macMessageDlgPopup(Ihandle* ih, int x, int y)
+#ifndef NSAlertHelpReturn
+#define NSAlertHelpReturn 1003
+#endif
+
+static char* cocoaMessageDlgGetAutoModalAttrib(Ihandle* ih)
 {
-#if 1
-//  InativeHandle* parent = iupDialogGetNativeParent(ih);
-  char *icon, *buttons;
-  NSInteger result;
-  NSAlert *alert = [[NSAlert new] autorelease];  
-  NSAlertStyle nsStyle = NSInformationalAlertStyle; 
-  (void)x;
-  (void)y;       
+  InativeHandle* parent = iupDialogGetNativeParent(ih);
+  int automodal = 1;
+  if (parent)
+    automodal = 0;
+  return iupStrReturnBoolean(automodal);
+}
 
-  icon = iupAttribGetStr(ih, "DIALOGTYPE");
-  if (iupStrEqualNoCase(icon, "ERROR"))
+static int cocoaMessageDlgPopup(Ihandle* ih, int x, int y)
+{
+  (void)x; /* Positioning is not supported by NSAlert. */
+  (void)y;
+
+  InativeHandle* parent = iupDialogGetNativeParent(ih);
+  char* title_str = iupAttribGet(ih, "TITLE");
+  char* value_str = iupAttribGet(ih, "VALUE");
+  char* icon_str = iupAttribGetStr(ih, "DIALOGTYPE");
+  char* buttons_str = iupAttribGetStr(ih, "BUTTONS");
+  int button_def = iupAttribGetInt(ih, "BUTTONDEFAULT");
+
+  NSWindow* parentWindow = nil;
+  Ihandle* parent_ih = IupGetAttributeHandle(ih, "PARENTDIALOG");
+
+  if (parent)
   {
-    nsStyle = NSCriticalAlertStyle;
+    if ([(id)parent isKindOfClass:[NSWindow class]])
+      parentWindow = (NSWindow*)parent;
+    else if ([(id)parent isKindOfClass:[NSView class]])
+      parentWindow = [(NSView*)parent window];
+
+    if (parentWindow && !parent_ih)
+      parent_ih = (Ihandle*)objc_getAssociatedObject(parentWindow, IHANDLE_ASSOCIATED_OBJ_KEY);
   }
-  else if (iupStrEqualNoCase(icon, "WARNING"))
+  else if (parent_ih)
   {
-    nsStyle = NSWarningAlertStyle;
+    parentWindow = cocoaDialogGetWindow(parent_ih);
   }
-  else if (iupStrEqualNoCase(icon, "INFORMATION"))
+
+  /* If no parent found, find the current key window that is an IUP dialog. */
+  if (!parent_ih)
   {
-    nsStyle = NSInformationalAlertStyle;
+    NSWindow* keyWindow = [NSApp keyWindow];
+    if (keyWindow)
+    {
+      Ihandle* active_ih = (Ihandle*)objc_getAssociatedObject(keyWindow, IHANDLE_ASSOCIATED_OBJ_KEY);
+      if (iupObjectCheck(active_ih) && iupdrvDialogIsVisible(active_ih))
+      {
+        parent_ih = active_ih;
+        parentWindow = keyWindow;
+      }
+    }
   }
-  else if (iupStrEqualNoCase(icon, "QUESTION"))
+
+  if (parent_ih)
   {
-    nsStyle = NSInformationalAlertStyle;
+    parent_ih = IupGetDialog(parent_ih);
   }
-  [alert setAlertStyle:nsStyle];
-   
-  buttons = iupAttribGetStr(ih, "BUTTONS");     
-  if (iupStrEqualNoCase(buttons, "OKCANCEL")) {  
-	  [alert addButtonWithTitle:NSLocalizedString(@"OK", @"OK")];
-	[alert addButtonWithTitle:NSLocalizedString(@"Cancel", @"Cancel")];
-	  
-  } else if (iupStrEqualNoCase(buttons, "YESNO")) {
-	  [alert addButtonWithTitle:NSLocalizedString(@"Yes", @"Yes")];
-	[alert addButtonWithTitle:NSLocalizedString(@"No", @"No")];
-  } else
+
+  NSInteger response;
+  BOOL help_pressed;
+  NSMutableDictionary* responseMap = nil;
+
+  do {
+    help_pressed = NO;
+    NSAlert* alert = [[NSAlert alloc] init];
+
+    [alert setMessageText:[NSString stringWithUTF8String:title_str ? title_str : ""]];
+    [alert setInformativeText:[NSString stringWithUTF8String:value_str ? value_str : ""]];
+
+    if (iupStrEqualNoCase(icon_str, "ERROR"))
+      [alert setAlertStyle:NSAlertStyleCritical];
+    else if (iupStrEqualNoCase(icon_str, "WARNING"))
+      [alert setAlertStyle:NSAlertStyleWarning];
+    else /* INFORMATION, QUESTION */
+      [alert setAlertStyle:NSAlertStyleInformational];
+
+    if (button_def == 0)
+      button_def = 1;
+
+    NSMutableArray* titles = [NSMutableArray array];
+    NSMutableArray* responses = [NSMutableArray array];
+
+    if (iupStrEqualNoCase(buttons_str, "OKCANCEL"))
+    {
+      [titles addObject:@"OK"];     [responses addObject:@"1"];
+      [titles addObject:@"Cancel"]; [responses addObject:@"2"];
+    }
+    else if (iupStrEqualNoCase(buttons_str, "RETRYCANCEL"))
+    {
+      const char* retry_cstr = IupGetLanguageString("IUP_RETRY");
+      NSString* retry_str = retry_cstr ? [NSString stringWithUTF8String:retry_cstr] : @"Retry";
+      [titles addObject:retry_str]; [responses addObject:@"1"];
+      [titles addObject:@"Cancel"]; [responses addObject:@"2"];
+    }
+    else if (iupStrEqualNoCase(buttons_str, "YESNO"))
+    {
+      [titles addObject:@"Yes"]; [responses addObject:@"1"];
+      [titles addObject:@"No"];  [responses addObject:@"2"];
+    }
+    else if (iupStrEqualNoCase(buttons_str, "YESNOCANCEL"))
+    {
+      [titles addObject:@"Yes"];    [responses addObject:@"1"];
+      [titles addObject:@"No"];     [responses addObject:@"2"];
+      [titles addObject:@"Cancel"]; [responses addObject:@"3"];
+    }
+    else
+    {
+      [titles addObject:@"OK"]; [responses addObject:@"1"];
+    }
+
+    if(responseMap) [responseMap release];
+    responseMap = [[NSMutableDictionary dictionary] retain];
+
+    /* Add buttons in their natural IUP order (1, 2, 3...) */
+    for (int i = 0; i < [titles count]; i++)
+    {
+        [alert addButtonWithTitle:titles[i]];
+        /* Map the sequentially assigned Cocoa response code to our IUP response value. */
+        [responseMap setObject:responses[i] forKey:@(NSAlertFirstButtonReturn + i)];
+    }
+
+    /* By default, the first button added gets the Return key equivalent. */
+    /* We need to manually move this designation to the button specified by BUTTONDEFAULT. */
+    int default_idx = button_def - 1;
+    if (default_idx >= 0 && default_idx < [[alert buttons] count])
+    {
+        NSButton* firstButton = [[alert buttons] objectAtIndex:0]; /* The button added first. */
+
+        if (default_idx != 0)
+        {
+            /* If the default is not the first button, remove the default status from the first button */
+            [firstButton setKeyEquivalent:@""];
+            /* And assign it to the correct button. */
+            NSButton* defaultButton = [[alert buttons] objectAtIndex:default_idx];
+            [defaultButton setKeyEquivalent:@"\r"];
+        }
+        else
+        {
+            /* If the default IS the first button, ensure it has the Return key equivalent. This is normally the default behavior. */
+            [firstButton setKeyEquivalent:@"\r"];
+        }
+    }
+
+    if (IupGetCallback(ih, "HELP_CB"))
+    {
+      [alert setShowsHelp:YES];
+    }
+
+    if (parentWindow) {
+        [alert beginSheetModalForWindow:parentWindow completionHandler:^(NSModalResponse returnCode) {
+            [NSApp stopModalWithCode:returnCode];
+        }];
+        response = [NSApp runModalForWindow:[alert window]];
+    } else {
+        response = [alert runModal];
+    }
+
+    [alert release];
+
+    if (response == NSAlertHelpReturn)
+    {
+      help_pressed = YES;
+      Icallback cb = IupGetCallback(ih, "HELP_CB");
+      if (cb && cb(ih) == IUP_CLOSE)
+      {
+        if (iupStrEqualNoCase(buttons_str, "YESNOCANCEL"))
+          iupAttribSet(ih, "BUTTONRESPONSE", "3");
+        else if (iupStrEqualNoCase(buttons_str, "OK"))
+          iupAttribSet(ih, "BUTTONRESPONSE", "1");
+        else
+          iupAttribSet(ih, "BUTTONRESPONSE", "2");
+
+        if(responseMap) [responseMap release];
+        return IUP_NOERROR;
+      }
+    }
+
+  } while (help_pressed);
+
+  NSString* iup_response = [responseMap objectForKey:@(response)];
+  if (iup_response)
   {
-	  [alert addButtonWithTitle:NSLocalizedString(@"OK", @"OK")];
-//    num_but = 1;
-  }       
-  [alert setInformativeText: [NSString stringWithUTF8String:iupAttribGet(ih, "VALUE")]];
-  [alert setMessageText:     [NSString stringWithUTF8String:iupAttribGet(ih, "TITLE")]];
+    iupAttribSet(ih, "BUTTONRESPONSE", [iup_response UTF8String]);
+  }
+  else
+  {
+    /* This case occurs if the dialog is dismissed unexpectedly (e.g., window close button). */
+    if (iupStrEqualNoCase(buttons_str, "YESNOCANCEL"))
+      iupAttribSet(ih, "BUTTONRESPONSE", "3");
+    else if (iupStrEqualNoCase(buttons_str, "OK"))
+      iupAttribSet(ih, "BUTTONRESPONSE", "1");
+    else
+      iupAttribSet(ih, "BUTTONRESPONSE", "2");
+  }
 
-  result = [alert runModal];
-  if (result == 0)
+  if (parent_ih && iupObjectCheck(parent_ih))
   {
-    iupAttribSetStr(ih, "BUTTONRESPONSE", NULL);
-    return IUP_ERROR;
+    IupSetFocus(parent_ih);
   }
 
-  if (result == NSAlertFirstButtonReturn)
-    iupAttribSetStr(ih, "BUTTONRESPONSE", "1");
-  else if (result == NSAlertSecondButtonReturn) 
-    iupAttribSetStr(ih, "BUTTONRESPONSE", "2");
-#endif
+  if(responseMap) [responseMap release];
+
   return IUP_NOERROR;
 }
 
 void iupdrvMessageDlgInitClass(Iclass* ic)
 {
-  ic->DlgPopup = macMessageDlgPopup;
+  ic->DlgPopup = cocoaMessageDlgPopup;
+
+  iupClassRegisterAttribute(ic, "AUTOMODAL", cocoaMessageDlgGetAutoModalAttrib, NULL, IUPAF_SAMEASSYSTEM, "1", IUPAF_NOT_MAPPED|IUPAF_READONLY|IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_open.m
===================================================================
--- src/cocoa/iupcocoa_open.m	(revision 5971)
+++ src/cocoa/iupcocoa_open.m	(working copy)
@@ -1,200 +1,164 @@
 /** \file
- * \brief MAC Driver Core
+ * \brief macOS Driver Core
  *
  * See Copyright Notice in "iup.h"
  */
 
-#include <stdio.h>          
+#import <Cocoa/Cocoa.h>
+#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>          
-#import <Cocoa/Cocoa.h>
+#include <string.h>
 
 #include "iup.h"
-
-#include "iup_str.h"
 #include "iup_drv.h"
 #include "iup_drvinfo.h"
+#include "iup_globalattrib.h"
 #include "iup_object.h"
-#include "iup_globalattrib.h"
+#include "iup_str.h"
 
 #include "iupcocoa_drv.h"
 
-#import "IupAppDelegate.h"
-
-
 static NSAutoreleasePool* s_autoreleasePool = nil;
-static IupAppDelegate* s_appDelegate = nil;
-// This is a hack to try to get around modal dialogs, IUP_CLOSE, and the fact that IupExitLoop doesn't work the same way.
-NSMutableArray* g_stackOfModals = nil;
 
+IUP_SDK_API void* iupdrvGetDisplay(void)
+{
+  return NULL;
+}
 
-#if 0
-char* iupmacGetNativeWindowHandle(Ihandle* ih)
+static bool cocoaGetByteRGBAFromNSColor(NSColor* ns_color, unsigned char* red, unsigned char* green, unsigned char* blue, unsigned char* alpha)
 {
-  id window = ih->handle->window;
-  if (window)
-    return (char*)window;
+  NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
+  if (rgb_color)
+  {
+    CGFloat rgba_components[4];
+    [rgb_color getComponents:rgba_components];
+    *red = (unsigned char)iupROUND(rgba_components[0] * 255.0);
+    *green = (unsigned char)iupROUND(rgba_components[1] * 255.0);
+    *blue = (unsigned char)iupROUND(rgba_components[2] * 255.0);
+    *alpha = (unsigned char)iupROUND(rgba_components[3] * 255.0);
+    return true;
+  }
   else
-    return NULL;
+  {
+    return false;
+  }
 }
-#endif
 
-void* iupdrvGetDisplay(void)
+void iupcocoaSetGlobalColors(void)
 {
-  return NULL;
+  unsigned char r, g, b, a;
+
+  if (cocoaGetByteRGBAFromNSColor([NSColor windowBackgroundColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("DLGBGCOLOR", r, g, b);
+  if (cocoaGetByteRGBAFromNSColor([NSColor labelColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("DLGFGCOLOR", r, g, b);
+
+  if (cocoaGetByteRGBAFromNSColor([NSColor textBackgroundColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("TXTBGCOLOR", r, g, b);
+  if (cocoaGetByteRGBAFromNSColor([NSColor textColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("TXTFGCOLOR", r, g, b);
+  if (cocoaGetByteRGBAFromNSColor([NSColor selectedTextBackgroundColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("TXTHLCOLOR", r, g, b);
+
+  if (cocoaGetByteRGBAFromNSColor([NSColor linkColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("LINKFGCOLOR", r, g, b);
+
+  if (cocoaGetByteRGBAFromNSColor([NSColor windowBackgroundColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("MENUBGCOLOR", r, g, b);
+  if (cocoaGetByteRGBAFromNSColor([NSColor labelColor], &r, &g, &b, &a))
+    iupGlobalSetDefaultColorAttrib("MENUFGCOLOR", r, g, b);
 }
 
-static bool cocoaGetByteRGBAFromNSColor(NSColor* ns_color, unsigned char* red, unsigned char* green, unsigned char* blue, unsigned char* alpha)
+static const char* iupCocoaGetSystemLanguage(void)
 {
-	NSColor* rgb_color = [ns_color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
-	if(rgb_color)
-	{
-		CGFloat rgba_components[4];
-		[rgb_color getComponents:rgba_components];
-		*red = iupROUND(rgba_components[0] * 255.0);
-		*green = iupROUND(rgba_components[1] * 255.0);
-		*blue = iupROUND(rgba_components[2] * 255.0);
-		*alpha = iupROUND(rgba_components[3] * 255.0);
-		return true;
-	}
-	else
-	{
-		NSCAssert(false, @"Color conversion failed");
-		return false;
-	}
+  static char iupmac_language[20] = "en";
+  NSString* language = [[NSLocale preferredLanguages] firstObject];
+  if (language)
+  {
+    strncpy(iupmac_language, [language UTF8String], 19);
+    iupmac_language[19] = 0;
+  }
+  return iupmac_language;
 }
 
-void iupmacUpdateGlobalColors(void)
+int iupdrvOpen(int* argc, char*** argv)
 {
-	unsigned char r;
-	unsigned char g;
-	unsigned char b;
-	unsigned char a;
+  (void)argc;
+  (void)argv;
 
-	// I don't know what this should be
-	//	cocoaGetByteRGBAFromNSColor([NSColor controlBackgroundColor], &r, &g, &b, &a);
-	cocoaGetByteRGBAFromNSColor([NSColor windowFrameColor], &r, &g, &b, &a);
-	// 	cocoaGetByteRGBAFromNSColor([NSColor windowBackgroundColor], &r, &g, &b, &a);
-	iupGlobalSetDefaultColorAttrib("DLGBGCOLOR", r, g, b);
-	
-	cocoaGetByteRGBAFromNSColor([NSColor windowFrameTextColor], &r, &g, &b, &a);
-	
-	iupGlobalSetDefaultColorAttrib("DLGFGCOLOR", r, g, b);
-	
-	
-	
-	
-	cocoaGetByteRGBAFromNSColor([NSColor textBackgroundColor], &r, &g, &b, &a);
-	
-	iupGlobalSetDefaultColorAttrib("TXTBGCOLOR", r, g, b);
-	
-	cocoaGetByteRGBAFromNSColor([NSColor controlTextColor], &r, &g, &b, &a);
-	
-	iupGlobalSetDefaultColorAttrib("TXTFGCOLOR", r, g, b);
-	
-	// FIXME: I don't know where these values came from
-	iupGlobalSetDefaultColorAttrib("MENUBGCOLOR", 183,183,183);
-	
-	
-	cocoaGetByteRGBAFromNSColor([NSColor controlTextColor], &r, &g, &b, &a);
-	
-	iupGlobalSetDefaultColorAttrib("MENUFGCOLOR", r, g, b);
-}
+  if (nil == s_autoreleasePool)
+  {
+    s_autoreleasePool = [[NSAutoreleasePool alloc] init];
+  }
 
-int iupdrvOpen(int *argc, char ***argv)
-{                        
-  (void)argc; /* unused in the mac driver */
-  (void)argv;
+  [NSApplication sharedApplication];
 
-	// Assuming we're always on the main thread.
-	// This will be using a singleton pattern depending if iupdrvClose drains it or not.
-	// Not using dispatch_once thinking about GNUStep
-	if(nil == s_autoreleasePool)
-	{
-		s_autoreleasePool = [[NSAutoreleasePool alloc] init];
-	}
+  /* Ensure the application is treated as a foreground application capable of showing UI. */
+  if ([NSApp activationPolicy] == NSApplicationActivationPolicyProhibited)
+  {
+    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
+  }
 
-	[NSApplication sharedApplication];
-//	[NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
-	/*
-	id menubar = [[NSMenu new] autorelease];
-	id appMenuItem = [[NSMenuItem new] autorelease];
-	[menubar addItem:appMenuItem];
-	[NSApp setMainMenu:menubar];
-	id appMenu = [[NSMenu new] autorelease];
-	id appName = [[NSProcessInfo processInfo] processName];
-	id quitTitle = [@"Quit " stringByAppendingString:appName];
-	id quitMenuItem = [[[NSMenuItem alloc] initWithTitle:quitTitle
-												  action:@selector(terminate:) keyEquivalent:@"q"] autorelease];
-	[appMenu addItem:quitMenuItem];
-	[appMenuItem setSubmenu:appMenu];
-	 */
-	/*
-	id window = [[[NSWindow alloc] initWithContentRect:NSMakeRect(0, 0, 200, 200)
-											 styleMask:NSTitledWindowMask backing:NSBackingStoreBuffered defer:NO]
-				 autorelease];
-	[window cascadeTopLeftFromPoint:NSMakePoint(20,20)];
-	[window setTitle:appName];
-	[window makeKeyAndOrderFront:nil];
-	 */
-//	[NSApp activateIgnoringOtherApps:YES];
-	if(nil == s_appDelegate)
-	{
-		s_appDelegate = [[IupAppDelegate alloc] init];
-	}
-	[NSApp setDelegate:s_appDelegate];
+  /* Manually finish the launch process. This is normally handled by [NSApp run], but IUP uses a custom event loop. */
+  [NSApp finishLaunching];
 
-	
-	// TODO: Is it possible to support 10.12 automatic window tabbing?
-	if([NSWindow respondsToSelector:@selector(setAllowsAutomaticWindowTabbing:)])
-	{
-		[NSWindow setAllowsAutomaticWindowTabbing:NO];
-	}
-	
-	if(nil == g_stackOfModals)
-	{
-		g_stackOfModals = [[NSMutableArray alloc] init];
-	}
-	
-//  IupSetGlobal("DRIVER", "MAC");
+  /* This sets a default menu at startup. It will be replaced later if an IUP dialog with a menu is shown. */
+  iupcocoaEnsureDefaultApplicationMenu();
+
+  /* Disable automatic window tabbing */
+  if ([NSWindow respondsToSelector:@selector(setAllowsAutomaticWindowTabbing:)])
+  {
+    [NSWindow setAllowsAutomaticWindowTabbing:NO];
+  }
+
   IupSetGlobal("DRIVER", "Cocoa");
+  IupSetGlobal("WINDOWING", "COCOA");
+  IupSetGlobal("SYSTEMLANGUAGE", iupCocoaGetSystemLanguage());
 
+  iupcocoaSetGlobalColors();
+  IupSetGlobal("_IUP_RESET_GLOBALCOLORS", "YES");
 
-//  IupSetGlobal("SYSTEMLANGUAGE", iupmacGetSystemLanguage());
+  /* All NSStrings in this implementation use UTF-8. */
+  IupSetInt(NULL, "UTF8MODE", 1);
 
-  iupmacUpdateGlobalColors();
+  return IUP_NOERROR;
+}
 
-  IupSetGlobal("_IUP_RESET_GLOBALCOLORS", "YES");  /* will update the global colors when the first dialog is mapped */
+int iupdrvSetGlobalAppIDAttrib(const char* value)
+{
+  static int appid_set = 0;
+  if (appid_set || !value || !value[0])
+    return 0;
 
+  IupStoreGlobal("_IUP_APPID_INTERNAL", value);
+  appid_set = 1;
+  return 1;
+}
 
-	// Not sure if this is the correct thing to do, but the IupTests have a check to for UTF8MODE. All the NSStrings in this implementation use UTF8String and the non-UTF8MODE tests crash.
-	
-	IupSetInt(NULL, "UTF8MODE", 1);
+int iupdrvSetGlobalAppNameAttrib(const char* value)
+{
+  static int appname_set = 0;
+  if (appname_set || !value || !value[0])
+    return 0;
 
-  return IUP_NOERROR;
+  NSString* appName = [NSString stringWithUTF8String:value];
+  [[NSProcessInfo processInfo] setProcessName:appName];
+  appname_set = 1;
+  return 1;
 }
 
 void iupdrvClose(void)
 {
-	// My current understanding is that IUP will not clean up our application menu Ihandles. So we need to do it ourselves.
-	// By this point, IUP has already cleanup up all its pointers and our code is finally running.
-	iupCocoaMenuCleanupApplicationMenu();
-	
+  /* This cleans up the default menu instance and the IUP menu tracking. */
+  iupcocoaMenuCleanupApplicationMenu();
 
-	// I think the NSStatusItems get cleaned up via Iup because they are IupDialogs and Iup should run through the UnMapMethod.
-
-	// Consider: What if there are modal sessions left when closing? But since this variable is a hack, I don't think this is the right mechanism to use to try to clean this. The IUP core would be better.
-	[g_stackOfModals release];
-	g_stackOfModals = nil;
-	
-	[s_appDelegate release];
-	s_appDelegate = nil;
-	
-	// Hmmm...there could a problem. Objects might get called to be Destroyed after the close.
-	// They shouldn't do this.
-	// But if it happens, maybe we either never drain and do a dispatch_once.
-	[s_autoreleasePool drain];
-	s_autoreleasePool = nil;
-	
-	
+  /*
+   * Draining the autorelease pool here can cause a crash, especially when the app
+   * is quit by closing the last window. The system seems to require the pool
+   * to exist longer than the IupClose call. We accept a minor memory leak at
+   * program termination, which is standard practice for modern applications,
+   * rather than risk a crash. The pool is not set to nil to prevent re-allocation
+   * if IupOpen/IupClose are called multiple times.
+   */
+  /* [s_autoreleasePool drain]; */
 }
Index: src/cocoa/iupcocoa_progressbar.m
===================================================================
--- src/cocoa/iupcocoa_progressbar.m	(revision 5971)
+++ src/cocoa/iupcocoa_progressbar.m	(working copy)
@@ -1,10 +1,11 @@
 /** \file
-* \brief Progress bar Control
-*
-* See Copyright Notice in "iup.h"
-*/
+ * \brief Progress bar Control
+ *
+ * See Copyright Notice in "iup.h"
+ */
 
-#include <Cocoa/Cocoa.h>
+#import <Cocoa/Cocoa.h>
+#import <QuartzCore/QuartzCore.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -24,379 +25,235 @@
 
 #include "iupcocoa_drv.h"
 
-#import <QuartzCore/QuartzCore.h>
 
+void iupdrvProgressBarGetMinSize(Ihandle* ih, int* w, int* h)
+{
+  static int horiz_min_w = -1, horiz_min_h = -1;
+  static int vert_min_w = -1, vert_min_h = -1;
 
+  if (horiz_min_w < 0)
+  {
+    NSProgressIndicator* temp_horiz = [[NSProgressIndicator alloc] init];
+    NSProgressIndicator* temp_vert = [[NSProgressIndicator alloc] init];
 
-// TODO: API: I think we're going to need a separate start/stop key.
-// Cocoa Indeterminate is for progresses you don't know the range for, but are still animated when in progress.
+    [temp_horiz setStyle:NSProgressIndicatorStyleBar];
+    [temp_vert setStyle:NSProgressIndicatorStyleBar];
 
-// TODO: FEATURE: Cocoa provides spinner style
+    NSSize horiz_size = [temp_horiz fittingSize];
+    NSSize vert_size = [temp_vert fittingSize];
 
+    horiz_min_w = (int)horiz_size.width;
+    horiz_min_h = (int)horiz_size.height;
+    vert_min_w = (int)vert_size.width;
+    vert_min_h = (int)vert_size.height;
 
+    /* NSProgressIndicator has flexible width, so use reasonable defaults */
+    if (horiz_min_w < 1) horiz_min_w = 100;
+    if (horiz_min_h < 1) horiz_min_h = 20;
+    if (vert_min_w < 1) vert_min_w = 20;
+    if (vert_min_h < 1) vert_min_h = 100;
 
+    [temp_horiz release];
+    [temp_vert release];
+  }
 
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    *w = vert_min_w;
+    *h = vert_min_h;
+  }
+  else
+  {
+    *w = horiz_min_w;
+    *h = horiz_min_h;
+  }
+}
+
 /*
-Apple Bug Radar: 32298779
-Due to an Apple bug, we can't just use setFrameCenterRotation: to create a vertical progress bar.
-The rendering is really screwed up under certain conditions. 
-It seems that Layer Backed Views must be enabled,
-and should be enabled immediately when created (and not enabled later) or the rendering is glitched.
-As a workaround, we can create a container NSView which we rotate instead. 
-And this doesn't require layer backed views to be enabled.
-However, there seem to be other bugs with the container approach we also have to workaround.
-Trying to move the NSProgressIndicator inside the view to compensate the position for the rotated transform brings back the corruption.
-We can transform the container view, but now we have a coordinate mismatch between Cocoa and IUP.
-So another workaround is to create another container view.
-We translate the inner container view so the outer container view maps 1-to-1 with the IUP x,y expected values.
-But I found some other rendering glitches with this.
-First, don't use an NSView with clipping disabled. This causes all sorts of glitches (vertical pixels appearing nearby and flickering on resize).
-Also, enabling layer backed mode would break everything and go back to the original corruption.
-Without clipping, we must create NSViews large enough for the entire progressbar in either direction.
+   NOTE: Vertical NSProgressIndicator has a rendering bug in Cocoa when simply rotated.
+   WORKAROUND: Use a hierarchy: root container  transform view (rotated)  progress bar.
+   This approach avoids the rendering bug without requiring layer-backed views.
+   The transform view is offset to compensate for coordinate system changes after rotation.
 */
 
+/* The offset needed to position the rotated progress bar correctly within its container */
+#define VERTICAL_PROGRESSBAR_OFFSET 6.0
+
 static NSView* cocoaProgressBarGetRootView(Ihandle* ih)
 {
-	NSView* root_container_view = (NSView*)ih->handle;
-	NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
-	return root_container_view;
+  if (!ih || !ih->handle)
+    return nil;
+
+  NSView* root_container_view = (NSView*)ih->handle;
+  NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
+  return root_container_view;
 }
 
-// This is the intermediate transform view
 static NSView* cocoaProgressBarGetTransformView(Ihandle* ih)
 {
-	if(iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
-	{
-		NSView* root_container_view = cocoaProgressBarGetRootView(ih);
-		NSView* intermediate_transform_view = [[root_container_view subviews] firstObject];
-		NSCAssert([intermediate_transform_view isKindOfClass:[NSView class]], @"Expected NSView");
-		return intermediate_transform_view;
-	}
-	else
-	{
-		NSView* root_container_view = (NSView*)ih->handle;
-		NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
-		return root_container_view;
-	}
+  if (!ih || !ih->handle)
+    return nil;
+
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    NSView* root_container_view = cocoaProgressBarGetRootView(ih);
+    if (!root_container_view)
+      return nil;
+
+    NSView* intermediate_transform_view = [[root_container_view subviews] firstObject];
+    NSCAssert([intermediate_transform_view isKindOfClass:[NSView class]], @"Expected NSView");
+    return intermediate_transform_view;
+  }
+  else
+  {
+    return cocoaProgressBarGetRootView(ih);
+  }
 }
 
 static NSProgressIndicator* cocoaProgressBarGetProgressIndicator(Ihandle* ih)
 {
-	if(iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
-	{
-		NSView* intermediate_transform_view = cocoaProgressBarGetTransformView(ih);
-		NSProgressIndicator* progress_bar = [[intermediate_transform_view subviews] firstObject];
-		NSCAssert([progress_bar isKindOfClass:[NSProgressIndicator class]], @"Expected NSProgressIndicator");
-		return progress_bar;
-	}
-	else
-	{
-		NSProgressIndicator* root_container_view = (NSProgressIndicator*)ih->handle;
-		NSCAssert([root_container_view isKindOfClass:[NSProgressIndicator class]], @"Expected NSProgressIndicator");
-		return root_container_view;
-	}
-}
+  if (!ih || !ih->handle)
+    return nil;
 
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    NSView* intermediate_transform_view = cocoaProgressBarGetTransformView(ih);
+    if (!intermediate_transform_view)
+      return nil;
 
+    NSProgressIndicator* progress_bar = [[intermediate_transform_view subviews] firstObject];
+    NSCAssert([progress_bar isKindOfClass:[NSProgressIndicator class]], @"Expected NSProgressIndicator");
+    return progress_bar;
+  }
+  else
+  {
+    NSProgressIndicator* progress_indicator = (NSProgressIndicator*)ih->handle;
+    NSCAssert([progress_indicator isKindOfClass:[NSProgressIndicator class]], @"Expected NSProgressIndicator");
+    return progress_indicator;
+  }
+}
 
-
-
 static int cocoaProgressBarSetValueAttrib(Ihandle* ih, const char* value)
 {
-	NSProgressIndicator* progress_bar = cocoaProgressBarGetProgressIndicator(ih);
-	
-	if (ih->data->marquee)
-	{
-		return 0;
-	}
-	
-	if(!value)
-	{
-		ih->data->value = 0;
-	}
-	else
-	{
-		iupStrToDouble(value, &(ih->data->value));
-	}
+  if (ih->data->marquee)
+    return 0;
 
-	iProgressBarCropValue(ih);
+  NSProgressIndicator* progress_bar = cocoaProgressBarGetProgressIndicator(ih);
+  if (!progress_bar)
+    return 0;
 
-	[progress_bar setMinValue:ih->data->vmin];
-	[progress_bar setMaxValue:ih->data->vmax];
-	[progress_bar setDoubleValue:ih->data->value];
+  if (!value)
+    ih->data->value = 0;
+  else
+    iupStrToDouble(value, &(ih->data->value));
 
-	//	[progress_bar setFrameCenterRotation:ih->data->value];
-//	[progress_bar setFrameCenterRotation:M_PI/180.0 * ih->data->value];
+  iProgressBarCropValue(ih);
 
-	// Hack to test rotation
-	// The problem with this technique is that the widget "snaps back" on window resize.
-	// This is the typical problem of the layer going behind the view's back and the view eventually re-asserting itself.
-#if 0
-	CALayer* bar_layer = [progress_bar layer];
-	
-//	[[progress_bar superview] setWantsLayer:YES];
-	[bar_layer setAnchorPoint:CGPointMake(0.5, 0.5)];
-//	CGAffineTransform transform = progress_bar.layer.affineTransform;
-	CGAffineTransform transform = CGAffineTransformIdentity;
-//	transform = CGAffineTransformRotate(transform, M_PI/180.0 * ih->data->value);
-	transform = CGAffineTransformRotate(transform, M_PI/180.0 * 90.0);
-//	transform = CGAffineTransformRotate(transform, ih->data->value);
-	progress_bar.layer.affineTransform = transform;
-#endif
-	
-	// Not sure if I really need this, but
-	// https://developer.apple.com/library/mac/qa/qa1473/_index.html
-	[progress_bar displayIfNeeded];
-	
-	
+  [progress_bar setMinValue:ih->data->vmin];
+  [progress_bar setMaxValue:ih->data->vmax];
+  [progress_bar setDoubleValue:ih->data->value];
+  [progress_bar displayIfNeeded];
 
-//	gtk_progress_bar_set_fraction(pbar, (ih->data->value - ih->data->vmin) / (ih->data->vmax - ih->data->vmin));
-	
-	return 0;
+  return 0;
 }
 
 static int cocoaProgressBarSetMarqueeAttrib(Ihandle* ih, const char* value)
 {
-	if (!ih->data->marquee)
-	{
-		return 0;
-	}
-	NSProgressIndicator* progress_bar = cocoaProgressBarGetProgressIndicator(ih);
-	
-	if (iupStrBoolean(value))
-	{
-		// FIXME: This feels like a hack
-		[progress_bar startAnimation:nil];
-		IupSetAttribute(ih->data->timer, "RUN", "YES");
-	}
-	else
-	{
-		// FIXME: This feels like a hack
-		[progress_bar stopAnimation:nil];
-	}
-	return 1;
-}
+  if (!ih->data->marquee)
+    return 0;
 
-static int cocoaProgressBarSetContextMenuAttrib(Ihandle* ih, const char* value)
-{
-	Ihandle* menu_ih = (Ihandle*)value;
-	NSProgressIndicator* progress_bar = cocoaProgressBarGetProgressIndicator(ih);
-	iupCocoaCommonBaseSetContextMenuForWidget(ih, progress_bar, menu_ih);
+  NSProgressIndicator* progress_bar = cocoaProgressBarGetProgressIndicator(ih);
+  if (!progress_bar)
+    return 0;
 
-	return 1;
+  if (iupStrBoolean(value))
+    [progress_bar startAnimation:nil];
+  else
+    [progress_bar stopAnimation:nil];
+
+  return 1;
 }
 
-
 static int cocoaProgressBarMapMethod(Ihandle* ih)
 {
-//	char* value;
+  int initial_width = 200;
+  int initial_height = 30;
 
+  IupGetIntInt(ih, "RASTERSIZE", &initial_width, &initial_height);
+  if (0 == initial_width)
+    initial_width = 200;
+  if (0 == initial_height)
+    initial_height = 30;
 
-	int initial_width = 200;
-	int initial_height = 30;
-	
-//	woffset += 60;
-//	hoffset += 10;
-	//	ih->data->type = 0;
-	
-	// Due to an Apple bug, we can't just use setFrameCenterRotation: to create a vertical progress bar.
-	// The rendering is really screwed up under certain conditions. It seems that Layer Backed Views must be enabled, and should be enabled immediately when created (and not enabled later) or the rendering is glitched.
-	// As a workaround, we can create a container NSView which we rotate instead. And this doesn't even require layer backed views to be enabled.
+  NSRect initial_rect = NSMakeRect(0, 0, initial_width, initial_height);
+  NSProgressIndicator* progress_indicator = [[NSProgressIndicator alloc] initWithFrame:initial_rect];
+  NSView* container_view = nil;
 
-	// IUP doc says 200x30 is the default
-	// However, Mac always draws the bar 6 pixels thick. It seems to pad with empty space if you make it bigger. And Interface Builder says the height is always 20 (presuming padding around 6 pixels)
-	
-	IupGetIntInt(ih, "RASTERSIZE", &initial_width, &initial_height);
-	if(0 == initial_width)
-	{
-		initial_width = 200;
-	}
-	if(0 == initial_height)
-	{
-		initial_height = 30;
-	}
-	
-//	NSRect initial_rect = NSMakeRect(0, 0, 200, 30);
-//	NSRect initial_rect = NSMakeRect(0, 0, 200, 20);
-	NSRect initial_rect = NSMakeRect(0, 0, initial_width, initial_height);
+  [progress_indicator setUsesThreadedAnimation:YES];
 
+  if (iupAttribGetBoolean(ih, "MARQUEE"))
+  {
+    ih->data->marquee = 1;
+    [progress_indicator setIndeterminate:YES];
+  }
+  else
+  {
+    ih->data->marquee = 0;
+    [progress_indicator setIndeterminate:NO];
+  }
 
-	NSProgressIndicator* progress_indicator = [[NSProgressIndicator alloc] initWithFrame:initial_rect];
-	NSView* container_view = nil;
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    int max_dim = iupMAX(initial_width, initial_height);
+    NSRect container_rect = NSMakeRect(0, 0, max_dim, max_dim);
 
-	
+    container_view = [[NSView alloc] initWithFrame:container_rect];
+    NSView* transform_view = [[NSView alloc] initWithFrame:container_rect];
 
-	// Warning: Saw a claim that threaded animation breaks vertical
-	[progress_indicator setUsesThreadedAnimation:YES];
+    [container_view addSubview:transform_view];
+    [transform_view addSubview:progress_indicator];
+    [transform_view release];
+    [progress_indicator release];
 
-	// FIXME: Iup doesn't seem to have explicit start/stop commands.
-	// Cocoa Indeterminate is for progresses you don't know the range for, but are still animated when in progress.
-	[progress_indicator startAnimation:nil];
+    NSSize widget_size = container_rect.size;
 
-	
-	// Vertical mode is completely broken. This appears to be a Mac bug.
-	if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
-	{
-		
-		int max_dim = iupMAX(initial_width, initial_height);
-		// The container views must be large enough to hold the progressbar in either direction.
-		NSRect container_rect = NSMakeRect(0, 0, max_dim, max_dim);
-		
-		container_view = [[NSView alloc] initWithFrame:container_rect];
-		NSView* transform_view = [[NSView alloc] initWithFrame:container_rect];
-		
-		[container_view addSubview:transform_view];
-		[transform_view addSubview:progress_indicator];
-		[transform_view release];
-		[progress_indicator release];
-		
-		
-		
-		NSRect widget_frame = [container_view frame];
-		NSSize widget_size = widget_frame.size;
-		
+    CGFloat x_offset = -container_rect.size.width + (initial_rect.size.height - VERTICAL_PROGRESSBAR_OFFSET);
+    [transform_view setFrame:NSMakeRect(x_offset, 0.0, widget_size.width, widget_size.height)];
 
-		// subtract the full_view_width and add back the thickness of the bar, minus 6 pixels for the actual bar (that way at say <0,0> won't clip half the bar)
-		[transform_view setFrame:NSMakeRect(0.0-container_rect.size.width+(initial_rect.size.height-6.0), 0.0, widget_size.width, widget_size.height)];
-//		[transform_view setFrame:NSMakeRect(0.0-200.0+(30.0-6.0), 0, 200, 200)];
-		
-		if (ih->userheight < ih->userwidth)
-		{
-			int tmp = ih->userheight;
-			ih->userheight = ih->userwidth;
-			ih->userwidth = tmp;
-		}
+    if (ih->userheight < ih->userwidth)
+    {
+      int tmp = ih->userheight;
+      ih->userheight = ih->userwidth;
+      ih->userwidth = tmp;
+    }
 
-		// do after setFrame: before setFrameCenterRotation: otherwise me must transform the values to include the rotation.
-		[transform_view setFrameCenterRotation:90.0];
-//		[container_view setWantsLayer:YES];
+    [transform_view setFrameCenterRotation:90.0];
 
-		// We must not allow IUP to EXPAND the width of the NSProgressIndicator so unset the bit flag if it is set.
-		ih->expand = ih->expand & ~IUP_EXPAND_WIDTH;
+    ih->expand = ih->expand & ~IUP_EXPAND_WIDTH;
+  }
+  else
+  {
+    container_view = progress_indicator;
+    [progress_indicator setAutoresizingMask:(NSViewWidthSizable)];
 
-		// Autosizing breaks vertical. We can't support EXPAND right now :(
-		// And setting the frame on the progress indicator also breaks vertical so we can't manually resize either.
-		//	[transform_view setAutoresizingMask:(NSViewWidthSizable|NSViewHeightSizable)];
-		//	[progress_indicator setAutoresizingMask:(NSViewWidthSizable|NSViewHeightSizable)];
-		//[transform_view setAutoresizingMask:(NSViewWidthSizable)];
-		//[progress_indicator setAutoresizingMask:(NSViewWidthSizable)];
+    ih->expand = ih->expand & ~IUP_EXPAND_HEIGHT;
+  }
 
-	}
-	else
-	{
-//		[progress_indicator setWantsLayer:NO];
+  ih->handle = container_view;
+  iupcocoaSetAssociatedViews(ih, progress_indicator, container_view);
+  iupcocoaAddToParent(ih);
 
-		
-		container_view = progress_indicator;
-		
-		
-		// Autosizing breaks vertical
-		//	[transform_view setAutoresizingMask:(NSViewWidthSizable|NSViewHeightSizable)];
-		//	[progress_indicator setAutoresizingMask:(NSViewWidthSizable|NSViewHeightSizable)];
-		//[transform_view setAutoresizingMask:(NSViewWidthSizable)];
-		[progress_indicator setAutoresizingMask:(NSViewWidthSizable)];
-	
-		
-		// We must not allow IUP to EXPAND the height of the NSProgressIndicator so unset the bit flag if it is set.
-		// Mac fixes the thickness to 6 pixels. Expanding causes the progress bar to become uncentered in the container view.
-		// TODO: Maybe we should remove the container view for just the horizontal.
-		ih->expand = ih->expand & ~IUP_EXPAND_HEIGHT;
-
-		
-	}
-	
-	if (iupAttribGetBoolean(ih, "MARQUEE"))
-	{
-
-		ih->data->marquee = 1;
-		[progress_indicator setIndeterminate:YES];
-		
-		
-	}
-	else
-	{
-		ih->data->marquee = 0;
-		[progress_indicator setIndeterminate:NO];
-
-	}
-	
-
-	
-
-	
-
-	
-
-	
-//	[progress_indicator sizeToFit];
-	
-	
-	
-//	ih->handle = progress_indicator;
-	ih->handle = container_view;
-
-	
-	iupCocoaSetAssociatedViews(ih, progress_indicator, container_view);
-
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
-	
-
-	
-	
-	
-	
-	
-	return IUP_NOERROR;
+  return IUP_NOERROR;
 }
 
-static void cocoaProgressBarUnMapMethod(Ihandle* ih)
-{
-	id progress_bar = ih->handle;
-
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[progress_bar release];
-	ih->handle = NULL;
-	
-}
-
 void iupdrvProgressBarInitClass(Iclass* ic)
 {
-  /* Driver Dependent Class functions */
-	ic->Map = cocoaProgressBarMapMethod;
-	ic->UnMap = cocoaProgressBarUnMapMethod;
+  ic->Map = cocoaProgressBarMapMethod;
 
-
-  /* Driver Dependent Attribute functions */
-  
-  /* Visual */
   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-  
-  /* Special */
   iupClassRegisterAttribute(ic, "FGCOLOR", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);
-#if 1
-
-  /* IupProgressBar only */
-  iupClassRegisterAttribute(ic, "VALUE",  iProgressBarGetValueAttrib,  cocoaProgressBarSetValueAttrib,  NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
-	
+  iupClassRegisterAttribute(ic, "VALUE", iProgressBarGetValueAttrib, cocoaProgressBarSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "ORIENTATION", NULL, NULL, IUPAF_SAMEASSYSTEM, "HORIZONTAL", IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "MARQUEE",     NULL, cocoaProgressBarSetMarqueeAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "DASHED",      NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-#endif
-	
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, cocoaProgressBarSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
+  iupClassRegisterAttribute(ic, "MARQUEE", NULL, cocoaProgressBarSetMarqueeAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "DASHED", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_tabs.m
===================================================================
--- src/cocoa/iupcocoa_tabs.m	(revision 5971)
+++ src/cocoa/iupcocoa_tabs.m	(working copy)
@@ -1,12 +1,8 @@
-/** \file
-* \brief Tabs Control
-*
-* See Copyright Notice in "iup.h"
-*/
-
 /*
-Uses NSTabViewController which requires 10.10.
-*/
+ * This implementation uses the custom IupCocoaTabBarView library to provide the tab bar UI,
+ * and a custom NSView (IupTabsRootView) to manage the content area.
+ * This approach allows for customization of fonts, colors, images and close button.
+ */
 
 #import <Cocoa/Cocoa.h>
 #import <objc/runtime.h>
@@ -13,118 +9,548 @@
 
 #include <stdlib.h>
 #include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include <memory.h>
-#include <stdarg.h>
 
 #include "iup.h"
 #include "iupcbs.h"
 
 #include "iup_object.h"
-#include "iup_layout.h"
 #include "iup_attrib.h"
 #include "iup_str.h"
-#include "iup_dialog.h"
 #include "iup_drv.h"
 #include "iup_drvfont.h"
-#include "iup_stdcontrols.h"
+#include "iup_tabs.h"
+#include "iup_array.h"
 #include "iup_image.h"
-#include "iup_tabs.h"
 
-#include "iup_drvfont.h"
 #include "iupcocoa_drv.h"
+#include "IupCocoaTabBarView.h"
 
-// Need to subclass to get at delegate callbacks for NSTabView.
-@interface IupTabViewController : NSTabViewController
-@property(nonatomic, assign) NSUInteger previousSelectedIndex;
+
+/* Forward declarations */
+static int cocoaTabsPosFixFromNative(Ihandle* ih, int native_pos);
+static int cocoaTabsCreateAndInsertItem(Ihandle* ih, Ihandle* child, int iup_pos);
+static void cocoaTabsHideShowPage(Ihandle* ih, int old_pos, int new_pos, int is_native);
+static Iarray* cocoaTabsGetVisibleArray(Ihandle* ih);
+
+
+/*
+   ===============================================================================
+ * IupTabsRootView:
+ * A custom view that holds the IupCocoaTabBarView and the content area.
+ * It manages the layout of these two subviews based on the TABTYPE.
+ ===============================================================================
+ */
+@interface IupTabsRootView : NSView
+{
+  IupCocoaTabBarView* _tabBarView;
+  NSView* _contentAreaView;
+}
+@property(nonatomic, retain) IupCocoaTabBarView* tabBarView;
+@property(nonatomic, retain) NSView* contentAreaView;
+- (Ihandle*)ihandle;
+- (void)layout;
 @end
 
-@implementation IupTabViewController
+/* Private methods */
+@interface IupTabsRootView ()
+  - (void)_handleRightMouseDownOnTabCell:(IupCocoaTabCell *)tab_cell cb:(IFni)cb ih:(Ihandle *)ih event:(NSEvent *)event;
+  @end
 
-- (Ihandle*) ihandle
+  @implementation IupTabsRootView
+  @synthesize tabBarView = _tabBarView;
+  @synthesize contentAreaView = _contentAreaView;
+
+  - (void)dealloc
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
-	return ih;
+  self.tabBarView = nil;
+  self.contentAreaView = nil;
+  [super dealloc];
 }
 
-- (void) tabView:(NSTabView*)tab_view didSelectTabViewItem:(nullable NSTabViewItem*)tab_view_item
+- (Ihandle*)ihandle
 {
-	[super tabView:tab_view didSelectTabViewItem:tab_view_item];
-	Ihandle* ih = [self ihandle];
-	
-	
-	IFnnn cb = (IFnnn)IupGetCallback(ih, "TABCHANGE_CB");
-	// Watch out: We must not be didSelectTabViewItem or we get the current instead of previous
-	// willSelectTabViewItem did not work any better, even if I queried before calling super
-//	int prev_pos = iupdrvTabsGetCurrentTab(ih);
-	NSUInteger prev_pos = [self previousSelectedIndex];
-	
-	NSArray<NSTabViewItem*>* array_of_items = [self tabViewItems];
-	int pos = (int)[array_of_items indexOfObject:tab_view_item];
-	
-	Ihandle* child = IupGetChild(ih, pos);
-	Ihandle* prev_child = IupGetChild(ih, (int)prev_pos);
-	
+  return (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+}
 
+- (BOOL)isFlipped
+{
+  return YES;
+}
+
+- (void)resizeSubviewsWithOldSize:(NSSize)oldSize
+{
+  [super resizeSubviewsWithOldSize:oldSize];
+  [self layout];
+}
+
+/* The layout method is the core of the composite control.
+   It positions the tab bar and content area based on ih->data->type and ih->data->orientation. */
+- (void)layout
+{
+  [super layout];
+
+  Ihandle* ih = [self ihandle];
+  if (!ih) return;
+
+  NSRect bounds = [self bounds];
+  NSRect tab_bar_frame = NSZeroRect;
+  NSRect content_frame = NSZeroRect;
+
+  /* For vertical tab bars (LEFT/RIGHT). The dimensions are swapped based on text orientation. */
+  BOOL isVerticalText = (ih->data->orientation == ITABS_VERTICAL);
+  CGFloat kVerticalTabBarWidth = isVerticalText ? kTabCellHeight : kMinTabCellWidth;
+
+  switch (ih->data->type) {
+    case ITABS_BOTTOM:
+      tab_bar_frame = NSMakeRect(0, bounds.size.height - kTabBarViewHeight, bounds.size.width, kTabBarViewHeight);
+      content_frame = NSMakeRect(0, 0, bounds.size.width, bounds.size.height - kTabBarViewHeight);
+      [self.tabBarView setOrientation:IupCocoaTabBarHorizontal];
+      break;
+    case ITABS_LEFT:
+      tab_bar_frame = NSMakeRect(0, 0, kVerticalTabBarWidth, bounds.size.height);
+      content_frame = NSMakeRect(kVerticalTabBarWidth, 0, bounds.size.width - kVerticalTabBarWidth, bounds.size.height);
+      [self.tabBarView setOrientation:IupCocoaTabBarVertical];
+      break;
+    case ITABS_RIGHT:
+      tab_bar_frame = NSMakeRect(bounds.size.width - kVerticalTabBarWidth, 0, kVerticalTabBarWidth, bounds.size.height);
+      content_frame = NSMakeRect(0, 0, bounds.size.width - kVerticalTabBarWidth, bounds.size.height);
+      [self.tabBarView setOrientation:IupCocoaTabBarVertical];
+      break;
+    case ITABS_TOP:
+    default:
+      tab_bar_frame = NSMakeRect(0, 0, bounds.size.width, kTabBarViewHeight);
+      content_frame = NSMakeRect(0, kTabBarViewHeight, bounds.size.width, bounds.size.height - kTabBarViewHeight);
+      [self.tabBarView setOrientation:IupCocoaTabBarHorizontal];
+      break;
+  }
+
+  [self.tabBarView setFrame:tab_bar_frame];
+  [self.contentAreaView setFrame:content_frame];
+
+  iupcocoaCommonBaseLayoutGetChildView(ih);
+  iupdrvBaseLayoutUpdateMethod(ih);
+}
+
+- (BOOL)becomeFirstResponder
+{
+  BOOL result = [super becomeFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = [self ihandle];
+    if (ih)
+      iupcocoaFocusIn(ih);
+  }
+  return result;
+}
+
+- (BOOL)resignFirstResponder
+{
+  BOOL result = [super resignFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = [self ihandle];
+    if (ih)
+      iupcocoaFocusOut(ih);
+  }
+  return result;
+}
+
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = [self ihandle];
+  if (ih)
+  {
+    if (iupAttribGet(ih, "_IUPCOCOA_CANFOCUS"))
+      return iupAttribGetBoolean(ih, "_IUPCOCOA_CANFOCUS");
+    return iupAttribGetBoolean(ih, "CANFOCUS");
+  }
+  return [super acceptsFirstResponder];
+}
+
+- (void)keyDown:(NSEvent *)event
+{
+  Ihandle* ih = [self ihandle];
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaKeyEvent(ih, event, mac_key_code, true))
+      [super keyDown:event];
+  }
+  else
+    [super keyDown:event];
+}
+
+- (void)keyUp:(NSEvent *)event
+{
+  Ihandle* ih = [self ihandle];
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaKeyEvent(ih, event, mac_key_code, false))
+      [super keyUp:event];
+  }
+  else
+    [super keyUp:event];
+}
+
+- (void)flagsChanged:(NSEvent *)event
+{
+  Ihandle* ih = [self ihandle];
+  if (ih)
+  {
+    int mac_key_code = [event keyCode];
+    if (!iupcocoaModifierEvent(ih, event, mac_key_code))
+      [super flagsChanged:event];
+  }
+  else
+    [super flagsChanged:event];
+}
+
+- (void)rightMouseDown:(NSEvent*)event
+{
+  Ihandle* ih = [self ihandle];
+  if (!ih)
+  {
+    [super rightMouseDown:event];
+    return;
+  }
+
+  IFni cb = (IFni)IupGetCallback(ih, "RIGHTCLICK_CB");
+  if (!cb)
+  {
+    [super rightMouseDown:event];
+    return;
+  }
+
+  /* Check if the click is inside the tab bar */
+  NSPoint pointInWindow = [event locationInWindow];
+  NSPoint pointInTabBar = [self.tabBarView convertPoint:pointInWindow fromView:nil];
+
+  if (NSPointInRect(pointInTabBar, [self.tabBarView bounds]))
+  {
+    IupCocoaTabCell* tab_cell = [self.tabBarView tabCellInPoint:pointInTabBar];
+    if (tab_cell)
+    {
+      /* Call the helper method using Objective-C syntax */
+      [self _handleRightMouseDownOnTabCell:tab_cell cb:cb ih:ih event:event];
+    }
+    else
+      [super rightMouseDown:event];
+  }
+  else
+  {
+    [super rightMouseDown:event];
+  }
+}
+
+/* Handles the logic for a right-click on a specific tab */
+- (void)_handleRightMouseDownOnTabCell:(IupCocoaTabCell *)tab_cell cb:(IFni)cb ih:(Ihandle *)ih event:(NSEvent *)event
+{
+  /* 'self' here now correctly refers to the IupTabsRootView instance */
+  NSInteger native_pos = [[self.tabBarView tabs] indexOfObject:tab_cell];
+  if (native_pos != NSNotFound)
+  {
+    int iup_pos = cocoaTabsPosFixFromNative(ih, (int)native_pos);
+    if (iup_pos != -1)
+    {
+      cb(ih, iup_pos);
+    }
+  }
+  else
+  {
+    /* This case should be unlikely if tab_cell was found, but forward just in case. */
+    [super rightMouseDown:event];
+  }
+}
+
+@end
+
+
 /*
-	if (iupAttribGet(ih, "_IUPCOCOA_IGNORE_SWITCHPAGE"))
-		return;
- 
-	NSView* tab_content_view = (NSView*)iupAttribGet(child, "_IUPTAB_CONTAINER");
-	NSView* prev_tab_content_view = (NSView*)iupAttribGet(prev_child, "_IUPTAB_CONTAINER");
- 
-	if (tab_content_view) gtk_widget_show(tab_content_view);   // show new page, if any
-	if (prev_tab_container) gtk_widget_hide(prev_tab_container);  // hide previous page, if any
-*/
+   ===============================================================================
+ * IupTabsDelegate:
+ * Handles callbacks from the IupCocoaTabBarView and translates them to IUP.
+ ===============================================================================
+ */
+@interface IupTabsDelegate : NSObject <IupCocoaTabBarViewDelegate, NSMenuDelegate>
+@property(nonatomic, assign) Ihandle* ihandle;
+@property(nonatomic, assign) int previousIupPos;
+@end
 
-	if(iupAttribGet(ih, "_IUPCOCOA_IGNORE_CHANGE"))
-	{
-		[self setPreviousSelectedIndex:(NSUInteger)pos];
-		return;
-	}
-	
-	if(cb)
-	{
-		cb(ih, child, prev_child);
-	}
-	else
-	{
-		IFnii cb2 = (IFnii)IupGetCallback(ih, "TABCHANGEPOS_CB");
-		if(cb2)
-		{
-			cb2(ih, pos, (int)prev_pos);
-		}
-	}
+@implementation IupTabsDelegate
 
-	[self setPreviousSelectedIndex:(NSUInteger)pos];
+/* A tab was just selected */
+- (void)tabDidActived:(IupCocoaTabCell*)tab
+{
+  Ihandle* ih = self.ihandle;
+  if (!ih || !tab) return;
+
+  if (iupAttribGet(ih, "_IUPCOCOA_IGNORE_CHANGE"))
+  {
+    return;
+  }
+
+  IupCocoaTabBarView* tab_bar_view = [(IupTabsRootView*)(ih->handle) tabBarView];
+  int native_pos = (int)[[tab_bar_view tabs] indexOfObject:tab];
+  int pos = cocoaTabsPosFixFromNative(ih, native_pos);
+
+  int prev_pos = self.previousIupPos;
+  if (pos == prev_pos) return;
+
+  /* Show/Hide the respective content views */
+  cocoaTabsHideShowPage(ih, prev_pos, pos, 0);
+
+  /* Fire IUP callbacks */
+  if (pos != -1 && prev_pos != -1)
+  {
+    Ihandle* child = IupGetChild(ih, pos);
+    Ihandle* prev_child = IupGetChild(ih, prev_pos);
+
+    IFnnn cb = (IFnnn)IupGetCallback(ih, "TABCHANGE_CB");
+    if (cb)
+    {
+      cb(ih, child, prev_child);
+    }
+    else
+    {
+      IFnii cb2 = (IFnii)IupGetCallback(ih, "TABCHANGEPOS_CB");
+      if (cb2)
+      {
+        cb2(ih, pos, prev_pos);
+      }
+    }
+  }
+
+  self.previousIupPos = pos;
 }
 
+/* User clicked the close button */
+- (BOOL)tabWillClose:(IupCocoaTabCell*)tab
+{
+  Ihandle* ih = self.ihandle;
+  if (!ih || !tab) return NO;
 
+  IupCocoaTabBarView* tab_bar_view = [(IupTabsRootView*)(ih->handle) tabBarView];
+  int native_pos = (int)[[tab_bar_view tabs] indexOfObject:tab];
+  int iup_pos = cocoaTabsPosFixFromNative(ih, native_pos);
+  if (iup_pos == -1) return NO;
+
+  Ihandle* child = IupGetChild(ih, iup_pos);
+  if (!child) return NO;
+
+  IFni cb = (IFni)IupGetCallback(ih, "TABCLOSE_CB");
+  int ret = IUP_DEFAULT;
+  if (cb)
+  {
+    ret = cb(ih, iup_pos);
+  }
+
+  if (ret == IUP_IGNORE)
+  {
+    return NO;
+  }
+  else
+  {
+    objc_setAssociatedObject(tab, @"IUP_CLOSE_ACTION", [NSNumber numberWithInt:ret], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    objc_setAssociatedObject(tab, @"IUP_CLOSE_POS", [NSNumber numberWithInt:iup_pos], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    return YES;
+  }
+}
+
+- (void)tabDidClosed:(IupCocoaTabCell*)tab
+{
+  Ihandle* ih = self.ihandle;
+  if (!ih || !tab) return;
+
+  NSNumber* actionNum = objc_getAssociatedObject(tab, @"IUP_CLOSE_ACTION");
+  NSNumber* posNum = objc_getAssociatedObject(tab, @"IUP_CLOSE_POS");
+
+  if (!actionNum || !posNum) return;
+
+  int ret = [actionNum intValue];
+  int iup_pos = [posNum intValue];
+
+  Ihandle* child = IupGetChild(ih, iup_pos);
+  if (!child) return;
+
+  if (ret == IUP_CONTINUE)
+  {
+    IupDestroy(child);
+    IupRefreshChildren(ih);
+  }
+  else if (ret == IUP_DEFAULT)
+  {
+    Iarray* visible_array = cocoaTabsGetVisibleArray(ih);
+    int* visible_data = (int*)iupArrayGetData(visible_array);
+
+    iupTabsCheckCurrentTab(ih, iup_pos, 0);
+    visible_data[iup_pos] = 0;
+
+    IupTabsDelegate* delegate = (IupTabsDelegate*)self;
+    IupCocoaTabBarView* tab_bar_view = [(IupTabsRootView*)(ih->handle) tabBarView];
+    if (delegate)
+    {
+      int new_native_pos = (int)[[tab_bar_view tabs] indexOfObject:[tab_bar_view selectedTab]];
+      delegate.previousIupPos = cocoaTabsPosFixFromNative(ih, new_native_pos);
+    }
+  }
+
+  objc_setAssociatedObject(tab, @"IUP_CLOSE_ACTION", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  objc_setAssociatedObject(tab, @"IUP_CLOSE_POS", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+}
+
 @end
 
-static IupTabViewController* cocoaGetTabViewController(Ihandle* ih)
+
+/*
+   ===============================================================================
+ * Helper Functions
+ ===============================================================================
+ */
+
+static IupTabsRootView* cocoaGetRootView(Ihandle* ih)
 {
-	if(ih && ih->handle)
-	{
-		IupTabViewController* tab_view_controller = (IupTabViewController*)ih->handle;
-		NSCAssert([tab_view_controller isKindOfClass:[IupTabViewController class]], @"Expected IupTabViewController");
-		return tab_view_controller;
-	}
-	else
-	{
-		NSCAssert(1, @"Expected ih->handle");
-	}
-	return nil;
+  if (ih && ih->handle)
+  {
+    IupTabsRootView* root_view = (IupTabsRootView*)ih->handle;
+    NSCAssert([root_view isKindOfClass:[IupTabsRootView class]], @"Expected IupTabsRootView");
+    return root_view;
+  }
+  return nil;
 }
 
-// IUP seems to use this value as a boolean, not a width or height.
-// Additionally, Iup's compute natural size is completely useless for us and this API conveys no useful information for us.
-// So this is never called.
+static IupCocoaTabBarView* cocoaGetTabBarView(Ihandle* ih)
+{
+  IupTabsRootView* root_view = cocoaGetRootView(ih);
+  if (root_view)
+  {
+    return [root_view tabBarView];
+  }
+  return nil;
+}
+
+static NSView* cocoaGetContentAreaView(Ihandle* ih)
+{
+  IupTabsRootView* root_view = cocoaGetRootView(ih);
+  if (root_view)
+  {
+    return [root_view contentAreaView];
+  }
+  return nil;
+}
+
+/* Manages an array tracking the visibility of each IUP child tab.
+   This is necessary because Cocoa's API removes invisible tabs, not just hides them. */
+static Iarray* cocoaTabsGetVisibleArray(Ihandle* ih)
+{
+  Iarray* visible_array = (Iarray*)iupAttribGet(ih, "_IUPCOCOA_VISIBLEARRAY");
+  if (!visible_array)
+  {
+    int i, count = IupGetChildCount(ih);
+    visible_array = iupArrayCreate(count > 0 ? count : 1, sizeof(int));
+    iupAttribSet(ih, "_IUPCOCOA_VISIBLEARRAY", (char*)visible_array);
+    if (count > 0)
+    {
+      int* visible_data = (int*)iupArrayGetData(visible_array);
+      for (i = 0; i < count; i++)
+      {
+        visible_data[i] = 1; /* All visible by default */
+      }
+    }
+  }
+  return visible_array;
+}
+
+static int cocoaTabsPosFixToNative(Ihandle* ih, int iup_pos)
+{
+  Iarray* visible_array = cocoaTabsGetVisibleArray(ih);
+  int* visible_data = (int*)iupArrayGetData(visible_array);
+  if (iup_pos < 0 || iup_pos >= iupArrayCount(visible_array) || !visible_data[iup_pos])
+  {
+    return -1;
+  }
+
+  int native_pos = 0;
+  for (int i = 0; i < iup_pos; i++)
+  {
+    if (visible_data[i])
+    {
+      native_pos++;
+    }
+  }
+
+  return native_pos;
+}
+
+static int cocoaTabsPosFixFromNative(Ihandle* ih, int native_pos)
+{
+  if (native_pos < 0)
+  {
+    return -1;
+  }
+
+  Iarray* visible_array = cocoaTabsGetVisibleArray(ih);
+  int* visible_data = (int*)iupArrayGetData(visible_array);
+  int count = iupArrayCount(visible_array);
+  int current_native_pos = -1;
+
+  for (int iup_pos = 0; iup_pos < count; iup_pos++)
+  {
+    if (visible_data[iup_pos])
+    {
+      current_native_pos++;
+    }
+    if (current_native_pos == native_pos)
+    {
+      return iup_pos;
+    }
+  }
+  return -1;
+}
+
+/* Hides the old page and shows the new one */
+static void cocoaTabsHideShowPage(Ihandle* ih, int old_pos, int new_pos, int is_native)
+{
+  int iup_old_pos = old_pos;
+  int iup_new_pos = new_pos;
+
+  if (is_native)
+  {
+    iup_old_pos = cocoaTabsPosFixFromNative(ih, old_pos);
+    iup_new_pos = cocoaTabsPosFixFromNative(ih, new_pos);
+  }
+
+  if (iup_old_pos >= 0)
+  {
+    Ihandle* old_child = IupGetChild(ih, iup_old_pos);
+    if(old_child)
+    {
+      NSView* old_container = (NSView*)iupAttribGet(old_child, "_IUPTAB_CONTAINER");
+      if (old_container) [old_container setHidden:YES];
+    }
+  }
+
+  if (iup_new_pos >= 0)
+  {
+    Ihandle* new_child = IupGetChild(ih, iup_new_pos);
+    if(new_child)
+    {
+      NSView* new_container = (NSView*)iupAttribGet(new_child, "_IUPTAB_CONTAINER");
+      if (new_container) [new_container setHidden:NO];
+    }
+  }
+}
+
+/*
+   ===============================================================================
+ * IUP Driver Functions
+ ===============================================================================
+ */
+
 int iupdrvTabsExtraDecor(Ihandle* ih)
 {
-	(void)ih;
-	return 1; // FIXME: Total guess
+  (void)ih;
+  return 0;
 }
 
 int iupdrvTabsExtraMargin(void)
@@ -134,679 +560,785 @@
 
 int iupdrvTabsGetLineCountAttrib(Ihandle* ih)
 {
-	(void)ih;
-	return 1;
+  return 1;
 }
 
 void iupdrvTabsSetCurrentTab(Ihandle* ih, int pos)
 {
-	IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-	NSArray<NSTabViewItem*>* array_of_items = [tab_view_controller tabViewItems];
-	if(pos >= [array_of_items count])
-	{
-		return;
-	}
-	
-	// Doc: "It is not called when the current tab is programmatically changed or removed"
-	iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", "1");
-	[tab_view_controller setSelectedTabViewItemIndex:pos];
-	iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", NULL);
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (!tab_bar_view)
+  {
+    return;
+  }
+
+  int native_pos = cocoaTabsPosFixToNative(ih, pos);
+  if (native_pos < 0 || (NSUInteger)native_pos >= [[tab_bar_view tabs] count])
+  {
+    return;
+  }
+
+  IupCocoaTabCell* tab_cell = [[tab_bar_view tabs] objectAtIndex:native_pos];
+
+  iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", "1");
+  [tab_cell setAsActiveTab];
+
+  /* setAsActiveTab calls the delegate, but we need to manually
+     update the previous position and show/hide the page
+     because the "IGNORE_CHANGE" flag is set. */
+  IupTabsDelegate* delegate = (IupTabsDelegate*)[tab_bar_view delegate];
+  int old_pos = delegate.previousIupPos;
+  delegate.previousIupPos = pos;
+  cocoaTabsHideShowPage(ih, old_pos, pos, 0);
+
+  iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", NULL);
 }
 
 int iupdrvTabsGetCurrentTab(Ihandle* ih)
 {
-	IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-	return (int)[tab_view_controller selectedTabViewItemIndex];
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (!tab_bar_view)
+  {
+    return -1;
+  }
+
+  IupCocoaTabCell* selected_tab = [tab_bar_view selectedTab];
+  if (!selected_tab)
+  {
+    return -1;
+  }
+
+  int native_pos = (int)[[tab_bar_view tabs] indexOfObject:selected_tab];
+  return cocoaTabsPosFixFromNative(ih, native_pos);
 }
 
-// Hidden tabs are not supported
-int iupdrvTabsIsTabVisible(Ihandle* child, int pos)
+void iupdrvTabsGetTabSize(Ihandle* ih, const char* tab_title, const char* tab_image, int* tab_width, int* tab_height)
 {
-	return 1;
+  int width = 0;
+  int height = kTabCellHeight;  /* Fixed height = 28 */
+  int text_width = 0;
+  int text_height = 0;
+
+  /* Check if this is vertical text orientation for LEFT/RIGHT tabs */
+  int isVerticalText = (ih->data->orientation == ITABS_VERTICAL) && (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT);
+
+  /* Measure text dimensions */
+  if (tab_title)
+  {
+    text_width = iupdrvFontGetStringWidth(ih, tab_title);
+    iupdrvFontGetCharSize(ih, NULL, &text_height);
+    width = text_width;
+
+    /* Height: use MAX of text and kTabCellHeight */
+    if (text_height > height)
+      height = text_height;
+  }
+
+  /* Add image width */
+  if (tab_image)
+  {
+    void* img = iupImageGetImage(tab_image, ih, 0, NULL);
+    if (img)
+    {
+      int img_w, img_h;
+      iupdrvImageGetInfo(img, &img_w, &img_h, NULL);
+
+      width += 16;
+      if (tab_title)
+        width += 4;  /* Spacing between image and text */
+
+      /* Height: use MAX */
+      if (img_h > height)
+        height = img_h;
+    }
+  }
+
+  /* Add horizontal padding based on tab content
+   *
+   * We add maximum expected padding (close button case) to ensure text is never clipped.
+   * The actual close button visibility is controlled by SHOWCLOSE attribute.
+   */
+  if (tab_image)
+  {
+    width += 10;
+  }
+  else
+  {
+    width += 8;
+  }
+
+  /* Add right padding: assume close button may be present */
+  width += 28;
+
+  /* Clamp width between kMinTabCellWidth and kMaxTabCellWidth */
+  if (width < kMinTabCellWidth)
+    width = kMinTabCellWidth;
+  if (width > kMaxTabCellWidth)
+    width = kMaxTabCellWidth;
+
+  if (isVerticalText)
+  {
+    /* For vertical text, the text width becomes the tab height (text is rotated 90) */
+    if (tab_width) *tab_width = height;
+    if (tab_height) *tab_height = width;
+  }
+  else
+  {
+    if (tab_width) *tab_width = width;
+    if (tab_height) *tab_height = height;
+  }
 }
 
-static int cocoaTabsSetTabTypeAttrib(Ihandle* ih, const char* value)
+int iupdrvTabsIsTabVisible(Ihandle* child, int pos)
 {
-	NSTabViewControllerTabStyle new_style = NSTabViewControllerTabStyleSegmentedControlOnTop;
-	
-	if(iupStrEqualNoCase(value, "BOTTOM"))
-	{
-		ih->data->type = ITABS_BOTTOM;
-		new_style = NSTabViewControllerTabStyleSegmentedControlOnBottom;
-	}
-	else if(iupStrEqualNoCase(value, "LEFT"))
-	{
-		
-	}
-	else if(iupStrEqualNoCase(value, "RIGHT"))
-	{
-	}
-	else if(iupStrEqualNoCase(value, "TOP"))
-	{
-		ih->data->type = ITABS_TOP;
-		new_style = NSTabViewControllerTabStyleSegmentedControlOnTop;
-	}
-	else /* "TOP" */
-	{
-		ih->data->type = ITABS_TOP;
-		new_style = NSTabViewControllerTabStyleSegmentedControlOnTop;
-	}
-	
-	
-	if(ih->handle)
-	{
-		IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-		[tab_view_controller setTabStyle:new_style];
-		
-		// FIXME:
-		// I'm having problems where BOTTOM gets clipped.
-		// Refresh isn't helping.
-		//IupRefresh(ih);
-	}
-	
-	return 0;
+  Ihandle* ih = IupGetParent(child);
+  if (!ih) return 0;
+
+  Iarray* visible_array = cocoaTabsGetVisibleArray(ih);
+  if (pos < 0 || pos >= iupArrayCount(visible_array))
+  {
+    return 0;
+  }
+
+  return ((int*)iupArrayGetData(visible_array))[pos];
 }
 
-static int cocoaTabsSetTabTitleAttrib(Ihandle* ih, int pos, const char* value)
+/*
+   ===============================================================================
+ * IUP Attribute Setters
+ ===============================================================================
+ */
+
+static int cocoaTabsSetTabVisibleAttrib(Ihandle* ih, int pos, const char* value)
 {
-	// Setting this to make the default getter iupTabsGetTitleAttrib() work
-	Ihandle* child = IupGetChild(ih, pos);
-	if(child)
-	{
-		iupAttribSetStr(child, "TABTITLE", value);
-	}
-	IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-	
-	NSArray<NSTabViewItem*>* array_of_items = [tab_view_controller tabViewItems];
-	if(pos >= [array_of_items count])
-	{
-		return 0;
-	}
-	
-	NSTabViewItem* tab_view_item = [array_of_items objectAtIndex:pos];
-	
-	NSString* tab_title = nil;
-	if(value)
-	{
-		char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);   /* remove & */
-		tab_title = [NSString stringWithUTF8String:stripped_str];
-	}
-	else
-	{
-		tab_title = @"";
-	}
-	
-	[tab_view_item setLabel:tab_title];
-	
-	
+  Ihandle* child = IupGetChild(ih, pos);
+  if (!child) return 0;
 
+  int is_visible = iupdrvTabsIsTabVisible(child, pos);
+  int new_visible = iupStrBoolean(value);
 
-	return 0;
+  if (is_visible == new_visible) return 0;
+
+  Iarray* visible_array = cocoaTabsGetVisibleArray(ih);
+  int* visible_data = (int*)iupArrayGetData(visible_array);
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+
+  if (new_visible)
+  {
+    visible_data[pos] = 1;
+    cocoaTabsCreateAndInsertItem(ih, child, pos);
+  }
+  else
+  {
+    int native_pos = cocoaTabsPosFixToNative(ih, pos);
+    iupTabsCheckCurrentTab(ih, pos, 0);
+    visible_data[pos] = 0;
+
+    if (native_pos >= 0 && (NSUInteger)native_pos < [[tab_bar_view tabs] count])
+    {
+      IupCocoaTabCell* tab_cell = [[tab_bar_view tabs] objectAtIndex:native_pos];
+
+      iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", "1");
+      [tab_bar_view removeTabCell:tab_cell];
+      iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", NULL);
+
+      IupTabsDelegate* delegate = (IupTabsDelegate*)[tab_bar_view delegate];
+      if (delegate)
+      {
+        int new_native_pos = (int)[[tab_bar_view tabs] indexOfObject:[tab_bar_view selectedTab]];
+        delegate.previousIupPos = cocoaTabsPosFixFromNative(ih, new_native_pos);
+      }
+    }
+  }
+  IupRefresh(ih);
+  return 0;
 }
 
-static int cocoaTabsSetTabImageAttrib(Ihandle* ih, int pos, const char* value)
+static char* cocoaTabsGetMultilineAttrib(Ihandle* ih)
 {
-	Ihandle* child = IupGetChild(ih, pos);
-	if(child)
-	{
-		iupAttribSetStr(child, "TABIMAGE", value);
-	}
-	
-	IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-	NSArray* array_of_items = [tab_view_controller tabViewItems];
-	NSTabViewItem* tab_view_item = [array_of_items objectAtIndex:pos];
-	
-	NSImage* bitmap_image = nil;
-	if(value)
-	{
-		bitmap_image = iupImageGetImage(value, ih, 0, NULL);
-	}
-	else
-	{
-		
-	}
-	[tab_view_item setImage:bitmap_image];
-	
-	return 1;
+  return iupStrReturnBoolean(ih->data->is_multiline);
 }
 
-/* This doesn't seem to work even though there is a font property.
-Even though the property is not marked read-only, the comments describe it as a "getter"
-My attempts to set this property seem to be a no-op
-*/
-/*
-static int cocoaTabsSetStandardFontAttrib(Ihandle* ih, const char* value)
+static int cocoaTabsSetMultilineAttrib(Ihandle* ih, const char* value)
 {
-	if(!iupdrvSetFontAttrib(ih, value))
-	{
-		return 0;
-	}
-	
-	if(ih->handle)
-	{
-		IupCocoaFont* iup_font = iupCocoaGetFont(ih);
+  (void)value;
+  /* MULTILINE is not supported by IupCocoaTabBarView.
+     We set the internal flag based on orientation, as this is used
+     by the IUP core for layout calculations. */
+  if (ih->data->orientation == ITABS_VERTICAL)
+  {
+    ih->data->is_multiline = 1;
+  }
+  else
+  {
+    ih->data->is_multiline = 0;
+  }
 
-		IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-		NSTabView* tab_view = [tab_view_controller tabView];
-
-		[tab_view setFont:[iup_font nativeFont]];
-	}
-	
-	return 1;
+  return 0;
 }
-*/
 
-// I think this should work, but I don't see any results. Apple bug?
-#define IUPCOCOA_ENABLE_TABTIP 0
-#if IUPCOCOA_ENABLE_TABTIP
-static int cocoaTabsSetTabTipAttrib(Ihandle* ih, int pos, const char* value)
+static int cocoaTabsSetTabTypeAttrib(Ihandle* ih, const char* value)
 {
-		// Setting this to make the default getter iupTabsGetTitleAttrib() work
-	Ihandle* child = IupGetChild(ih, pos);
-	if(child)
-	{
-		iupAttribSetStr(child, "TABTIP", value);
-	}
-	IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-	
-	NSArray<NSTabViewItem*>* array_of_items = [tab_view_controller tabViewItems];
-	if(pos >= [array_of_items count])
-	{
-		return 0;
-	}
-	
-	NSTabViewItem* tab_view_item = [array_of_items objectAtIndex:pos];
-	
-	NSString* tab_tip = nil;
-	if(value)
-	{
-		tab_tip = [NSString stringWithUTF8String:value];
-	}
-	else
-	{
-		tab_tip = nil;
-	}
-	
-	[tab_view_item setToolTip:tab_tip];
+  /* TABTYPE and TABORIENTATION are independent */
+  /* TABTYPE only sets the tab position, not the text orientation */
+  if (iupStrEqualNoCase(value, "BOTTOM"))
+  {
+    ih->data->type = ITABS_BOTTOM;
+    ih->data->is_multiline = 0;
+  }
+  else if (iupStrEqualNoCase(value, "LEFT"))
+  {
+    ih->data->type = ITABS_LEFT;
+    ih->data->is_multiline = 1; /* LEFT/RIGHT tabs work better with MULTILINE */
+  }
+  else if (iupStrEqualNoCase(value, "RIGHT"))
+  {
+    ih->data->type = ITABS_RIGHT;
+    ih->data->is_multiline = 1; /* LEFT/RIGHT tabs work better with MULTILINE */
+  }
+  else /* "TOP" */
+  {
+    ih->data->type = ITABS_TOP;
+    ih->data->is_multiline = 0;
+  }
 
-	
-	return 0;
+  if (ih->handle)
+  {
+    IupTabsRootView* root_view = (IupTabsRootView*)ih->handle;
+    [root_view layout];
+  }
+  return 0;
 }
 
-static char* cocoaTabsGetTabTipAttrib(Ihandle* ih, int pos)
+static int cocoaTabsSetTabOrientationAttrib(Ihandle* ih, const char* value)
 {
-	Ihandle* child = IupGetChild(ih, pos);
-	if (child)
-	{
-		return iupAttribGet(child, "TABTIP");
-	}
-	else
-	{
-		return NULL;
-	}
+  if (ih->handle) /* Allow to set only before mapping */
+    return 0;
+
+  if (iupStrEqualNoCase(value, "VERTICAL"))
+    ih->data->orientation = ITABS_VERTICAL;
+  else
+    ih->data->orientation = ITABS_HORIZONTAL;
+
+  return 0;
 }
-#endif
 
+static int cocoaTabsSetTabTitleAttrib(Ihandle* ih, int pos, const char* value)
+{
+  Ihandle* child = IupGetChild(ih, pos);
+  if (child) iupAttribSetStr(child, "TABTITLE", value);
 
-static int cocoaTabsSetContextMenuAttrib(Ihandle* ih, const char* value)
-{
-	IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-	NSView* tab_view = [tab_view_controller tabView];
-	
-	Ihandle* menu_ih = (Ihandle*)value;
-	id ih_widget_to_attach_menu_to = tab_view;
-	iupCocoaCommonBaseSetContextMenuForWidget(ih, ih_widget_to_attach_menu_to, menu_ih);
-	
-	return 1;
+  int native_pos = cocoaTabsPosFixToNative(ih, pos);
+  if (native_pos < 0) return 0;
+
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (!tab_bar_view || (NSUInteger)native_pos >= [[tab_bar_view tabs] count]) return 0;
+
+  IupCocoaTabCell* tab_cell = [[tab_bar_view tabs] objectAtIndex:native_pos];
+  NSString* tab_title = @"";
+  if (value)
+  {
+    char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);
+    tab_title = [NSString stringWithUTF8String:stripped_str];
+    if (stripped_str && stripped_str != value) free(stripped_str);
+  }
+  [tab_cell setTitle:tab_title];
+
+  [tab_bar_view redraw];
+  return 0;
 }
 
+static int cocoaTabsSetTabImageAttrib(Ihandle* ih, int pos, const char* value)
+{
+  Ihandle* child = IupGetChild(ih, pos);
+  if (child) iupAttribSetStr(child, "TABIMAGE", value);
 
+  int native_pos = cocoaTabsPosFixToNative(ih, pos);
+  if (native_pos < 0) return 1;
 
-static void cocoaTabsChildAddedMethod(Ihandle* ih, Ihandle* child)
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (!tab_bar_view || (NSUInteger)native_pos >= [[tab_bar_view tabs] count]) return 1;
+
+  IupCocoaTabCell* tab_cell = [[tab_bar_view tabs] objectAtIndex:native_pos];
+  NSImage* bitmap_image = value ? iupImageGetImage(value, ih, 0, NULL) : nil;
+  [tab_cell setImage:bitmap_image];
+
+  [tab_bar_view redraw];
+  return 1;
+}
+
+static int cocoaTabsSetShowCloseAttrib(Ihandle* ih, int pos, const char* value)
 {
-  /* make sure it has at least one name */
-	if (!iupAttribGetHandleName(child))
-	{
-		iupAttribSetHandleName(child);
-	}
-	
-	if(ih->handle)
-	{
-		IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-		
-		int pos = IupGetChildPos(ih, child);
-		
-		// It appears I am required to setup a NSViewController for each tab.
-		// Since I do not have a nib, I am also required to alloc a NSView for it.
-		NSViewController* view_controller = [[[NSViewController alloc] initWithNibName:nil bundle:nil] autorelease];
-#if 1
-		NSView* content_view = [[[NSView alloc] initWithFrame:NSZeroRect] autorelease];
-#else
-		// For Debugging: Paints the content view red to help debug layout regions.
-		NSView* content_view = [[[NSBox alloc] initWithFrame:NSZeroRect] autorelease];
-		[content_view setBoxType:NSBoxCustom];
-		[content_view setFillColor:[NSColor redColor]];
-		[content_view setTitlePosition:NSNoTitle];
-#endif
+  if (pos == -1) /* Global attribute */
+  {
+    int i, count = IupGetChildCount(ih);
+    for (i = 0; i < count; i++)
+    {
+      /* Call self recursively for each child */
+      cocoaTabsSetShowCloseAttrib(ih, i, value);
+    }
+    /* Also set the default for future children */
+    iupAttribSetStr(ih, "SHOWCLOSE", value);
+    return 1; /* Mark as processed */
+  }
 
-		[view_controller setView:content_view];
-		NSTabViewItem* tab_item = [NSTabViewItem tabViewItemWithViewController:view_controller];
+  Ihandle* child = IupGetChild(ih, pos);
+  if (child) iupAttribSetStr(child, "SHOWCLOSE", value);
 
-		// adding the tab view on the active tab will trigger a change callback that I don't think we are supposed to fire:
-		// Doc: "It is not called when the current tab is programmatically changed or removed"
-		iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", "1");
-		[tab_view_controller insertTabViewItem:tab_item atIndex:pos];
-		//	[tab_view_controller addTabViewItem:tab_item];
-		//	NSView* content_view = [tab_item view];
-		iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", NULL);
+  int native_pos = cocoaTabsPosFixToNative(ih, pos);
+  if (native_pos < 0) return 0; /* Not visible, nothing to do */
 
-		// IMPORTANT: We are putting the content_view in here and not the ViewController or TabViewItem
-		// This is because the rest of IUP "just works" when there is a regular view for the map key.
-		// And the system will correctly add, layout, and remove this view.
-		iupAttribSet(child, "_IUPTAB_CONTAINER", (char*)content_view);
-		
-		
-		// Apply attributes that have been set before map
-		char* tab_attribute = NULL;
-		tab_attribute = iupAttribGet(child, "TABTITLE");
-		cocoaTabsSetTabTitleAttrib(ih, pos, tab_attribute);
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (!tab_bar_view || (NSUInteger)native_pos >= [[tab_bar_view tabs] count]) return 0;
 
-		tab_attribute = iupAttribGet(child, "TABIMAGE");
-		cocoaTabsSetTabImageAttrib(ih, pos, tab_attribute);
+  IupCocoaTabCell* tab_cell = [[tab_bar_view tabs] objectAtIndex:native_pos];
+  if (iupStrBoolean(value))
+  {
+    [tab_cell setHasCloseButton:YES];
+  }
+  else
+  {
+    [tab_cell setHasCloseButton:NO];
+  }
 
-#if IUPCOCOA_ENABLE_TABTIP
-		tab_attribute = iupAttribGet(child, "TABTIP");
-		cocoaTabsSetTabTipAttrib(ih, pos, tab_attribute);
-#endif
+  [tab_bar_view redraw];
+  return 1;
+}
 
-		// Need to force a re-layout to fit the new tab
-		//IupRefresh(ih);
+static int cocoaTabsSetFontAttrib(Ihandle* ih, const char* value)
+{
+  if (!iupdrvSetFontAttrib(ih, value))
+  {
+    return 0;
+  }
 
-	}
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (tab_bar_view)
+  {
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+    if (iup_font)
+    {
+      [tab_bar_view setTabFont:iup_font.nativeFont];
+      [tab_bar_view redraw];
+    }
+  }
+  return 1;
 }
 
-static void cocoaTabsChildRemovedMethod(Ihandle* ih, Ihandle* child, int pos)
+static int cocoaTabsSetFgColorAttrib(Ihandle* ih, const char* value)
 {
-	// NSLog(@"cocoaTabsChildRemovedMethod: %p, %p, %d", ih, child, pos);
-	if(ih->handle)
-	{
-		// Strange: This function gets called back multiple times under some circumstances.
-		// If this is added as one of the tabs:
-		//   vboxB = IupVbox(IupLabel("Label BBB"), IupButton("Button BBB", "cbChildButton"), NULL);
-		// this triggers multiple callbacks.
-		// But if this is instead added as the tab,
-		//   vboxB = IupFrame(IupVbox(IupLabel("Label BBB"), IupButton("Button BBB", "cbChildButton"), NULL));
-		// I only get one callback.
-		// The multiple callbacks screw me up because I end up deleting other tabs.
-		// The other implementations have this check for "_IUPTAB_CONTAINER" which seems to avoid the multiple deletion issue.
-		// I don't really understand why things work this way, but it seems to solve the problem.
-		NSView* content_view = (NSView*)iupAttribGet(child, "_IUPTAB_CONTAINER");
-		if(content_view)
-		{
-		
-			IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
-			
-			// I think this will make Iup switch the current tab to something else so when we remove the tab, both the native & IUP will agree which tab number they are on
-	//		iupTabsCheckCurrentTab(ih, pos, 1);
-			iupAttribSet(child, "_IUPTAB_CONTAINER", NULL);
-			
-			NSArray* array_of_items = [tab_view_controller tabViewItems];
-			NSTabViewItem* tab_view_item = [array_of_items objectAtIndex:pos];
-	
-			// removing the tab view on the active tab will trigger a change callback that I don't think we are supposed to fire:
-			// Doc: "It is not called when the current tab is programmatically changed or removed"
-			iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", "1");
-			[tab_view_controller removeTabViewItem:tab_view_item];
-			iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", NULL);
+  unsigned char r, g, b;
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
 
-			[tab_view_controller setPreviousSelectedIndex:[tab_view_controller selectedTabViewItemIndex]];
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (tab_bar_view)
+  {
+    CGFloat red = r/255.0;
+    CGFloat green = g/255.0;
+    CGFloat blue = b/255.0;
+    NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
 
-			// Need to force a re-layout to refit the tabs
-			//IupRefresh(ih);
-		}
-	}
+    [tab_bar_view setTabTitleColor:the_color];
+    [tab_bar_view setTabActivedTitleColor:the_color];
+    [tab_bar_view redraw];
+  }
+  return 1;
 }
 
-static int cocoaTabsMapMethod(Ihandle* ih)
+static int cocoaTabsSetAllowReorderAttrib(Ihandle* ih, const char* value)
 {
-//	NSTabView* tab_control = [[NSTabView alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)];
-	IupTabViewController* tab_view_controller = [[IupTabViewController alloc] init];
-	// We don't want to see "NSViewController" in the tab by default
-	[tab_view_controller setCanPropagateSelectedChildViewControllerTitle:NO];
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (tab_bar_view)
+  {
+    if (iupStrBoolean(value))
+    {
+      [tab_bar_view setAllowsDragging:YES];
+    }
+    else
+    {
+      [tab_bar_view setAllowsDragging:NO];
+    }
+  }
+  return 1;
+}
 
-	// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-	objc_setAssociatedObject(tab_view_controller, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+static int cocoaTabsSetTabListAttrib(Ihandle* ih, const char* value)
+{
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (tab_bar_view)
+  {
+    if (iupStrBoolean(value))
+    {
+      [tab_bar_view setAllowsTabListMenu:YES];
+    }
+    else
+    {
+      [tab_bar_view setAllowsTabListMenu:NO];
+    }
+    [tab_bar_view redraw];
+  }
+  return 1;
+}
 
+static int cocoaTabsSetCloseButtonOnHoverAttrib(Ihandle* ih, const char* value)
+{
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (tab_bar_view)
+  {
+    if (iupStrBoolean(value))
+    {
+      [tab_bar_view setShowsCloseButtonOnHover:YES];
+    }
+    else
+    {
+      [tab_bar_view setShowsCloseButtonOnHover:NO];
+    }
+    [tab_bar_view redraw];
+  }
+  return 1;
+}
 
-	
+static int cocoaTabsSetBgColorAttrib(Ihandle* ih, const char* value)
+{
+  unsigned char r, g, b;
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
 
-//	ih->handle = tab_control;
-	ih->handle = tab_view_controller;
-	
-	// This is one of those cases where this may not make any sense and nil might be an acceptable value.
-//	iupCocoaSetAssociatedViews(ih, nil, nil);
-	iupCocoaSetAssociatedViews(ih, [tab_view_controller view], [tab_view_controller view]);
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  if (tab_bar_view)
+  {
+    CGFloat red = r/255.0;
+    CGFloat green = g/255.0;
+    CGFloat blue = b/255.0;
+    NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
 
-	
-	// sanity checks
+    /* Set all three color properties for a consistent look */
+    [tab_bar_view setBgColor:the_color];
+    [tab_bar_view setTabBGColor:the_color];
+    [tab_bar_view setTabActivedBGColor:the_color];
+    [tab_bar_view redraw];
+  }
+  return 1;
+}
+
+
 /*
-	ih->data->is_multiline = 0;
-	ih->data->show_close = 0;
-	ih->data->vert_padding = 0;
-	ih->data->horiz_padding = 0;
-*/
+   ===============================================================================
+ * IUP Methods
+ ===============================================================================
+ */
 
-	// Need to apply the style if the user has set it already
-	cocoaTabsSetTabTypeAttrib(ih, iupTabsGetTabTypeAttrib(ih));
-	
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
-	
+static int cocoaTabsCreateAndInsertItem(Ihandle* ih, Ihandle* child, int iup_pos)
+{
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  int native_pos = cocoaTabsPosFixToNative(ih, iup_pos);
+  if (native_pos < 0) return -1;
 
-//	cocoaTabsSetStandardFontAttrib(ih, iupGetFontValue(ih));
+  char* title = iupAttribGet(child, "TABTITLE");
+  if (!title) title = iupAttribGetId(ih, "TABTITLE", iup_pos);
 
-	
-	/* Create pages and tabs */
-	if(ih->firstchild)
-	{
-		Ihandle* child;
-		Ihandle* current_child = (Ihandle*)iupAttribGet(ih, "_IUPTABS_VALUE_HANDLE");
-		
-		for(child = ih->firstchild; child; child = child->brother)
-		{
-			cocoaTabsChildAddedMethod(ih, child);
-		}
-		
-		if(current_child)
-		{
-			IupSetAttribute(ih, "VALUE_HANDLE", (char*)current_child);
-			
-			/* current value is now given by the native system */
-			iupAttribSet(ih, "_IUPTABS_VALUE_HANDLE", NULL);
-		}
-	}
-	
-	
-	
-	return IUP_NOERROR;
-}
+  char* image_name = iupAttribGet(child, "TABIMAGE");
+  if (!image_name) image_name = iupAttribGetId(ih, "TABIMAGE", iup_pos);
 
-static void cocoaTabsUnMapMethod(Ihandle* ih)
-{
-	id tab_control = ih->handle;
+  char* show_close = iupAttribGet(child, "SHOWCLOSE");
+  if (!show_close) show_close = iupAttribGet(ih, "SHOWCLOSE");
 
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		cocoaTabsSetContextMenuAttrib(ih, NULL);
-	}
+  NSString* ns_title = @"";
+  if (title)
+  {
+    char* stripped_str = iupStrProcessMnemonic(title, NULL, 0);
+    ns_title = [NSString stringWithUTF8String:stripped_str];
+    if (stripped_str && stripped_str != title) free(stripped_str);
+  }
 
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[tab_control release];
-	ih->handle = NULL;
-	
-}
+  NSImage* ns_image = image_name ? iupImageGetImage(image_name, ih, 0, NULL) : nil;
 
+  IupCocoaTabCell *tab_cell = [IupCocoaTabCell tabCellWithTabBarView:tab_bar_view title:ns_title image:ns_image];
 
+  if (iupStrBoolean(show_close))
+  {
+    [tab_cell setHasCloseButton:YES];
+  }
 
+  id<IupCocoaTabBarViewDelegate> delegate = [tab_bar_view delegate];
 
+  if ([delegate respondsToSelector:@selector(tabWillBeCreated:)])
+  {
+    [delegate tabWillBeCreated:tab_cell];
+  }
 
-static int cocoaTabsComputeFullTabBarWidth(Ihandle* ih)
+  iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", "1");
+  [[tab_bar_view tabs] insertObject:tab_cell atIndex:native_pos];
+
+  if ([[tab_bar_view tabs] count] == 1)
+  {
+    [tab_cell setAsActiveTab];
+    if ([delegate isKindOfClass:[IupTabsDelegate class]])
+    {
+      [(IupTabsDelegate*)delegate setPreviousIupPos:iup_pos];
+    }
+  }
+  iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", NULL);
+
+  if ([delegate respondsToSelector:@selector(tabDidBeCreated:)])
+  {
+    [delegate tabDidBeCreated:tab_cell];
+  }
+
+  [tab_bar_view redraw];
+
+  return 0;
+}
+
+static void cocoaTabsChildAddedMethod(Ihandle* ih, Ihandle* child)
 {
-	int running_width = 0;
-	int pos;
-	char *tabtitle, *tabimage;
-	Ihandle* child;
+  if (!iupAttribGetHandleName(child)) iupAttribSetHandleName(child);
 
-	// For the standard font, our result comes out at 25,16, which overshoots too much for this.
-	/*
-		int char_width;
-		int char_height;
-		iupdrvFontGetCharSize(ih, &char_width, &char_height);
-	 NSLog(@"cocoaTabsGetCombinedWidth char_width:%d, char_height:%d", char_width, char_height);
-	 */
-	for(pos = 0, child = ih->firstchild; child; child = child->brother, pos++)
-	{
-		tabtitle = iupAttribGetId(ih, "TABTITLE", pos);
-		if (!tabtitle) tabtitle = iupAttribGet(child, "TABTITLE");
-		tabimage = iupAttribGetId(ih, "TABIMAGE", pos);
-		if (!tabimage) tabimage = iupAttribGet(child, "TABIMAGE");
+  if (ih->handle)
+  {
+    /* Add to visibility array */
+    Iarray* visible_array = cocoaTabsGetVisibleArray(ih);
+    int pos = IupGetChildPos(ih, child);
+    iupArrayInsert(visible_array, pos, 1);
+    ((int*)iupArrayGetData(visible_array))[pos] = 1;
 
-		
+    /* Create the native tab cell */
+    cocoaTabsCreateAndInsertItem(ih, child, pos);
 
-		bool has_image = true;
-		
-		int current_tab_width = 0;
-		if(tabtitle)
-		{
-			char* stripped_str = iupStrProcessMnemonic(tabtitle, NULL, 0);   /* remove & */
+    /* Create the content container view */
+    NSView* content_area = cocoaGetContentAreaView(ih);
+    NSView* content_container = [[[NSView alloc] initWithFrame:[content_area bounds]] autorelease];
+    [content_container setHidden:YES]; /* Hide by default */
 
-			// Apple doesn't let us change the font, so we know exactly
-			/*
-			NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
-			NSFont* tab_font = [NSFont messageFontOfSize:0];
-			NSSize string_size = [ns_string sizeWithFont:myFont
-                           constrainedToSize:maximumSize
-                               lineBreakMode:self.myLabel.lineBreakMode];
-			*/
-			
+    [content_area addSubview:content_container];
+    iupAttribSet(child, "_IUPTAB_CONTAINER", (char*)content_container);
+  }
+}
 
-			int current_text_width = iupdrvFontGetStringWidth(ih, stripped_str);
-			current_tab_width += current_text_width;
-//			NSLog(@"%s current_text_width:%d, current_tab_width:%d", tabtitle, current_text_width, current_tab_width);
-			
-			
-		}
-		
-		if(tabimage)
-		{
-			void* img = iupImageGetImage(tabimage, ih, 0, NULL);
-			if(img)
-			{
-				has_image = true;
-				int image_w = 16;
-				int image_h = 16;
-				
-				// Getting the real image dimensions won't work. Apple seems to be resizing the image to fit in the tab bar.
-				// It seems to be about 16x16
-				iupdrvImageGetInfo(img, &image_w, &image_h, NULL);
-				current_tab_width += image_w;
+static void cocoaTabsChildRemovedMethod(Ihandle* ih, Ihandle* child, int pos)
+{
+  if (!ih->handle) return;
 
-//				NSLog(@"%s, image_w:%d, current_tab_width:%d", tabimage, image_w, current_tab_width);
-				// There is some padding to account for between the image and text
-//				current_tab_width += char_width;
-				
-			}
-		}
+  NSView* content_container = (NSView*)iupAttribGet(child, "_IUPTAB_CONTAINER");
+  IupCocoaTabBarView* tab_bar_view = cocoaGetTabBarView(ih);
+  Iarray* visible_array = cocoaTabsGetVisibleArray(ih);
 
-		if(has_image && tabtitle)
-		{
-			// There is about 1 character space bewtween the image and text.
-			// I measured about 10 pixels. Our character width over-estimates too much.
-			// Update: I was coming in over, so I dropped by 1
-			current_tab_width += 9;
-		
-			// There is also about a 7-8 pixel lead-in, and a 10 pixel trail around the whole thing
-			// Update: I was coming in over, so I dropped by 1
-			current_tab_width += 7 + 9;
-		}
-		else if(has_image)
-		{
-			// There is an about 10 pixel lead-in and 10 pixel trail.
-			// Update: I was coming in over, so I dropped by 1
-			current_tab_width += 9 + 9;
+  int is_visible = ((int*)iupArrayGetData(visible_array))[pos];
 
-		}
-		else if(tabtitle)
-		{
-			// There is an about 14 pixel lead-in and 14 pixel trail.
-			// Update: I was coming in over, so I dropped by 1
-			current_tab_width += 13 + 13;
-		}
-		else
-		{
-			// I'm seeing about 18 pixels in the empty NULL title
-			current_tab_width += 9 + 9;
-		}
-		
-	
-		running_width += current_tab_width;
-//		NSLog(@"bottom-loop running_width:%d, current_tab_width:%d", running_width, current_tab_width);
+  if (is_visible)
+  {
+    int native_pos = cocoaTabsPosFixToNative(ih, pos);
+    if (native_pos >= 0 && (NSUInteger)native_pos < [[tab_bar_view tabs] count])
+    {
+      iupTabsCheckCurrentTab(ih, pos, 1);
 
+      IupCocoaTabCell* tab_cell = [[tab_bar_view tabs] objectAtIndex:native_pos];
+
+      iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", "1");
+      /* removeTabCell handles re-activating another tab */
+      [tab_bar_view removeTabCell:tab_cell];
+      iupAttribSet(ih, "_IUPCOCOA_IGNORE_CHANGE", NULL);
+
+      /* Update the delegate's internal state */
+      IupTabsDelegate* delegate = (IupTabsDelegate*)[tab_bar_view delegate];
+      if (delegate)
+      {
+        int new_native_pos = (int)[[tab_bar_view tabs] indexOfObject:[tab_bar_view selectedTab]];
+        delegate.previousIupPos = cocoaTabsPosFixFromNative(ih, new_native_pos);
+      }
+    }
   }
 
-	// With my current numbers, I'm coming in about perfect, but the window edge is exactly on the tab bar end.
-	// So let's add a pixel or two to give it a little breathing room.
-	
-	running_width += 2;
+  if (content_container)
+  {
+    [content_container removeFromSuperview];
+  }
 
-  return running_width;
+  iupArrayRemove(visible_array, pos, 1);
+  iupAttribSet(child, "_IUPTAB_CONTAINER", NULL);
+
+  [tab_bar_view redraw];
 }
 
-static void cocoaTabsComputeNaturalSize(Ihandle* ih, int *w, int *h, int *children_expand)
+static int cocoaTabsMapMethod(Ihandle* ih)
 {
-	Ihandle* child;
-	int children_naturalwidth, children_naturalheight;
-//  int decorwidth, decorheight;
-	
-	/* calculate total children natural size (even for hidden children) */
-	children_naturalwidth = 0;
-	children_naturalheight = 0;
-	
-	for(child = ih->firstchild; child; child = child->brother)
-	{
-		/* update child natural size first */
-		iupBaseComputeNaturalSize(child);
-		
-		*children_expand |= child->expand;
-		children_naturalwidth = iupMAX(children_naturalwidth, child->naturalwidth);
-		children_naturalheight = iupMAX(children_naturalheight, child->naturalheight);
-	}
+  /* Create the root view */
+  IupTabsRootView* root_view = [[IupTabsRootView alloc] initWithFrame:NSZeroRect];
+  ih->handle = root_view; /* DO NOT release root_view, ih->handle owns it */
+  objc_setAssociatedObject(root_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
 
-	// IUP's common core implementation for iTabsGetDecorSize is completely useless for us.
-	// It focuses on the wrong things for us, has the wrong assumptions,
-	// and doesn't seem to understand that the tab bar itself needs a minimum width.
-	// (Maybe it assumes the tabs wrap, which is not the case for Cocoa.)
-	// So this
-//  iTabsGetDecorSize(ih, &decorwidth, &decorheight);
-//  *w = children_naturalwidth + decorwidth;
-//  *h = children_naturalheight + decorheight;
-//	NSLog(@"iupClassObjectComputeNaturalSize children_naturalwidth:%d, children_naturalheight:%d", children_naturalwidth, children_naturalheight);
+  /* Create the Tab Bar */
+  IupCocoaTabBarView* tab_bar_view = [[IupCocoaTabBarView alloc] initWithFrame:NSZeroRect];
+  [root_view setTabBarView:tab_bar_view];
+  [root_view addSubview:tab_bar_view];
+  [tab_bar_view release];
 
-	IupTabViewController* tab_view_controller = cocoaGetTabViewController(ih);
+  /* Create the Content Area */
+  NSView* content_area_view = [[NSView alloc] initWithFrame:NSZeroRect];
+  [root_view setContentAreaView:content_area_view];
+  [root_view addSubview:content_area_view];
+  [content_area_view release];
 
-	NSTabView* tab_view = [tab_view_controller tabView];
-	
-	// It seems that this might give us the correct height. But the width doesn't seem helpful.
-	// Apple allows truncating the strings into the tabs with ellipses.
-	// So trying to compute the natural size with that value isn't working out.
-	NSRect the_rect = [tab_view frame];
-	//NSLog(@"cocoaTabsComputeNaturalSize the_rect: %@", NSStringFromRect(the_rect));
+  /* Create the Delegate */
+  IupTabsDelegate* delegate = [[IupTabsDelegate alloc] init];
+  [delegate setIhandle:ih];
+  [tab_bar_view setDelegate:delegate];
+  /* Store the delegate so we can release it on Unmap */
+  objc_setAssociatedObject(root_view, @"IUP_TABS_DELEGATE", delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  [delegate release];
 
-/*
-	// this is 0,0
-	NSSize minimum_size = [tab_view minimumSize];
-	NSLog(@"cocoaTabsComputeNaturalSize minimum_size: %@", NSStringFromSize(minimum_size));
-	// this is 0,0
-	NSSize preferredContentSize = [tab_view_controller preferredContentSize];
-	NSLog(@"cocoaTabsComputeNaturalSize preferredContentSize: %@", NSStringFromSize(preferredContentSize));
-	// This is 20,20
-	NSSize preferredMinimumSize = [tab_view_controller preferredMinimumSize];
-	NSLog(@"cocoaTabsComputeNaturalSize v: %@", NSStringFromSize(preferredMinimumSize));
-*/
+  iupcocoaSetAssociatedViews(ih, root_view, root_view);
+  cocoaTabsGetVisibleArray(ih);
 
-	// The above built-in values does't seem to include the segmented-bar space as part of the size.
-	// I don't know an official way to compute the size.
-	// So we have to do it the hard way and brute force an estimate.
-	int max_tab_bar_width = cocoaTabsComputeFullTabBarWidth(ih);
-	//NSLog(@"cocoaTabsComputeNaturalSize max_tab_width: %d", max_tab_bar_width);
+  /* Set text orientation before tab type, as layout depends on it */
+  [tab_bar_view setTextOrientation: (ih->data->orientation == ITABS_VERTICAL) ? IupCocoaTabTextVertical : IupCocoaTabTextHorizontal];
 
-	// We also need to account for the tab bar height and padding.
-	// The bar height seems to be about 21 pixels
-	// There also seems to be about 4 pixels of space above, and 6 pixels below.
-	// UPDATE: The frame on tabView seems to get us the height we need. My values seem to be bigger than what frame says.
-//	int add_tab_height = 21 + 4 + 6;
+  /* Set attributes that must be set before children are added */
+  cocoaTabsSetTabTypeAttrib(ih, iupTabsGetTabTypeAttrib(ih));
 
-	int final_w;
-	int final_h;
-	
-	final_w = iupMAX(children_naturalwidth, max_tab_bar_width);
-	
-//	final_h = children_naturalwidth + add_tab_height;
-	final_h = iupMAX(children_naturalheight, the_rect.size.height);
+  if (iupAttribGet(ih, "FONT"))
+    cocoaTabsSetFontAttrib(ih, iupAttribGet(ih, "FONT"));
+  if (iupAttribGet(ih, "FGCOLOR"))
+    cocoaTabsSetFgColorAttrib(ih, iupAttribGet(ih, "FGCOLOR"));
+  if (iupAttribGet(ih, "BGCOLOR"))
+    cocoaTabsSetBgColorAttrib(ih, iupAttribGet(ih, "BGCOLOR"));
+  if (iupAttribGet(ih, "ALLOWREORDER"))
+    cocoaTabsSetAllowReorderAttrib(ih, iupAttribGet(ih, "ALLOWREORDER"));
+  if (iupAttribGet(ih, "TABLIST"))
+    cocoaTabsSetTabListAttrib(ih, iupAttribGet(ih, "TABLIST"));
+  if (iupAttribGet(ih, "CLOSEBUTTONONHOVER"))
+    cocoaTabsSetCloseButtonOnHoverAttrib(ih, iupAttribGet(ih, "CLOSEBUTTONONHOVER"));
 
-//	NSLog(@"cocoaTabsComputeNaturalSize final w:%d h:%d", final_w, final_h);
+  iupcocoaAddToParent(ih);
 
-	*w = final_w;
-	*h = final_h;
+  if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+  {
+    iupcocoaSetCanFocus(ih, 0);
+  }
+  else
+  {
+    iupcocoaSetCanFocus(ih, 1);
+  }
+
+  if (ih->firstchild)
+  {
+    Ihandle* child;
+    Ihandle* current_child = (Ihandle*)iupAttribGet(ih, "_IUPTABS_VALUE_HANDLE");
+    int current_pos = -1, i = 0;
+
+    if (current_child)
+    {
+      Ihandle* c = ih->firstchild;
+      while (c)
+      {
+        if (c == current_child)
+        {
+          current_pos = i;
+          break;
+        }
+        c = c->brother;
+        i++;
+      }
+    }
+
+    for (child = ih->firstchild; child; child = child->brother)
+    {
+      cocoaTabsChildAddedMethod(ih, child);
+    }
+
+    if (current_pos != -1)
+    {
+      iupdrvTabsSetCurrentTab(ih, current_pos);
+      iupAttribSet(ih, "_IUPTABS_VALUE_HANDLE", NULL);
+    }
+    else
+    {
+      /* Activate the first tab by default */
+      iupdrvTabsSetCurrentTab(ih, 0);
+    }
+
+    IupRefresh(ih);
+  }
+
+  return IUP_NOERROR;
 }
 
-
-void iupdrvTabsInitClass(Iclass* ic)
+static void cocoaTabsUnMapMethod(Ihandle* ih)
 {
+  id root_view = ih->handle;
+  if (!root_view) return;
 
-  /* Driver Dependent Class functions */
-	ic->Map = cocoaTabsMapMethod;
-	ic->UnMap = cocoaTabsUnMapMethod;
-	ic->ChildAdded     = cocoaTabsChildAddedMethod;
-	ic->ChildRemoved   = cocoaTabsChildRemovedMethod;
-	//	ic->LayoutUpdate = cocoaTabsLayoutUpdateMethod;
-	ic->ComputeNaturalSize = cocoaTabsComputeNaturalSize;
+  IupCocoaTabBarView* tab_bar_view = [(IupTabsRootView*)root_view tabBarView];
+  if (tab_bar_view)
+    [tab_bar_view setDelegate:nil];
 
-  /* IupTabs only */
-  iupClassRegisterAttribute(ic, "TABTYPE", iupTabsGetTabTypeAttrib, cocoaTabsSetTabTypeAttrib, IUPAF_SAMEASSYSTEM, "TOP", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
-  iupClassRegisterAttributeId(ic, "TABTITLE", iupTabsGetTitleAttrib, cocoaTabsSetTabTitleAttrib, IUPAF_NO_INHERIT);
-  iupClassRegisterAttributeId(ic, "TABIMAGE", NULL, cocoaTabsSetTabImageAttrib, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
+  objc_setAssociatedObject(root_view, @"IUP_TABS_DELEGATE", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 
+  Iarray* visible_array = (Iarray*)iupAttribGet(ih, "_IUPCOCOA_VISIBLEARRAY");
+  if (visible_array)
+  {
+    iupArrayDestroy(visible_array);
+    iupAttribSet(ih, "_IUPCOCOA_VISIBLEARRAY", NULL);
+  }
 
-  /* Common */
-	/* This doesn't seem to work even though there is a font property.
-	 Even though the property is not marked read-only, the comments describe it as a "getter"
-	 My attempts to set this property seem to be a no-op
-	 */
-//  iupClassRegisterAttribute(ic, "STANDARDFONT", NULL, cocoaTabsSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);
+  iupcocoaRemoveFromParent(ih);
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+  [root_view release];
+  ih->handle = NULL;
+}
 
-#if 0
+static void cocoaTabsLayoutUpdateMethod(Ihandle* ih)
+{
+  if (!ih->handle) return;
 
-  /* Driver Dependent Attribute functions */
+  iupdrvBaseLayoutUpdateMethod(ih);
 
-	// Not supported (there is no close button for tabs)
-  iupClassRegisterCallback(ic, "TABCLOSE_CB", "i");
+  IupTabsRootView* root_view = (IupTabsRootView*)ih->handle;
+  [root_view layout];
 
+  NSView* content_area = cocoaGetContentAreaView(ih);
+  if (!content_area) return;
 
-  /* Visual */
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, gtkTabsSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, gtkTabsSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
+  NSRect content_rect = [content_area bounds];
 
-  /* IupTabs only */
-  iupClassRegisterAttribute(ic, "TABORIENTATION", iupTabsGetTabOrientationAttrib, gtkTabsSetTabOrientationAttrib, IUPAF_SAMEASSYSTEM, "HORIZONTAL", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
-  iupClassRegisterAttributeId(ic, "TABVISIBLE", iupTabsGetTabVisibleAttrib, gtkTabsSetTabVisibleAttrib, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "PADDING", iupTabsGetPaddingAttrib, gtkTabsSetPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
-#endif
+  Ihandle* child;
+  for (child = ih->firstchild; child; child = child->brother)
+  {
+    NSView* child_container = (NSView*)iupAttribGet(child, "_IUPTAB_CONTAINER");
+    if (child_container)
+    {
+      [child_container setFrame:content_rect];
+    }
+  }
+}
 
-  /* NOT supported */
-  iupClassRegisterAttribute(ic, "STANDARDFONT", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-  iupClassRegisterAttribute(ic, "TABORIENTATION", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-  iupClassRegisterAttribute(ic, "TABVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-  iupClassRegisterAttribute(ic, "PADDING", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
+void iupdrvTabsInitClass(Iclass* ic)
+{
+  ic->Map = cocoaTabsMapMethod;
+  ic->UnMap = cocoaTabsUnMapMethod;
+  ic->LayoutUpdate = cocoaTabsLayoutUpdateMethod;
+  ic->ChildAdded = cocoaTabsChildAddedMethod;
+  ic->ChildRemoved = cocoaTabsChildRemovedMethod;
 
-	// New API:
-	//I think this should work, but I am not getting results. Apple bug?
-#if IUPCOCOA_ENABLE_TABTIP
-  iupClassRegisterAttributeId(ic, "TABTIP", cocoaTabsGetTabTipAttrib, cocoaTabsSetTabTipAttrib, IUPAF_NO_INHERIT);
-#endif
+  iupClassRegisterCallback(ic, "RIGHTCLICK_CB", "i");
+  iupClassRegisterCallback(ic, "TABCLOSE_CB", "i");
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, cocoaTabsSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupCocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+  iupClassRegisterAttribute(ic, "TABTYPE", iupTabsGetTabTypeAttrib, cocoaTabsSetTabTypeAttrib, IUPAF_SAMEASSYSTEM, "TOP", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "TABTITLE", iupTabsGetTitleAttrib, cocoaTabsSetTabTitleAttrib, IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "TABIMAGE", NULL, cocoaTabsSetTabImageAttrib, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "TABVISIBLE", iupTabsGetTabVisibleAttrib, cocoaTabsSetTabVisibleAttrib, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TABORIENTATION", iupTabsGetTabOrientationAttrib, cocoaTabsSetTabOrientationAttrib, IUPAF_SAMEASSYSTEM, "HORIZONTAL", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
-	
+  iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupcocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+
+  iupClassRegisterAttribute(ic, "FONT", NULL, cocoaTabsSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, cocoaTabsSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaTabsSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "ALLOWREORDER", NULL, cocoaTabsSetAllowReorderAttrib, IUPAF_SAMEASSYSTEM, "NO", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TABLIST", NULL, cocoaTabsSetTabListAttrib, IUPAF_SAMEASSYSTEM, "NO", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "SHOWCLOSE", NULL, cocoaTabsSetShowCloseAttrib, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "CLOSEBUTTONONHOVER", NULL, cocoaTabsSetCloseButtonOnHoverAttrib, IUPAF_SAMEASSYSTEM, "NO", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+
+  iupClassRegisterAttribute(ic, "TABPADDING", NULL, NULL, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MULTILINE", cocoaTabsGetMultilineAttrib, cocoaTabsSetMultilineAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
-
Index: src/cocoa/iupcocoa_text.m
===================================================================
--- src/cocoa/iupcocoa_text.m	(revision 5971)
+++ src/cocoa/iupcocoa_text.m	(working copy)
@@ -31,398 +31,475 @@
 #include "iup_childtree.h"
 
 #include "iupcocoa_drv.h"
-#import "IUPTextSpinnerFilesOwner.h"
+#import "IupCocoaTextSpinnerFilesOwner.h"
 
-// the point of this is we have a unique memory address for an identifier
+@interface NSNib (IupTextSpinner)
++ (instancetype)IupTextSpinner;
+@end
+
+@interface NSNib (IupTextSpinnerNoBindings)
++ (instancetype)IupTextSpinnerNoBindings;
+@end
+
 static const void* IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY = "IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY";
 static const void* IUP_COCOA_TEXT_DELEGATE_OBJ_KEY = "IUP_COCOA_TEXT_DELEGATE_OBJ_KEY";
+static const void* IUP_COCOA_TEXT_FORMATTER_KEY = "IUP_COCOA_TEXT_FORMATTER_KEY";
+static const void* IUP_COCOA_TEXT_OVERWRITE_KEY = "IUP_COCOA_TEXT_OVERWRITE_KEY";
 
-
-#if __APPLE__
-	#define USE_NSSTACKVIEW_TEXTFIELD_CONTAINER 1
-#else // Intended for GNUStep because it lacks NSStackView
-	// USE_CONTAINERVIEW_TEXTFIELD_CONTAINER was intended to try to build an equivalent to the NSStackView approach using the old autoresizingMask, but I can't get it to work correctly in the complicated IupGrid situtation.
-	// The default fallback case is actually better than this container approach.
-//	#define USE_CONTAINERVIEW_TEXTFIELD_CONTAINER 1
-#endif
-
-
-
 typedef enum
 {
-	IupCocoaTextSubType_UNKNOWN = -1,
-	IUPCOCOATEXTSUBTYPE_FIELD,
-	IUPCOCOATEXTSUBTYPE_VIEW,
-	IUPCOCOATEXTSUBTYPE_STEPPER,
+  IUPCOCOATEXTSUBTYPE_FIELD,
+  IUPCOCOATEXTSUBTYPE_VIEW,
+  IUPCOCOATEXTSUBTYPE_STEPPER,
 } IupCocoaTextSubType;
 
-/*
- Each IUP list subtype requires a completely different Cocoa native widget.
- This function provides a consistent and centralized way to distinguish which subtype we need.
- */
+/* Forward declaration */
+static bool cocoaTextComputeLineColumnFromRangeForTextView(NSTextView* text_view, NSRange native_selection_range,
+              NSUInteger* out_start_line, NSUInteger* out_start_column, NSUInteger* out_end_line, NSUInteger* out_end_column);
+
+/* Each IUP text subtype requires a completely different Cocoa native widget.
+   This function provides a consistent and centralized way to distinguish which subtype we need.
+   */
 static IupCocoaTextSubType cocoaTextGetSubType(Ihandle* ih)
 {
-	if(ih->data->is_multiline)
-	{
-		return IUPCOCOATEXTSUBTYPE_VIEW;
-	}
-	else if(iupAttribGetBoolean(ih, "SPIN"))
-	{
-		return IUPCOCOATEXTSUBTYPE_STEPPER;
-	}
-	else
-	{
-		return IUPCOCOATEXTSUBTYPE_FIELD;
-	}
-	return IupCocoaTextSubType_UNKNOWN;
+  if(ih->data->is_multiline)
+  {
+    return IUPCOCOATEXTSUBTYPE_VIEW;
+  }
+  else if(iupAttribGetBoolean(ih, "SPIN"))
+  {
+    return IUPCOCOATEXTSUBTYPE_STEPPER;
+  }
+  else
+  {
+    return IUPCOCOATEXTSUBTYPE_FIELD;
+  }
 }
 
 static NSView* cocoaTextGetRootView(Ihandle* ih)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSView* root_container_view = (NSView*)ih->handle;
-			NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
-			return root_container_view;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSView* root_container_view = (NSView*)ih->handle;
-			NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
-			return root_container_view;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSStackView* root_container_view = (NSView*)ih->handle;
-			NSCAssert([root_container_view isKindOfClass:[NSStackView class]], @"Expected NSStackView");
-			return root_container_view;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	return nil;
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSView* root_container_view = (NSView*)ih->handle;
+        NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
+        return root_container_view;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSView* root_container_view = (NSView*)ih->handle;
+        NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
+        return root_container_view;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSStackView* root_container_view = (NSStackView*)ih->handle;
+        NSCAssert([root_container_view isKindOfClass:[NSStackView class]], @"Expected NSStackView");
+        return root_container_view;
+      }
+    default:
+      {
+        break;
+      }
+  }
+  return nil;
 }
 
-
 static NSTextField* cocoaTextGetTextField(Ihandle* ih)
 {
-#ifdef USE_NSSTACKVIEW_TEXTFIELD_CONTAINER
-	NSStackView* root_container_view = (NSStackView*)ih->handle;
-	NSTextField* text_field = [[root_container_view views] firstObject];
-	NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-	return text_field;
-#elif defined(USE_CONTAINERVIEW_TEXTFIELD_CONTAINER)
-	NSView* root_container_view = (NSView*)ih->handle;
-	NSTextField* text_field = [[root_container_view subviews] firstObject];
-	NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-	return text_field;
-#else
-	NSTextField* root_container_view = (NSTextField*)ih->handle;
-	NSCAssert([root_container_view isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-	return root_container_view;
-#endif
-
+  NSTextField* root_container_view = (NSTextField*)ih->handle;
+  NSCAssert([root_container_view isKindOfClass:[NSTextField class]], @"Expected NSTextField");
+  return root_container_view;
 }
 
 static NSTextView* cocoaTextGetTextView(Ihandle* ih)
 {
-	NSScrollView* root_container_view = (NSScrollView*)cocoaTextGetRootView(ih);
-	NSCAssert([root_container_view isKindOfClass:[NSScrollView class]], @"Expected NSScrollView");
-	NSTextView* text_view = [root_container_view documentView];
-	NSCAssert([text_view isKindOfClass:[NSTextView class]], @"Expected NSTextView");
-	return text_view;
+  NSScrollView* root_container_view = (NSScrollView*)cocoaTextGetRootView(ih);
+  NSCAssert([root_container_view isKindOfClass:[NSScrollView class]], @"Expected NSScrollView");
+  NSTextView* text_view = [root_container_view documentView];
+  NSCAssert([text_view isKindOfClass:[NSTextView class]], @"Expected NSTextView");
+  return text_view;
 }
 
 static NSStepper* cocoaTextGetStepperView(Ihandle* ih)
 {
-#if 0
-	NSStackView* root_container_view = (NSStackView*)ih->handle;
-	NSStepper* stepper_view = [[root_container_view views] lastObject];
-	NSCAssert([stepper_view isKindOfClass:[NSStepper class]], @"Expected NSStepper");
-	return stepper_view;
-#else
-	IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject((id)ih->handle, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
-	NSCAssert([spinner_container isKindOfClass:[IUPTextSpinnerContainer class]], @"Expected IUPTextSpinnerContainer");
-	return [spinner_container stepperView];
-#endif
+  IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject((id)ih->handle, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
+  NSCAssert([spinner_container isKindOfClass:[IUPTextSpinnerContainer class]], @"Expected IUPTextSpinnerContainer");
+  return [spinner_container stepperView];
 }
 
 static NSTextField* cocoaTextGetStepperTextField(Ihandle* ih)
 {
-#if 0
-	NSStackView* root_container_view = (NSStackView*)ih->handle;
-	NSTextField* text_field = [[root_container_view views] firstObject];
-	NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-	return text_field;
-#else
-	IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject((id)ih->handle, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
-	NSCAssert([spinner_container isKindOfClass:[IUPTextSpinnerContainer class]], @"Expected IUPTextSpinnerContainer");
-	return [spinner_container textField];
-#endif
+  IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject((id)ih->handle, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
+  NSCAssert([spinner_container isKindOfClass:[IUPTextSpinnerContainer class]], @"Expected IUPTextSpinnerContainer");
+  return [spinner_container textField];
 }
 
 static IUPStepperObject* cocoaTextGetStepperObject(Ihandle* ih)
 {
-	IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject((id)ih->handle, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
-	NSCAssert([spinner_container isKindOfClass:[IUPTextSpinnerContainer class]], @"Expected IUPTextSpinnerContainer");
-	return [spinner_container stepperObject];
+  IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject((id)ih->handle, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
+  NSCAssert([spinner_container isKindOfClass:[IUPTextSpinnerContainer class]], @"Expected IUPTextSpinnerContainer");
+  return [spinner_container stepperObject];
 }
 
-static IUPStepperObjectController* cocoaTextGetStepperObjectController(Ihandle* ih)
-{
-	IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject((id)ih->handle, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
-	NSCAssert([spinner_container isKindOfClass:[IUPTextSpinnerContainer class]], @"Expected IUPTextSpinnerContainer");
-	return [spinner_container stepperObjectController];
-}
+/* Custom text field cell to control text insets */
+@interface IupCocoaTextFieldCell : NSTextFieldCell
+@end
 
+@implementation IupCocoaTextFieldCell
 
-
-// This is shared between IupCocoaTextField & IupCocoaSecureTextField
-static BOOL IupCocoaTextFieldActionCallbackHelper(Ihandle* ih, NSRange change_range, NSString* replacement_string)
+- (NSRect)drawingRectForBounds:(NSRect)rect
 {
-	if(ih->data->disable_callbacks)
-	{
-		return YES;
-	}
-	
-	
-	IFnis action_cb = (IFnis)IupGetCallback(ih, "ACTION");
-	int ret_val;
-	
-	if(NULL != action_cb)
-	{
-		
-		// FIXME: Converting to UTF8String may break the start/end ranges
-		int start_pos = (int)change_range.location;
-		// FIXME: I don't know what end_pos is. I thought I needed to subtract 1, but not doing so makes things work
-//		int end_pos = (int)(start_pos + change_range.length - 1);
-		int end_pos = (int)(start_pos + change_range.length);
-		
-		if(end_pos < start_pos)
-		{
-			end_pos = start_pos;
-		}
-		
-		// Note: I'm assuming we're always in UTF8 mode
-		
-		//int iupEditCallActionCb(Ihandle* ih, IFnis cb, const char* insert_value, int start, int end, void *mask, int nc, int remove_dir, int utf8)
-		// FIXME: remove_direction???: 1 backwards, 0 forwards, -1???. I don't know what this means.
-		const char* c_str = [replacement_string UTF8String];
-		
-		// I think iupEditCallActionCb assumes a delete is NULL for the insert_value and "" will break it.
-		if(0 == strlen(c_str))
-		{
-			c_str = NULL;
-		}
-		
-		ret_val = iupEditCallActionCb(ih, action_cb, c_str, start_pos, end_pos, ih->data->mask, ih->data->nc, 1, YES);
+  NSRect drawingRect = [super drawingRectForBounds:rect];
+  /* Super already provides inset - reset to exactly 2px to match NSTextView textContainerInset */
+  CGFloat currentInset = drawingRect.origin.x - rect.origin.x;
+  CGFloat targetInset = 2.0;
+  CGFloat adjustment = targetInset - currentInset;
 
-		// FIXME: I don't understand the documentation return value rules.
-		if(0 == ret_val)
-		{
-			return YES;
-		}
-		else if(-1 != ret_val)
-		{
-			return NO;
-		}
-		
-	}
-	return YES;
+  drawingRect.origin.x += adjustment;
+  drawingRect.size.width -= (2.0 * adjustment);
+
+  return drawingRect;
 }
 
+@end
 
-// Helper function for NSTextField and NSSecureTextField overrides of textView:menu:forEvent:atIndex: to inject user menu items into the context menu.
-static void cocoaTextFieldOverrideContextMenuHelper(Ihandle* ih, NSTextView* text_view, NSMenu* the_menu)
-{
-	Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
-	if(NULL != menu_ih)
-	{
-		NSMenu* user_menu = (NSMenu*)menu_ih->handle;
-		iupCocoaCommonBaseAppendMenuItems(the_menu, user_menu);
-		// It appears that Cocoa may append "Services" after our entries if something is selected, so we want another separator.
-		NSRange selected_range = [text_view selectedRange];
-		if(selected_range.length > 0)
-		{
-			[the_menu addItem:[NSMenuItem separatorItem]];
-		}
-	}
-}
-
 @interface IupCocoaTextField : NSTextField
 @end
 
 @implementation IupCocoaTextField
 
-/*
-- (void) controlTextDidBeginEditing:(NSNotification*)notification
++ (Class)cellClass
 {
+  return [IupCocoaTextFieldCell class];
 }
 
-- (void) controlTextDidEndEditing:(NSNotification*)notification
+- (BOOL) textView:(NSTextView*)text_view shouldChangeTextInRange:(NSRange)change_range replacementString:(NSString*)replacement_string
 {
+  BOOL ret_flag;
+  id the_delegate = [self delegate];
+  if([the_delegate respondsToSelector:@selector(textView:shouldChangeTextInRange:replacementString:)])
+  {
+    ret_flag = [the_delegate textView:text_view shouldChangeTextInRange:change_range replacementString:replacement_string];
+    if(NO == ret_flag)
+    {
+      return NO;
+    }
+  }
+
+  NSTextField* text_field = self;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  if(ih->data->disable_callbacks)
+  {
+    return YES;
+  }
+
+  IFnis action_cb = (IFnis)IupGetCallback(ih, "ACTION");
+  int ret_val;
+
+  int start_pos = (int)change_range.location;
+  int end_pos = (int)(start_pos + change_range.length);
+
+  if(end_pos < start_pos)
+  {
+    end_pos = start_pos;
+  }
+
+  const char* c_str;
+  int remove_dir;
+
+  if([replacement_string length] == 0)
+  {
+    c_str = NULL;
+    remove_dir = -1;
+  }
+  else
+  {
+    c_str = [replacement_string UTF8String];
+    remove_dir = 0;
+  }
+
+  ret_val = iupEditCallActionCb(ih, action_cb, c_str, start_pos, end_pos, ih->data->mask, ih->data->nc, remove_dir, YES);
+
+  if(ret_val == 0)
+  {
+    return NO;
+  }
+  else if(ret_val != -1 && c_str != NULL)
+  {
+    char replace_char[2];
+    replace_char[0] = (char)ret_val;
+    replace_char[1] = 0;
+
+    NSString* replacement = [NSString stringWithUTF8String:replace_char];
+
+    ih->data->disable_callbacks = 1;
+    [text_view replaceCharactersInRange:change_range withString:replacement];
+    ih->data->disable_callbacks = 0;
+
+    [text_view didChangeText];
+    return NO;
+  }
+
+  [text_view didChangeText];
+  return YES;
 }
-*/
 
-// I'm in dangerous territory here and could break things like undo
-// http://www.cocoabuilder.com/archive/cocoa/309009-equivalent-of-uitextfield-textfield-shouldchangecharactersinrange-replacementstring-for-nstextfield.html
-// Also, I'm not sure if this is public or private API. If the latter, we need to remove it.
-- (BOOL) textView:(NSTextView*)text_view shouldChangeTextInRange:(NSRange)change_range replacementString:(NSString*)replacement_string
+- (NSMenu *)textView:(NSTextView *)text_view menu:(NSMenu *)the_menu forEvent:(NSEvent *)the_event atIndex:(NSUInteger)char_index
 {
-//	NSLog(@"textView shouldChangeTextInRange replacement: %@", replacement_string);
-	
-	BOOL ret_flag;
-	if([super textView:text_view shouldChangeTextInRange:change_range replacementString:replacement_string])
-	{
-		id the_delegate = [self delegate];
-		if([the_delegate respondsToSelector:@selector(textView:shouldChangeTextInRange:replacementString:)])
-		{
-			ret_flag = [the_delegate textView:text_view shouldChangeTextInRange:change_range replacementString:replacement_string];
-			if(NO == ret_flag)
-			{
-				// If something returned NO, I don't think a user callback can do anything.
-				return NO;
-			}
-		}
-	}
-	else
-	{
-		// If something returned NO, I don't think a user callback can do anything.
-		return NO;
-	}
-	
-	
-	NSTextField* text_field = self;
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY);
-	
-	ret_flag = IupCocoaTextFieldActionCallbackHelper(ih, change_range, replacement_string);
-	if(YES == ret_flag)
-	{
-	    [text_view didChangeText];
-	}
-	return ret_flag;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (iupAttribGet(ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+    if (menu_ih && menu_ih->handle)
+      return (NSMenu*)menu_ih->handle;
+    else
+      return nil;
+  }
+  return the_menu;
 }
 
-// WARNING: This was the only way I could figure out how to correctly override the contextual menu for NSTextField.
-// I tried setting the menu (on demand) of the field editor, but I ended up getting lots of missing items.
-// I tried creating my own field editor and setting a custom delegate for this method on it, but it never got invoked. I think Cocoa may ignore my delegate when used as a field editor.
-// I found a mention on the internet that vaguely suggested subclassing NSTextField and implementing this method.
-// I have not found documentation about this method in NSTextField, only as a delegate protocol for NSTextView.
-// This might mean this is private API so this may have to be disabled.
-// This seems to work though.
-- (NSMenu *)textView:(NSTextView *)text_view menu:(NSMenu *)the_menu forEvent:(NSEvent *)the_event atIndex:(NSUInteger)char_index
+@end
+
+/* Custom secure text field cell to control text insets */
+@interface IupCocoaSecureTextFieldCell : NSSecureTextFieldCell
+@end
+
+@implementation IupCocoaSecureTextFieldCell
+
+- (NSRect)drawingRectForBounds:(NSRect)rect
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
-	cocoaTextFieldOverrideContextMenuHelper(ih, text_view, the_menu);
-	return the_menu;
+  NSRect drawingRect = [super drawingRectForBounds:rect];
+  /* Super already provides inset - reset to exactly 2px to match NSTextView textContainerInset */
+  CGFloat currentInset = drawingRect.origin.x - rect.origin.x;
+  CGFloat targetInset = 2.0;
+  CGFloat adjustment = targetInset - currentInset;
+
+  drawingRect.origin.x += adjustment;
+  drawingRect.size.width -= (2.0 * adjustment);
+
+  return drawingRect;
 }
+
 @end
 
-
 @interface IupCocoaSecureTextField : NSSecureTextField
 @end
 
 @implementation IupCocoaSecureTextField
 
-/*
- - (void) controlTextDidBeginEditing:(NSNotification*)notification
- {
- }
- 
- - (void) controlTextDidEndEditing:(NSNotification*)notification
- {
- }
- */
++ (Class)cellClass
+{
+  return [IupCocoaSecureTextFieldCell class];
+}
 
-// I'm in dangerous territory here and could break things like undo
-// http://www.cocoabuilder.com/archive/cocoa/309009-equivalent-of-uitextfield-textfield-shouldchangecharactersinrange-replacementstring-for-nstextfield.html
-// Also, I'm not sure if this is public or private API. If the latter, we need to remove it.
 - (BOOL) textView:(NSTextView*)text_view shouldChangeTextInRange:(NSRange)change_range replacementString:(NSString*)replacement_string
 {
-	//	NSLog(@"textView shouldChangeTextInRange replacement: %@", replacement_string);
-	
-	BOOL ret_flag;
-	if([super textView:text_view shouldChangeTextInRange:change_range replacementString:replacement_string])
-	{
-		id the_delegate = [self delegate];
-		if([the_delegate respondsToSelector:@selector(textView:shouldChangeTextInRange:replacementString:)])
-		{
-			ret_flag = [the_delegate textView:text_view shouldChangeTextInRange:change_range replacementString:replacement_string];
-			if(NO == ret_flag)
-			{
-				// If something returned NO, I don't think a user callback can do anything.
-				return NO;
-			}
-		}
-	}
-	else
-	{
-		// If something returned NO, I don't think a user callback can do anything.
-		return NO;
-	}
-	
-	
-	NSTextField* text_field = self;
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY);
-	
-	ret_flag = IupCocoaTextFieldActionCallbackHelper(ih, change_range, replacement_string);
-	if(YES == ret_flag)
-	{
-	    [text_view didChangeText];
-	}
-	return ret_flag;
+  BOOL ret_flag;
+  id the_delegate = [self delegate];
+  if([the_delegate respondsToSelector:@selector(textView:shouldChangeTextInRange:replacementString:)])
+  {
+    ret_flag = [the_delegate textView:text_view shouldChangeTextInRange:change_range replacementString:replacement_string];
+    if(NO == ret_flag)
+    {
+      return NO;
+    }
+  }
+
+  NSTextField* text_field = self;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  if(ih->data->disable_callbacks)
+  {
+    return YES;
+  }
+
+  IFnis action_cb = (IFnis)IupGetCallback(ih, "ACTION");
+  int ret_val;
+
+  int start_pos = (int)change_range.location;
+  int end_pos = (int)(start_pos + change_range.length);
+
+  if(end_pos < start_pos)
+  {
+    end_pos = start_pos;
+  }
+
+  const char* c_str;
+  int remove_dir;
+
+  if([replacement_string length] == 0)
+  {
+    c_str = NULL;
+    remove_dir = -1;
+  }
+  else
+  {
+    c_str = [replacement_string UTF8String];
+    remove_dir = 0;
+  }
+
+  ret_val = iupEditCallActionCb(ih, action_cb, c_str, start_pos, end_pos, ih->data->mask, ih->data->nc, remove_dir, YES);
+
+  if(ret_val == 0)
+  {
+    return NO;
+  }
+  else if(ret_val != -1 && c_str != NULL)
+  {
+    char replace_char[2];
+    replace_char[0] = (char)ret_val;
+    replace_char[1] = 0;
+
+    NSString* replacement = [NSString stringWithUTF8String:replace_char];
+
+    ih->data->disable_callbacks = 1;
+    [text_view replaceCharactersInRange:change_range withString:replacement];
+    ih->data->disable_callbacks = 0;
+
+    [text_view didChangeText];
+    return NO;
+  }
+
+  [text_view didChangeText];
+  return YES;
 }
 
-// WARNING: This was the only way I could figure out how to correctly override the contextual menu for NSTextField.
-// I tried setting the menu (on demand) of the field editor, but I ended up getting lots of missing items.
-// I tried creating my own field editor and setting a custom delegate for this method on it, but it never got invoked. I think Cocoa may ignore my delegate when used as a field editor.
-// I found a mention on the internet that vaguely suggested subclassing NSTextField and implementing this method.
-// I have not found documentation about this method in NSTextField, only as a delegate protocol for NSTextView.
-// This might mean this is private API so this may have to be disabled.
-// This seems to work though.
 - (NSMenu *)textView:(NSTextView *)text_view menu:(NSMenu *)the_menu forEvent:(NSEvent *)the_event atIndex:(NSUInteger)char_index
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
-	cocoaTextFieldOverrideContextMenuHelper(ih, text_view, the_menu);
-	return the_menu;
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  if (!iupAttribGet(ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    return the_menu;
+  }
+
+  Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+
+  if(menu_ih && menu_ih->handle)
+  {
+    return (NSMenu*)menu_ih->handle;
+  }
+  else
+  {
+    return nil;
+  }
 }
 
 @end
 
+static void cocoaTextCallCaretCb(Ihandle* ih)
+{
+  IFniii cb = (IFniii)IupGetCallback(ih, "CARET_CB");
+  if (!cb)
+    return;
+
+  int col, lin, pos;
+
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+    {
+      NSTextView* text_view = cocoaTextGetTextView(ih);
+      NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
+      if(NSNotFound == cursor_range.location)
+      {
+        NSTextStorage* text_storage = [text_view textStorage];
+        cursor_range.location = [text_storage length];
+        cursor_range.length = 0;
+      }
+
+      NSUInteger lin_start=1;
+      NSUInteger col_start=1;
+      NSUInteger lin_end=1;
+      NSUInteger col_end=1;
+      bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, cursor_range, &lin_start, &col_start, &lin_end, &col_end);
+      if(!did_find_range)
+        return;
+
+      pos = (int)cursor_range.location;
+      lin = (int)lin_start;
+      col = (int)col_start;
+      break;
+    }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+    {
+      NSTextField* text_field = cocoaTextGetTextField(ih);
+      NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+      if (!field_editor)
+        return;
+
+      NSRange selected_range = [field_editor selectedRange];
+      pos = (int)selected_range.location;
+      col = pos + 1;
+      lin = 1;
+      break;
+    }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+    {
+      NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+      NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+      if (!field_editor)
+        return;
+
+      NSRange selected_range = [field_editor selectedRange];
+      pos = (int)selected_range.location;
+      col = pos + 1;
+      lin = 1;
+      break;
+    }
+    default:
+      return;
+  }
+
+  if (pos != ih->data->last_caret_pos)
+  {
+    ih->data->last_caret_pos = pos;
+    cb(ih, lin, col, pos);
+  }
+}
+
 @interface IupCocoaTextFieldDelegate : NSObject <NSControlTextEditingDelegate, NSTextFieldDelegate>
 @end
 
 @implementation IupCocoaTextFieldDelegate
-// We could have reused textView:shouldChangeTextInRange:replacementString:, but I have multiple concerns we may not be able to keep it.
-// So we use this for the VALUECHANGED_CB
+
 - (void) controlTextDidChange:(NSNotification*)the_notification
 {
-	NSTextField* text_field = [the_notification object];
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY);
-//	NSLog(@"controlTextDidChange: stringValue == %@", [text_field stringValue]);
+  NSTextField* text_field = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY);
 
-	if(ih->data->disable_callbacks)
-	{
-		return;
-	}
-	
-	IFn value_changed_callback = (IFn)IupGetCallback(ih, "VALUECHANGED_CB");
-	if(NULL != value_changed_callback)
-	{
-		int ret_val = value_changed_callback(ih);
-		(void)ret_val;
-	}
+  if(ih->data->disable_callbacks)
+  {
+    return;
+  }
+
+  IFn value_changed_callback = (IFn)IupGetCallback(ih, "VALUECHANGED_CB");
+  if(NULL != value_changed_callback)
+  {
+    int ret_val = value_changed_callback(ih);
+    (void)ret_val;
+  }
+
+  [self performSelector:@selector(checkCaretPosition:) withObject:the_notification afterDelay:0];
 }
 
+- (void) checkCaretPosition:(NSNotification*)the_notification
+{
+  NSTextField* text_field = [the_notification object];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  if (ih && !ih->data->disable_callbacks)
+    cocoaTextCallCaretCb(ih);
+}
+
 @end
 
-// NOTE: This callback is unfinished. Need to understand SPIN_CB rules better.
-// Inherit from IupCocoaTextFieldDelegate to get VALUECHANGED_CB
+/* Inherit from IupCocoaTextFieldDelegate to get VALUECHANGED_CB */
 @interface IupCocoaTextSpinnerDelegate : IupCocoaTextFieldDelegate
 @property(nonatomic, assign) Ihandle* ihandle;
 @end
@@ -429,44 +506,34 @@
 
 @implementation IupCocoaTextSpinnerDelegate
 
-/*
-- (BOOL)control:(NSControl*)the_control textShouldEndEditing:(NSText *)field_editor;
+- (IBAction) mySpinnerClickAction:(id)the_sender
 {
-//	NSLog(@"control: %@", the_control);
-//	NSLog(@"textShouldEndEditing: %@", field_editor);
-}
-*/
+  IFni callback_function;
+  Ihandle* ih = [self ihandle];
 
-- (IBAction) mySpinnerClickAction:(id)the_sender
-{
-	IFni callback_function;
-	Ihandle* ih = [self ihandle];
-	
-	callback_function = (IFni)IupGetCallback(ih, "SPIN_CB");
-	if(callback_function)
-	{
-		IUPStepperObject* stepper_object = cocoaTextGetStepperObject(ih);
-		NSNumber* ns_number = [stepper_object stepperValue];
-		
-		int current_value = [ns_number intValue];
-		
-		int ret_val = callback_function(ih, current_value);
-		
-		if(IUP_IGNORE == ret_val)
-		{
-			// We can't do anything with this
-		}
-	}
+  callback_function = (IFni)IupGetCallback(ih, "SPIN_CB");
+  if(callback_function)
+  {
+    IUPStepperObject* stepper_object = cocoaTextGetStepperObject(ih);
+    NSNumber* ns_number = [stepper_object stepperValue];
+
+    int current_value = [ns_number intValue];
+
+    int ret_val = callback_function(ih, current_value);
+
+    if(IUP_IGNORE == ret_val)
+    {
+      /* We can't do anything with this */
+    }
+  }
 }
 
-
 @end
 
-
-// Inherit from IupCocoaTextFieldDelegate to get VALUECHANGED_CB
+/* Inherit from IupCocoaTextFieldDelegate to get VALUECHANGED_CB */
 @interface IupCocoaTextViewDelegate : IupCocoaTextFieldDelegate <NSTextViewDelegate>
 {
-	NSUndoManager* undoManager;
+  NSUndoManager* undoManager;
 }
 @property(nonatomic, assign) Ihandle* ihandle;
 @end
@@ -475,311 +542,551 @@
 
 - (instancetype) init
 {
-	self = [super init];
-	if(nil != self)
-	{
-		undoManager = [[NSUndoManager alloc] init];
-	}
-	return self;
+  self = [super init];
+  if(nil != self)
+  {
+    undoManager = [[NSUndoManager alloc] init];
+  }
+  return self;
 }
 
 - (void) dealloc
 {
-	[undoManager release];
-	[super dealloc];
+  [undoManager release];
+  [super dealloc];
 }
 
 - (NSUndoManager*) undoManagerForTextView:(NSTextView*)text_view
 {
-	return undoManager;
+  return undoManager;
 }
 
-- (BOOL) textView:(NSTextView*)text_view shouldChangeTextInRange:(NSRange)change_range replacementString:(NSString*)replacement_string
+- (NSMenu *)textView:(NSTextView *)textView menu:(NSMenu *)menu forEvent:(NSEvent *)event atIndex:(NSUInteger)charIndex
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_view, IHANDLE_ASSOCIATED_OBJ_KEY);
-	BOOL ret_flag = IupCocoaTextFieldActionCallbackHelper(ih, change_range, replacement_string);
-	if(YES == ret_flag)
-	{
-	    [text_view didChangeText];
-	}
-	return ret_flag;
+  Ihandle* ih = [self ihandle];
+  if (iupAttribGet(ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+    if (menu_ih && menu_ih->handle)
+      return (NSMenu*)menu_ih->handle;
+    else
+      return nil;  /* Disable context menu */
+  }
+  return menu;
 }
 
+- (BOOL) textView:(NSTextView*)text_view shouldChangeTextInRange:(NSRange)change_range replacementString:(NSString*)replacement_string
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(text_view, IHANDLE_ASSOCIATED_OBJ_KEY);
 
+  if(ih->data->disable_callbacks)
+  {
+    return YES;
+  }
 
-// forward declaration
-static bool cocoaTextComputeLineColumnFromRangeForTextView(NSTextView* text_view, NSRange native_selection_range, NSUInteger* out_start_line, NSUInteger* out_start_column, NSUInteger* out_end_line, NSUInteger* out_end_column);
+  char* filter_case = iupAttribGet(ih, "_IUPCOCOA_FILTER_CASE");
+  char* filter_number = iupAttribGet(ih, "_IUPCOCOA_FILTER_NUMBER");
 
-// For CARET_CB
-- (void) textViewDidChangeSelection:(NSNotification*)the_notification
-{
-	IFniii callback_function;
-	Ihandle* ih = [self ihandle];
-	
-	callback_function = (IFniii)IupGetCallback(ih, "CARET_CB");
-	if(callback_function)
-	{
-		Ihandle* ih = [self ihandle];
-		NSTextView* text_view = cocoaTextGetTextView(ih);
+  if(filter_case || filter_number)
+  {
+    if([replacement_string length] > 0)
+    {
+      NSString* filtered_string = replacement_string;
 
-		NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
-		if(NSNotFound == cursor_range.location)
-		{
-			// what do we do?
-			NSTextStorage* text_storage = [text_view textStorage];
-			cursor_range.location = [text_storage length];
-			cursor_range.length = 0;
-		}
-		
-		NSUInteger lin_start=1;
-		NSUInteger col_start=1;
-		NSUInteger lin_end=1;
-		NSUInteger col_end=1;
-		bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, cursor_range, &lin_start, &col_start, &lin_end, &col_end);
-		if(!did_find_range)
-		{
-		}
-		// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-		int ret_val = callback_function(ih, (int)lin_start, (int)col_start, (int)cursor_range.location);
-		// This API doesn't claim to do anything with return values
+      if(filter_number)
+      {
+        NSCharacterSet* non_digit_set = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
+        NSString* digits_only = [[replacement_string componentsSeparatedByCharactersInSet:non_digit_set] componentsJoinedByString:@""];
 
+        if([digits_only length] == 0 && [replacement_string length] > 0)
+        {
+          return NO;
+        }
+        filtered_string = digits_only;
+      }
 
+      if(filter_case)
+      {
+        if(iupStrEqualNoCase(filter_case, "UPPER"))
+        {
+          filtered_string = [filtered_string uppercaseString];
+        }
+        else if(iupStrEqualNoCase(filter_case, "LOWER"))
+        {
+          filtered_string = [filtered_string lowercaseString];
+        }
+      }
 
-	}
+      if(![filtered_string isEqualToString:replacement_string])
+      {
+        ih->data->disable_callbacks = 1;
+        [text_view replaceCharactersInRange:change_range withString:filtered_string];
+        ih->data->disable_callbacks = 0;
+        [text_view didChangeText];
+        return NO;
+      }
+    }
+  }
 
+  BOOL is_overwrite = NO;
+  NSRange effective_range = change_range;
+  NSNumber* overwrite_mode = objc_getAssociatedObject(text_view, IUP_COCOA_TEXT_OVERWRITE_KEY);
+  if([overwrite_mode boolValue] && [replacement_string length] > 0 && change_range.length == 0)
+  {
+    NSTextStorage* text_storage = [text_view textStorage];
+    NSUInteger text_length = [text_storage length];
+
+    if(change_range.location < text_length)
+    {
+      NSUInteger chars_to_replace = [replacement_string length];
+      NSUInteger available_chars = text_length - change_range.location;
+
+      if(chars_to_replace > available_chars)
+        chars_to_replace = available_chars;
+
+      effective_range.length = chars_to_replace;
+      is_overwrite = YES;
+    }
+  }
+
+  IFnis action_cb = (IFnis)IupGetCallback(ih, "ACTION");
+  int ret_val;
+
+  int start_pos = (int)effective_range.location;
+  int end_pos = (int)(start_pos + effective_range.length);
+
+  if(end_pos < start_pos)
+  {
+    end_pos = start_pos;
+  }
+
+  const char* c_str;
+  int remove_dir;
+
+  if([replacement_string length] == 0)
+  {
+    c_str = NULL;
+    remove_dir = -1;
+  }
+  else
+  {
+    c_str = [replacement_string UTF8String];
+    remove_dir = 0;
+  }
+
+  ret_val = iupEditCallActionCb(ih, action_cb, c_str, start_pos, end_pos, ih->data->mask, ih->data->nc, remove_dir, YES);
+
+  if(ret_val == 0)
+  {
+    return NO;
+  }
+  else if(ret_val != -1 && c_str != NULL)
+  {
+    char replace_char[2];
+    replace_char[0] = (char)ret_val;
+    replace_char[1] = 0;
+
+    NSString* replacement = [NSString stringWithUTF8String:replace_char];
+
+    ih->data->disable_callbacks = 1;
+    [text_view replaceCharactersInRange:effective_range withString:replacement];
+    ih->data->disable_callbacks = 0;
+
+    [text_view didChangeText];
+    return NO;
+  }
+
+  if(is_overwrite)
+  {
+    ih->data->disable_callbacks = 1;
+    [text_view replaceCharactersInRange:effective_range withString:replacement_string];
+    ih->data->disable_callbacks = 0;
+    [text_view didChangeText];
+    return NO;
+  }
+
+  [text_view didChangeText];
+  return YES;
 }
 
+- (void) textViewDidChangeSelection:(NSNotification*)the_notification
+{
+  Ihandle* ih = [self ihandle];
+
+  if (ih && !ih->data->disable_callbacks)
+    cocoaTextCallCaretCb(ih);
+}
+
 @end
 
-
 void iupdrvTextAddSpin(Ihandle* ih, int *w, int h)
 {
+  static int spin_min_width = -1;
 
-	
+  (void)h;
+  (void)ih;
+
+  /* Measure the minimum width required by NSStepper */
+  if (spin_min_width < 0)
+  {
+    NSStepper* temp_stepper = [[NSStepper alloc] initWithFrame:NSZeroRect];
+    [temp_stepper setMinValue:0];
+    [temp_stepper setMaxValue:100];
+    [temp_stepper setIncrement:1];
+
+    NSSize fittingSize = [temp_stepper fittingSize];
+    spin_min_width = (int)fittingSize.width;
+
+    [temp_stepper release];
+  }
+
+  /* Only enforce minimum width, don't force expansion */
+  if (*w < spin_min_width)
+    *w = spin_min_width;
 }
 
 void iupdrvTextAddBorders(Ihandle* ih, int *x, int *y)
 {
-	// TODO: Originally, we wanted to lock down the height for NSTextFields so Iup wouldn't try to grow it.
-	// This broke multiline NSTextView's.
-	// We needed the Ihandle* to distinguish, but the API did not provide it.
-	// We've since changed the API to get this.
-	// However, we also employed NSStackView to prevent the NSTextField from increasing its height.
-	// This code seems to work for now, but probably should be heavily tested under more conditions.
-	
-	// if(ih->data->is_multiline)
+  static int cocoa_textfield_border_w = -1;
+  static int cocoa_textfield_border_h = -1;
+  static int cocoa_scrollview_border_w = -1;
+  static int cocoa_scrollview_border_h = -1;
 
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
 
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        /* Multiline text view with NSScrollView */
+        if (cocoa_scrollview_border_w < 0)
+        {
+          /* Measure NSScrollView with bezel border */
+          NSScrollView* temp_scroll = [[NSScrollView alloc] initWithFrame:NSZeroRect];
+          NSTextView* temp_text = [[NSTextView alloc] initWithFrame:NSZeroRect];
+          [temp_scroll setDocumentView:temp_text];
+          [temp_scroll setBorderType:NSBezelBorder];
+          [temp_scroll setHasVerticalScroller:YES];
 
-	// WARNING: This is still a hack. SCROLLBAR_PADDING ws randomly guessed to get by for now.
-	// BEWARE: The Cocoa widget may not exist yet when this is called. We will get an ih, but ih->handle is not established. This will make things harder.
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-//			NSTextView* text_view = cocoaTextGetTextView(ih);
+          /* Get the content insets */
+          NSSize content_size = [temp_scroll contentSize];
+          NSSize frame_size = [NSScrollView frameSizeForContentSize:content_size
+                                            horizontalScrollerClass:nil
+                                              verticalScrollerClass:[NSScroller class]
+                                                         borderType:NSBezelBorder
+                                                        controlSize:NSControlSizeRegular
+                                                      scrollerStyle:NSScrollerStyleOverlay];
 
-	
-			//	*y = *y+10;
-			//	*x = *x+4;
-				// NSTextField is all guess work about how to scale for any font size.
-				// Throw away ih->currentheight because it will EXPAND it.
-				// But for the standard font, we get fontheight=16 and we want the height to be 22
+          cocoa_scrollview_border_w = (int)lroundf(frame_size.width - content_size.width);
+          cocoa_scrollview_border_h = (int)lroundf(frame_size.height - content_size.height);
 
-			
-			//	int font_height = 16;
-				int font_height = *y;
-			
-			//	iupdrvFontGetCharSize(ih, NULL, &font_height);
-				const CGFloat HEIGHT_PADDING = 6.0;
-				const CGFloat SCROLLBAR_PADDING = 8.0;
+          if (cocoa_scrollview_border_w < 0) cocoa_scrollview_border_w = 2;
+          if (cocoa_scrollview_border_h < 0) cocoa_scrollview_border_h = 2;
 
-				*y = font_height + HEIGHT_PADDING + SCROLLBAR_PADDING;
-			//	*y = 16;
+          [temp_text release];
+          [temp_scroll release];
+        }
 
-				const CGFloat WIDTH_PADDING = 12.0;
-			
-			
-				*x = *x - WIDTH_PADDING;
+        *x += cocoa_scrollview_border_w;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			// Neither the field nor the cell work. I think I must change the field editor.
-//			NSTextField* text_field = cocoaTextGetTextField(ih);
+        /* For VISIBLELINES, we need to account for NSTextView's actual line height */
+        int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+        if (visiblelines > 0)
+        {
+          static CGFloat cocoa_line_height = -1.0;
 
+          if (cocoa_line_height < 0.0)
+          {
+            /* Measure actual NSTextView line height */
+            IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+            NSFont* font = [iup_font nativeFont];
+            if (!font)
+            {
+              const char* default_font = IupGetGlobal("DEFAULTFONT");
+              iup_font = iupcocoaFindFont(default_font);
+              font = iup_font ? [iup_font nativeFont] : [NSFont systemFontOfSize:13];
+            }
 
-			
-			//	*y = *y+10;
-			//	*x = *x+4;
-				// NSTextField is all guess work about how to scale for any font size.
-				// Throw away ih->currentheight because it will EXPAND it.
-				// But for the standard font, we get fontheight=16 and we want the height to be 22
+            /* NSLayoutManager calculates the actual line height used by NSTextView */
+            NSLayoutManager* layoutManager = [[NSLayoutManager alloc] init];
+            cocoa_line_height = [layoutManager defaultLineHeightForFont:font];
+            [layoutManager release];
+          }
 
-			
-			//	int font_height = 16;
-				int font_height = *y;
-			
-			//	iupdrvFontGetCharSize(ih, NULL, &font_height);
-				const CGFloat HEIGHT_PADDING = 6.0;
-			
-				*y = font_height + HEIGHT_PADDING;
-			//	*y = 16;
+          int char_height;
+          iupdrvFontGetCharSize(ih, NULL, &char_height);
 
-				const CGFloat WIDTH_PADDING = 12.0;
-			
-			
-				*x = *x - WIDTH_PADDING;
+          /* Calculate the difference per line */
+          int line_spacing = (int)lroundf(cocoa_line_height) - char_height;
+          if (line_spacing < 0)
+            line_spacing = 0;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-		
-		
-	
-			//	*y = *y+10;
-			//	*x = *x+4;
-				// NSTextField is all guess work about how to scale for any font size.
-				// Throw away ih->currentheight because it will EXPAND it.
-				// But for the standard font, we get fontheight=16 and we want the height to be 22
+          /* Add the total spacing for all visible lines */
+          int total_spacing = line_spacing * visiblelines;
+          *y += total_spacing;
+        }
 
-			
-			//	int font_height = 16;
-				int font_height = *y;
-			
-			//	iupdrvFontGetCharSize(ih, NULL, &font_height);
-				const CGFloat HEIGHT_PADDING = 6.0;
-			
-				*y = font_height + HEIGHT_PADDING;
-			//	*y = 16;
+        *y += cocoa_scrollview_border_h;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        /* Single line text field (NSTextField) with border */
+        if (cocoa_textfield_border_w < 0)
+        {
+          /* Measure NSTextField with border */
+          NSTextField* temp_field = [[NSTextField alloc] initWithFrame:NSZeroRect];
+          [temp_field setBordered:YES];
+          [temp_field setBezeled:YES];
+          [temp_field setStringValue:@"W"];
 
-				const CGFloat WIDTH_PADDING = 12.0;
-			
-			
-				*x = *x - WIDTH_PADDING;
-	
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	
-	
+          /* Get font metrics */
+          NSFont* font = [temp_field font];
+          if (!font)
+            font = [NSFont systemFontOfSize:13];
 
+          /* Measure text size using font */
+          NSDictionary* attrs = @{NSFontAttributeName: font};
+          NSSize text_size = [@"W" sizeWithAttributes:attrs];
+
+          /* Get intrinsic content size of the text field */
+          NSSize intrinsic_size = [temp_field intrinsicContentSize];
+
+          /* Border is intrinsic size minus text size */
+          cocoa_textfield_border_w = (int)lroundf(intrinsic_size.width - text_size.width);
+          cocoa_textfield_border_h = (int)lroundf(intrinsic_size.height - text_size.height);
+
+          if (cocoa_textfield_border_w < 0) cocoa_textfield_border_w = 6;
+          if (cocoa_textfield_border_h < 0) cocoa_textfield_border_h = 6;
+
+          [temp_field release];
+        }
+
+        *x += cocoa_textfield_border_w;
+        *y += cocoa_textfield_border_h;
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 }
 
-// GOTCHA: Modern characters may be multiple bytes (e.g. emoji characters).
-// Because of this, [string length] isn't correct, because it tells us the number of bytes, not characters.
-// The correct thing to do is to iterate through the string and count the glyphs.
-// But it probably is more expensive than what people think when they call this routine.
-// See https://www.objc.io/issues/9-strings/unicode/
-// NSString *s = @"The weather on \U0001F30D is \U0001F31E today.";
-// The weather on  is  today.
+void iupdrvTextAddExtraPadding(Ihandle* ih, int *w, int *h)
+{
+  static int cocoa_textfield_extra_w = -1;
+  static int cocoa_textfield_extra_h = -1;
+
+  if (cocoa_textfield_extra_w < 0)
+  {
+    /* Measure the difference between bordered and non-bordered NSTextField */
+    NSTextField* temp_bordered = [[NSTextField alloc] initWithFrame:NSZeroRect];
+    NSTextField* temp_noframe = [[NSTextField alloc] initWithFrame:NSZeroRect];
+
+    [temp_bordered setBordered:YES];
+    [temp_bordered setBezeled:YES];
+    [temp_bordered setStringValue:@"W"];
+
+    [temp_noframe setBordered:NO];
+    [temp_noframe setBezeled:NO];
+    [temp_noframe setStringValue:@"W"];
+
+    /* Get intrinsic sizes - bordered vs non-bordered */
+    NSSize bordered_size = [temp_bordered intrinsicContentSize];
+    NSSize noframe_size = [temp_noframe intrinsicContentSize];
+
+    /* Get font metrics */
+    NSFont* font = [temp_noframe font];
+    if (!font)
+      font = [NSFont systemFontOfSize:13];
+
+    NSDictionary* attrs = @{NSFontAttributeName: font};
+    NSSize text_size = [@"W" sizeWithAttributes:attrs];
+
+    /* The bezel adds extra size. The internal padding is what remains in no-frame version */
+    int extra_from_noframe_w = (int)lroundf(noframe_size.width - text_size.width);
+    int extra_from_noframe_h = (int)lroundf(noframe_size.height - text_size.height);
+
+    if (extra_from_noframe_w <= 0 || extra_from_noframe_h <= 0)
+    {
+      /* Fallback: Use a fraction of the border size as internal padding estimate */
+      int bezel_w = (int)lroundf(bordered_size.width - noframe_size.width);
+      int bezel_h = (int)lroundf(bordered_size.height - noframe_size.height);
+
+      cocoa_textfield_extra_w = (extra_from_noframe_w > 0) ? extra_from_noframe_w : (bezel_w > 0 ? bezel_w : 0);
+      cocoa_textfield_extra_h = (extra_from_noframe_h > 0) ? extra_from_noframe_h : (bezel_h > 0 ? bezel_h : 0);
+    }
+    else
+    {
+      cocoa_textfield_extra_w = extra_from_noframe_w;
+      cocoa_textfield_extra_h = extra_from_noframe_h;
+    }
+
+    if (cocoa_textfield_extra_w < 0) cocoa_textfield_extra_w = 0;
+    if (cocoa_textfield_extra_h < 0) cocoa_textfield_extra_h = 0;
+
+    [temp_bordered release];
+    [temp_noframe release];
+  }
+
+  (void)ih;
+  if (w) *w += cocoa_textfield_extra_w;
+  if (h) *h += cocoa_textfield_extra_h;
+}
+
+/* Characters may be multiple bytes (e.g. emoji characters). */
 static NSUInteger cocoaTextCountGlyphsInString(NSString* text_string)
 {
-	// Which of these two algorithms is better?
-	
-	
-//	NSLog(@"length: %zu\n%@", [text_string length], text_string);
-#if 0
-	NSUInteger glyph_count = 0;
-	NSUInteger index = 0;
-	NSUInteger raw_length = [text_string length];
-	while (index < raw_length)
-	{
-		NSRange the_range = [text_string rangeOfComposedCharacterSequenceAtIndex:index];
-		glyph_count++;
-		index += the_range.length;
-	}
-	return glyph_count;
-#else
-	NSRange full_range = NSMakeRange(0, [text_string length]);
-	// Remember __block let's us modify this outside variable inside the block
-	// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1
-	__block int glyph_count = 0;
-	[text_string enumerateSubstringsInRange:full_range
-		options:NSStringEnumerationByComposedCharacterSequences
-		usingBlock:^(NSString* substring, NSRange substring_range,
-		NSRange enclosing_range, BOOL* stop)
-		{
-			glyph_count++;
-		}
-	 ];
-	 return glyph_count;
-#endif
-	
+  NSRange full_range = NSMakeRange(0, [text_string length]);
+  __block int glyph_count = 0;
+  [text_string enumerateSubstringsInRange:full_range
+                                  options:NSStringEnumerationByComposedCharacterSequences
+                               usingBlock:^(NSString* substring, NSRange substring_range,
+                                   NSRange enclosing_range, BOOL* stop)
+                               {
+                                 glyph_count++;
+                               }
+  ];
+  return glyph_count;
 }
 
-// This formatter exists solely to support the NC feature.
-@interface IupFormatter : NSFormatter
+/* Custom formatter to support UPPERCASE/LOWERCASE filters */
+@interface IupCaseFormatter : NSFormatter
+@property(nonatomic, assign) BOOL uppercase;
+@property(nonatomic, assign) BOOL lowercase;
 @property(nonatomic, assign) Ihandle* ihandle;
 @end
 
-// I only use isPartialStringValid for "NC"
-@implementation IupFormatter
+@implementation IupCaseFormatter
 
-// required. pass-through behavior
 - (NSString*) stringForObjectValue:(id)obj_val
 {
-    return obj_val;
+  NSString* str = obj_val;
+  if ([self uppercase])
+    return [str uppercaseString];
+  else if ([self lowercase])
+    return [str lowercaseString];
+  return str;
 }
 
-
-// required. pass-through behavior
 - (BOOL)getObjectValue:(id*)out_obj_result forString:(NSString*)the_string errorDescription:(NSString**)the_error
 {
-	if(the_error)
+  if(the_error)
+    *the_error = nil;
+
+  if(out_obj_result)
+  {
+    if ([self uppercase])
+      *out_obj_result = [[the_string uppercaseString] retain];
+    else if ([self lowercase])
+      *out_obj_result = [[the_string lowercaseString] retain];
+    else
+      *out_obj_result = [the_string retain];
+  }
+  return YES;
+}
+
+- (BOOL)isPartialStringValid:(NSString**)partial_string proposedSelectedRange:(NSRangePointer)proposed_sel_range originalString:(NSString*)orig_string originalSelectedRange:(NSRange)orig_sel_range errorDescription:(NSString**)the_error
+{
+  /* Transform the string in real-time as the user types */
+  if ([self uppercase] && partial_string && *partial_string)
+  {
+    NSString* upper = [*partial_string uppercaseString];
+    if (![*partial_string isEqualToString:upper])
     {
-		*the_error = nil;
-	}
-    if(out_obj_result)
+      *partial_string = upper;
+      return NO; /* Force the field to update */
+    }
+  }
+  else if ([self lowercase] && partial_string && *partial_string)
+  {
+    NSString* lower = [*partial_string lowercaseString];
+    if (![*partial_string isEqualToString:lower])
     {
-		*out_obj_result = [the_string retain];
-	}
-    return YES;
+      *partial_string = lower;
+      return NO; /* Force the field to update */
+    }
+  }
+
+  /* Check NC limit if applicable */
+  Ihandle* ih = [self ihandle];
+  if (ih && ih->data->nc > 0)
+  {
+    NSUInteger glyph_count = cocoaTextCountGlyphsInString(*partial_string);
+    if (glyph_count > ih->data->nc)
+    {
+      return NO;
+    }
+  }
+
+  return YES;
 }
 
+@end
 
+/* This formatter supports the NC feature. */
+@interface IupFormatter : NSFormatter
+@property(nonatomic, assign) Ihandle* ihandle;
+@end
+
+/* I only use isPartialStringValid for "NC" */
+@implementation IupFormatter
+
+/* Required. Pass-through behavior */
+- (NSString*) stringForObjectValue:(id)obj_val
+{
+  return obj_val;
+}
+
+/* Required. Pass-through behavior */
+- (BOOL)getObjectValue:(id*)out_obj_result forString:(NSString*)the_string errorDescription:(NSString**)the_error
+{
+  if(the_error)
+  {
+    *the_error = nil;
+  }
+  if(out_obj_result)
+  {
+    *out_obj_result = [the_string retain];
+  }
+  return YES;
+}
+
 - (BOOL)isPartialStringValid:(NSString*)partial_string newEditingString:(NSString**)new_string errorDescription:(NSString**)the_error
 {
-    if(new_string)
-    {
-		*new_string = nil;
-	}
-	if(the_error)
-    {
-		*the_error = nil;
-	}
+  if(new_string)
+  {
+    *new_string = nil;
+  }
+  if(the_error)
+  {
+    *the_error = nil;
+  }
 
-	// empty string is okay
-    if([partial_string length] == 0)
+  /* Empty string is okay */
+  if([partial_string length] == 0)
+  {
+    return YES;
+  }
+  /* Make sure to limit the length if the IUP "NC" feature is in use */
+  Ihandle* ih = [self ihandle];
+  if(ih->data->nc > 0)
+  {
+    /* I think this is supposed to be a glyph count instead of a byte count. */
+    NSUInteger glyph_count = cocoaTextCountGlyphsInString(partial_string);
+    if(glyph_count > ih->data->nc)
     {
-        return YES;
-	}
-	// Make sure to limit the length if the IUP "NC" feature is in use
-	Ihandle* ih = [self ihandle];
-	if(ih->data->nc > 0)
-	{
-		// I think this is supposed to be a glyph count instead of a byte count.
-		// So we need to do extra work.
-		NSUInteger glyph_count = cocoaTextCountGlyphsInString(partial_string);
-		if(glyph_count > ih->data->nc)
-		{
-			return NO;
-		}
-	}
-	return YES;
+      return NO;
+    }
+  }
+  return YES;
 }
 
 @end
 
-// This formatter exists to support the FILTER feature and the "NC" feature.
+/* This formatter exists to support the FILTER feature and the "NC" feature. */
 @interface IupNumberFormatter : NSNumberFormatter
 @property(nonatomic, assign) Ihandle* ihandle;
 @end
@@ -788,1685 +1095,1371 @@
 
 - (BOOL)isPartialStringValid:(NSString*)partial_string newEditingString:(NSString**)new_string errorDescription:(NSString**)the_error
 {
-    if(new_string)
-    {
-		*new_string = nil;
-	}
-	if(the_error)
-    {
-		*the_error = nil;
-	}
+  if(new_string)
+  {
+    *new_string = nil;
+  }
+  if(the_error)
+  {
+    *the_error = nil;
+  }
 
-	// empty string is okay
-    if([partial_string length] == 0)
+  /* Empty string is okay */
+  if([partial_string length] == 0)
+  {
+    return YES;
+  }
+  /* Make sure to limit the length if the IUP "NC" feature is in use */
+  Ihandle* ih = [self ihandle];
+  if(ih->data->nc > 0)
+  {
+    NSUInteger glyph_count = cocoaTextCountGlyphsInString(partial_string);
+    if(glyph_count > ih->data->nc)
     {
-        return YES;
-	}
-	// Make sure to limit the length if the IUP "NC" feature is in use
-	Ihandle* ih = [self ihandle];
-	if(ih->data->nc > 0)
-	{
-		// I think this is supposed to be a glyph count instead of a byte count.
-		// So we need to do extra work.
-		NSUInteger glyph_count = cocoaTextCountGlyphsInString(partial_string);
-		if(glyph_count > ih->data->nc)
-		{
-			return NO;
-		}
-	}
+      return NO;
+    }
+  }
 
-	NSMutableCharacterSet* allowed_character_set = [[NSCharacterSet decimalDigitCharacterSet] mutableCopy];
-	[allowed_character_set autorelease];
-	// Allow scientific notation, decimal points, and positive and negative. Also allow people to enter commas as both decimals and separators. Space is also separator.
-	if(NSNumberFormatterNoStyle == [self numberStyle])
-	{
-		// Turns out NSNumberFormatterNoStyle is very restrictive.
-		// No leading + allowed (- is okay)
-		// No grouping separators
-		/*
-		NSString* grouping_separator = [self groupingSeparator]; // doesb't seem to include space
-		[allowed_character_set addCharactersInString:grouping_separator];
-		[allowed_character_set addCharactersInString:@"+- "];
-		*/
-		[allowed_character_set addCharactersInString:@"-"];
-	}
-	else
-	{
-		// () is another way to express negative, but doesn't seem to work with our supported modes
-		// + only works with e, 1e+2 and not +5. We don't need it.
-		[allowed_character_set addCharactersInString:@".eE-, "];
-	}
-	NSCharacterSet* disallowed_character_set = [allowed_character_set invertedSet];
+  NSMutableCharacterSet* allowed_character_set = [[NSCharacterSet decimalDigitCharacterSet] mutableCopy];
+  [allowed_character_set autorelease];
+  /* Allow scientific notation, decimal points, and positive and negative. */
+  if(NSNumberFormatterNoStyle == [self numberStyle])
+  {
+    [allowed_character_set addCharactersInString:@"-"];
+  }
+  else
+  {
+    [allowed_character_set addCharactersInString:@".eE-, "];
+  }
+  NSCharacterSet* disallowed_character_set = [allowed_character_set invertedSet];
 
-	
-	// TODO: FIXME: I'm being lazy.
-	// This will allow invalid strings like 100-111, 23+eee-34,
-	// We may also want to specialize this for decimal, integer, scientific modes
-    if([partial_string rangeOfCharacterFromSet:disallowed_character_set].location != NSNotFound)
-    {
-        return NO;
-    }
+  if([partial_string rangeOfCharacterFromSet:disallowed_character_set].location != NSNotFound)
+  {
+    return NO;
+  }
 
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// NSNumberFormatter is more resilant to of fancy numbers (e.g. commas, locales, etc) than NSString integerValue
-			// And although the documentation says we only support INTEGERs,
-			// because we let people muck with FILTER,
-			// we may eventually end up in a more complicated case.
-			NSNumberFormatter* conversion_formatter = [[NSNumberFormatter alloc] init];
-			[conversion_formatter autorelease];
-			[conversion_formatter setNumberStyle:[self numberStyle]];
-			NSNumber* ns_number = [conversion_formatter numberFromString:partial_string];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSNumberFormatter* conversion_formatter = [[NSNumberFormatter alloc] init];
+        [conversion_formatter autorelease];
+        [conversion_formatter setNumberStyle:[self numberStyle]];
+        NSNumber* ns_number = [conversion_formatter numberFromString:partial_string];
 
-			double current_number = [ns_number doubleValue];
-			NSStepper* stepper_view = cocoaTextGetStepperView(ih);
-			double max_value = [stepper_view maxValue];
-			if(current_number > max_value)
-			{
-				return NO;
-			}
-			double min_value = [stepper_view minValue];
-			if(current_number < min_value)
-			{
-				return NO;
-			}
-			
-			
-			
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	
+        double current_number = [ns_number doubleValue];
+        NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+        double max_value = [stepper_view maxValue];
+        if(current_number > max_value)
+        {
+          return NO;
+        }
+        double min_value = [stepper_view minValue];
+        if(current_number < min_value)
+        {
+          return NO;
+        }
 
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
-
-    return YES;
+  return YES;
 }
 
-
 @end
 
-
-// Only for NSTextField.
-// I do not have a good solution for NSTextView
+/* Only for NSTextField. */
 static int cocoaTextSetNCAttrib(Ihandle* ih, const char* value)
 {
-	if(!iupStrToInt(value, &ih->data->nc))
-	{
-		ih->data->nc = 0;
-	}
-	
-	if(ih->handle)
-	{
-		IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-		switch(sub_type)
-		{
-			case IUPCOCOATEXTSUBTYPE_VIEW:
-			{
-				
-				break;
-			}
-			case IUPCOCOATEXTSUBTYPE_FIELD:
-			{
-				NSTextField* text_field = cocoaTextGetTextField(ih);
-				// If we already attached a formatter, it should already have the code to check for NC.
-				// We don't want to replace an IupNumberFormatter if it is already there, otherwise we lose the number formatting part.
-				if([text_field formatter])
-				{
-					return 0;
-				}
-				
-				IupFormatter* nc_formatter = [[IupFormatter alloc] init];
-				[nc_formatter autorelease];
-				[nc_formatter setIhandle:ih];
-				[text_field setFormatter:nc_formatter];
-				return 0;
-				
-				break;
-			}
-			case IUPCOCOATEXTSUBTYPE_STEPPER:
-			{
-				// Leave the existing the Number formatter alone
-				return 0;
-				
-				break;
-			}
-			default:
-			{
-				break;
-			}
-		}
-		
-		return 0;
-		
-	}
-	else
-	{
-		return 1; /* store until not mapped, when mapped will be set again */
-	}
+  if(!iupStrToInt(value, &ih->data->nc))
+  {
+    ih->data->nc = 0;
+  }
+
+  if(ih->handle)
+  {
+    IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+    switch(sub_type)
+    {
+      case IUPCOCOATEXTSUBTYPE_VIEW:
+        {
+          break;
+        }
+      case IUPCOCOATEXTSUBTYPE_FIELD:
+        {
+          NSTextField* text_field = cocoaTextGetTextField(ih);
+          /* If we already attached a formatter, it should already have the code to check for NC. */
+          if([text_field formatter])
+          {
+            return 0;
+          }
+
+          IupFormatter* nc_formatter = [[IupFormatter alloc] init];
+          [nc_formatter autorelease];
+          [nc_formatter setIhandle:ih];
+          [text_field setFormatter:nc_formatter];
+          return 0;
+        }
+      case IUPCOCOATEXTSUBTYPE_STEPPER:
+        {
+          /* Leave the existing the Number formatter alone */
+          return 0;
+        }
+      default:
+        {
+          break;
+        }
+    }
+
+    return 0;
+  }
+  else
+  {
+    return 1; /* store until not mapped, when mapped will be set again */
+  }
 }
 
-// Only for NSTextField. LOWERCASE, UPPERCASE not supported.
-// Introducing INTEGER, SCIENTIFC, CURRENCY
-// WATCH OUT: Be careful with the "NC" feature because the formatters may overwrite each other.
 static int cocoaTextSetFilterAttrib(Ihandle* ih, const char* value)
 {
-  	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-	
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        if(value)
+        {
+          if(iupStrEqualNoCase(value, "LOWERCASE"))
+          {
+            iupAttribSet(ih, "_IUPCOCOA_FILTER_CASE", "LOWER");
+            return 1;
+          }
+          else if(iupStrEqualNoCase(value, "UPPERCASE"))
+          {
+            iupAttribSet(ih, "_IUPCOCOA_FILTER_CASE", "UPPER");
+            return 1;
+          }
+          else if(iupStrEqualNoCase(value, "NUMBER"))
+          {
+            iupAttribSet(ih, "_IUPCOCOA_FILTER_NUMBER", "1");
+            return 1;
+          }
+        }
 
-			// remove the formatter
-			if(NULL == value)
-			{
-				// If "NC" is being used, we need to add back a formatter for that
-				if(ih->data->nc > 0)
-				{
-					IupFormatter* nc_formatter = [[IupFormatter alloc] init];
-					[nc_formatter autorelease];
-					[nc_formatter setIhandle:ih];
-					[text_field setFormatter:nc_formatter];
-				}
-				else
-				{
-					[text_field setFormatter:nil];
-				}
-				return 1;
-			}
+        iupAttribSet(ih, "_IUPCOCOA_FILTER_CASE", NULL);
+        iupAttribSet(ih, "_IUPCOCOA_FILTER_NUMBER", NULL);
+        return 1;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_FORMATTER_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 
+        if(NULL == value)
+        {
+          if(ih->data->nc > 0)
+          {
+            IupFormatter* nc_formatter = [[IupFormatter alloc] init];
+            [nc_formatter autorelease];
+            [nc_formatter setIhandle:ih];
+            [text_field setFormatter:nc_formatter];
+          }
+          else
+          {
+            [text_field setFormatter:nil];
+          }
+          return 1;
+        }
 
-			if(iupStrEqualNoCase(value, "NUMBER"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterDecimalStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-			if(iupStrEqualNoCase(value, "INTEGER"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterNoStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-			if(iupStrEqualNoCase(value, "SCIENTIFIC"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterScientificStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-			// requires the user to input a currency symbol which is kind of a pain
-/*
-			if(iupStrEqualNoCase(value, "CURRENCY"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterCurrencyStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-*/
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// I'm not completely sure I want to allow this for stepper because this will overwrite the NumberFormatter I set in Interface Builder
-			
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-	
-			// TODO: We should restore the interface builder formatter, but I'm lazy.
-			if(NULL == value)
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterDecimalStyle];
-				[text_field setFormatter:number_formatter];
+        if(iupStrEqualNoCase(value, "NUMBER"))
+        {
+          IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+          [number_formatter autorelease];
+          [number_formatter setIhandle:ih];
+          [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+          [number_formatter setPartialStringValidationEnabled:YES];
+          [number_formatter setNumberStyle:NSNumberFormatterDecimalStyle];
+          [text_field setFormatter:number_formatter];
+          return 1;
+        }
+        if(iupStrEqualNoCase(value, "INTEGER"))
+        {
+          IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+          [number_formatter autorelease];
+          [number_formatter setIhandle:ih];
+          [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+          [number_formatter setPartialStringValidationEnabled:YES];
+          [number_formatter setNumberStyle:NSNumberFormatterNoStyle];
+          [text_field setFormatter:number_formatter];
+          return 1;
+        }
+        if(iupStrEqualNoCase(value, "SCIENTIFIC"))
+        {
+          IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+          [number_formatter autorelease];
+          [number_formatter setIhandle:ih];
+          [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+          [number_formatter setPartialStringValidationEnabled:YES];
+          [number_formatter setNumberStyle:NSNumberFormatterScientificStyle];
+          [text_field setFormatter:number_formatter];
+          return 1;
+        }
+        if(iupStrEqualNoCase(value, "LOWERCASE"))
+        {
+          IupCaseFormatter* formatter = [[IupCaseFormatter alloc] init];
+          [formatter autorelease];
+          [formatter setIhandle:ih];
+          [formatter setLowercase:YES];
+          [formatter setUppercase:NO];
+          [text_field setFormatter:formatter];
+          objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_FORMATTER_KEY, formatter, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+          return 1;
+        }
+        if(iupStrEqualNoCase(value, "UPPERCASE"))
+        {
+          IupCaseFormatter* formatter = [[IupCaseFormatter alloc] init];
+          [formatter autorelease];
+          [formatter setIhandle:ih];
+          [formatter setUppercase:YES];
+          [formatter setLowercase:NO];
+          [text_field setFormatter:formatter];
+          objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_FORMATTER_KEY, formatter, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+          return 1;
+        }
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
 
-				return 1;
-			}
-			
-			if(iupStrEqualNoCase(value, "NUMBER"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterDecimalStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-			if(iupStrEqualNoCase(value, "INTEGER"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterNoStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-			if(iupStrEqualNoCase(value, "SCIENTIFIC"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterScientificStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-			// requires the user to input a currency symbol which is kind of a pain
-/*
-			if(iupStrEqualNoCase(value, "CURRENCY"))
-			{
-				IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-				[number_formatter autorelease];
-				[number_formatter setIhandle:ih];
-//				[number_formatter setFormattingContext:NSFormattingContextDynamic];
-				[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-				[number_formatter setPartialStringValidationEnabled:YES];
-				[number_formatter setNumberStyle:NSNumberFormatterCurrencyStyle];
-				[text_field setFormatter:number_formatter];
-				return 1;
-			}
-*/
+        if(NULL == value)
+        {
+          IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+          [number_formatter autorelease];
+          [number_formatter setIhandle:ih];
+          [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+          [number_formatter setPartialStringValidationEnabled:YES];
+          [number_formatter setNumberStyle:NSNumberFormatterDecimalStyle];
+          [text_field setFormatter:number_formatter];
+          return 1;
+        }
 
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return 0;
+        if(iupStrEqualNoCase(value, "NUMBER"))
+        {
+          IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+          [number_formatter autorelease];
+          [number_formatter setIhandle:ih];
+          [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+          [number_formatter setPartialStringValidationEnabled:YES];
+          [number_formatter setNumberStyle:NSNumberFormatterDecimalStyle];
+          [text_field setFormatter:number_formatter];
+          return 1;
+        }
+        if(iupStrEqualNoCase(value, "INTEGER"))
+        {
+          IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+          [number_formatter autorelease];
+          [number_formatter setIhandle:ih];
+          [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+          [number_formatter setPartialStringValidationEnabled:YES];
+          [number_formatter setNumberStyle:NSNumberFormatterNoStyle];
+          [text_field setFormatter:number_formatter];
+          return 1;
+        }
+        if(iupStrEqualNoCase(value, "SCIENTIFIC"))
+        {
+          IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+          [number_formatter autorelease];
+          [number_formatter setIhandle:ih];
+          [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+          [number_formatter setPartialStringValidationEnabled:YES];
+          [number_formatter setNumberStyle:NSNumberFormatterScientificStyle];
+          [text_field setFormatter:number_formatter];
+          return 1;
+        }
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return 0;
 }
 
-// This is currently broken.
-// I don't really understand how setDefaultTabInterval is supposed to work.
-// Also, I have to be very carefuly about not clobbering other attributes.
-// I tried as create-only, which avoids the clobbering problem, but it still doesn't resolve the first issue.
-/*
 static int cocoaTextSetTabSizeAttrib(Ihandle* ih, const char* value)
 {
-	if(!ih->data->is_multiline)
-	{
-		return 0;
-	}
+  if(!ih->data->is_multiline)
+  {
+    return 0;
+  }
 
-  	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			IupCocoaFont* iup_font = iupCocoaGetFont(ih);
-			NSTextStorage* text_storage = [text_view textStorage];
-			
-			
-			NSRange full_range = NSMakeRange(0, [text_storage length]);
-			
-			if((full_range.location == 0) && (full_range.length==0))
-			{
-				NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-				[undo_manager beginUndoGrouping];
-				//		[text_storage beginEditing];
-				
-				// Try setTypingAttributes out of desperation?
-				NSMutableDictionary* typing_attributes = [[text_view typingAttributes] mutableCopy];
-				[typing_attributes autorelease];
-				NSMutableParagraphStyle* paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
-				[paragraph_style autorelease];
-				[(NSMutableDictionary*)typing_attributes setObject:paragraph_style forKey:NSParagraphStyleAttributeName];
-				[text_view setTypingAttributes:typing_attributes];
-				
-				
-				//		[text_storage endEditing];
-				[text_view didChangeText];
-				[undo_manager endUndoGrouping];
-				return 1;
-			}
-			
-			
-			
-			
-			NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-			[undo_manager beginUndoGrouping];
-			[text_storage beginEditing];
-			
-			
-			NSString* all_string = [text_storage string];
-			
-			// The problem seems to be that in order to change the TextLines attribute for the entire block, I need to re-set the attribute.
-			// So I have to be very careful about applying attributes and not clobbering them.
-			// Try going paragraph by paragraph to add the attribute so I don't clobber it with a global value.
-			
-			
-			[all_string enumerateSubstringsInRange:full_range options:NSStringEnumerationByParagraphs usingBlock:
-			 ^(NSString * _Nullable substring, NSRange substring_range, NSRange enclosing_range, BOOL * _Nonnull stop)
-			 {
-				 *stop = NO;
-				 				NSLog(@"substring:%@", substring);
-				 				NSLog(@"substringRange:%@", NSStringFromRange(substring_range));
-				 				NSLog(@"enclosingRange:%@", NSStringFromRange(enclosing_range));
-				 
-				 NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = nil;
-				 NSMutableParagraphStyle* paragraph_style = nil;
-				 
-				 text_storage_attributes = [[text_storage attributedSubstringFromRange:enclosing_range] attributesAtIndex:0 effectiveRange:NULL];
-				 paragraph_style = [[text_storage_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
-				 [paragraph_style autorelease];
-				 if(nil == paragraph_style)
-				 {
-					 				NSLog(@"nil == paragraph_style");
-					 paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
-					 [paragraph_style autorelease];
-				 }
-				 
-				 int tab_size_int = 8;
-				 iupStrToInt(value, &tab_size_int);
-				 
-				 // WARNING: Cocoa uses points, not characters.
-				 // FIXME/TODO: Should probably ask for font of beginning of line instead of the main font.
-				 CGFloat tab_size_float = (CGFloat)(tab_size_int * [iup_font charWidth]);
-				 
-				 [paragraph_style setDefaultTabInterval:tab_size_float];
-				 //			[paragraph_style setDefaultTabInterval:20 * [iup_font charWidth]];
-				 [text_storage addAttribute:NSParagraphStyleAttributeName value:paragraph_style range:enclosing_range];
-				 
-				 
-		
-				 
-			 }
-			 ];
-			
-			[text_storage endEditing];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        IupCocoaFont* iup_font = iupcocoaGetFont(ih);
 
-			// Try setTypingAttributes for end
-			{
-				NSMutableDictionary* typing_attributes = [[text_view typingAttributes] mutableCopy];
-				[typing_attributes autorelease];
-				NSMutableParagraphStyle* paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
-				[paragraph_style autorelease];
-				[(NSMutableDictionary*)typing_attributes setObject:paragraph_style forKey:NSParagraphStyleAttributeName];
-				[text_view setTypingAttributes:typing_attributes];
-			}
+        int tab_size = 8;
+        if(value) iupStrToInt(value, &tab_size);
 
-			[text_view didChangeText];
-			[undo_manager endUndoGrouping];
-			return 1;
+        CGFloat char_width = [[iup_font nativeFont] maximumAdvancement].width;
+        if (char_width == 0) char_width = 8; /* fallback */
+        CGFloat tab_width = tab_size * char_width;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			break;
+        NSMutableParagraphStyle* paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
+        [paragraph_style autorelease];
 
+        /* Create tab stops */
+        NSMutableArray* tab_stops = [NSMutableArray array];
+        for (int i = 1; i <= 32; i++)
+        {
+          NSTextTab* tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentLeft location:i * tab_width options:@{}];
+          [tab_stops addObject:tab];
+          [tab release];
+        }
+        [paragraph_style setTabStops:tab_stops];
+        [paragraph_style setDefaultTabInterval:tab_width];
 
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
+        /* Apply to the text view */
+        [text_view setDefaultParagraphStyle:paragraph_style];
 
+        /* Update typing attributes */
+        NSMutableDictionary* typing_attributes = [[text_view typingAttributes] mutableCopy];
+        [typing_attributes autorelease];
+        [typing_attributes setObject:paragraph_style forKey:NSParagraphStyleAttributeName];
+        [text_view setTypingAttributes:typing_attributes];
 
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	return 0;
+        return 1;
+      }
+    default:
+      {
+        break;
+      }
+  }
+  return 0;
 }
-*/
 
 static int cocoaTextSetValueAttrib(Ihandle* ih, const char* value)
 {
-	NSString* ns_string;
-	
-	if(NULL == value)
-	{
-		ns_string = @"";
-	}
-	else
-	{
-		ns_string = [NSString stringWithUTF8String:value];
-	}
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			IupCocoaFont* iup_font = iupCocoaGetFont(ih);
-			NSTextStorage* text_storage = [text_view textStorage];
-			
-			NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-			[undo_manager beginUndoGrouping];
-			[text_storage beginEditing];
-			
-			
-			NSAttributedString* attributed_string = [[NSAttributedString alloc] initWithString:ns_string attributes:[iup_font attributeDictionary]];
-			[attributed_string autorelease];
-			
-			
-			ih->data->disable_callbacks = 1;
-			[text_view shouldChangeTextInRange:NSMakeRange(0, [text_storage length]) replacementString:ns_string];
-			[text_storage setAttributedString:attributed_string];
-			ih->data->disable_callbacks = 0;
-			
-			[text_storage endEditing];
-			
-			// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-			[text_view didChangeText];
-			[text_storage endEditing];
-			[undo_manager endUndoGrouping];
+  NSString* ns_string;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-			IupCocoaFont* iup_font = iupCocoaGetFont(ih);
-			if([iup_font usesAttributes])
-			{
-				NSAttributedString* attributed_string = [[NSAttributedString alloc] initWithString:ns_string attributes:[iup_font attributeDictionary]];
-				[text_field setAttributedStringValue:attributed_string];
-				[attributed_string release];
-			
-			}
-			else
-			{
-				[text_field setStringValue:ns_string];
-			}
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
-			
-			// NSNumberFormatter is more resilant to of fancy numbers (e.g. commas, locales, etc) than NSString integerValue
-			// And although the documentation says we only support INTEGERs,
-			// because we let people muck with FILTER,
-			// we may eventually end up in a more complicated case.
-			NSNumberFormatter* conversion_formatter = [[NSNumberFormatter alloc] init];
-			[conversion_formatter autorelease];
-			NSNumberFormatter* text_field_formatter = (NSNumberFormatter*)[text_field formatter];
-			[conversion_formatter setNumberStyle:[text_field_formatter numberStyle]];
-			NSNumber* ns_number = [conversion_formatter numberFromString:ns_string];
+  if(NULL == value)
+  {
+    ns_string = @"";
+  }
+  else
+  {
+    ns_string = [NSString stringWithUTF8String:value];
+  }
 
-			double current_number = [ns_number doubleValue];
-			NSStepper* stepper_view = cocoaTextGetStepperView(ih);
-			double max_value = [stepper_view maxValue];
-			if(current_number > max_value)
-			{
-				current_number = max_value;
-			}
-			double min_value = [stepper_view minValue];
-			if(current_number < min_value)
-			{
-				current_number = min_value;
-			}
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+        NSTextStorage* text_storage = [text_view textStorage];
 
-			// Do we need to worry about NSAttributedString?
-			if(iupAttribGetBoolean(ih, "SPINAUTO"))
-			{
-				// With Cocoa Bindings, we must set the model or controller, not the view.
-				// Otherwise, if we set the view directly,
-				// when we click on the stepper, it will have a stale version of the world
-				// and increment from the stale value instead of the value seen in the field.
-				NSNumber* number_to_set = [NSNumber numberWithDouble:current_number];
-				IUPStepperObject* stepper_object = cocoaTextGetStepperObject(ih);
-				[stepper_object setStepperValue:number_to_set];
-			}
-			else
-			{
-				ns_string = [NSString stringWithFormat:@"%lf", current_number];
-				[text_field setStringValue:ns_string];
-			}
-			
-			
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return 0;
+        NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+        [undo_manager beginUndoGrouping];
+        [text_storage beginEditing];
+
+        NSMutableDictionary* attributes = [[iup_font attributeDictionary] mutableCopy];
+
+        /* Ensure a foreground color is present. If a user-defined FGCOLOR exists, it will be used. */
+        /* Otherwise, default to the system's adaptive text color to support dark/light mode. */
+        if (![attributes objectForKey:NSForegroundColorAttributeName])
+        {
+          char* fgcolor_str = iupAttribGet(ih, "FGCOLOR");
+          unsigned char r, g, b;
+          if (fgcolor_str && iupStrToRGB(fgcolor_str, &r, &g, &b))
+          {
+            [attributes setObject:[NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0] forKey:NSForegroundColorAttributeName];
+          }
+          else
+          {
+            [attributes setObject:[NSColor textColor] forKey:NSForegroundColorAttributeName];
+          }
+        }
+
+        NSAttributedString* attributed_string = [[NSAttributedString alloc] initWithString:ns_string attributes:attributes];
+        [attributes release];
+
+        ih->data->disable_callbacks = 1;
+        [text_view shouldChangeTextInRange:NSMakeRange(0, [text_storage length]) replacementString:ns_string];
+        [text_storage setAttributedString:attributed_string];
+        ih->data->disable_callbacks = 0;
+
+        [attributed_string release];
+
+        [text_storage endEditing];
+        [text_view didChangeText];
+        [undo_manager endUndoGrouping];
+
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
+        IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+        if([iup_font usesAttributes])
+        {
+          NSAttributedString* attributed_string = [[NSAttributedString alloc] initWithString:ns_string attributes:[iup_font attributeDictionary]];
+          [text_field setAttributedStringValue:attributed_string];
+          [attributed_string release];
+        }
+        else
+        {
+          [text_field setStringValue:ns_string];
+        }
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSCAssert([text_field isKindOfClass:[NSTextField class]], @"Expected NSTextField");
+
+        NSNumberFormatter* conversion_formatter = [[NSNumberFormatter alloc] init];
+        [conversion_formatter autorelease];
+        NSNumberFormatter* text_field_formatter = (NSNumberFormatter*)[text_field formatter];
+        [conversion_formatter setNumberStyle:[text_field_formatter numberStyle]];
+        NSNumber* ns_number = [conversion_formatter numberFromString:ns_string];
+
+        double current_number = [ns_number doubleValue];
+        NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+        double max_value = [stepper_view maxValue];
+        if(current_number > max_value)
+        {
+          current_number = max_value;
+        }
+        double min_value = [stepper_view minValue];
+        if(current_number < min_value)
+        {
+          current_number = min_value;
+        }
+
+        if(iupAttribGetBoolean(ih, "SPINAUTO"))
+        {
+          NSNumber* number_to_set = [NSNumber numberWithDouble:current_number];
+          IUPStepperObject* stepper_object = cocoaTextGetStepperObject(ih);
+          [stepper_object setStepperValue:number_to_set];
+        }
+        else
+        {
+          ns_string = [NSString stringWithFormat:@"%lf", current_number];
+          [text_field setStringValue:ns_string];
+        }
+
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return 0;
 }
 
 static char* cocoaTextGetValueAttrib(Ihandle* ih)
 {
-	char* value = NULL;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			
-			NSString* ns_string = [[text_view textStorage] string];
-			value = iupStrReturnStr([ns_string UTF8String]);
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			
-			NSString* ns_string = [text_field stringValue];
-			value = iupStrReturnStr([ns_string UTF8String]);
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			
-			NSString* ns_string = [text_field stringValue];
-			value = iupStrReturnStr([ns_string UTF8String]);
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	if(NULL == value)
-	{
-		value = "";
-	}
-	
-	return value;
+  char* value = NULL;
+
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+
+        NSString* ns_string = [[text_view textStorage] string];
+        value = iupStrReturnStr([ns_string UTF8String]);
+
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+
+        NSString* ns_string = [text_field stringValue];
+        value = iupStrReturnStr([ns_string UTF8String]);
+
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+
+        NSString* ns_string = [text_field stringValue];
+        value = iupStrReturnStr([ns_string UTF8String]);
+
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  if(NULL == value)
+  {
+    value = "";
+  }
+
+  return value;
 }
 
-
 static int cocoaTextSetBgColorAttrib(Ihandle* ih, const char* value)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			
-			NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-			[undo_manager beginUndoGrouping];
-			
-			unsigned char r, g, b;
-			if(iupStrToRGB(value, &r, &g, &b))
-			{
-				CGFloat red = r/255.0;
-				CGFloat green = g/255.0;
-				CGFloat blue = b/255.0;
-				
-				NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-				[text_view setBackgroundColor:the_color];
-			}
-			else
-			{
-				NSColor* the_color = [NSColor textBackgroundColor];
-				[text_view setBackgroundColor:the_color];
-			}
-	
-			
-			// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-			[text_view didChangeText];
-			[undo_manager endUndoGrouping];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
 
-			return 1;
+        NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+        [undo_manager beginUndoGrouping];
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			
-			unsigned char r, g, b;
-			if(iupStrToRGB(value, &r, &g, &b))
-			{
-				CGFloat red = r/255.0;
-				CGFloat green = g/255.0;
-				CGFloat blue = b/255.0;
-				
-				NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-				[text_field setBackgroundColor:the_color];
-			}
-			else
-			{
-				[text_field setBackgroundColor:nil];
-			}
-			return 1;
+        unsigned char r, g, b;
+        if(iupStrToRGB(value, &r, &g, &b))
+        {
+          CGFloat red = r/255.0;
+          CGFloat green = g/255.0;
+          CGFloat blue = b/255.0;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			
-			unsigned char r, g, b;
-			if(iupStrToRGB(value, &r, &g, &b))
-			{
-				CGFloat red = r/255.0;
-				CGFloat green = g/255.0;
-				CGFloat blue = b/255.0;
-				
-				NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-				[text_field setBackgroundColor:the_color];
-			}
-			else
-			{
-				[text_field setBackgroundColor:nil];
-			}
+          NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+          [text_view setBackgroundColor:the_color];
+        }
+        else
+        {
+          NSColor* the_color = [NSColor textBackgroundColor];
+          [text_view setBackgroundColor:the_color];
+        }
 
-			return 1;
+        [text_view didChangeText];
+        [undo_manager endUndoGrouping];
 
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return 0;
+        return 1;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+
+        unsigned char r, g, b;
+        if(iupStrToRGB(value, &r, &g, &b))
+        {
+          CGFloat red = r/255.0;
+          CGFloat green = g/255.0;
+          CGFloat blue = b/255.0;
+
+          NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+          [text_field setBackgroundColor:the_color];
+        }
+        else
+        {
+          [text_field setBackgroundColor:nil];
+        }
+        return 1;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+
+        unsigned char r, g, b;
+        if(iupStrToRGB(value, &r, &g, &b))
+        {
+          CGFloat red = r/255.0;
+          CGFloat green = g/255.0;
+          CGFloat blue = b/255.0;
+
+          NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+          [text_field setBackgroundColor:the_color];
+        }
+        else
+        {
+          [text_field setBackgroundColor:nil];
+        }
+
+        return 1;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return 0;
 }
 
 static int cocoaTextSetFgColorAttrib(Ihandle* ih, const char* value)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			// WARNING: FORMATTING is better to use than this
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			
-			NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-			[undo_manager beginUndoGrouping];
-			
-			unsigned char r, g, b;
-			if(iupStrToRGB(value, &r, &g, &b))
-			{
-				CGFloat red = r/255.0;
-				CGFloat green = g/255.0;
-				CGFloat blue = b/255.0;
-				
-				NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-				// setTextColor is provided by NSText
-				[text_view setTextColor:the_color];
-			}
-			else
-			{
-				NSColor* the_color = [NSColor textBackgroundColor];
-				[text_view setTextColor:the_color];
-			}
-	
-			
-			// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-			[text_view didChangeText];
-			[undo_manager endUndoGrouping];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        NSTextStorage* text_storage = [text_view textStorage];
+        NSRange full_range = NSMakeRange(0, [text_storage length]);
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			
-			unsigned char r, g, b;
-			if(iupStrToRGB(value, &r, &g, &b))
-			{
-				CGFloat red = r/255.0;
-				CGFloat green = g/255.0;
-				CGFloat blue = b/255.0;
-				
-				NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-				[text_field setTextColor:the_color];
-			}
-			else
-			{
-				[text_field setTextColor:nil];
-			}
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			
-			unsigned char r, g, b;
-			if(iupStrToRGB(value, &r, &g, &b))
-			{
-				CGFloat red = r/255.0;
-				CGFloat green = g/255.0;
-				CGFloat blue = b/255.0;
-				
-				NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-				[text_field setTextColor:the_color];
-			}
-			else
-			{
-				[text_field setTextColor:nil];
-			}
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return iupdrvBaseSetBgColorAttrib(ih, value);
+        NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+        [undo_manager beginUndoGrouping];
+        [text_storage beginEditing];
+
+        unsigned char r, g, b;
+        NSColor* the_color;
+        if (iupStrToRGB(value, &r, &g, &b))
+        {
+          CGFloat red = r / 255.0;
+          CGFloat green = g / 255.0;
+          CGFloat blue = b / 255.0;
+          the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+        }
+        else
+        {
+          the_color = [NSColor textColor];
+        }
+
+        /* This sets typing attributes for new text. */
+        [text_view setTextColor:the_color];
+
+        /* This applies the color to all existing text. */
+        if ([text_storage length] > 0)
+        {
+          [text_storage addAttribute:NSForegroundColorAttributeName value:the_color range:full_range];
+        }
+
+        [text_storage endEditing];
+        [text_view didChangeText];
+        [undo_manager endUndoGrouping];
+
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+
+        unsigned char r, g, b;
+        if(iupStrToRGB(value, &r, &g, &b))
+        {
+          CGFloat red = r/255.0;
+          CGFloat green = g/255.0;
+          CGFloat blue = b/255.0;
+
+          NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+          [text_field setTextColor:the_color];
+        }
+        else
+        {
+          [text_field setTextColor:nil];
+        }
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+
+        unsigned char r, g, b;
+        if(iupStrToRGB(value, &r, &g, &b))
+        {
+          CGFloat red = r/255.0;
+          CGFloat green = g/255.0;
+          CGFloat blue = b/255.0;
+
+          NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+          [text_field setTextColor:the_color];
+        }
+        else
+        {
+          [text_field setTextColor:nil];
+        }
+
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return iupdrvBaseSetBgColorAttrib(ih, value);
 }
 
-
-/// For the provided start_line, start_column, end_line, end_column, get the native NSRange for the selection.
+/* For the provided start_line, start_column, end_line, end_column, get the native NSRange for the selection. */
 static bool cocoaTextComputeRangeFromLineColumnForTextView(NSTextView* text_view, NSUInteger start_line, NSUInteger start_column, NSUInteger end_line, NSUInteger end_column, NSRange* out_range)
 {
-	*out_range = NSMakeRange(0, 0);
+  *out_range = NSMakeRange(0, 0);
 
-	if(end_line < start_line)
-	{
-		return false;
-	}
-	else if((end_line == start_line) && (end_column < start_column))
-	{
-		return false;
-	}
+  if(end_line < start_line)
+  {
+    return false;
+  }
+  else if((end_line == start_line) && (end_column < start_column))
+  {
+    return false;
+  }
 
-	NSLayoutManager* layout_manager = [text_view layoutManager];
-	NSUInteger number_of_glyphs = [layout_manager numberOfGlyphs];
-	if(0 == number_of_glyphs)
-	{
-		if((start_line <= 1) && (start_column <= 1))
-		{
-			return true;
-		}
-		else
-		{
-			return false;
-		}
-	}
-	NSUInteger number_of_lines;
-	NSUInteger index;
+  NSLayoutManager* layout_manager = [text_view layoutManager];
+  NSUInteger number_of_glyphs = [layout_manager numberOfGlyphs];
+  if(0 == number_of_glyphs)
+  {
+    if((start_line <= 1) && (start_column <= 1))
+    {
+      return true;
+    }
+    else
+    {
+      return false;
+    }
+  }
+  NSUInteger number_of_lines;
+  NSUInteger index;
 
-	NSRange line_range = NSMakeRange(0, 0);
+  NSRange line_range = NSMakeRange(0, 0);
 
-	bool found_start_line = false;
-	bool found_start_column = false;
-	NSUInteger selection_start_index = 0;
+  bool found_start_line = false;
+  bool found_start_column = false;
+  NSUInteger selection_start_index = 0;
 
-	for(number_of_lines = 0, index = 0; index < number_of_glyphs;)
-	{
-		NSUInteger last_index = index; // this is for a workaround where end_line==start_line
-		NSRange last_range = line_range; // this is for a workaround where end_line==start_line
-		
-		(void) [layout_manager lineFragmentRectForGlyphAtIndex:index
-			effectiveRange:&line_range];
-		index = NSMaxRange(line_range);
-		number_of_lines++;
-		if(number_of_lines == start_line)
-		{
-			found_start_line = true;
-			// line_range.length will tell us how manay glyphs there are on this line
-			if(line_range.length >= start_column)
-			{
-				found_start_column = true;
-				// The line_range.length may have overshot, so we need to subtract out the extra glyphs
-				NSUInteger overshot_count = line_range.length - (start_column-1);
-	
-				// index contains our total running count of all glyphs, which is what we need to specify the range for text selection
-				selection_start_index = index - overshot_count;
-			}
-			else
-			{
-				// Decision: If there are not enough columns on this line,
-				// do we start the selection at the end of the line
-				// or do we abort?
-				found_start_column = false;
-				selection_start_index = index;
-			}
-			
-			// Edge case: end_line is the same line as start_line
-			// The problem is we handle the end positions in the next block, but advance to the next line earlier in this loop.
-			// The easiest workaround to do is back up the counters and re-do the next line in the next block if this is the case.
-			if(start_line == end_line)
-			{
-				number_of_lines--;
-				line_range = last_range;
-				index = last_index;
-			}
-			
-			break;
-		}
-	}
+  for(number_of_lines = 0, index = 0; index < number_of_glyphs;)
+  {
+    NSUInteger last_index = index;
+    NSRange last_range = line_range;
 
-	if(!found_start_line)
-	{
-		NSLog(@"Failed to find startLine of %lu. Number of lines is %lu", start_line, number_of_lines);
-		return false;
-	}
+    (void) [layout_manager lineFragmentRectForGlyphAtIndex:index
+                                            effectiveRange:&line_range];
+    index = NSMaxRange(line_range);
+    number_of_lines++;
+    if(number_of_lines == start_line)
+    {
+      found_start_line = true;
+      if(line_range.length >= start_column)
+      {
+        found_start_column = true;
+        NSUInteger overshot_count = line_range.length - (start_column-1);
+        selection_start_index = index - overshot_count;
+      }
+      else
+      {
+        found_start_column = false;
+        selection_start_index = index;
+      }
 
-	// If we comment out this block, we're going to allow being too short on columns.
-/*
-	if(!found_start_column)
-	{
-		NSLog(@"Failed to find startColumn line of %lu. Number of columns at line %lu is %lu", start_column, number_of_lines, line_range.location);
-		return false;
-	}
-*/
+      /* Edge case: end_line is the same line as start_line */
+      if(start_line == end_line)
+      {
+        number_of_lines--;
+        line_range = last_range;
+        index = last_index;
+      }
 
-	// Do end
-	bool found_end_line = false;
-	bool found_end_column = false;
-	NSUInteger selection_end_index = 0;
+      break;
+    }
+  }
 
-	for(; index < number_of_glyphs;)
-	{
-		(void) [layout_manager lineFragmentRectForGlyphAtIndex:index
-			effectiveRange:&line_range];
-		index = NSMaxRange(line_range);
-		number_of_lines++;
-		if(number_of_lines == end_line)
-		{
-			found_end_line = true;
-			// line_range.length will tell us how manay glyphs there are on this line
-			if(line_range.length >= end_column)
-			{
-				found_start_column = true;
-				// The line_range.length may have overshot, so we need to subtract out the extra glyphs
-				NSUInteger overshot_count = line_range.length - (end_column-1);
-	
-				// index contains our total running count of all glyphs, which is what we need to specify the range for text selection
-				selection_end_index = index - overshot_count;
-			}
-			else
-			{
-				// Decision: If there are not enough columns on this line,
-				// do we start the selection at the end of the line
-				// or do we abort?
-				found_end_column = false;
-				selection_end_index = index;
-			}
-			break;
-		}
-	}
+  if(!found_start_line)
+  {
+    return false;
+  }
 
-	// Decision: If there are not enough lines,
-	// do we select up to the end,
-	// or do we abort?
-	if(!found_end_line)
-	{
-#if 0
-		NSLog(@"Failed to find startLine of %lu. Number of lines is %lu", start_line, number_of_lines);
-		return false;
-#else
-		selection_end_index = index;
-#endif
-	}
+  /* Do end */
+  bool found_end_line = false;
+  bool found_end_column = false;
+  NSUInteger selection_end_index = 0;
 
-	// If we comment out this block, we're going to allow being too short on columns.
-/*
-	if(!found_start_column)
-	{
-		NSLog(@"Failed to find startColumn line of %lu. Number of columns at line %lu is %lu", start_column, number_of_lines, line_range.length);
-		return false;
-	}
-*/
+  for(; index < number_of_glyphs;)
+  {
+    (void) [layout_manager lineFragmentRectForGlyphAtIndex:index
+                                            effectiveRange:&line_range];
+    index = NSMaxRange(line_range);
+    number_of_lines++;
+    if(number_of_lines == end_line)
+    {
+      found_end_line = true;
+      if(line_range.length >= end_column)
+      {
+        found_start_column = true;
+        NSUInteger overshot_count = line_range.length - (end_column-1);
+        selection_end_index = index - overshot_count;
+      }
+      else
+      {
+        found_end_column = false;
+        selection_end_index = index;
+      }
+      break;
+    }
+  }
 
-	NSRange selection_range = NSMakeRange(selection_start_index, selection_end_index-selection_start_index);
-//	[textView setSelectedRange:selection_range];
-	*out_range = selection_range;
+  if(!found_end_line)
+  {
+    selection_end_index = index;
+  }
 
-	return true;
+  NSRange selection_range = NSMakeRange(selection_start_index, selection_end_index-selection_start_index);
+  *out_range = selection_range;
+
+  return true;
 }
 
-/// For a provided native_selection_range, get the start_line, start_column, end_line, end_column
-/// @param native_selection_range This is a range that something like [text_view selectedRange] would return
+/* For a provided native_selection_range, get the start_line, start_column, end_line, end_column */
 static bool cocoaTextComputeLineColumnFromRangeForTextView(NSTextView* text_view, NSRange native_selection_range, NSUInteger* out_start_line, NSUInteger* out_start_column, NSUInteger* out_end_line, NSUInteger* out_end_column)
 {
-	*out_start_line = 1;
-	*out_start_column = 1;
-	*out_end_line = 1;
-	*out_end_column = 1;
+  *out_start_line = 1;
+  *out_start_column = 1;
+  *out_end_line = 1;
+  *out_end_column = 1;
 
-	NSUInteger start_line = 1;
-	NSUInteger start_column = 1;
-	NSUInteger end_line = 1;
-	NSUInteger end_column = 1;
+  NSUInteger start_line = 1;
+  NSUInteger start_column = 1;
+  NSUInteger end_line = 1;
+  NSUInteger end_column = 1;
 
+  NSLayoutManager* layout_manager = [text_view layoutManager];
+  NSUInteger number_of_glyphs = [layout_manager numberOfGlyphs];
+  if(0 == number_of_glyphs)
+  {
+    if(native_selection_range.location == 0)
+    {
+      return true;
+    }
+    else
+    {
+      return false;
+    }
+  }
 
-	NSLayoutManager* layout_manager = [text_view layoutManager];
-	NSUInteger number_of_glyphs = [layout_manager numberOfGlyphs];
-	if(0 == number_of_glyphs)
-	{
-		if(native_selection_range.location == 0)
-		{
-			return true;
-		}
-		else
-		{
-			return false;
-		}
-	}
-	
-	NSUInteger number_of_lines;
-	NSUInteger index;
-	NSRange line_range = NSMakeRange(0, 0);
+  NSUInteger number_of_lines;
+  NSUInteger index;
+  NSRange line_range = NSMakeRange(0, 0);
 
+  bool found_start_line = false;
+  bool found_start_column = false;
+  NSUInteger selection_start_index = native_selection_range.location;
+  NSUInteger selection_end_index = native_selection_range.location + native_selection_range.length;
 
+  for(number_of_lines = 0, index = 0; index < number_of_glyphs;)
+  {
+    (void) [layout_manager lineFragmentRectForGlyphAtIndex:index
+                                            effectiveRange:&line_range];
+    index = NSMaxRange(line_range);
+    number_of_lines++;
+    if(index >= selection_start_index)
+    {
+      found_start_line = true;
+      start_line = number_of_lines;
 
-	bool found_start_line = false;
-	bool found_start_column = false;
-	NSUInteger selection_start_index = native_selection_range.location;
-	NSUInteger selection_end_index = native_selection_range.location + native_selection_range.length;
+      found_start_column = true;
+      NSUInteger overshot_count = index - (selection_start_index);
+      start_column = line_range.length - overshot_count + 1;
 
-	for(number_of_lines = 0, index = 0; index < number_of_glyphs;)
-	{
-//		NSUInteger last_index = index; // this is for a workaround where end_line==start_line
-//		NSRange last_range = line_range; // this is for a workaround where end_line==start_line
-		
-		(void) [layout_manager lineFragmentRectForGlyphAtIndex:index
-			effectiveRange:&line_range];
-		index = NSMaxRange(line_range);
-		number_of_lines++;
-		if(index >= selection_start_index)
-		{
-			found_start_line = true;
-			start_line = number_of_lines;
-			
-			found_start_column = true;
-			// Getting a full line at a time may have overshot, so we need to subtract out the extra glyphs
-			NSUInteger overshot_count = index - (selection_start_index);
+      /* Edge case: end_line is the same line as start_line */
+      if(index >= selection_end_index)
+      {
+        NSUInteger overshot_end_count = index - (selection_end_index);
+        end_column = line_range.length - overshot_end_count + 1;
+        end_line = start_line;
 
-			// line_range.length will tell us how manay glyphs there are on this lin
-			start_column = line_range.length - overshot_count + 1;
+        *out_start_line = start_line;
+        *out_start_column = start_column;
+        *out_end_line = end_line;
+        *out_end_column = end_column;
+        return true;
+      }
+      break;
+    }
+  }
 
+  if(!found_start_line)
+  {
+    return false;
+  }
 
-			// Edge case: end_line is the same line as start_line
-			// The problem is we handle the end positions in the next block, but advance to the next line earlier in this loop.
-			// So just handle it here and return immediately.
-			if(index >= selection_end_index)
-			{
-				NSUInteger overshot_end_count = index - (selection_end_index);
-				end_column = line_range.length - overshot_end_count + 1;
-				end_line = start_line;
-				
-				*out_start_line = start_line;
-				*out_start_column = start_column;
-				*out_end_line = end_line;
-				*out_end_column = end_column;
-				return true;
-			}
-			break;
-		}
-	}
+  /* Do end */
+  bool found_end_line = false;
+  bool found_end_column = false;
 
-	if(!found_start_line)
-	{
-		NSLog(@"Failed to find start position at %lu. Number of glyphs is %lu", selection_start_index, number_of_glyphs);
-		return false;
-	}
+  for(; index < number_of_glyphs;)
+  {
+    (void) [layout_manager lineFragmentRectForGlyphAtIndex:index
+                                            effectiveRange:&line_range];
+    index = NSMaxRange(line_range);
+    number_of_lines++;
+    if(index >= selection_end_index)
+    {
+      found_end_line = true;
+      end_line = number_of_lines;
 
-	// If we comment out this block, we're going to allow being too short on columns.
-/*
-	if(!found_start_column)
-	{
-		NSLog(@"Failed to find startColumn line of %lu. Number of columns at line %lu is %lu", start_column, number_of_lines, line_range.location);
-		return false;
-	}
-*/
+      found_end_column = true;
 
-	// Do end
-	bool found_end_line = false;
-	bool found_end_column = false;
+      NSUInteger overshot_count = index - (selection_end_index);
+      end_column = line_range.length - overshot_count + 1;
+      break;
+    }
+  }
 
-	for(; index < number_of_glyphs;)
-	{
-		(void) [layout_manager lineFragmentRectForGlyphAtIndex:index
-			effectiveRange:&line_range];
-		index = NSMaxRange(line_range);
-		number_of_lines++;
-		if(index >= selection_end_index)
-		{
-			found_end_line = true;
-			end_line = number_of_lines;
-			
-			found_end_column = true;
+  if(!found_end_line)
+  {
+    end_line = number_of_lines;
+    end_column = line_range.length;
+  }
 
-			// Getting a full line at a time may have overshot, so we need to subtract out the extra glyphs
-			NSUInteger overshot_count = index - (selection_end_index);
-
-			// line_range.length will tell us how manay glyphs there are on this lin
-			end_column = line_range.length - overshot_count + 1;
-			break;
-		}
-	}
-
-	// Decision: If there are not enough lines,
-	// do we select up to the end,
-	// or do we abort?
-	if(!found_end_line)
-	{
-#if 0
-		NSLog(@"Failed to find end position of %lu. Number of gylphs is %lu", selection_end_index, number_of_glyphs);
-		return false;
-#else
-		end_line = number_of_lines;
-		end_column = line_range.length;
-#endif
-	}
-
-
-
-	*out_start_line = start_line;
-	*out_start_column = start_column;
-	*out_end_line = end_line;
-	*out_end_column = end_column;
-	return true;
+  *out_start_line = start_line;
+  *out_start_column = start_column;
+  *out_end_line = end_line;
+  *out_end_column = end_column;
+  return true;
 }
 
 void iupdrvTextConvertLinColToPos(Ihandle* ih, int lin, int col, int *pos)
 {
-//		NSLog(@"iupdrvTextConvertLinColToPos");
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			NSUInteger lin_start = lin;
-			NSUInteger col_start = col;
-			NSUInteger lin_end = lin;
-			NSUInteger col_end = col;
-			NSRange native_selection_range = NSMakeRange(0, 0);
-			
-			bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
-			if(did_find_range)
-			{
-				if(pos)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*pos = (int)native_selection_range.location;
-				}
-			}
-			return;
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			// This should be trivial, but it isn't quite...
-			// Without newlines, it should be pos = col -1
-			// Because the user can add newlines in a NSTextField (option-return), we may need to do some heroics.
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        NSUInteger lin_start = lin;
+        NSUInteger col_start = col;
+        NSUInteger lin_end = lin;
+        NSUInteger col_end = col;
+        NSRange native_selection_range = NSMakeRange(0, 0);
 
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
+        if(did_find_range)
+        {
+          if(pos)
+          {
+            *pos = (int)native_selection_range.location;
+          }
+        }
+        return;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
 
-			if(![field_editor isKindOfClass:[NSTextView class]])
-			{
-				if(pos)
-				{
-					if(col > 0)
-					{
-						*pos = col - 1;
-					}
-					else
-					{
-						// What do we do here?
-						*pos = 0;
-					}
-				}
-				return;
-			}
-			
-			NSTextView* text_view = (NSTextView*)field_editor;
-			NSUInteger lin_start = lin;
-			NSUInteger col_start = col;
-			NSUInteger lin_end = lin;
-			NSUInteger col_end = col;
-			NSRange native_selection_range = NSMakeRange(0, 0);
-			
-			bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
-			if(did_find_range)
-			{
-				if(pos)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*pos = (int)native_selection_range.location;
-				}
-			}
-			return;
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// This should be trivial, but it isn't quite...
-			// Without newlines, it should be pos = col -1
-			// Because the user can add newlines in a NSTextField (option-return), we may need to do some heroics.
+        if(![field_editor isKindOfClass:[NSTextView class]])
+        {
+          if(pos)
+          {
+            if(col > 0)
+            {
+              *pos = col - 1;
+            }
+            else
+            {
+              *pos = 0;
+            }
+          }
+          return;
+        }
 
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSTextView* text_view = (NSTextView*)field_editor;
+        NSUInteger lin_start = lin;
+        NSUInteger col_start = col;
+        NSUInteger lin_end = lin;
+        NSUInteger col_end = col;
+        NSRange native_selection_range = NSMakeRange(0, 0);
 
-			if(![field_editor isKindOfClass:[NSTextView class]])
-			{
-				if(pos)
-				{
-					if(col > 0)
-					{
-						*pos = col - 1;
-					}
-					else
-					{
-						// What do we do here?
-						*pos = 0;
-					}
-				}
-				return;
-			}
-			
-			NSTextView* text_view = (NSTextView*)field_editor;
-			NSUInteger lin_start = lin;
-			NSUInteger col_start = col;
-			NSUInteger lin_end = lin;
-			NSUInteger col_end = col;
-			NSRange native_selection_range = NSMakeRange(0, 0);
-			
-			bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
-			if(did_find_range)
-			{
-				if(pos)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*pos = (int)native_selection_range.location;
-				}
-			}
-			return;
+        bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
+        if(did_find_range)
+        {
+          if(pos)
+          {
+            *pos = (int)native_selection_range.location;
+          }
+        }
+        return;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
 
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+        if(![field_editor isKindOfClass:[NSTextView class]])
+        {
+          if(pos)
+          {
+            if(col > 0)
+            {
+              *pos = col - 1;
+            }
+            else
+            {
+              *pos = 0;
+            }
+          }
+          return;
+        }
 
+        NSTextView* text_view = (NSTextView*)field_editor;
+        NSUInteger lin_start = lin;
+        NSUInteger col_start = col;
+        NSUInteger lin_end = lin;
+        NSUInteger col_end = col;
+        NSRange native_selection_range = NSMakeRange(0, 0);
+
+        bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
+        if(did_find_range)
+        {
+          if(pos)
+          {
+            *pos = (int)native_selection_range.location;
+          }
+        }
+        return;
+      }
+    default:
+      {
+        break;
+      }
+  }
 }
 
 void iupdrvTextConvertPosToLinCol(Ihandle* ih, int pos, int *lin, int *col)
 {
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        NSRange range_position = NSMakeRange(pos, 0);
 
-//	NSLog(@"iupdrvTextConvertPosToLinCol");
+        NSUInteger lin_start=1;
+        NSUInteger col_start=1;
+        NSUInteger lin_end=1;
+        NSUInteger col_end=1;
+        bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, range_position, &lin_start, &col_start, &lin_end, &col_end);
+        if(did_find_range)
+        {
+          if(lin)
+          {
+            *lin = (int)lin_start;
+          }
+          if(col)
+          {
+            *col = (int)col_start;
+          }
+        }
+        return;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
 
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			// Use selectedRanges to get an array of multiple selections if we ever have to handle that
-			NSRange range_position = NSMakeRange(pos, 0);
+        if(![field_editor isKindOfClass:[NSTextView class]])
+        {
+          if(lin)
+          {
+            *lin = 1;
+          }
+          if(col)
+          {
+            *col = pos + 1;
+          }
 
-			
-			NSUInteger lin_start=1;
-			NSUInteger col_start=1;
-			NSUInteger lin_end=1;
-			NSUInteger col_end=1;
-			bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, range_position, &lin_start, &col_start, &lin_end, &col_end);
-			if(did_find_range)
-			{
-				if(lin)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*lin = (int)lin_start;
-				}
-				if(col)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*col = (int)col_start;
-				}
-			}
-			return;
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			// This should be trivial, but it isn't quite...
-			// Without newlines, it should be pos = col -1
-			// Because the user can add newlines in a NSTextField (option-return), we may need to do some heroics.
+          return;
+        }
 
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSTextView* text_view = (NSTextView*)field_editor;
+        NSUInteger lin_start=1;
+        NSUInteger col_start=1;
+        NSUInteger lin_end=1;
+        NSUInteger col_end=1;
+        NSRange range_position = NSMakeRange(pos, 0);
+        bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, range_position, &lin_start, &col_start, &lin_end, &col_end);
+        if(did_find_range)
+        {
+          if(lin)
+          {
+            *lin = (int)lin_start;
+          }
+          if(col)
+          {
+            *col = (int)col_start;
+          }
+        }
+        return;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
 
-			if(![field_editor isKindOfClass:[NSTextView class]])
-			{
-				if(lin)
-				{
-					*lin = 1;
-				}
-				if(col)
-				{
-					*col = pos + 1;
-				}
+        if(![field_editor isKindOfClass:[NSTextView class]])
+        {
+          if(lin)
+          {
+            *lin = 1;
+          }
+          if(col)
+          {
+            *col = pos + 1;
+          }
 
-				return;
-			}
-			
-			
-			NSTextView* text_view = (NSTextView*)field_editor;
-			NSUInteger lin_start=1;
-			NSUInteger col_start=1;
-			NSUInteger lin_end=1;
-			NSUInteger col_end=1;
-			NSRange range_position = NSMakeRange(pos, 0);
-			bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, range_position, &lin_start, &col_start, &lin_end, &col_end);
-			if(did_find_range)
-			{
-				if(lin)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*lin = (int)lin_start;
-				}
-				if(col)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*col = (int)col_start;
-				}
-			}
-			return;
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
+          return;
+        }
 
-			// This should be trivial, but it isn't quite...
-			// Without newlines, it should be pos = col -1
-			// Because the user can add newlines in a NSTextField (option-return), we may need to do some heroics.
-
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-
-			if(![field_editor isKindOfClass:[NSTextView class]])
-			{
-				if(lin)
-				{
-					*lin = 1;
-				}
-				if(col)
-				{
-					*col = pos + 1;
-				}
-
-				return;
-			}
-			
-			
-			NSTextView* text_view = (NSTextView*)field_editor;
-			NSUInteger lin_start=1;
-			NSUInteger col_start=1;
-			NSUInteger lin_end=1;
-			NSUInteger col_end=1;
-			NSRange range_position = NSMakeRange(pos, 0);
-			bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, range_position, &lin_start, &col_start, &lin_end, &col_end);
-			if(did_find_range)
-			{
-				if(lin)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*lin = (int)lin_start;
-				}
-				if(col)
-				{
-					// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-					*col = (int)col_start;
-				}
-			}
-			return;
-			
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+        NSTextView* text_view = (NSTextView*)field_editor;
+        NSUInteger lin_start=1;
+        NSUInteger col_start=1;
+        NSUInteger lin_end=1;
+        NSUInteger col_end=1;
+        NSRange range_position = NSMakeRange(pos, 0);
+        bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, range_position, &lin_start, &col_start, &lin_end, &col_end);
+        if(did_find_range)
+        {
+          if(lin)
+          {
+            *lin = (int)lin_start;
+          }
+          if(col)
+          {
+            *col = (int)col_start;
+          }
+        }
+        return;
+      }
+    default:
+      {
+        break;
+      }
+  }
 }
 
-
-// FIXME: I don't know if this is ever called.
 void* iupdrvTextAddFormatTagStartBulk(Ihandle* ih)
 {
-//	NSLog(@"iupdrvTextAddFormatTagStartBulk");
-	NSTextView* text_view = cocoaTextGetTextView(ih);
-	NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-	[undo_manager beginUndoGrouping];
-	
-	NSTextStorage* text_storage = [text_view textStorage];
-	// I'm not sure if this is safe. The LayoutManager will throw an exception if a layout is done while beginEditing
-	[text_storage beginEditing];
-	return NULL;
+  NSTextView* text_view = cocoaTextGetTextView(ih);
+  NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+  [undo_manager beginUndoGrouping];
+
+  NSTextStorage* text_storage = [text_view textStorage];
+  [text_storage beginEditing];
+  return NULL;
 }
 
-// FIXME: I don't know if this is ever called.
 void iupdrvTextAddFormatTagStopBulk(Ihandle* ih, void* state)
 {
-//	NSLog(@"iupdrvTextAddFormatTagStopBulk");
-	
-	NSTextView* text_view = cocoaTextGetTextView(ih);
-	NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-	
-	NSTextStorage* text_storage = [text_view textStorage];
-	[text_storage endEditing];
-	//	  [text_view didChangeText];
-	[undo_manager endUndoGrouping];
+  NSTextView* text_view = cocoaTextGetTextView(ih);
+  NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
 
+  NSTextStorage* text_storage = [text_view textStorage];
+  [text_storage endEditing];
+  [undo_manager endUndoGrouping];
 }
 
-// You must pass in a valid paragraph_style. This routine will alter it depending on which Iup attributes were set.
-// Called by cocoaTextParseParagraphFormat to apply format tags.
-// But broken out so it can also be used for setTypingAttributes:
+/* You must pass in a valid paragraph_style. This routine will alter it depending on which Iup attributes were set. */
 static bool cocoaTextParseParagraphAttributes(NSMutableParagraphStyle* paragraph_style, Ihandle* formattag)
 {
-	bool needs_paragraph_style = false;
-	char* format;
-	
-	format = iupAttribGet(formattag, "ALIGNMENT");
-	if(format)
-	{
-		if(iupStrEqualNoCase(format, "JUSTIFY"))
-		{
-			[paragraph_style setAlignment:NSTextAlignmentJustified];
-		}
-		else if(iupStrEqualNoCase(format, "RIGHT"))
-		{
-			[paragraph_style setAlignment:NSTextAlignmentRight];
-		}
-		else if(iupStrEqualNoCase(format, "CENTER"))
-		{
-			[paragraph_style setAlignment:NSTextAlignmentCenter];
-		}
-		else /* "LEFT" */
-		{
-			[paragraph_style setAlignment:NSTextAlignmentLeft];
-		}
-		needs_paragraph_style = true;
-	}
-	
-	format = iupAttribGet(formattag, "INDENT");
-	if(format)
-	{
-		int val = 0;
-		if(iupStrToInt(format, &val))
-		{
-			[paragraph_style setFirstLineHeadIndent:(CGFloat)val];
-			needs_paragraph_style = true;
-		}
-		
-		format = iupAttribGet(formattag, "INDENTRIGHT");
-		if(format && iupStrToInt(format, &val))
-		{
-			// The Iup/Windows implementation seems to use the value relative to the right margin.
-			// In Cocoa, positive values are the distance from the left margin, and negative values are from the right.
-			// NOTE: Cocoa uses head/tail, not left/right because it supports right-to-left languages.
-			[paragraph_style setTailIndent:(CGFloat)(-val)];
-			needs_paragraph_style = true;
-		}
-		
-		format = iupAttribGet(formattag, "INDENTOFFSET");
-		if(format && iupStrToInt(format, &val))
-		{
-			[paragraph_style setHeadIndent:(CGFloat)(val)];
-			needs_paragraph_style = true;
-		}
-	}
-	
-	
-	format = iupAttribGet(formattag, "LINESPACING");
-	if(format)
-	{
-		double val = 0;
-		
-		if(iupStrEqualNoCase(format, "SINGLE"))
-		{
-			[paragraph_style setLineSpacing:1.0];
-		}
-		else if(iupStrEqualNoCase(format, "ONEHALF"))
-		{
-			[paragraph_style setLineSpacing:1.5];
-		}
-		else if(iupStrEqualNoCase(format, "DOUBLE"))
-		{
-			[paragraph_style setLineSpacing:2.0];
-		}
-		else if(iupStrToDouble(format, &val))
-		{
-			[paragraph_style setLineSpacing:val];
-		}
-		needs_paragraph_style = true;
-	}
-	
-	format = iupAttribGet(formattag, "SPACEBEFORE");
-	if(format)
-	{
-		double val = 0;
-		if(iupStrToDouble(format, &val))
-		{
-			[paragraph_style setParagraphSpacingBefore:val];
-			needs_paragraph_style = true;
-		}
-	}
-	
-	format = iupAttribGet(formattag, "SPACEAFTER");
-	if(format)
-	{
-		double val = 0;
-		if(iupStrToDouble(format, &val))
-		{
-			[paragraph_style setParagraphSpacing:val];
-			needs_paragraph_style = true;
-		}
-	}
-	
-	format = iupAttribGet(formattag, "TABSARRAY");
-	if(format)
-	{
-		int pos = 0;
-		char* str;
-		NSMutableArray* tab_array = [NSMutableArray array];
-		
-		while(format)
-		{
-			str = iupStrDupUntil((char**)&format, ' ');
-			if (!str) break;
-			pos = atoi(str);
-			free(str);
-			
-			str = iupStrDupUntil((char**)&format, ' ');
-			if (!str) break;
-			
-			NSTextTab* text_tab = nil;
-			// NOTE: DECIMAL is not supported.
-			// Cocoa additioanlly supports natural and justified.
-			if(iupStrEqualNoCase(str, "LEFT"))
-			{
-				text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentLeft location:(CGFloat)pos options:[NSDictionary dictionary]];
-			}
-			else if(iupStrEqualNoCase(str, "RIGHT"))
-			{
-				text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentRight location:(CGFloat)pos options:[NSDictionary dictionary]];
-			}
-			else if(iupStrEqualNoCase(str, "CENTER"))
-			{
-				text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentCenter location:(CGFloat)pos options:[NSDictionary dictionary]];
-			}
-			else /* fallback for unsupported options */
-			{
-				text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentLeft location:(CGFloat)pos options:[NSDictionary dictionary]];
-			}
-			free(str);
-			
-			[tab_array addObject:text_tab];
-			[text_tab release];
-		}
-		
-		[paragraph_style setTabStops:tab_array];
-		needs_paragraph_style = true;
-	}
+  bool needs_paragraph_style = false;
+  const char* format;
 
-	return needs_paragraph_style;
+  format = iupAttribGet(formattag, "ALIGNMENT");
+  if(format)
+  {
+    if(iupStrEqualNoCase(format, "JUSTIFY"))
+    {
+      [paragraph_style setAlignment:NSTextAlignmentJustified];
+    }
+    else if(iupStrEqualNoCase(format, "RIGHT"))
+    {
+      [paragraph_style setAlignment:NSTextAlignmentRight];
+    }
+    else if(iupStrEqualNoCase(format, "CENTER"))
+    {
+      [paragraph_style setAlignment:NSTextAlignmentCenter];
+    }
+    else /* "LEFT" */
+    {
+      [paragraph_style setAlignment:NSTextAlignmentLeft];
+    }
+    needs_paragraph_style = true;
+  }
+
+  format = iupAttribGet(formattag, "INDENT");
+  if(format)
+  {
+    int val = 0;
+    if(iupStrToInt(format, &val))
+    {
+      [paragraph_style setFirstLineHeadIndent:(CGFloat)val];
+      needs_paragraph_style = true;
+    }
+
+    format = iupAttribGet(formattag, "INDENTRIGHT");
+    if(format && iupStrToInt(format, &val))
+    {
+      [paragraph_style setTailIndent:(CGFloat)(-val)];
+      needs_paragraph_style = true;
+    }
+
+    format = iupAttribGet(formattag, "INDENTOFFSET");
+    if(format && iupStrToInt(format, &val))
+    {
+      [paragraph_style setHeadIndent:(CGFloat)val];
+      needs_paragraph_style = true;
+    }
+  }
+
+  format = iupAttribGet(formattag, "LINESPACING");
+  if(format)
+  {
+    double val = 0;
+
+    if(iupStrEqualNoCase(format, "SINGLE"))
+    {
+      [paragraph_style setLineSpacing:1.0];
+    }
+    else if(iupStrEqualNoCase(format, "ONEHALF"))
+    {
+      [paragraph_style setLineSpacing:1.5];
+    }
+    else if(iupStrEqualNoCase(format, "DOUBLE"))
+    {
+      [paragraph_style setLineSpacing:2.0];
+    }
+    else if(iupStrToDouble(format, &val))
+    {
+      [paragraph_style setLineSpacing:val];
+    }
+    needs_paragraph_style = true;
+  }
+
+  format = iupAttribGet(formattag, "SPACEBEFORE");
+  if(format)
+  {
+    double val = 0;
+    if(iupStrToDouble(format, &val))
+    {
+      [paragraph_style setParagraphSpacingBefore:val];
+      needs_paragraph_style = true;
+    }
+  }
+
+  format = iupAttribGet(formattag, "SPACEAFTER");
+  if(format)
+  {
+    double val = 0;
+    if(iupStrToDouble(format, &val))
+    {
+      [paragraph_style setParagraphSpacing:val];
+      needs_paragraph_style = true;
+    }
+  }
+
+  format = iupAttribGet(formattag, "TABSARRAY");
+  if(format)
+  {
+    int pos = 0;
+    char* str;
+    NSMutableArray* tab_array = [NSMutableArray array];
+
+    while(format)
+    {
+      str = iupStrDupUntil(&format, ' ');
+      if (!str) break;
+      pos = atoi(str);
+      free(str);
+
+      str = iupStrDupUntil(&format, ' ');
+      if (!str) break;
+
+      NSTextTab* text_tab = nil;
+      if(iupStrEqualNoCase(str, "LEFT"))
+      {
+        text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentLeft location:(CGFloat)pos options:[NSDictionary dictionary]];
+      }
+      else if(iupStrEqualNoCase(str, "RIGHT"))
+      {
+        text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentRight location:(CGFloat)pos options:[NSDictionary dictionary]];
+      }
+      else if(iupStrEqualNoCase(str, "CENTER"))
+      {
+        text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentCenter location:(CGFloat)pos options:[NSDictionary dictionary]];
+      }
+      else
+      {
+        text_tab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentLeft location:(CGFloat)pos options:[NSDictionary dictionary]];
+      }
+      free(str);
+
+      [tab_array addObject:text_tab];
+      [text_tab release];
+    }
+
+    [paragraph_style setTabStops:tab_array];
+    needs_paragraph_style = true;
+  }
+
+  return needs_paragraph_style;
 }
 
-// TODO/FIXME: I still get cases where I clobber formatting when (maybe?) I should not be clobbering. (The Iup spec is a bit undefined on this.)
-// Example: The text case with 3 lines of containing "First Line" "Second Line Big Big Big" "Third Line"
-// If you then set a color format for the selection of the 3 lines, you lose italics, underline, strikethrough. (But font size is preserved.)
-// I'm thinking maybe the algorithm should be changed to use any enumeration APIs Cocoa may provide.
-// Since of blindly applying the attributes for the selected block,
-// we enumerate over the range and try to pick up each individual piece and try to preserve existing attributes for each section.
-// Then we apply the new attribute over each sub-section.
-// This will require modifcation to the calling algorthm, because it sets the attribute for the entire section from the caller.
-// That will need to be pushed down into here.
-// See:
-// - (void)enumerateAttributesInRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSDictionary<NSAttributedStringKey, id> *attrs, NSRange range, BOOL *stop))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));
-// And see the Bullet/Numbering code because it has started moving towards that model already.
 static bool cocoaTextParseParagraphFormat(Ihandle* ih, Ihandle* formattag, NSTextView* text_view, NSRange selection_range)
 {
-	NSTextStorage* text_storage = [text_view textStorage];
-	NSString* all_string = [text_storage string];
-	__block bool did_change_attribute = false;
-	// The problem seems to be that in order to change the TextLines attribute for the entire block, I need to re-set the attribute.
-	// So I have to be very careful about applying attributes and not clobbering them.
-	
-	[text_storage beginEditing];
-	
-	
-	[all_string enumerateSubstringsInRange:selection_range options:NSStringEnumerationByParagraphs usingBlock:
-	 ^(NSString * _Nullable substring, NSRange substring_range, NSRange enclosing_range, BOOL * _Nonnull stop)
-		{
-			*stop = NO;
-			// NSLog(@"substring:%@", substring);
-			// NSLog(@"substringRange:%@", NSStringFromRange(substring_range));
-			// NSLog(@"enclosingRange:%@", NSStringFromRange(enclosing_range));
-			
-			// If the selection block starts in the middle of the paragraph instead of the beginning,
-			// we have to decide whether we should start as-is,
-			// or back-up to the beginning.
-			// We will use getParagraphStart to back up to the beginning.
-			NSUInteger start_paragraph_index;
-			NSUInteger end_paragraph_index;
-			NSUInteger contents_end_paragraph_index;
-			[all_string getParagraphStart:&start_paragraph_index end:&end_paragraph_index contentsEnd:&contents_end_paragraph_index forRange:enclosing_range];
-			
-			// NSLog(@"start_paragraph_index:%lu", start_paragraph_index);
-			// NSLog(@"end_paragraph_index:%lu", end_paragraph_index);
-			// NSLog(@"contents_end_paragraph_index:%lu", contents_end_paragraph_index);
-			
-			
-			// end_paragraph_index seems to include the newline, which we want
-			NSRange paragraph_range = NSMakeRange(start_paragraph_index, end_paragraph_index-start_paragraph_index);
-			// NSLog(@"paragraph_range:%@", NSStringFromRange(paragraph_range));
-			
-			
-			NSAttributedString* current_paragraph = [text_storage attributedSubstringFromRange:paragraph_range];
-			//					NSLog(@"current_line: %@", current_line);
-			NSDictionary<NSAttributedStringKey, id>* current_paragraph_attributes = [current_paragraph attributesAtIndex:0 effectiveRange:NULL];
-			
-			// Assumption: I'm going to assume I don't need to worry about substrings with different attributes because I am only changing the paragraph attribute which should apply to the whole paragraph.
-			// That's why I'm ignoring the efffectiveRange: result here.
-			// If I'm wrong, this code should either duplicate the cocoaTextParseCharacterFormat,
-			// or be merged directly into cocoaTextParseParagraphFormat since if I'm wrong,
-			// that implies there is no point of having distinct paragraph attributes anyway.
-			
-			
-			// We only care about the ParagraphStyle attribute.
-			// Get the existing one so we don't clobber existing properties, or if it doesn't exist, create a default one.
-			NSMutableParagraphStyle* paragraph_style = nil;
-			paragraph_style = [[current_paragraph_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
-			if(nil == paragraph_style)
-			{
-				paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
-			}
-			[paragraph_style autorelease];
-			
-			
-			bool needs_paragraph_style = cocoaTextParseParagraphAttributes(paragraph_style, formattag);
-			if(needs_paragraph_style)
-			{
-				[text_view shouldChangeTextInRange:paragraph_range replacementString:nil];
-				[text_storage addAttribute:NSParagraphStyleAttributeName value:paragraph_style range:paragraph_range];
-				did_change_attribute = true;
-			}
-		}
-	];
-	
-	[text_storage endEditing];
-	
-	if(did_change_attribute)
-	{
-		[text_view didChangeText];
-	}
-	return did_change_attribute;
-	
+  NSTextStorage* text_storage = [text_view textStorage];
+  NSString* all_string = [text_storage string];
+  __block bool did_change_attribute = false;
+
+  [text_storage beginEditing];
+
+  [all_string enumerateSubstringsInRange:selection_range options:NSStringEnumerationByParagraphs usingBlock:
+    ^(NSString * _Nullable substring, NSRange substring_range, NSRange enclosing_range, BOOL * _Nonnull stop)
+    {
+      *stop = NO;
+
+      NSUInteger start_paragraph_index;
+      NSUInteger end_paragraph_index;
+      NSUInteger contents_end_paragraph_index;
+      [all_string getParagraphStart:&start_paragraph_index end:&end_paragraph_index contentsEnd:&contents_end_paragraph_index forRange:enclosing_range];
+
+      NSRange paragraph_range = NSMakeRange(start_paragraph_index, end_paragraph_index-start_paragraph_index);
+
+      NSAttributedString* current_paragraph = [text_storage attributedSubstringFromRange:paragraph_range];
+      NSDictionary<NSAttributedStringKey, id>* current_paragraph_attributes = [current_paragraph attributesAtIndex:0 effectiveRange:NULL];
+
+      NSMutableParagraphStyle* paragraph_style = nil;
+      paragraph_style = [[current_paragraph_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
+      if(nil == paragraph_style)
+      {
+        paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
+      }
+      [paragraph_style autorelease];
+
+      bool needs_paragraph_style = cocoaTextParseParagraphAttributes(paragraph_style, formattag);
+      if(needs_paragraph_style)
+      {
+        [text_view shouldChangeTextInRange:paragraph_range replacementString:nil];
+        [text_storage addAttribute:NSParagraphStyleAttributeName value:paragraph_style range:paragraph_range];
+        did_change_attribute = true;
+      }
+    }
+  ];
+
+  [text_storage endEditing];
+
+  if(did_change_attribute)
+  {
+    [text_view didChangeText];
+  }
+  return did_change_attribute;
 }
 
-
 const NSUInteger kIupNumberingStyleNone = 0;
 const NSUInteger kIupNumberingStyleRightParenthesis = 1;
 const NSUInteger kIupNumberingStyleParenthesis = 2;
@@ -2477,10 +2470,7 @@
 
 @property(nonatomic, assign) NSUInteger numberingStyle;
 
-// override
 - (NSString*) markerForItemNumber:(NSInteger)item_num;
-
-// convenience method
 - (NSString*) markerWithTabsForItemNumber:(NSInteger)item_num;
 
 @end
@@ -2487,4122 +2477,3172 @@
 
 @implementation IupNumberingTextList
 
-// We need to override this because when the user hits return to insert a new line,
-// any custom formatting manually added to the marker will get discarded.
-// Adding the custom formatting here should preserve our customizations.
 - (NSString*) markerForItemNumber:(NSInteger)item_num
 {
-	NSString* base_string = [super markerForItemNumber:item_num];
-	NSString* customized_marker = nil;
-	switch([self numberingStyle])
-	{
-		case kIupNumberingStyleRightParenthesis:
-		{
-			customized_marker = [NSString stringWithFormat:@"%@)", base_string];
-			break;
-		}
-		case kIupNumberingStyleParenthesis:
-		{
-			customized_marker = [NSString stringWithFormat:@"(%@)", base_string];
-			break;
-		}
-		case kIupNumberingStylePeriod:
-		{
-			customized_marker = [NSString stringWithFormat:@"%@.", base_string];
-			break;
-		}
-		case kIupNumberingStyleNonNumber:
-		{
-			customized_marker = @"";
-			break;
-		}
-		
-		case kIupNumberingStyleNone:
-		default:
-		{
-			customized_marker = base_string;
-			break;
-		}
-	}
-	
-	return customized_marker;
+  NSString* base_string = [super markerForItemNumber:item_num];
+  NSString* customized_marker = nil;
+  switch([self numberingStyle])
+  {
+    case kIupNumberingStyleRightParenthesis:
+      {
+        customized_marker = [NSString stringWithFormat:@"%@)", base_string];
+        break;
+      }
+    case kIupNumberingStyleParenthesis:
+      {
+        customized_marker = [NSString stringWithFormat:@"(%@)", base_string];
+        break;
+      }
+    case kIupNumberingStylePeriod:
+      {
+        customized_marker = [NSString stringWithFormat:@"%@.", base_string];
+        break;
+      }
+    case kIupNumberingStyleNonNumber:
+      {
+        customized_marker = @"";
+        break;
+      }
+
+    case kIupNumberingStyleNone:
+                        default:
+      {
+        customized_marker = base_string;
+        break;
+      }
+  }
+
+  return customized_marker;
 }
 
-// When we use this to format (create) a list, we are required to add a leading and trailing tab.
-// Apple's documentation doesn't state this, but this appears to be a requirement.
-// However, I cannot put it directly in markerForItemNumber because it seems to screw up things
-// when I hit return to insert new lines in a list. It appears in that case, Apple is trying to add tabs,
-// and then gets too many and it thinks it needs to created new nested lists and gets screwy.
 - (NSString*) markerWithTabsForItemNumber:(NSInteger)item_num
 {
-	NSString* base_string = [self markerForItemNumber:item_num];
-	NSString* customized_marker = nil;
-	customized_marker = [NSString stringWithFormat:@"\t%@\t", base_string];
-	return customized_marker;
+  NSString* base_string = [self markerForItemNumber:item_num];
+  NSString* customized_marker = nil;
+  customized_marker = [NSString stringWithFormat:@"\t%@\t", base_string];
+  return customized_marker;
 }
 
 @end
 
-/*
-NOTES: Not supporting NUMBERINGTAB because following TextEdit.app conventions, we use two tabs (before & after the marker), so the API doesn't fit.
-Using TABSARRAY seems to be the correct way to control indentation for this (looking at TextEdit.app).
-Additionally, because we must manually inject the markers into the text, a variable number of tabs makes it harder to remove formatting because we already must use regex to find patterns since we don't necessarily know the marker type to remove.
-Long term, we might like to support nested lists, which NUMBERINGTAB will make harder to detect since it could confuse the number of tabs to look for.
-*/
 static bool cocoaTextParseBulletNumberListFormat(Ihandle* ih, Ihandle* formattag, NSTextView* text_view, NSRange selection_range)
 {
-	// Apple doesn't provide these string constants until 10.13, so we provide our own copy.
-	static NSString* IupNSTextListMarkerBox = @"{box}";
-	static NSString* IupNSTextListMarkerCheck = @"{check}";
-	static NSString* IupNSTextListMarkerCircle = @"{circle}";
-	static NSString* IupNSTextListMarkerDiamond = @"{diamond}";
-	static NSString* IupNSTextListMarkerDisc = @"{disc}";
-	static NSString* IupNSTextListMarkerHyphen = @"{hyphen}";
-	static NSString* IupNSTextListMarkerSquare = @"{square}";
-	static NSString* IupNSTextListMarkerLowercaseHexadecimal = @"{lower-hexadecimal}";
-	static NSString* IupNSTextListMarkerUppercaseHexadecimal = @"{upper-hexadecimal}";
-	static NSString* IupNSTextListMarkerOctal = @"{octal}";
-	static NSString* IupNSTextListMarkerLowercaseAlpha = @"{lower-alpha}";
-	static NSString* IupNSTextListMarkerUppercaseAlpha = @"{upper-alpha}";
-	static NSString* IupNSTextListMarkerLowercaseLatin = @"{lower-latin}"; // seems to be the same as alpha
-	static NSString* IupNSTextListMarkerUppercaseLatin = @"{upper-latin}"; // seems to be the same as alpha
-	static NSString* IupNSTextListMarkerLowercaseRoman = @"{lower-roman}";
-	static NSString* IupNSTextListMarkerUppercaseRoman = @"{upper-roman}";
-	static NSString* IupNSTextListMarkerDecimal = @"{decimal}";
-	
-	char* format;
-	bool use_list = false;
-	NSString* which_list_marker = nil;
+  static NSString* IupNSTextListMarkerBox = @"{box}";
+  static NSString* IupNSTextListMarkerCheck = @"{check}";
+  static NSString* IupNSTextListMarkerCircle = @"{circle}";
+  static NSString* IupNSTextListMarkerDiamond = @"{diamond}";
+  static NSString* IupNSTextListMarkerDisc = @"{disc}";
+  static NSString* IupNSTextListMarkerHyphen = @"{hyphen}";
+  static NSString* IupNSTextListMarkerSquare = @"{square}";
+  static NSString* IupNSTextListMarkerLowercaseHexadecimal = @"{lower-hexadecimal}";
+  static NSString* IupNSTextListMarkerUppercaseHexadecimal = @"{upper-hexadecimal}";
+  static NSString* IupNSTextListMarkerOctal = @"{octal}";
+  static NSString* IupNSTextListMarkerLowercaseAlpha = @"{lower-alpha}";
+  static NSString* IupNSTextListMarkerUppercaseAlpha = @"{upper-alpha}";
+  static NSString* IupNSTextListMarkerLowercaseLatin = @"{lower-latin}";
+  static NSString* IupNSTextListMarkerUppercaseLatin = @"{upper-latin}";
+  static NSString* IupNSTextListMarkerLowercaseRoman = @"{lower-roman}";
+  static NSString* IupNSTextListMarkerUppercaseRoman = @"{upper-roman}";
+  static NSString* IupNSTextListMarkerDecimal = @"{decimal}";
 
-	format = iupAttribGet(formattag, "NUMBERING");
-	if(format)
-	{
-		use_list = true; // will unset in NONE case
-		if(iupStrEqualNoCase(format, "BULLET"))
-		{
-			which_list_marker = IupNSTextListMarkerDisc;
-		}
-		else if(iupStrEqualNoCase(format, "ARABIC"))
-		{
-			which_list_marker = IupNSTextListMarkerDecimal;
-		}
-		else if(iupStrEqualNoCase(format, "LCLETTER"))
-		{
-			which_list_marker = IupNSTextListMarkerLowercaseAlpha;
-		}
-		else if(iupStrEqualNoCase(format, "UCLETTER"))
-		{
-			which_list_marker = IupNSTextListMarkerUppercaseAlpha;
-		}
-		else if(iupStrEqualNoCase(format, "LCROMAN"))
-		{
-			which_list_marker = IupNSTextListMarkerLowercaseRoman;
-		}
-		else if(iupStrEqualNoCase(format, "UCROMAN"))
-		{
-			which_list_marker = IupNSTextListMarkerUppercaseRoman;
-		}
-		else if(iupStrEqualNoCase(format, "NONE"))
-		{
-			use_list = false;
-		}
-		else if(iupStrEqualNoCase(format, "BOX"))
-		{
-			which_list_marker = IupNSTextListMarkerBox;
-		}
-		else if(iupStrEqualNoCase(format, "CHECK"))
-		{
-			which_list_marker = IupNSTextListMarkerCheck;
-		}
-		else if(iupStrEqualNoCase(format, "CIRCLE"))
-		{
-			which_list_marker = IupNSTextListMarkerCircle;
-		}
-		else if(iupStrEqualNoCase(format, "DIAMOND"))
-		{
-			which_list_marker = IupNSTextListMarkerDiamond;
-		}
-		else if(iupStrEqualNoCase(format, "HYPHEN"))
-		{
-			which_list_marker = IupNSTextListMarkerHyphen;
-		}
-		else if(iupStrEqualNoCase(format, "SQUARE"))
-		{
-			which_list_marker = IupNSTextListMarkerSquare;
-		}
-		else if(iupStrEqualNoCase(format, "LCHEX"))
-		{
-			which_list_marker = IupNSTextListMarkerLowercaseHexadecimal;
-		}
-		else if(iupStrEqualNoCase(format, "UCHEX"))
-		{
-			which_list_marker = IupNSTextListMarkerUppercaseHexadecimal;
-		}
-		else if(iupStrEqualNoCase(format, "OCTAL"))
-		{
-			which_list_marker = IupNSTextListMarkerOctal;
-		}
-		else if(iupStrEqualNoCase(format, "LCLATIN"))
-		{
-			which_list_marker = IupNSTextListMarkerLowercaseLatin;
-		}
-		else if(iupStrEqualNoCase(format, "UCLATIN"))
-		{
-			which_list_marker = IupNSTextListMarkerUppercaseLatin;
-		}
-		else
-		{
-			use_list = false;
-		}
-	
-		if(use_list)
-		{
+  char* format;
+  bool use_list = false;
+  NSString* which_list_marker = nil;
 
+  format = iupAttribGet(formattag, "NUMBERING");
+  if(format)
+  {
+    use_list = true;
+    if(iupStrEqualNoCase(format, "BULLET"))
+    {
+      which_list_marker = IupNSTextListMarkerDisc;
+    }
+    else if(iupStrEqualNoCase(format, "ARABIC"))
+    {
+      which_list_marker = IupNSTextListMarkerDecimal;
+    }
+    else if(iupStrEqualNoCase(format, "LCLETTER"))
+    {
+      which_list_marker = IupNSTextListMarkerLowercaseAlpha;
+    }
+    else if(iupStrEqualNoCase(format, "UCLETTER"))
+    {
+      which_list_marker = IupNSTextListMarkerUppercaseAlpha;
+    }
+    else if(iupStrEqualNoCase(format, "LCROMAN"))
+    {
+      which_list_marker = IupNSTextListMarkerLowercaseRoman;
+    }
+    else if(iupStrEqualNoCase(format, "UCROMAN"))
+    {
+      which_list_marker = IupNSTextListMarkerUppercaseRoman;
+    }
+    else if(iupStrEqualNoCase(format, "NONE"))
+    {
+      use_list = false;
+    }
+    else if(iupStrEqualNoCase(format, "BOX"))
+    {
+      which_list_marker = IupNSTextListMarkerBox;
+    }
+    else if(iupStrEqualNoCase(format, "CHECK"))
+    {
+      which_list_marker = IupNSTextListMarkerCheck;
+    }
+    else if(iupStrEqualNoCase(format, "CIRCLE"))
+    {
+      which_list_marker = IupNSTextListMarkerCircle;
+    }
+    else if(iupStrEqualNoCase(format, "DIAMOND"))
+    {
+      which_list_marker = IupNSTextListMarkerDiamond;
+    }
+    else if(iupStrEqualNoCase(format, "HYPHEN"))
+    {
+      which_list_marker = IupNSTextListMarkerHyphen;
+    }
+    else if(iupStrEqualNoCase(format, "SQUARE"))
+    {
+      which_list_marker = IupNSTextListMarkerSquare;
+    }
+    else if(iupStrEqualNoCase(format, "LCHEX"))
+    {
+      which_list_marker = IupNSTextListMarkerLowercaseHexadecimal;
+    }
+    else if(iupStrEqualNoCase(format, "UCHEX"))
+    {
+      which_list_marker = IupNSTextListMarkerUppercaseHexadecimal;
+    }
+    else if(iupStrEqualNoCase(format, "OCTAL"))
+    {
+      which_list_marker = IupNSTextListMarkerOctal;
+    }
+    else if(iupStrEqualNoCase(format, "LCLATIN"))
+    {
+      which_list_marker = IupNSTextListMarkerLowercaseLatin;
+    }
+    else if(iupStrEqualNoCase(format, "UCLATIN"))
+    {
+      which_list_marker = IupNSTextListMarkerUppercaseLatin;
+    }
+    else
+    {
+      use_list = false;
+    }
 
-			NSUInteger which_number_style = kIupNumberingStyleNone;
-			
-			format = iupAttribGet(formattag, "NUMBERINGSTYLE");
-			if(format)
-			{
-				if(iupStrEqualNoCase(format, "RIGHTPARENTHESIS"))
-				{
-					which_number_style = kIupNumberingStyleRightParenthesis;
-				}
-				else if(iupStrEqualNoCase(format, "PARENTHESES"))
-				{
-					which_number_style = kIupNumberingStyleParenthesis;
-				}
-				else if(iupStrEqualNoCase(format, "PERIOD"))
-				{
-					which_number_style = kIupNumberingStylePeriod;
-				}
-				else if(iupStrEqualNoCase(format, "NONUMBER"))
-				{
-					which_number_style = kIupNumberingStyleNonNumber;
-				}
-				else if(iupStrEqualNoCase(format, "NONE"))
-				{
-					which_number_style = kIupNumberingStyleNone;
-				}
-				else
-				{
-					which_number_style = kIupNumberingStyleNone;
-				}
-			}
+    if(use_list)
+    {
+      NSUInteger which_number_style = kIupNumberingStyleNone;
 
+      format = iupAttribGet(formattag, "NUMBERINGSTYLE");
+      if(format)
+      {
+        if(iupStrEqualNoCase(format, "RIGHTPARENTHESIS"))
+        {
+          which_number_style = kIupNumberingStyleRightParenthesis;
+        }
+        else if(iupStrEqualNoCase(format, "PARENTHESES"))
+        {
+          which_number_style = kIupNumberingStyleParenthesis;
+        }
+        else if(iupStrEqualNoCase(format, "PERIOD"))
+        {
+          which_number_style = kIupNumberingStylePeriod;
+        }
+        else if(iupStrEqualNoCase(format, "NONUMBER"))
+        {
+          which_number_style = kIupNumberingStyleNonNumber;
+        }
+        else if(iupStrEqualNoCase(format, "NONE"))
+        {
+          which_number_style = kIupNumberingStyleNone;
+        }
+        else
+        {
+          which_number_style = kIupNumberingStyleNone;
+        }
+      }
 
+      NSTextStorage* text_storage = [text_view textStorage];
+      NSString* all_string = [text_storage string];
 
-			NSTextStorage* text_storage = [text_view textStorage];
-			NSString* all_string = [text_storage string];
+      [text_storage beginEditing];
 
-			// The problem seems to be that in order to change the TextLines attribute for the entire block, I need to re-set the attribute.
-			// So I have to be very careful about applying attributes and not clobbering them.
-			
-			[text_storage beginEditing];
+      __block NSUInteger applied_paragraph_start = NSUIntegerMax;
+      __block NSUInteger applied_paragraph_end = 0;
+      __block NSMutableArray<NSTextList*>* array_of_text_lists = [NSMutableArray array];
+      __block NSUInteger item_count = 1;
+      [all_string enumerateSubstringsInRange:selection_range options:NSStringEnumerationByParagraphs usingBlock:
+        ^(NSString * _Nullable substring, NSRange substring_range, NSRange enclosing_range, BOOL * _Nonnull stop)
+        {
+          *stop = NO;
 
-			
-			__block NSUInteger applied_paragraph_start = NSUIntegerMax;
-			__block NSUInteger applied_paragraph_end = 0;
-			__block NSMutableArray<NSTextList*>* array_of_text_lists = [NSMutableArray array];
-			__block NSUInteger item_count = 1;
-			[all_string enumerateSubstringsInRange:selection_range options:NSStringEnumerationByParagraphs usingBlock:
-				^(NSString * _Nullable substring, NSRange substring_range, NSRange enclosing_range, BOOL * _Nonnull stop)
-				{
-					*stop = NO;
-	//				NSLog(@"substring:%@", substring);
-	//				NSLog(@"substringRange:%@", NSStringFromRange(substring_range));
-	//				NSLog(@"enclosingRange:%@", NSStringFromRange(enclosing_range));
+          NSUInteger start_paragraph_index;
+          NSUInteger end_paragraph_index;
+          NSUInteger contents_end_paragraph_index;
+          [all_string getParagraphStart:&start_paragraph_index end:&end_paragraph_index contentsEnd:&contents_end_paragraph_index forRange:enclosing_range];
 
-					// If the selection block starts in the middle of the paragraph instead of the beginning,
-					// we have to decide whether we should start as-is,
-					// or back-up to the beginning.
-					// TextEdit.app backs up to the beginning, so we will use getParagraphStart to back up to the beginning.
-					NSUInteger start_paragraph_index;
-					NSUInteger end_paragraph_index;
-					NSUInteger contents_end_paragraph_index;
-					[all_string getParagraphStart:&start_paragraph_index end:&end_paragraph_index contentsEnd:&contents_end_paragraph_index forRange:enclosing_range];
+          if(applied_paragraph_start > start_paragraph_index)
+          {
+            applied_paragraph_start = start_paragraph_index;
+          }
+          if(applied_paragraph_end < end_paragraph_index)
+          {
+            applied_paragraph_end = end_paragraph_index;
+          }
 
-	//				NSLog(@"start_paragraph_index:%lu", start_paragraph_index);
-	//				NSLog(@"end_paragraph_index:%lu", end_paragraph_index);
-	//				NSLog(@"contents_end_paragraph_index:%lu", contents_end_paragraph_index);
+          NSRange paragraph_range = NSMakeRange(start_paragraph_index, end_paragraph_index-start_paragraph_index);
 
-					if(applied_paragraph_start > start_paragraph_index)
-					{
-						applied_paragraph_start = start_paragraph_index;
-					}
-					if(applied_paragraph_end < end_paragraph_index)
-					{
-						applied_paragraph_end = end_paragraph_index;
-					}
+          IupNumberingTextList* text_list = [[IupNumberingTextList alloc] initWithMarkerFormat:which_list_marker options:0];
+          [text_list autorelease];
+          [text_list setNumberingStyle:which_number_style];
+          [array_of_text_lists addObject:text_list];
 
-					// end_paragraph_index seems to include the newline, which we want
-					NSRange paragraph_range = NSMakeRange(start_paragraph_index, end_paragraph_index-start_paragraph_index);
-//					NSLog(@"paragraph_range:%@", NSStringFromRange(paragraph_range));
+          NSMutableAttributedString* current_line = [[text_storage attributedSubstringFromRange:paragraph_range] mutableCopy];
+          [current_line autorelease];
+          NSDictionary<NSAttributedStringKey, id>* current_line_attributes = [current_line attributesAtIndex:0 effectiveRange:NULL];
 
+          NSString* marker_with_style_prefix = nil;
+          marker_with_style_prefix = [text_list markerWithTabsForItemNumber:item_count];
 
-					IupNumberingTextList* text_list = [[IupNumberingTextList alloc] initWithMarkerFormat:which_list_marker options:0];
-					[text_list autorelease];
-					[text_list setNumberingStyle:which_number_style];
-					[array_of_text_lists addObject:text_list];
-					
-					NSMutableAttributedString* current_line = [[text_storage attributedSubstringFromRange:paragraph_range] mutableCopy];
-					[current_line autorelease];
-//					NSLog(@"current_line: %@", current_line);
-					NSDictionary<NSAttributedStringKey, id>* current_line_attributes = [current_line attributesAtIndex:0 effectiveRange:NULL];
+          NSAttributedString* attribued_prefix = [[NSAttributedString alloc] initWithString:marker_with_style_prefix attributes:current_line_attributes];
+          [attribued_prefix autorelease];
+          [current_line insertAttributedString:attribued_prefix atIndex:0];
 
-//					NSLog(@"current_line_attributes: %@", current_line_attributes);
+          ih->data->disable_callbacks = 1;
+          [text_view shouldChangeTextInRange:paragraph_range replacementString:[current_line string]];
+          ih->data->disable_callbacks = 0;
+          [text_storage replaceCharactersInRange:paragraph_range withAttributedString:current_line];
 
-					NSString* marker_with_style_prefix = nil;
-					marker_with_style_prefix = [text_list markerWithTabsForItemNumber:item_count];
-					
-					NSAttributedString* attribued_prefix = [[NSAttributedString alloc] initWithString:marker_with_style_prefix attributes:current_line_attributes];
-					[attribued_prefix autorelease];
-					[current_line insertAttributedString:attribued_prefix atIndex:0];
-//					[current_line fixAttributesInRange:NSMakeRange(0, [current_line length])];
+          item_count++;
+        }
+      ];
 
-					ih->data->disable_callbacks = 1;
-					// For undo manager
-					[text_view shouldChangeTextInRange:paragraph_range replacementString:[current_line string]];
-					ih->data->disable_callbacks = 0;
-					[text_storage replaceCharactersInRange:paragraph_range withAttributedString:current_line];
+      if(applied_paragraph_start == NSUIntegerMax)
+      {
+        applied_paragraph_start = selection_range.location;
+      }
+      if(applied_paragraph_end == 0)
+      {
+        applied_paragraph_end = selection_range.location + selection_range.length;
+      }
 
+      NSRange applied_paragraph_range = NSMakeRange(applied_paragraph_start, applied_paragraph_end-applied_paragraph_start);
+      NSMutableDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[[text_storage attributedSubstringFromRange:applied_paragraph_range] attributesAtIndex:0 effectiveRange:NULL] mutableCopy];
+      [text_storage_attributes autorelease];
+      NSMutableParagraphStyle* paragraph_style = [[text_storage_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
+      [paragraph_style autorelease];
+      if(nil == paragraph_style)
+      {
+        paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
+        [paragraph_style autorelease];
+      }
 
+      [paragraph_style setTextLists:array_of_text_lists];
+      [text_storage addAttribute:NSParagraphStyleAttributeName value:paragraph_style range:applied_paragraph_range];
 
-					item_count++;
-				
-				}
-			];
+      [text_storage endEditing];
+      [text_view didChangeText];
 
+    }
+    else /* We attempt to remove list formatting */
+    {
+      NSTextStorage* text_storage = [text_view textStorage];
+      NSString* all_string = [text_storage string];
 
-			if(applied_paragraph_start == NSUIntegerMax)
-			{
-				applied_paragraph_start = selection_range.location;
-			}
-			if(applied_paragraph_end == 0)
-			{
-				applied_paragraph_end = selection_range.location + selection_range.length;
-			}
+      [text_storage beginEditing];
 
-			
-			NSRange applied_paragraph_range = NSMakeRange(applied_paragraph_start, applied_paragraph_end-applied_paragraph_start);
-			NSMutableDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[[text_storage attributedSubstringFromRange:applied_paragraph_range] attributesAtIndex:0 effectiveRange:NULL] mutableCopy];
-			[text_storage_attributes autorelease];
-			NSMutableParagraphStyle* paragraph_style = [[text_storage_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
-			[paragraph_style autorelease];
-			if(nil == paragraph_style)
-			{
-//				NSLog(@"nil == paragraph_style");
-				paragraph_style = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];
-				[paragraph_style autorelease];
-			}
-			
-			// Be careful here:
-			// It seems I must do this last, otherwise the list doesn't take effect.
-			// (You should be able to add a new line in-between the lines, and it should automatically
-			// insert a new bullet and renumber all the lines accordingly.)
-			// But applying this last seems to blow away some attributes.
-			// Use addAttribute and avoid setAttributes
-			// In the text.c test,
-			// I lose the strike-through and italics on "Second Line"
-			// I lose the alignment on "Third Line" (this is not completely unreasonable)
-			[paragraph_style setTextLists:array_of_text_lists];
-			[text_storage addAttribute:NSParagraphStyleAttributeName value:paragraph_style range:applied_paragraph_range];
+      __block NSUInteger applied_paragraph_start = NSUIntegerMax;
+      __block NSUInteger applied_paragraph_end = 0;
+      [all_string enumerateSubstringsInRange:selection_range options:NSStringEnumerationByParagraphs usingBlock:
+        ^(NSString * _Nullable substring, NSRange substring_range, NSRange enclosing_range, BOOL * _Nonnull stop)
+        {
+          *stop = NO;
 
+          NSUInteger start_paragraph_index;
+          NSUInteger end_paragraph_index;
+          NSUInteger contents_end_paragraph_index;
+          [all_string getParagraphStart:&start_paragraph_index end:&end_paragraph_index contentsEnd:&contents_end_paragraph_index forRange:enclosing_range];
+          if(applied_paragraph_start > start_paragraph_index)
+          {
+            applied_paragraph_start = start_paragraph_index;
+          }
+          if(applied_paragraph_end < end_paragraph_index)
+          {
+            applied_paragraph_end = end_paragraph_index;
+          }
 
-			[text_storage endEditing];
-			[text_view didChangeText];
+          NSRange paragraph_range = NSMakeRange(start_paragraph_index, end_paragraph_index-start_paragraph_index);
 
-			
-		}
-		else // we attempt to remove list formatting
-		{
-			NSTextStorage* text_storage = [text_view textStorage];
-			NSString* all_string = [text_storage string];
+          NSMutableAttributedString* current_line = [[text_storage attributedSubstringFromRange:paragraph_range] mutableCopy];
+          [current_line autorelease];
+          NSString* current_line_nsstr = [current_line string];
 
-			// The problem seems to be that in order to remove the TextLines attribute for the entire block, I need to re-set the attribute.
-			// So I have to be very careful about applying attributes and not clobbering them.
+          NSString* marker_prefix_pattern = @"^\t.*?\t";
+          NSError* ns_error = nil;
+          NSRegularExpression* reg_ex = [NSRegularExpression
+            regularExpressionWithPattern:marker_prefix_pattern
+                                 options:NSRegularExpressionAnchorsMatchLines
+                                   error:&ns_error
+          ];
 
-			
-			[text_storage beginEditing];
+          NSArray<NSTextCheckingResult*>* regex_matches = [reg_ex matchesInString:current_line_nsstr
+                                                                          options:kNilOptions
+                                                                            range:NSMakeRange(0, [current_line_nsstr length])
+          ];
 
-			__block NSUInteger applied_paragraph_start = NSUIntegerMax;
-			__block NSUInteger applied_paragraph_end = 0;
-			[all_string enumerateSubstringsInRange:selection_range options:NSStringEnumerationByParagraphs usingBlock:
-				^(NSString * _Nullable substring, NSRange substring_range, NSRange enclosing_range, BOOL * _Nonnull stop)
-				{
-					*stop = NO;
-	//				NSLog(@"substring:%@", substring);
-	//				NSLog(@"substringRange:%@", NSStringFromRange(substring_range));
-	//				NSLog(@"enclosingRange:%@", NSStringFromRange(enclosing_range));
+          for(NSTextCheckingResult* match in regex_matches)
+          {
+            [current_line deleteCharactersInRange:[match range]];
+          }
 
-					// If the selection block starts in the middle of the paragraph instead of the beginning,
-					// we have to decide whether we should start as-is,
-					// or back-up to the beginning.
-					// TextEdit.app backs up to the beginning, so we will use getParagraphStart to back up to the beginning.
-					NSUInteger start_paragraph_index;
-					NSUInteger end_paragraph_index;
-					NSUInteger contents_end_paragraph_index;
-					[all_string getParagraphStart:&start_paragraph_index end:&end_paragraph_index contentsEnd:&contents_end_paragraph_index forRange:enclosing_range];
-					if(applied_paragraph_start > start_paragraph_index)
-					{
-						applied_paragraph_start = start_paragraph_index;
-					}
-					if(applied_paragraph_end < end_paragraph_index)
-					{
-						applied_paragraph_end = end_paragraph_index;
-					}
-	//				NSLog(@"start_paragraph_index:%lu", start_paragraph_index);
-	//				NSLog(@"end_paragraph_index:%lu", end_paragraph_index);
-	//				NSLog(@"contents_end_paragraph_index:%lu", contents_end_paragraph_index);
+          ih->data->disable_callbacks = 1;
+          [text_view shouldChangeTextInRange:paragraph_range replacementString:[current_line string]];
+          ih->data->disable_callbacks = 0;
+          [text_storage replaceCharactersInRange:paragraph_range withAttributedString:current_line];
+        }
+      ];
+      NSRange applied_paragraph_range = NSMakeRange(applied_paragraph_start, applied_paragraph_end-applied_paragraph_start);
+      NSMutableDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[[text_storage attributedSubstringFromRange:applied_paragraph_range] attributesAtIndex:0 effectiveRange:NULL] mutableCopy];
+      [text_storage_attributes autorelease];
+      NSMutableParagraphStyle* paragraph_style = [[text_storage_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
+      [paragraph_style autorelease];
+      if(nil == paragraph_style)
+      {
+      }
+      else
+      {
+        [paragraph_style setTextLists:[NSArray array]];
+        [text_storage removeAttribute:NSParagraphStyleAttributeName range:applied_paragraph_range];
+      }
 
-					// end_paragraph_index seems to include the newline, which we want
-					NSRange paragraph_range = NSMakeRange(start_paragraph_index, end_paragraph_index-start_paragraph_index);
-				//	NSRange paragraph_range = NSMakeRange(start_paragraph_index, contents_end_paragraph_index-start_paragraph_index);
-	//				NSLog(@"paragraph_range:%@", NSStringFromRange(paragraph_range));
+      [text_storage endEditing];
+      [text_view didChangeText];
+    }
+    return true;
+  }
+  return false;
+}
 
+static NSFont* cocoaTextChangeFontWeight(NSFont* start_font, int font_target_weight)
+{
+  NSFontManager* font_manager = [NSFontManager sharedFontManager];
+  NSFont* target_font = start_font;
 
-					NSMutableAttributedString* current_line = [[text_storage attributedSubstringFromRange:paragraph_range] mutableCopy];
-					[current_line autorelease];
-					NSString* current_line_nsstr = [current_line string];
-	//				NSLog(@"current_line bef:%@", current_line);
+  NSInteger current_weight = [font_manager weightOfFont:target_font];
+  if(current_weight < font_target_weight)
+  {
+    while(current_weight < font_target_weight)
+    {
+      NSFont* result_font;
+      result_font = [font_manager convertWeight:YES ofFont:target_font];
+      current_weight = [font_manager weightOfFont:target_font];
 
-					NSString* marker_prefix_pattern = @"^\t.*?\t";
-					NSError* ns_error = nil;
-					NSRegularExpression* reg_ex = [NSRegularExpression
-						regularExpressionWithPattern:marker_prefix_pattern
-						options:NSRegularExpressionAnchorsMatchLines
-						error:&ns_error
-					];
-					
-					NSArray<NSTextCheckingResult*>* regex_matches = [reg_ex matchesInString:current_line_nsstr
-						options:kNilOptions
-						range:NSMakeRange(0, [current_line_nsstr length])
-					];
-					
-					// There should only be 1 match right now since we anchor with ^
-					// But maybe in the future we can leverage the loop to look at nested lists
-					for(NSTextCheckingResult* match in regex_matches)
-					{
-	//					NSLog(@"match:%@", match);
-	//					NSLog(@"match range:%@", NSStringFromRange([match range]));
-						[current_line deleteCharactersInRange:[match range]];
-	//					NSLog(@"current_line aft:%@", current_line);
-					}
+      if(result_font == target_font)
+      {
+        break;
+      }
+      else
+      {
+        target_font = result_font;
+      }
+    }
+  }
+  else if(current_weight > font_target_weight)
+  {
+    while(current_weight > font_target_weight)
+    {
+      NSFont* result_font;
+      result_font = [font_manager convertWeight:NO ofFont:target_font];
+      current_weight = [font_manager weightOfFont:target_font];
 
-					// Must be [current_line string] and not current_line_nsstr because we mutated current_line and current_line_nsstr may be out of date
-					ih->data->disable_callbacks = 1;
-					[text_view shouldChangeTextInRange:paragraph_range replacementString:[current_line string]];
-					ih->data->disable_callbacks = 0;
-					[text_storage replaceCharactersInRange:paragraph_range withAttributedString:current_line];
+      if(result_font == target_font)
+      {
+        break;
+      }
+      else
+      {
+        target_font = result_font;
+      }
+    }
+  }
+  return target_font;
+}
 
+static NSMutableDictionary* cocoaTextParseCharacterFormat(Ihandle* ih, Ihandle* formattag, NSTextView* text_view, NSRange selection_range)
+{
+  char* format;
+  bool did_change_attribute = false;
+  bool did_change_font_size = false;
+  bool did_change_font_family = false;
+  bool did_change_font_traits = false;
+  bool did_change_font_weight = false;
 
-				}
-			];
-			NSRange applied_paragraph_range = NSMakeRange(applied_paragraph_start, applied_paragraph_end-applied_paragraph_start);
-			NSMutableDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[[text_storage attributedSubstringFromRange:applied_paragraph_range] attributesAtIndex:0 effectiveRange:NULL] mutableCopy];
-			[text_storage_attributes autorelease];
-			NSMutableParagraphStyle* paragraph_style = [[text_storage_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
-			[paragraph_style autorelease];
-			if(nil == paragraph_style)
-			{
-				// There was no TextList, so there is nothing to remove.
-//				NSLog(@"Nothing to remove");
-			}
-			else
-			{
-				// Can't set nil, so set empty array
-				[paragraph_style setTextLists:[NSArray array]];
-				/*
-				// Be careful here:
-				// Use removeAttribute and not setAttributes
-				*/
-//				NSLog(@"removed textlist");
+  bool did_change_font_fgcolor = false;
+  bool did_change_font_bgcolor = false;
 
-				[text_storage removeAttribute:NSParagraphStyleAttributeName range:applied_paragraph_range];
+  bool needs_add_font_fgcolor = false;
+  bool needs_add_font_bgcolor = false;
 
-			}
+  NSString* font_family_name = nil;
+  CGFloat font_size = 0.0;
+  NSFontTraitMask trait_mask = 0;
+  int font_target_weight = 5;
+  NSMutableDictionary* attribute_dict = [NSMutableDictionary dictionary];
 
-			[text_storage endEditing];
-			[text_view didChangeText];
-		}
-		return true;
-	} // end if NUMBERING
-	return false;
-}
+  format = iupAttribGet(formattag, "FONTSIZE");
+  if(format)
+  {
+    int font_size_int = 0;
+    iupStrToInt(format, &font_size_int);
+    if(font_size_int < 0)
+    {
+    }
+    else
+    {
+      font_size = (CGFloat)font_size_int;
+      did_change_font_size = true;
+      did_change_attribute = true;
+    }
+  }
 
+  format = iupAttribGet(formattag, "FONTFACE");
+  if(format)
+  {
+    const char* mapped_name = iupFontGetMacName(format);
+    if(mapped_name)
+    {
+      font_family_name = [NSString stringWithUTF8String:mapped_name];
+    }
+    else
+    {
+      font_family_name = [NSString stringWithUTF8String:format];
+    }
 
+    did_change_attribute = true;
+    did_change_font_family = true;
+  }
 
-static NSFont* cocoaTextChangeFontWeight(NSFont* start_font, int font_target_weight)
-{
-	// Ugh: This has no effect.
-	// [attribute_dict setValue:[NSNumber numberWithFloat:weight_scale] forKey:NSFontWeightTrait];
-	
-	// I don't want to create a font from scratch because there are warnings about using FamilyName for the default/system font.
-	// And I just don't want to accidentally miss any properties.
-	// But this leaves us only with this curious API which will attempt to bump up/down the weight by 1 level at a time.
-	// If it can't go any higher/lower, it returns back the original font.
-	// The levels are not well defined, so this is very imprecise.
-	
-	NSFontManager* font_manager = [NSFontManager sharedFontManager];
-	NSFont* target_font = start_font;
+  format = iupAttribGet(formattag, "RISE");
+  if(format)
+  {
+    if(iupStrEqualNoCase(format, "SUPERSCRIPT"))
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:1]
+                        forKey:NSSuperscriptAttributeName];
+      font_size = font_size * 0.6444444444444;
+      did_change_font_size = true;
+    }
+    else if(iupStrEqualNoCase(format, "SUBSCRIPT"))
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:-1]
+                        forKey:NSSuperscriptAttributeName];
+      font_size = font_size * 0.6444444444444;
+      did_change_font_size = true;
+    }
+    else
+    {
+      int offset_val = 0;
+      iupStrToInt(format, &offset_val);
+      [attribute_dict setValue:[NSNumber numberWithDouble:(double)offset_val]
+                        forKey:NSBaselineOffsetAttributeName];
+    }
+    did_change_attribute = true;
+  }
 
-	NSInteger current_weight = [font_manager weightOfFont:target_font];
-	if(current_weight < font_target_weight)
-	{
-		// need to go up
-		while(current_weight < font_target_weight)
-		{
-			NSFont* result_font;
-			result_font = [font_manager convertWeight:YES ofFont:target_font];
-			current_weight = [font_manager weightOfFont:target_font];
-			
-			if(result_font == target_font)
-			{
-				// unable to convert more
-				break;
-			}
-			else
-			{
-				target_font = result_font;
-			}
-		}
-	}
-	else if(current_weight > font_target_weight)
-	{
-		// need to go down
-		while(current_weight > font_target_weight)
-		{
-			NSFont* result_font;
-			result_font = [font_manager convertWeight:NO ofFont:target_font];
-			current_weight = [font_manager weightOfFont:target_font];
-			
-			if(result_font == target_font)
-			{
-				// unable to convert more
-				break;
-			}
-			else
-			{
-				target_font = result_font;
-			}
-		}
-	}
-	else
-	{
-		// already at target weight
-	}
-	return target_font;
-}
+  format = iupAttribGet(formattag, "FONTSCALE");
+  if(format)
+  {
+    double fval = 0;
+    if (iupStrEqualNoCase(format, "XX-SMALL"))
+      fval = 0.5787037037037;
+    else if (iupStrEqualNoCase(format, "X-SMALL"))
+      fval = 0.6444444444444;
+    else if (iupStrEqualNoCase(format, "SMALL"))
+      fval = 0.8333333333333;
+    else if (iupStrEqualNoCase(format, "MEDIUM"))
+      fval = 1.0;
+    else if (iupStrEqualNoCase(format, "LARGE"))
+      fval = 1.2;
+    else if (iupStrEqualNoCase(format, "X-LARGE"))
+      fval = 1.4399999999999;
+    else if (iupStrEqualNoCase(format, "XX-LARGE"))
+      fval = 1.728;
+    else
+      iupStrToDouble(format, &fval);
 
+    if(fval > 0)
+    {
+      font_size = font_size * fval;
+      did_change_font_size = true;
+      did_change_attribute = true;
+    }
+  }
 
-// This returns a non-nil dictionary only for the setTypingAttributes: case (change formatting at the end of the document).
-// Calls may merge that dictionary with whatever to call setTypingAttributes:
-// Otherwise it changes the formatting at the selected range and returns nil.
-//
-// Be careful about clobbering:
-// Example: The text case with 3 lines of containing "First Line" "Second Line Big Big Big" "Third Line" with different sizes, strike through, underline, colors, alignments in different sections.
-// If you then set a color format for the selection of the 3 lines,
-// you don't want to lose italics, underline, strikethrough, font size, alignment (paragraph attribute)
-//
-// This is like the 3rd time I've re-written this.
-// The problem has been clobbering previous properties that have been set earlier.
-// I generally don't want to lose the old properties if they are orthogonal to the ones being set.
-// This is compounded when the user selects a range that spans characters that have applied different attributes.
-// So this algorithm now attempts to traverse the substrings broken up by different attribute types,
-// and uses addAttributes to only add/overwrite changes to the substring to try to avoid clobbering.
-static NSMutableDictionary* cocoaTextParseCharacterFormat(Ihandle* ih, Ihandle* formattag, NSTextView* text_view, NSRange selection_range)
-{
-	char* format;
-	bool did_change_attribute = false;
-	bool did_change_font_size = false;
-	bool did_change_font_family = false;
-	bool did_change_font_traits = false;
-	bool did_change_font_weight = false;
+  format = iupAttribGet(formattag, "ITALIC");
+  if(format)
+  {
+    if(iupStrBoolean(format))
+    {
+      trait_mask |= NSItalicFontMask;
+      did_change_attribute = true;
+      did_change_font_traits = true;
+    }
+  }
 
-	bool did_change_font_fgcolor = false;
-	bool did_change_font_bgcolor = false;
+  format = iupAttribGet(formattag, "UNDERLINE");
+  if(format)
+  {
+    if(iupStrEqualNoCase(format, "SINGLE"))
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid|NSUnderlineStyleSingle]
+                        forKey:NSUnderlineStyleAttributeName];
+    }
+    else if(iupStrEqualNoCase(format, "DOUBLE"))
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid|NSUnderlineStyleDouble]
+                        forKey:NSUnderlineStyleAttributeName];
+    }
+    else if(iupStrEqualNoCase(format, "DOTTED"))
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:NSUnderlineStylePatternDot|NSUnderlineStyleSingle]
+                        forKey:NSUnderlineStyleAttributeName];
+    }
+    else /* "NONE" */
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:NSUnderlineStyleNone]
+                        forKey:NSUnderlineStyleAttributeName];
+    }
+    did_change_attribute = true;
+  }
 
-	// This is a bonus for calling removeObject:forKey: if the user provided NULL for a color and there was a color already set.
-	bool needs_add_font_fgcolor = false;
-	bool needs_add_font_bgcolor = false;
+  format = iupAttribGet(formattag, "STRIKEOUT");
+  if(format)
+  {
+    if(iupStrBoolean(format))
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:YES]
+                        forKey:NSStrikethroughStyleAttributeName];
+    }
+    else
+    {
+      [attribute_dict setValue:[NSNumber numberWithInt:NO]
+                        forKey:NSStrikethroughStyleAttributeName];
+    }
+    did_change_attribute = true;
+  }
 
+  format = iupAttribGet(formattag, "WEIGHT");
+  if(format)
+  {
+    int target_weight = 5;
 
-	NSString* font_family_name = nil;
-	CGFloat font_size = 0.0;
-	NSFontTraitMask trait_mask = 0;
-	int font_target_weight = 5;
-	NSMutableDictionary* attribute_dict = [NSMutableDictionary dictionary];
-	
+    if(iupStrEqualNoCase(format, "EXTRALIGHT"))
+    {
+      target_weight = 0;
+    }
+    else if(iupStrEqualNoCase(format, "LIGHT"))
+    {
+      target_weight = 3;
+    }
+    else if(iupStrEqualNoCase(format, "SEMIBOLD"))
+    {
+      target_weight = 6;
+    }
+    else if(iupStrEqualNoCase(format, "BOLD"))
+    {
+      target_weight = 8;
+    }
+    else if (iupStrEqualNoCase(format, "EXTRABOLD"))
+    {
+      target_weight = 10;
+    }
+    else if(iupStrEqualNoCase(format, "HEAVY"))
+    {
+      target_weight = 11;
+    }
+    else /* "NORMAL" */
+    {
+      target_weight = 5;
+    }
+    font_target_weight = target_weight;
 
-	format = iupAttribGet(formattag, "FONTSIZE");
-	if(format)
-	{
-		int font_size_int = 0;
-		iupStrToInt(format, &font_size_int);
-		// less than 0 is in "pixels",
-		// but Apple platforms don't really support this because of all the things they do for resolution independent scaling (e.g. retina)
-		// All things must be in points.
-		if(font_size_int < 0)
-		{
-		
-		}
-		else
-		{
-			font_size = (CGFloat)font_size_int;
-			did_change_font_size = true;
-			did_change_attribute = true;
-		}
-	}
-	
-	format = iupAttribGet(formattag, "FONTFACE");
-	if(format)
-	{
-		/* Map standard names to native names */
-		const char* mapped_name = iupFontGetMacName(format);
-		if(mapped_name)
-		{
-			font_family_name = [NSString stringWithUTF8String:mapped_name];
-		}
-		else
-		{
-			font_family_name = [NSString stringWithUTF8String:format];
-		}
-		
-//		target_font = [font_manager convertFont:target_font toFamily:font_family_name];
-		did_change_attribute = true;
-		did_change_font_family = true;
-	}
+    did_change_attribute = true;
+    did_change_font_weight = true;
+  }
 
-	format = iupAttribGet(formattag, "RISE");
-	if(format)
-	{
-		// For Mac, NSSuperscriptAttributeName
-		// iOS kCTSuperscriptAttributeName
-		// Pass in a negative value for subscript.
-    	if(iupStrEqualNoCase(format, "SUPERSCRIPT"))
-		{
-	  		[attribute_dict setValue:[NSNumber numberWithInt:1]
-				forKey:NSSuperscriptAttributeName];
-			// I don't know how small to make the font. IUP uses X-SMALL on GTK.
-			font_size = font_size * 0.6444444444444;
-			did_change_font_size = true;
-		}
-		else if(iupStrEqualNoCase(format, "SUBSCRIPT"))
-		{
-	  		[attribute_dict setValue:[NSNumber numberWithInt:-1]
-				forKey:NSSuperscriptAttributeName];
-			// I don't know how small to make the font. IUP uses X-SMALL on GTK.
-			font_size = font_size * 0.6444444444444;
-			did_change_font_size = true;
-		}
-		else
-		{
-			int offset_val = 0;
-			iupStrToInt(format, &offset_val);
-			[attribute_dict setValue:[NSNumber numberWithDouble:(double)offset_val]
-				forKey:NSBaselineOffsetAttributeName];
-			// user is expected to set the font size for this case
-		}
-		did_change_attribute = true;
-	}
+  format = iupAttribGet(formattag, "FGCOLOR");
+  if(format)
+  {
+    unsigned char r, g, b;
+    if(iupStrToRGB(format, &r, &g, &b))
+    {
+      CGFloat red = r/255.0;
+      CGFloat green = g/255.0;
+      CGFloat blue = b/255.0;
 
+      NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+      [attribute_dict setValue:the_color
+                        forKey:NSForegroundColorAttributeName];
 
-	format = iupAttribGet(formattag, "FONTSCALE");
-	if(format)
-	{
-		double fval = 0;
-		if (iupStrEqualNoCase(format, "XX-SMALL"))
-			fval = 0.5787037037037;
-		else if (iupStrEqualNoCase(format, "X-SMALL"))
-			fval = 0.6444444444444;
-		else if (iupStrEqualNoCase(format, "SMALL"))
-			fval = 0.8333333333333;
-		else if (iupStrEqualNoCase(format, "MEDIUM"))
-			fval = 1.0;
-		else if (iupStrEqualNoCase(format, "LARGE"))
-			fval = 1.2;
-		else if (iupStrEqualNoCase(format, "X-LARGE"))
-			fval = 1.4399999999999;
-		else if (iupStrEqualNoCase(format, "XX-LARGE"))
-			fval = 1.728;
-		else
-			iupStrToDouble(format, &fval);
-		
-		if(fval > 0)
-		{
-			font_size = font_size * fval;
-			did_change_font_size = true;
-			did_change_attribute = true;
-		}
-	}
+      needs_add_font_fgcolor = true;
+    }
+    else
+    {
+      needs_add_font_fgcolor = false;
+    }
+    did_change_attribute = true;
+    did_change_font_fgcolor = true;
+  }
 
+  format = iupAttribGet(formattag, "BGCOLOR");
+  if(format)
+  {
+    unsigned char r, g, b;
+    if(iupStrToRGB(format, &r, &g, &b))
+    {
+      CGFloat red = r/255.0;
+      CGFloat green = g/255.0;
+      CGFloat blue = b/255.0;
 
-	
+      NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
+      [attribute_dict setObject:the_color
+                         forKey:NSBackgroundColorAttributeName];
+      needs_add_font_bgcolor = true;
+    }
+    else
+    {
+      needs_add_font_bgcolor = false;
+    }
+    did_change_attribute = true;
+    did_change_font_bgcolor = true;
+  }
 
-	format = iupAttribGet(formattag, "ITALIC");
-	if(format)
-	{
-		if(iupStrBoolean(format))
-		{
-			trait_mask |= NSItalicFontMask;
-			did_change_attribute = true;
-			did_change_font_traits = true;
-		}
-	}
+  format = iupAttribGet(formattag, "DISABLED");
+  if(format)
+  {
+    if(iupStrBoolean(format))
+    {
+      NSColor* the_color = [NSColor disabledControlTextColor];
+      [attribute_dict setValue:the_color
+                        forKey:NSForegroundColorAttributeName];
+      did_change_font_fgcolor = true;
+      needs_add_font_fgcolor = true;
+    }
+    else
+    {
+      if(iupAttribGet(formattag, "FGCOLOR"))
+      {
+      }
+      else
+      {
+        [attribute_dict removeObjectForKey:NSForegroundColorAttributeName];
+        did_change_font_fgcolor = true;
+        needs_add_font_fgcolor = false;
+      }
+    }
+    did_change_attribute = true;
+  }
 
+  if(did_change_attribute)
+  {
+    NSFontManager* font_manager = [NSFontManager sharedFontManager];
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
 
-	format = iupAttribGet(formattag, "UNDERLINE");
-	if(format)
-	{
-		// TODO: Apple supports DOTTED (and DASHED) independently of SINGLE/DOUBLE.
-		if(iupStrEqualNoCase(format, "SINGLE"))
-		{
-			[attribute_dict setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid|NSUnderlineStyleSingle]
-				forKey:NSUnderlineStyleAttributeName];
-		}
-		else if(iupStrEqualNoCase(format, "DOUBLE"))
-		{
-			[attribute_dict setValue:[NSNumber numberWithInt:NSUnderlinePatternSolid|NSUnderlineStyleDouble]
-				forKey:NSUnderlineStyleAttributeName];
-		}
-		else if(iupStrEqualNoCase(format, "DOTTED"))
-		{
-			[attribute_dict setValue:[NSNumber numberWithInt:NSUnderlineStylePatternDot|NSUnderlineStyleSingle]
-				forKey:NSUnderlineStyleAttributeName];
-		}
-		else /* "NONE" */
-		{
-			[attribute_dict setValue:[NSNumber numberWithInt:NSUnderlineStyleNone]
-				forKey:NSUnderlineStyleAttributeName];
-		}
-		did_change_attribute = true;
-	}
+    NSTextStorage* text_storage = [text_view textStorage];
 
+    if(selection_range.location < [text_storage length])
+    {
+      [text_storage beginEditing];
+      ih->data->disable_callbacks = 1;
 
-	format = iupAttribGet(formattag, "STRIKEOUT");
-	if(format)
-	{
-		if(iupStrBoolean(format))
-		{
-	  		[attribute_dict setValue:[NSNumber numberWithInt:YES]
-				forKey:NSStrikethroughStyleAttributeName];
-		}
-		else
-		{
-			[attribute_dict setValue:[NSNumber numberWithInt:NO]
-				forKey:NSStrikethroughStyleAttributeName];
-		}
-		did_change_attribute = true;
-	}
+      NSUInteger loc = selection_range.location;
+      NSUInteger end = selection_range.length + loc;
+      while(loc < end)
+      {
+        NSRange attrib_range;
 
-	format = iupAttribGet(formattag, "WEIGHT");
-	if(format)
-	{
-		/*
-		Apple Terminology						ISO Equivalent
-		1. ultralight
-		2. thin W1. ultralight
-		3. light, extralight 					W2. extralight
-		4. book									W3. light
-		5. regular, plain, display, roman		W4. semilight
-		6. medium								W5. medium
-		7. demi, demibold
-		8. semi, semibold						W6. semibold
-		9. bold									W7. bold
-		10. extra, extrabold					W8. extrabold
-		11. heavy, heavyface
-		12. black, super						W9. ultrabold
-		13. ultra, ultrablack, fat
-		14. extrablack, obese, nord
-		
-		The NSFontManager implementation of this method refuses to convert a fonts weight
-		if it cant maintain all other traits, such as italic and condensed.
-		You might wish to override this method to allow a looser interpretation of weight conversion
-		*/
-		// NSFontWeightTrait: The valid value range is from -1.0 to 1.0. The value of 0.0 corresponds to the regular or medium font weight.
-//		CGFloat weight_scale = 0;
-		// weightOfFont: An approximation of the weight of the given font, where 0 indicates the lightest possible weight, 5 indicates a normal or book weight, and 9 or more indicates a bold or heavier weight.
-		int target_weight = 5;
-		
-		if(iupStrEqualNoCase(format, "EXTRALIGHT"))
-		{
-//			weight_scale = -1.0;
-			target_weight = 0;
-		}
-		else if(iupStrEqualNoCase(format, "LIGHT"))
-		{
-//			weight_scale = -0.5;
-			target_weight = 3;
-		}
-		else if(iupStrEqualNoCase(format, "SEMIBOLD"))
-		{
-//			weight_scale = 0.25;
-			target_weight = 6;
-		}
-		else if(iupStrEqualNoCase(format, "BOLD"))
-		{
-//			weight_scale = 0.50;
-			target_weight = 8;
-		}
-		else if (iupStrEqualNoCase(format, "EXTRABOLD"))
-		{
-//			weight_scale = 0.75;
-			target_weight = 10;
-		}
-		else if(iupStrEqualNoCase(format, "HEAVY"))
-		{
-//			weight_scale = 1.0;
-			target_weight = 11;
-		}
-		else /* "NORMAL" */
-		{
-//			weight_scale = 0.0;
-			target_weight = 5;
-		}
-		font_target_weight = target_weight;
+        NSRange sub_range = {loc, end-loc};
+        NSAttributedString* current_substring = [text_storage attributedSubstringFromRange:sub_range];
+        NSDictionary<NSAttributedStringKey, id>* current_substring_attributes = [current_substring attributesAtIndex:0 effectiveRange:&attrib_range];
 
-		did_change_attribute = true;
-		did_change_font_weight = true;
+        NSFont* target_font = nil;
 
-	}
-	
-	
-	
-	format = iupAttribGet(formattag, "FGCOLOR");
-	if(format)
-	{
-		unsigned char r, g, b;
-		if(iupStrToRGB(format, &r, &g, &b))
-		{
-			CGFloat red = r/255.0;
-			CGFloat green = g/255.0;
-			CGFloat blue = b/255.0;
+        if(did_change_font_family || did_change_font_traits || did_change_font_size || did_change_font_weight)
+        {
+          NSFont* base_font = [current_substring_attributes objectForKey:NSFontAttributeName];
+          if(nil == base_font)
+          {
+            base_font = [iup_font nativeFont];
+          }
+          target_font = base_font;
 
-			NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-			[attribute_dict setValue:the_color
-				forKey:NSForegroundColorAttributeName];
+          if(did_change_font_family)
+          {
+            target_font = [font_manager convertFont:target_font toFamily:font_family_name];
+          }
+          if(did_change_font_size)
+          {
+            target_font = [font_manager convertFont:target_font toSize:font_size];
+          }
+          if(did_change_font_traits)
+          {
+            target_font = [font_manager convertFont:target_font toHaveTrait:trait_mask];
+          }
 
-			needs_add_font_fgcolor = true;
-		}
-		else
-		{
-			// removing is unnecessary with the current algorthm since it shouldn't be in there, but also won't hurt
-//			[attribute_dict removeObjectForKey:NSForegroundColorAttributeName];
-			needs_add_font_fgcolor = false;
-		}
-		did_change_attribute = true;
-		did_change_font_fgcolor = true;
-	}
-	
-	format = iupAttribGet(formattag, "BGCOLOR");
-	if(format)
-	{
-		unsigned char r, g, b;
-		if(iupStrToRGB(format, &r, &g, &b))
-		{
-			CGFloat red = r/255.0;
-			CGFloat green = g/255.0;
-			CGFloat blue = b/255.0;
+          if(did_change_font_weight)
+          {
+            target_font = cocoaTextChangeFontWeight(target_font, font_target_weight);
+          }
 
-			NSColor* the_color = [NSColor colorWithCalibratedRed:red green:green blue:blue alpha:1.0];
-			[attribute_dict setObject:the_color
-				forKey:NSBackgroundColorAttributeName];
-				needs_add_font_bgcolor = true;
-		}
-		else
-		{
-			// removing is unnecessary with the current algorthm since it shouldn't be in there, but also won't hurt
-//			[attribute_dict removeObjectForKey:NSBackgroundColorAttributeName];
-			needs_add_font_bgcolor = false;
-		}
-		did_change_attribute = true;
-		did_change_font_bgcolor = true;
-	}
-	
-	// Disabled color (not actually disabled)
-	// Watch-out, FGCOLOR can conflict with this because they both use NSForegroundColorAttributeName
-	format = iupAttribGet(formattag, "DISABLED");
-	if(format)
-	{
-		if(iupStrBoolean(format))
-		{
-			// Is it secondarySelectedControlColor or disabledControlTextColor?
-			NSColor* the_color = [NSColor disabledControlTextColor];
-//			NSColor* the_color = [NSColor secondarySelectedControlColor];
-			[attribute_dict setValue:the_color
-				forKey:NSForegroundColorAttributeName];
-			did_change_font_fgcolor = true;
-			needs_add_font_fgcolor = true;
-		}
-		else
-		{
-			// If the user specified FGCOLOR, then it was already set above.
-			if(iupAttribGet(formattag, "FGCOLOR"))
-			{
-			
-			}
-			else
-			{
-				// this removes the FGCOLOR if it was set
-				[attribute_dict removeObjectForKey:NSForegroundColorAttributeName];
-				did_change_font_fgcolor = true;
-				needs_add_font_fgcolor = false;
-			}
+          [attribute_dict setObject:target_font forKey:NSFontAttributeName];
+        }
+        NSRange adjusted_range = { loc, attrib_range.length };
+        [text_view shouldChangeTextInRange:adjusted_range replacementString:nil];
+        [text_storage addAttributes:attribute_dict range:adjusted_range];
 
-		}
-		did_change_attribute = true;
-	}
-	
-	
-	
-	
-	
+        if(did_change_font_fgcolor && !needs_add_font_fgcolor)
+        {
+          [text_storage removeAttribute:NSForegroundColorAttributeName range:adjusted_range];
+        }
+        if(did_change_font_bgcolor && !needs_add_font_bgcolor)
+        {
+          [text_storage removeAttribute:NSBackgroundColorAttributeName range:adjusted_range];
+        }
 
-	if(did_change_attribute)
-	{
-		NSFontManager* font_manager = [NSFontManager sharedFontManager];
-		IupCocoaFont* iup_font = iupCocoaGetFont(ih);
+        loc += attrib_range.length;
+      }
 
-		NSTextStorage* text_storage = [text_view textStorage];
-		
-		
-		// Ugh: I need to handle two separate cases that don't quite fit.
-		// Case 1: Apply formatting to existing strings.
-		// Case 2: Apply formatting to all new text (setTypingAttributes:)
-		// So I have a bunch of code duplication.
+      ih->data->disable_callbacks = 0;
+      [text_storage endEditing];
+      [text_view didChangeText];
 
-		
-		if(selection_range.location < [text_storage length])
-		{
-			[text_storage beginEditing];
-			ih->data->disable_callbacks = 1;
-			//		NSString* text_string = [text_storage string];
-			
-			
-			// This loop will iterate through all the sub-strings with different attributes
-			// We are using attributesAtIndex:effectiveRange:
-			// where the return value of effectiveRange: will tell us how far the current substring goes until the next attribute change.
-			// We then apply the new attributes to each piece at a time.
-			NSUInteger loc = selection_range.location;
-			NSUInteger end = selection_range.length + loc;
-			while(loc < end)
-			{	/* Run through the string in terms of attachment runs */
-				NSRange attrib_range;	/* Attachment attribute run */
-				
-				NSRange sub_range = {loc, end-loc};
-				NSAttributedString* current_substring = [text_storage attributedSubstringFromRange:sub_range];
-				NSDictionary<NSAttributedStringKey, id>* current_substring_attributes = [current_substring attributesAtIndex:0 effectiveRange:&attrib_range];
-		
-				NSFont* target_font = nil;
+      attribute_dict = nil;
+    }
+    else /* For setTypingAttributes: */
+    {
+      NSDictionary<NSAttributedStringKey, id>* current_substring_attributes = [text_view typingAttributes];
 
-				if(did_change_font_family || did_change_font_traits || did_change_font_size || did_change_font_weight)
-				{
-					NSFont* base_font = [current_substring_attributes objectForKey:NSFontAttributeName];
-					if(nil == base_font)
-					{
-						base_font = [iup_font nativeFont];
-					}
-					target_font = base_font;
-					
-					if(did_change_font_family)
-					{
-						target_font = [font_manager convertFont:target_font toFamily:font_family_name];
-					}
-					if(did_change_font_size)
-					{
-						target_font = [font_manager convertFont:target_font toSize:font_size];
-					}
-					if(did_change_font_traits)
-					{
-						target_font = [font_manager convertFont:target_font toHaveTrait:trait_mask];
-					}
-					
-					
-					
-					if(did_change_font_weight)
-					{
-						target_font = cocoaTextChangeFontWeight(target_font, font_target_weight);
-					}
-					
-					[attribute_dict setObject:target_font forKey:NSFontAttributeName];
-					
-				}
-				NSRange adjusted_range = { loc, attrib_range.length };
-				[text_view shouldChangeTextInRange:adjusted_range replacementString:nil];
-				[text_storage addAttributes:attribute_dict range:adjusted_range];
-				
-				
-				// This is going above & beyond the IUP required spec.
-				// I am removing color attributes if the user passed NULL (or illegal values)
-				if(did_change_font_fgcolor && !needs_add_font_fgcolor)
-				{
-					[text_storage removeAttribute:NSForegroundColorAttributeName range:adjusted_range];
-				}
-				if(did_change_font_bgcolor && !needs_add_font_bgcolor)
-				{
-					[text_storage removeAttribute:NSBackgroundColorAttributeName range:adjusted_range];
-				}
-				
-				
-				loc += attrib_range.length;
-				
-			}
-			
-			ih->data->disable_callbacks = 0;
-			[text_storage endEditing];
-			[text_view didChangeText];
-			
-			// We used the dictionary and no longer need it.
-			// Returning a non-nil dictionary is used by case 2:
-			attribute_dict = nil;
-			
-		}
-		else // for setTypingAttributes:
-		{
-			// Instead of setting the typingAttributes here, we are going to prepare an attribute dictionary to return.
-			// The reason is that the paragraph attribute handler passes back modifications,
-			// so returning a dictionary that can be later merged with that one makes things easier.
+      NSFont* target_font = nil;
 
+      if(did_change_font_family || did_change_font_traits || did_change_font_size || did_change_font_weight)
+      {
+        NSFont* base_font = [current_substring_attributes objectForKey:NSFontAttributeName];
+        if(nil == base_font)
+        {
+          base_font = [iup_font nativeFont];
+        }
+        target_font = base_font;
 
-			NSDictionary<NSAttributedStringKey, id>* current_substring_attributes = [text_view typingAttributes];
-		
-			NSFont* target_font = nil;
+        if(did_change_font_family)
+        {
+          target_font = [font_manager convertFont:target_font toFamily:font_family_name];
+        }
+        if(did_change_font_size)
+        {
+          target_font = [font_manager convertFont:target_font toSize:font_size];
+        }
+        if(did_change_font_traits)
+        {
+          target_font = [font_manager convertFont:target_font toHaveTrait:trait_mask];
+        }
 
-			if(did_change_font_family || did_change_font_traits || did_change_font_size || did_change_font_weight)
-			{
-				NSFont* base_font = [current_substring_attributes objectForKey:NSFontAttributeName];
-				if(nil == base_font)
-				{
-					base_font = [iup_font nativeFont];
-				}
-				target_font = base_font;
-				
-				if(did_change_font_family)
-				{
-					target_font = [font_manager convertFont:target_font toFamily:font_family_name];
-				}
-				if(did_change_font_size)
-				{
-					target_font = [font_manager convertFont:target_font toSize:font_size];
-				}
-				if(did_change_font_traits)
-				{
-					target_font = [font_manager convertFont:target_font toHaveTrait:trait_mask];
-				}
-				
-				
-				
-				if(did_change_font_weight)
-				{
-					target_font = cocoaTextChangeFontWeight(target_font, font_target_weight);
-				}
-				
-				[attribute_dict setObject:target_font forKey:NSFontAttributeName];
-			}
-	
-		}
-		
-	}
-	
-	if(did_change_attribute)
-	{
-		return attribute_dict;
-	}
-	else
-	{
-		return nil;
-	}
+        if(did_change_font_weight)
+        {
+          target_font = cocoaTextChangeFontWeight(target_font, font_target_weight);
+        }
+
+        [attribute_dict setObject:target_font forKey:NSFontAttributeName];
+      }
+    }
+  }
+
+  if(did_change_attribute)
+  {
+    return attribute_dict;
+  }
+  else
+  {
+    return nil;
+  }
 }
 
 void iupdrvTextAddFormatTag(Ihandle* ih, Ihandle* formattag, int bulk)
 {
-	if(!ih->data->is_multiline)
-	{
-		return;
-	}
-	if(!ih->data->has_formatting)
-	{
-		return;
-	}
-	NSTextView* text_view = cocoaTextGetTextView(ih);
+  if(!ih->data->is_multiline)
+  {
+    return;
+  }
+  if(!ih->data->has_formatting)
+  {
+    return;
+  }
+  NSTextView* text_view = cocoaTextGetTextView(ih);
 
+  char* iup_selection = NULL;
+  NSRange native_selection_range = {0, 0};
+  iup_selection = iupAttribGet(formattag, "SELECTION");
+  if(iup_selection)
+  {
+    int ret_val;
+    NSUInteger lin_start=1, col_start=1, lin_end=1, col_end=1;
 
-	char* iup_selection = NULL;
-	NSRange native_selection_range = {0, 0};
-	iup_selection = iupAttribGet(formattag, "SELECTION");
-	if(iup_selection)
-	{
-		int ret_val;
-		NSUInteger lin_start=1;
-		NSUInteger col_start=1;
-		NSUInteger lin_end=1;
-		NSUInteger col_end=1;
+    ret_val = sscanf(iup_selection, "%lu,%lu:%lu,%lu", &lin_start, &col_start, &lin_end, &col_end);
+    if(ret_val != 4)
+    {
+      return;
+    }
+    if(lin_start<1 || col_start<1 || lin_end<1 || col_end<1)
+    {
+      return;
+    }
 
-		ret_val = sscanf(iup_selection, "%lu,%lu:%lu,%lu", &lin_start, &col_start, &lin_end, &col_end);
-		if(ret_val != 4)
-		{
-			return;
-		}
-		if(lin_start<1 || col_start<1 || lin_end<1 || col_end<1)
-		{
-			return;
-		}
-		
-		bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
-		if(!did_find_range)
-		{
-			return;
-		}
-	}
-	else
-	{
-		char* iup_selection_pos = iupAttribGet(formattag, "SELECTIONPOS");
-		if(iup_selection_pos)
-		{
-			// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-			int start_int = 0;
-			int end_int = 0;
+    bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &native_selection_range);
+    if(!did_find_range)
+    {
+      return;
+    }
+  }
+  else
+  {
+    char* iup_selection_pos = iupAttribGet(formattag, "SELECTIONPOS");
+    if(iup_selection_pos)
+    {
+      int start_int = 0;
+      int end_int = 0;
 
-			if(iupStrToIntInt(iup_selection_pos, &start_int, &end_int, ':')!=2)
-			{
-				return;
-			}
-      		if(start_int<0 || end_int<0)
-      		{
-		        return;
-			}
-			NSUInteger start = (NSUInteger)start_int;
-			NSUInteger end = (NSUInteger)end_int;
-			native_selection_range = NSMakeRange(start, end-start);
-		}
-		else
-		{
+      if(iupStrToIntInt(iup_selection_pos, &start_int, &end_int, ':')!=2)
+      {
+        return;
+      }
+      if(start_int<0 || end_int<0)
+      {
+        return;
+      }
+      NSUInteger start = (NSUInteger)start_int;
+      NSUInteger end = (NSUInteger)end_int;
+      native_selection_range = NSMakeRange(start, end-start);
+    }
+    else
+    {
+      NSTextStorage* text_storage = [text_view textStorage];
+      native_selection_range = NSMakeRange([text_storage length], 0);
 
-			NSTextStorage* text_storage = [text_view textStorage];
-			native_selection_range = NSMakeRange([text_storage length], 0);
+      NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+      [undo_manager beginUndoGrouping];
 
-			NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-			[undo_manager beginUndoGrouping];
-			
-			NSDictionary* typing_attributes = [text_view typingAttributes];
-			NSMutableParagraphStyle* paragraph_style = [[typing_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
-			if(nil == paragraph_style)
-			{
-				paragraph_style = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
-			}
-			[paragraph_style autorelease];
-			bool needs_paragraph_style_change = cocoaTextParseParagraphAttributes(paragraph_style, formattag);
-			
+      NSDictionary* typing_attributes = [text_view typingAttributes];
+      NSMutableParagraphStyle* paragraph_style = [[typing_attributes objectForKey:NSParagraphStyleAttributeName] mutableCopy];
+      if(nil == paragraph_style)
+      {
+        paragraph_style = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
+      }
+      [paragraph_style autorelease];
+      bool needs_paragraph_style_change = cocoaTextParseParagraphAttributes(paragraph_style, formattag);
 
-			NSMutableDictionary* new_character_attributes = cocoaTextParseCharacterFormat(ih, formattag, text_view, native_selection_range);
-			
-			if(new_character_attributes || needs_paragraph_style_change)
-			{
-				// Merge all the attributes together
-				NSMutableDictionary* merged_attributes = [typing_attributes mutableCopy];
-				[merged_attributes autorelease];
-				
-				if(new_character_attributes != nil)
-				{
-					// This should overwrite any new properties with the old, while retaining the unchanged attributes
-					[merged_attributes addEntriesFromDictionary:new_character_attributes];
-				}
-				if(needs_paragraph_style_change)
-				{
-					[merged_attributes setObject:paragraph_style forKey:NSParagraphStyleAttributeName];
-				}
-			
-				[text_view setTypingAttributes:merged_attributes];
-				typing_attributes = merged_attributes;
-			}
-			
+      NSMutableDictionary* new_character_attributes = cocoaTextParseCharacterFormat(ih, formattag, text_view, native_selection_range);
 
-			// Append a newline so we have a fresh line to enable bullet lists
-			// If we don't, the previous line gets converted into a list which is often not what I think people expect.
-			NSAttributedString* attributed_append_string = [[NSAttributedString alloc] initWithString:@"\n" attributes:typing_attributes];
-			[attributed_append_string autorelease];
-			
-			// We need to mark the proposed change range (before we change it) in order to call shouldChangeTextInRange:
-			NSRange change_range = NSMakeRange([text_storage length], 0);
-			ih->data->disable_callbacks = 1;
-			[text_view shouldChangeTextInRange:change_range replacementString:[attributed_append_string string]];
-			[text_storage beginEditing];
-			[text_storage appendAttributedString:attributed_append_string];
-			  ih->data->disable_callbacks = 0;
-			[text_storage endEditing];
-		
-		
-			// We need a length of least 1 or an exception gets thrown inside cocoaTextParseBulletNumberListFormat
-			// Hence why we append a newline.
-			native_selection_range = NSMakeRange([text_storage length]-1, 1);
-//			native_selection_range = NSMakeRange(change_range.location, 1);
-			cocoaTextParseBulletNumberListFormat(ih, formattag, text_view, native_selection_range);
-			
-			// The result of the above yields an extra blank line after the bullet.
-			// So another hack is the delete the final newline
-			change_range = NSMakeRange([text_storage length]-1, 1);
-			ih->data->disable_callbacks = 1;
-			[text_view shouldChangeTextInRange:change_range replacementString:@""];
-			[text_storage beginEditing];
-			[text_storage deleteCharactersInRange:change_range];
-			  ih->data->disable_callbacks = 0;
-			[text_storage endEditing];
-		
-		
-			
-			[undo_manager endUndoGrouping];
-			
-			// Return immediately. The fall-through code is for selection-only
-			return;
-			
-		}
-	}
-	
-	
-	IupCocoaFont* iup_font = iupCocoaGetFont(ih);
+      if(new_character_attributes || needs_paragraph_style_change)
+      {
+        NSMutableDictionary* merged_attributes = [typing_attributes mutableCopy];
+        [merged_attributes autorelease];
 
-	// Use the current set font as the baseline. We will modify a local copy of its attributes from there.
-	NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
-	[attribute_dict autorelease];
-	NSTextStorage* text_storage = [text_view textStorage];
-	// Get the attributes (if any) for the selected range, and merge it into our copy of the font's attributes.
-	// This will overwrite/merge the current attributes into our font copy attributes.
-	NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[text_storage attributedSubstringFromRange:native_selection_range] attributesAtIndex:0 effectiveRange:NULL];
-	[attribute_dict addEntriesFromDictionary:text_storage_attributes];
+        if(new_character_attributes != nil)
+        {
+          [merged_attributes addEntriesFromDictionary:new_character_attributes];
+        }
+        if(needs_paragraph_style_change)
+        {
+          [merged_attributes setObject:paragraph_style forKey:NSParagraphStyleAttributeName];
+        }
 
+        [text_view setTypingAttributes:merged_attributes];
+        typing_attributes = merged_attributes;
+      }
 
-	
-//	NSLog(@"iupdrvTextAddFormatTag: %@", NSStringFromRange(native_selection_range));
-	NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-	[undo_manager beginUndoGrouping];
-	
-//	[text_storage beginEditing];
-	// Only the bullet/number feature changes the text. nil should express attribute-only change
-	[text_view shouldChangeTextInRange:native_selection_range replacementString:nil];
+      NSAttributedString* attributed_append_string = [[NSAttributedString alloc] initWithString:@"\n" attributes:typing_attributes];
+      [attributed_append_string autorelease];
 
+      NSRange change_range = NSMakeRange([text_storage length], 0);
+      ih->data->disable_callbacks = 1;
+      [text_view shouldChangeTextInRange:change_range replacementString:[attributed_append_string string]];
+      [text_storage beginEditing];
+      [text_storage appendAttributedString:attributed_append_string];
+      ih->data->disable_callbacks = 0;
+      [text_storage endEditing];
 
-	// cocoaTextParseBulletNumberListFormat actually re-adjusts its ranges to fit the list block.
-	// So it doesn't use the attribute_dict for our current range.
-	// I originally had a lot of problems with attributes clobbering each other, so order used to matter.
-	// I think some of those issues are improved, so order may not be as important now.
-	cocoaTextParseBulletNumberListFormat(ih, formattag, text_view, native_selection_range);
+      native_selection_range = NSMakeRange([text_storage length]-1, 1);
+      cocoaTextParseBulletNumberListFormat(ih, formattag, text_view, native_selection_range);
 
-	cocoaTextParseParagraphFormat(ih, formattag, text_view, native_selection_range);
-	cocoaTextParseCharacterFormat(ih, formattag, text_view, native_selection_range);
+      change_range = NSMakeRange([text_storage length]-1, 1);
+      ih->data->disable_callbacks = 1;
+      [text_view shouldChangeTextInRange:change_range replacementString:@""];
+      [text_storage beginEditing];
+      [text_storage deleteCharactersInRange:change_range];
+      ih->data->disable_callbacks = 0;
+      [text_storage endEditing];
 
-	
-//	[text_storage endEditing];
+      [undo_manager endUndoGrouping];
 
-	[text_view didChangeText];
-	[undo_manager endUndoGrouping];
-	
+      return;
+    }
+  }
 
-}
+  IupCocoaFont* iup_font = iupcocoaGetFont(ih);
 
+  NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
+  [attribute_dict autorelease];
+  NSTextStorage* text_storage = [text_view textStorage];
+  NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[text_storage attributedSubstringFromRange:native_selection_range] attributesAtIndex:0 effectiveRange:NULL];
+  [attribute_dict addEntriesFromDictionary:text_storage_attributes];
 
+  NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+  [undo_manager beginUndoGrouping];
 
+  [text_view shouldChangeTextInRange:native_selection_range replacementString:nil];
+
+  cocoaTextParseBulletNumberListFormat(ih, formattag, text_view, native_selection_range);
+  cocoaTextParseParagraphFormat(ih, formattag, text_view, native_selection_range);
+  cocoaTextParseCharacterFormat(ih, formattag, text_view, native_selection_range);
+
+  [text_view didChangeText];
+  [undo_manager endUndoGrouping];
+}
+
 static char* cocoaTextGetFormattingAttrib(Ihandle* ih)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			
-			NSCAssert(([cocoaTextGetTextView(ih) isRichText] == ih->data->has_formatting), @"Expecting isRichText==ih->data->has_formatting");
-			return iupStrReturnBoolean(ih->data->has_formatting);
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		default:
-		{
-			break;
-		}
-	}
-	
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+    {
+      return iupStrReturnBoolean(ih->data->has_formatting);
+    }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+    default:
+    {
+      break;
+    }
+  }
+
   return iupStrReturnBoolean(false);
 }
 
 static int cocoaTextSetFormattingAttrib(Ihandle* ih, const char* value)
 {
-	if(!ih->handle)
-	{
-		// This is before map.
-		// Let the variable be set, so we can read it inside Map and do the right thing.
-		ih->data->has_formatting = iupStrBoolean(value);
-		return 0;
-	}
+  if(!ih->handle)
+  {
+    ih->data->has_formatting = iupStrBoolean(value);
+    return 0;
+  }
 
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			bool enable_formatting = iupStrBoolean(value);
-			
-			if(enable_formatting)
-			{
-				NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-//				[undo_manager beginUndoGrouping];
-				[text_view setRichText:enable_formatting];
-//				[text_view setImportsGraphics:enable_formatting];
-//				[undo_manager endUndoGrouping];
-				
-				// I can't seem to undo setRichText:
-				// NOTE: If this could be made to work, to correctly implement this,
-				// I would need to override setRichText: to keep ih->data->has_formatting in sync for the undo.
-				// But since I can't make it work, reset the undo stack.
-				[undo_manager removeAllActions];
-				
-			}
-			else
-			{
-				NSTextView* text_view = cocoaTextGetTextView(ih);
-				NSRange selection_range;
-				NSTextStorage* text_storage = [text_view textStorage];
-				selection_range = NSMakeRange(0, [text_storage length]);
-				
-				NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-//				[undo_manager beginUndoGrouping];
-				[text_storage beginEditing];
-				
-				ih->data->disable_callbacks = 1;
-				[text_view shouldChangeTextInRange:selection_range replacementString:nil];
-				[text_storage setAttributes:nil range:selection_range];
-				ih->data->disable_callbacks = 0;
-				
-				[text_storage endEditing];
-				
-				IupCocoaFont* iup_font = iupCocoaGetFont(ih);
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        bool enable_formatting = iupStrBoolean(value);
 
-				[text_view setTypingAttributes:[iup_font attributeDictionary]];
-	//			[text_view setImportsGraphics:enable_formatting];
-				[text_view setRichText:enable_formatting];
-			
-				// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-				[text_view didChangeText];
-				[text_storage endEditing];
-//				[undo_manager endUndoGrouping];
+        if(enable_formatting)
+        {
+          [text_view setRichText:enable_formatting];
+          NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+          [undo_manager removeAllActions];
+        }
+        else
+        {
+          NSTextView* text_view = cocoaTextGetTextView(ih);
+          NSRange selection_range;
+          NSTextStorage* text_storage = [text_view textStorage];
+          selection_range = NSMakeRange(0, [text_storage length]);
 
-				// I can't seem to undo setRichText:
-				// NOTE: If this could be made to work, to correctly implement this,
-				// I would need to override setRichText: to keep ih->data->has_formatting in sync for the undo.
-				// But since I can't make it work, reset the undo stack.
-				[undo_manager removeAllActions];
-			}
-			
-			
-			ih->data->has_formatting = enable_formatting;
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		default:
-		{
-			ih->data->has_formatting = 0;
-			break;
-		}
-	}
-	
-	return 0;
+          NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+          [text_storage beginEditing];
+
+          ih->data->disable_callbacks = 1;
+          [text_view shouldChangeTextInRange:selection_range replacementString:nil];
+          [text_storage setAttributes:nil range:selection_range];
+          ih->data->disable_callbacks = 0;
+
+          [text_storage endEditing];
+
+          IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+
+          [text_view setTypingAttributes:[iup_font attributeDictionary]];
+          [text_view setRichText:enable_formatting];
+
+          [text_view didChangeText];
+          [text_storage endEditing];
+          [undo_manager removeAllActions];
+        }
+
+        ih->data->has_formatting = enable_formatting;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+  case IUPCOCOATEXTSUBTYPE_STEPPER:
+                           default:
+      {
+        ih->data->has_formatting = 0;
+        break;
+      }
+  }
+
+  return 0;
 }
 
-
 static int cocoaTextSetRemoveFormattingAttrib(Ihandle* ih, const char* value)
 {
-	if(!ih->data->is_multiline)
-	{
-		return 0;
-	}
-	
-	NSTextView* text_view = cocoaTextGetTextView(ih);
-	NSRange selection_range;
-	NSTextStorage* text_storage = [text_view textStorage];
-	
-	if(iupStrEqualNoCase(value, "ALL"))
-	{
-		selection_range = NSMakeRange(0, [text_storage length]);
-	}
-	else
-	{
-		// Use selectedRanges to get an array of multiple selections if we ever have to handle that
-		selection_range = [text_view selectedRange];
-		if(NSNotFound == selection_range.location)
-		{
-			return 0;
-		}
-	}
-	
-	NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-	[undo_manager beginUndoGrouping];
-	[text_storage beginEditing];
-	
-	ih->data->disable_callbacks = 1;
-	[text_view shouldChangeTextInRange:selection_range replacementString:nil];
-	[text_storage setAttributes:nil range:selection_range];
-	ih->data->disable_callbacks = 0;
-	
-	[text_storage endEditing];
-	
-	// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-	[text_view didChangeText];
-	[text_storage endEditing];
-	[undo_manager endUndoGrouping];
-	
-	return 0;
-}
+  if(!ih->data->is_multiline)
+  {
+    return 0;
+  }
 
+  NSTextView* text_view = cocoaTextGetTextView(ih);
+  NSRange selection_range;
+  NSTextStorage* text_storage = [text_view textStorage];
 
-static int cocoaTextSetAlignmentAttrib(Ihandle* ih, const char* value)
-{
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			
-			// NSText provides these methods
-			if(iupStrEqualNoCase(value, "ARIGHT"))
-			{
-				[text_view setAlignment:NSTextAlignmentRight];
-			}
-			else if (iupStrEqualNoCase(value, "ACENTER"))
-			{
-				[text_view setAlignment:NSTextAlignmentCenter];
-			}
-			else /* "ALEFT" */
-			{
-				[text_view setAlignment:NSTextAlignmentLeft];
-			}
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			// NSControl provides these methods
-			if(iupStrEqualNoCase(value, "ARIGHT"))
-			{
-				[text_field setAlignment:NSTextAlignmentRight];
-			}
-			else if (iupStrEqualNoCase(value, "ACENTER"))
-			{
-				[text_field setAlignment:NSTextAlignmentCenter];
-			}
-			else /* "ALEFT" */
-			{
-				[text_field setAlignment:NSTextAlignmentLeft];
-			}
+  if(iupStrEqualNoCase(value, "ALL"))
+  {
+    selection_range = NSMakeRange(0, [text_storage length]);
+  }
+  else
+  {
+    selection_range = [text_view selectedRange];
+    if(NSNotFound == selection_range.location)
+    {
+      return 0;
+    }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			// NSControl provides these methods
-			if(iupStrEqualNoCase(value, "ARIGHT"))
-			{
-				[text_field setAlignment:NSTextAlignmentRight];
-			}
-			else if (iupStrEqualNoCase(value, "ACENTER"))
-			{
-				[text_field setAlignment:NSTextAlignmentCenter];
-			}
-			else /* "ALEFT" */
-			{
-				[text_field setAlignment:NSTextAlignmentLeft];
-			}
+  NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+  [undo_manager beginUndoGrouping];
+  [text_storage beginEditing];
 
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+  ih->data->disable_callbacks = 1;
+  [text_view shouldChangeTextInRange:selection_range replacementString:nil];
+  [text_storage setAttributes:nil range:selection_range];
+  ih->data->disable_callbacks = 0;
 
-	return 1;
+  [text_storage endEditing];
+
+  [text_view didChangeText];
+  [text_storage endEditing];
+  [undo_manager endUndoGrouping];
+
+  return 0;
 }
 
+static int cocoaTextSetAlignmentAttrib(Ihandle* ih, const char* value)
+{
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
 
+        if(iupStrEqualNoCase(value, "ARIGHT"))
+        {
+          [text_view setAlignment:NSTextAlignmentRight];
+        }
+        else if (iupStrEqualNoCase(value, "ACENTER"))
+        {
+          [text_view setAlignment:NSTextAlignmentCenter];
+        }
+        else /* "ALEFT" */
+        {
+          [text_view setAlignment:NSTextAlignmentLeft];
+        }
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        if(iupStrEqualNoCase(value, "ARIGHT"))
+        {
+          [text_field setAlignment:NSTextAlignmentRight];
+        }
+        else if (iupStrEqualNoCase(value, "ACENTER"))
+        {
+          [text_field setAlignment:NSTextAlignmentCenter];
+        }
+        else /* "ALEFT" */
+        {
+          [text_field setAlignment:NSTextAlignmentLeft];
+        }
 
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        if(iupStrEqualNoCase(value, "ARIGHT"))
+        {
+          [text_field setAlignment:NSTextAlignmentRight];
+        }
+        else if (iupStrEqualNoCase(value, "ACENTER"))
+        {
+          [text_field setAlignment:NSTextAlignmentCenter];
+        }
+        else /* "ALEFT" */
+        {
+          [text_field setAlignment:NSTextAlignmentLeft];
+        }
 
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return 1;
+}
+
 static char* cocoaTextGetSelectedTextAttrib(Ihandle* ih)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			// Note: use selectedRanges if we need to support multiple selection
-			NSRange selected_range = [text_view selectedRange];
-			NSString* selected_string = [[[text_view textStorage] string] substringWithRange:selected_range];
-			return iupStrReturnStr([selected_string UTF8String]);
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSRange selected_range = [field_editor selectedRange];
-			NSString* selected_string = [[field_editor string] substringWithRange:selected_range];
-			return iupStrReturnStr([selected_string UTF8String]);
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSRange selected_range = [field_editor selectedRange];
-			NSString* selected_string = [[field_editor string] substringWithRange:selected_range];
-			return iupStrReturnStr([selected_string UTF8String]);
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return NULL;
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        NSRange selected_range = [text_view selectedRange];
+        NSString* selected_string = [[[text_view textStorage] string] substringWithRange:selected_range];
+        return iupStrReturnStr([selected_string UTF8String]);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSRange selected_range = [field_editor selectedRange];
+        NSString* selected_string = [[field_editor string] substringWithRange:selected_range];
+        return iupStrReturnStr([selected_string UTF8String]);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSRange selected_range = [field_editor selectedRange];
+        NSString* selected_string = [[field_editor string] substringWithRange:selected_range];
+        return iupStrReturnStr([selected_string UTF8String]);
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return NULL;
 }
 
 static int cocoaTextSetSelectedTextAttrib(Ihandle* ih, const char* value)
 {
-	if(NULL == value)
-	{
-		return 0;
-	}
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			// Note: use selectedRanges if we need to support multiple selection
-			NSRange selected_range = [text_view selectedRange];
-			// make sure something is selected
-			if((NSNotFound == selected_range.location) || (0 == selected_range.length))
-			{
-				return 0;
-			}
-			
-			// We can't use NSTextView insertText because
-			// if this is used to programmatically alter text while the widget is disabled,
-			// then the insert will fail.
-			// So we must alter NSTextStorage directly.
-			
-			NSTextStorage* text_storage = [text_view textStorage];
-			IupCocoaFont* iup_font = iupCocoaGetFont(ih);
+  if(NULL == value)
+  {
+    return 0;
+  }
 
-			// Use the current set font as the baseline. We will modify a local copy of its attributes from there.
-			NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
-			[attribute_dict autorelease];
-			// Set the selection range to be at the very last character.
-			// Get the attributes (if any) for the selected range, and merge it into our copy of the font's attributes.
-			// This will overwrite/merge the current attributes into our font copy attributes.
-			// Needs to be 1 character or it raises an exception
-			NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[text_storage attributedSubstringFromRange:selected_range] attributesAtIndex:0 effectiveRange:NULL];
-			[attribute_dict addEntriesFromDictionary:text_storage_attributes];
-			
-			NSString* ns_insert_string = [NSString stringWithUTF8String:value];
-			
-			NSAttributedString* attributed_insert_string = [[NSAttributedString alloc] initWithString:ns_insert_string attributes:attribute_dict];
-			[attributed_insert_string autorelease];
-			
-			
-			NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-			[undo_manager beginUndoGrouping];
-			
-			ih->data->disable_callbacks = 1;
-			[text_view shouldChangeTextInRange:selected_range replacementString:[attributed_insert_string string]];
-			[text_storage beginEditing];
-			
-			[text_storage replaceCharactersInRange:selected_range withAttributedString:attributed_insert_string];
-			
-			ih->data->disable_callbacks = 0;
-			
-			[text_storage endEditing];
-			
-			// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-			[text_view didChangeText];
-			[undo_manager endUndoGrouping];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        NSRange selected_range = [text_view selectedRange];
+        if((NSNotFound == selected_range.location) || (0 == selected_range.length))
+        {
+          return 0;
+        }
 
+        NSTextStorage* text_storage = [text_view textStorage];
+        IupCocoaFont* iup_font = iupcocoaGetFont(ih);
 
-			return 0;
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSRange selected_range = [field_editor selectedRange];
-			if((NSNotFound == selected_range.location) || (0 == selected_range.length))
-			{
-				return 0;
-			}
-			
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			[(NSTextView*)field_editor insertText:ns_string replacementRange:selected_range];
-			return 0;
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSRange selected_range = [field_editor selectedRange];
-			if((NSNotFound == selected_range.location) || (0 == selected_range.length))
-			{
-				return 0;
-			}
-			
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			[(NSTextView*)field_editor insertText:ns_string replacementRange:selected_range];
-			return 0;
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	return 0;
+        NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
+        [attribute_dict autorelease];
+        NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[text_storage attributedSubstringFromRange:NSMakeRange(selected_range.location, 1)] attributesAtIndex:0 effectiveRange:NULL];
+        [attribute_dict addEntriesFromDictionary:text_storage_attributes];
+
+        NSString* ns_insert_string = [NSString stringWithUTF8String:value];
+
+        NSAttributedString* attributed_insert_string = [[NSAttributedString alloc] initWithString:ns_insert_string attributes:attribute_dict];
+        [attributed_insert_string autorelease];
+
+        NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+        [undo_manager beginUndoGrouping];
+
+        ih->data->disable_callbacks = 1;
+        [text_view shouldChangeTextInRange:selected_range replacementString:[attributed_insert_string string]];
+        [text_storage beginEditing];
+
+        [text_storage replaceCharactersInRange:selected_range withAttributedString:attributed_insert_string];
+
+        ih->data->disable_callbacks = 0;
+
+        [text_storage endEditing];
+
+        [text_view didChangeText];
+        [undo_manager endUndoGrouping];
+
+        return 0;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSRange selected_range = [field_editor selectedRange];
+        if((NSNotFound == selected_range.location) || (0 == selected_range.length))
+        {
+          return 0;
+        }
+
+        NSString* ns_string = [NSString stringWithUTF8String:value];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        [(NSTextView*)field_editor insertText:ns_string replacementRange:selected_range];
+        return 0;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSRange selected_range = [field_editor selectedRange];
+        if((NSNotFound == selected_range.location) || (0 == selected_range.length))
+        {
+          return 0;
+        }
+
+        NSString* ns_string = [NSString stringWithUTF8String:value];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        [(NSTextView*)field_editor insertText:ns_string replacementRange:selected_range];
+        return 0;
+      }
+    default:
+      {
+        break;
+      }
+  }
+  return 0;
 }
 
 static int cocoaTextSetSelectionAttrib(Ihandle* ih, const char* value)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return 0;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSRange selection_range = NSMakeRange(0, 0);
 
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
-	
-	
+  if (!value || iupStrEqualNoCase(value, "NONE"))
+  {
+  }
+  else if (iupStrEqualNoCase(value, "ALL"))
+  {
+    NSTextStorage* text_storage = [text_view textStorage];
+    NSUInteger start = 0;
+    NSUInteger end = [text_storage length];
+    selection_range = NSMakeRange(start, end);
+  }
+  else
+  {
+    int ret_val;
+    NSUInteger lin_start=1;
+    NSUInteger col_start=1;
+    NSUInteger lin_end=1;
+    NSUInteger col_end=1;
 
-	NSRange selection_range = NSMakeRange(0, 0);
-	
-	
-	if (!value || iupStrEqualNoCase(value, "NONE"))
-	{
-		//			start = 0;
-		//			end = 0;
-	}
-	else if (iupStrEqualNoCase(value, "ALL"))
-	{
-		NSTextStorage* text_storage = [text_view textStorage];
-		NSUInteger start;
-		NSUInteger end;
-		start = 0;
-		end = [text_storage length];
-		selection_range = NSMakeRange(start, end);
-	}
-	else
-	{
-		int ret_val;
-		NSUInteger lin_start=1;
-		NSUInteger col_start=1;
-		NSUInteger lin_end=1;
-		NSUInteger col_end=1;
-		
-		
-		switch(sub_type)
-		{
-			case IUPCOCOATEXTSUBTYPE_VIEW:
-			{
-				ret_val = sscanf(value, "%lu,%lu:%lu,%lu", &lin_start, &col_start, &lin_end, &col_end);
-				if(ret_val != 4)
-				{
-					return 0;
-				}
-				if(lin_start<1 || col_start<1 || lin_end<1 || col_end<1)
-				{
-					return 0;
-				}
-				break;
-			}
-			case IUPCOCOATEXTSUBTYPE_FIELD:
-			case IUPCOCOATEXTSUBTYPE_STEPPER:
-			{
-				int col_start_int = 1;
-				int col_end_int = 1;
-				if(iupStrToIntInt(value, &col_start_int, &col_end_int, ':')!=2)
-				{
-					return 0;
-				}
-				col_start = col_start_int;
-				col_end = col_end_int;
+    switch(sub_type)
+    {
+      case IUPCOCOATEXTSUBTYPE_VIEW:
+        {
+          ret_val = sscanf(value, "%lu,%lu:%lu,%lu", &lin_start, &col_start, &lin_end, &col_end);
+          if(ret_val != 4)
+          {
+            return 0;
+          }
+          if(lin_start<1 || col_start<1 || lin_end<1 || col_end<1)
+          {
+            return 0;
+          }
+          break;
+        }
+      case IUPCOCOATEXTSUBTYPE_FIELD:
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+        {
+          int col_start_int = 1;
+          int col_end_int = 1;
+          if(iupStrToIntInt(value, &col_start_int, &col_end_int, ':')!=2)
+          {
+            return 0;
+          }
+          col_start = col_start_int;
+          col_end = col_end_int;
 
-				if(col_start<0 || col_end<0)
-				{
-					return 0;
-				}
-				break;
-			}
-			default:
-			{
-				return 0;
-				break;
-			}
-		}
-		
-		bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &selection_range);
-		if(!did_find_range)
-		{
-			return 0;
-		}
-	}
-	
-	[text_view setSelectedRange:selection_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
+          if(col_start<0 || col_end<0)
+          {
+            return 0;
+          }
+          break;
+        }
+    default:
+        {
+          return 0;
+        }
+    }
 
-	return 0;
+    bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &selection_range);
+    if(!did_find_range)
+    {
+      return 0;
+    }
+  }
+
+  [text_view setSelectedRange:selection_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
+
+  return 0;
 }
 
 static char* cocoaTextGetSelectionAttrib(Ihandle* ih)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return NULL;
+        break;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSRange selected_range = [text_view selectedRange];
+  if(NSNotFound == selected_range.location)
+  {
+    return NULL;
+  }
 
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
+  NSUInteger lin_start=1;
+  NSUInteger col_start=1;
+  NSUInteger lin_end=1;
+  NSUInteger col_end=1;
+  bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, selected_range, &lin_start, &col_start, &lin_end, &col_end);
+  if(!did_find_range)
+  {
+    return NULL;
+  }
 
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        return iupStrReturnStrf("%lu,%lu:%lu,%lu", lin_start, col_start, lin_end, col_end);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+  case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        if(lin_end > 1)
+        {
+          did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, 1, col_start, 1, col_end, &selected_range);
+          if(did_find_range)
+          {
+            col_start = selected_range.location + 1;
+            col_end = col_start + selected_range.length;
+          }
+          else
+          {
+            return NULL;
+          }
+        }
 
-	// Use selectedRanges to get an array of multiple selections if we ever have to handle that
-	NSRange selected_range = [text_view selectedRange];
-	if(NSNotFound == selected_range.location)
-	{
-		return NULL;
-	}
-	
-	NSUInteger lin_start=1;
-	NSUInteger col_start=1;
-	NSUInteger lin_end=1;
-	NSUInteger col_end=1;
-	bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, selected_range, &lin_start, &col_start, &lin_end, &col_end);
-	if(!did_find_range)
-	{
-		return NULL;
-	}
-	
+        return iupStrReturnIntInt((int)col_start, (int)col_end, ':');
+        break;
+      }
+  default:
+      {
+        return NULL;
+        break;
+      }
+  }
 
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			return iupStrReturnStrf("%lu,%lu:%lu,%lu", lin_start, col_start, lin_end, col_end);
-
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// FIXME: There is an edge case where a \n is snuck into the NSTextField. This will break things.
-			// This algorithm may be overkill.
-			if(lin_end > 1)
-			{
-				did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, 1, col_start, 1, col_end, &selected_range);
-				if(did_find_range)
-				{
-					// pos is 0 indexed, col is 1 indexed, so we need to add 1
-					col_start = selected_range.location + 1;
-					col_end = col_start + selected_range.length;
-				}
-				else
-				{
-					return NULL;
-				}
-			}
-			
-			// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-			return iupStrReturnIntInt((int)col_start, (int)col_end, ':');
-
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
-	
-
-	return NULL;
+  return NULL;
 }
 
-
 static int cocoaTextSetSelectionPosAttrib(Ihandle* ih, const char* value)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return 0;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSUInteger start;
+  NSUInteger end;
+  NSRange selection_range = NSMakeRange(0, 0);
 
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
+  if (!value || iupStrEqualNoCase(value, "NONE"))
+  {
+  }
+  else if (iupStrEqualNoCase(value, "ALL"))
+  {
+    NSTextStorage* text_storage = [text_view textStorage];
 
-	NSUInteger start;
-	NSUInteger end;
-	NSRange selection_range = NSMakeRange(0, 0);
-	
-	
-	if (!value || iupStrEqualNoCase(value, "NONE"))
-	{
-		//			start = 0;
-		//			end = 0;
-	}
-	else if (iupStrEqualNoCase(value, "ALL"))
-	{
-		NSTextStorage* text_storage = [text_view textStorage];
-		
-		start = 0;
-		end = [text_storage length];
-		selection_range = NSMakeRange(start, end);
-	}
-	else
-	{
-		// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-		int start_int = 0;
-		int end_int = 0;
-		
-		if(iupStrToIntInt(value, &start_int, &end_int, ':')!=2)
-		{
-			return 0;
-		}
-		if(start_int<0 || end_int<0)
-		{
-			return 0;
-		}
-		start = (NSUInteger)start_int;
-		end = (NSUInteger)end_int;
-		selection_range = NSMakeRange(start, end-start);
-	}
-	
-	[text_view setSelectedRange:selection_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
-	
+    start = 0;
+    end = [text_storage length];
+    selection_range = NSMakeRange(start, end);
+  }
+  else
+  {
+    int start_int = 0;
+    int end_int = 0;
 
+    if(iupStrToIntInt(value, &start_int, &end_int, ':')!=2)
+    {
+      return 0;
+    }
+    if(start_int<0 || end_int<0)
+    {
+      return 0;
+    }
+    start = (NSUInteger)start_int;
+    end = (NSUInteger)end_int;
+    selection_range = NSMakeRange(start, end-start);
+  }
 
-	return 0;
+  [text_view setSelectedRange:selection_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
+
+  return 0;
 }
 
 static char* cocoaTextGetSelectionPosAttrib(Ihandle* ih)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return NULL;
+        break;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSRange selected_range = [text_view selectedRange];
+  if(NSNotFound == selected_range.location)
+  {
+    return NULL;
+  }
+  NSUInteger start = selected_range.location;
+  NSUInteger end = selected_range.location + selected_range.length;
 
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
-	
-	// Use selectedRanges to get an array of multiple selections if we ever have to handle that
-	NSRange selected_range = [text_view selectedRange];
-	if(NSNotFound == selected_range.location)
-	{
-		return NULL;
-	}
-	NSUInteger start = selected_range.location;
-	NSUInteger end = selected_range.location + selected_range.length;
-	
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	return iupStrReturnIntInt((int)start, (int)end, ':');
-	
+  return iupStrReturnIntInt((int)start, (int)end, ':');
 }
 
-// TODO: This is almost identical to Caret. (Caret also sets the cursor.) Should make Caret call this.
-static int cocoaTextSetScrollToAttrib(Ihandle* ih, const char* value)
+static int cocoaTextSetCaretAttrib(Ihandle* ih, const char* value)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return 0;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSRange cursor_range = NSMakeRange(0, 0);
 
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
-	
-	
-	NSRange cursor_range = NSMakeRange(0, 0);
-	
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	int start_int = 0;
-	int end_int = 0;
-	
-	if(iupStrToIntInt(value, &start_int, &end_int, ':')!=2)
-	{
-		return 0;
-	}
-	if(start_int<0 || end_int<0)
-	{
-		return 0;
-	}
-	NSUInteger lin_start=start_int;
-	NSUInteger col_start=end_int;
-	NSUInteger lin_end=start_int;
-	NSUInteger col_end=end_int;
-	bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &cursor_range);
-	if(did_find_range)
-	{
-		[text_view scrollRangeToVisible:cursor_range];
-	}
-	
+  int start_int = 0;
+  int end_int = 0;
 
-	return 0;
+  if(iupStrToIntInt(value, &start_int, &end_int, ':')!=2)
+  {
+    return 0;
+  }
+  if(start_int<0 || end_int<0)
+  {
+    return 0;
+  }
+  NSUInteger lin_start=start_int;
+  NSUInteger col_start=end_int;
+  NSUInteger lin_end=start_int;
+  NSUInteger col_end=end_int;
+  bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &cursor_range);
+  if(did_find_range)
+  {
+    [text_view setSelectedRange:cursor_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
+    [text_view scrollRangeToVisible:cursor_range];
+  }
+
+  return 0;
 }
 
-// TODO: This is almost identical to Caret. (Caret also sets the cursor.) Should make Caret call this.
-static int cocoaTextSetScrollToPosAttrib(Ihandle* ih, const char* value)
+static char* cocoaTextGetCaretAttrib(Ihandle* ih)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return NULL;
+        break;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
+  if(NSNotFound == cursor_range.location)
+  {
+    return NULL;
+  }
 
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
-	
-	NSRange cursor_range = NSMakeRange(0, 0);
-	
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	int pos = 0;
-	if(!iupStrToInt(value, &pos))
-	{
-		return 0;
-	}
-	if(pos<0)
-	{
-		return 0;
-	}
-	cursor_range = NSMakeRange(pos, 0);
-	
+  NSUInteger lin_start=1;
+  NSUInteger col_start=1;
+  NSUInteger lin_end=1;
+  NSUInteger col_end=1;
+  bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, cursor_range, &lin_start, &col_start, &lin_end, &col_end);
+  if(!did_find_range)
+  {
+    return NULL;
+  }
 
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			[text_view scrollRangeToVisible:cursor_range];
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
+  [text_view scrollRangeToVisible:cursor_range];
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        return iupStrReturnIntInt((int)lin_start, (int)col_start, ':');
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+  case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        if(lin_end > 1)
+        {
+          did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, 1, col_start, 1, col_end, &cursor_range);
+          if(did_find_range)
+          {
+            col_start = cursor_range.location + 1;
+          }
+          else
+          {
+            return NULL;
+          }
+        }
 
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
-	return 0;
+        return iupStrReturnInt((int)col_start);
+        break;
+      }
+  default:
+      {
+        return NULL;
+        break;
+      }
+  }
+
+  return NULL;
 }
 
-// TODO: This is almost identical to ScrollTo. (Caret also sets the cursor.) Should make Caret call ScrollTo.
-static int cocoaTextSetCaretAttrib(Ihandle* ih, const char* value)
+static int cocoaTextSetScrollToAttrib(Ihandle* ih, const char* value)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  if (!value)
+    return 0;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  NSTextView* text_view = nil;
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      text_view = cocoaTextGetTextView(ih);
+      break;
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+    {
+      NSTextField* text_field = cocoaTextGetTextField(ih);
+      NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+      if ([field_editor isKindOfClass:[NSTextView class]])
+        text_view = (NSTextView*)field_editor;
+      break;
+    }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+    {
+      NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+      NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+      if ([field_editor isKindOfClass:[NSTextView class]])
+        text_view = (NSTextView*)field_editor;
+      break;
+    }
+    default:
+      return 0;
+  }
 
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
-	
-	
-	NSRange cursor_range = NSMakeRange(0, 0);
-	
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	int start_int = 0;
-	int end_int = 0;
-	
-	if(iupStrToIntInt(value, &start_int, &end_int, ':')!=2)
-	{
-		return 0;
-	}
-	if(start_int<0 || end_int<0)
-	{
-		return 0;
-	}
-	NSUInteger lin_start=start_int;
-	NSUInteger col_start=end_int;
-	NSUInteger lin_end=start_int;
-	NSUInteger col_end=end_int;
-	bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &cursor_range);
-	if(did_find_range)
-	{
-		[text_view setSelectedRange:cursor_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
-		[text_view scrollRangeToVisible:cursor_range];
-	}
-	
+  if (!text_view)
+    return 0;
 
-	return 0;
-}
+  NSRange cursor_range = NSMakeRange(0, 0);
 
-static char* cocoaTextGetCaretAttrib(Ihandle* ih)
-{
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  if (ih->data->is_multiline)
+  {
+    int lin = 1, col = 1;
+    iupStrToIntInt(value, &lin, &col, ',');
+    if (lin < 1) lin = 1;
+    if (col < 1) col = 1;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+    NSUInteger lin_start = lin;
+    NSUInteger col_start = col;
+    NSUInteger lin_end = lin;
+    NSUInteger col_end = col;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+    bool did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, lin_start, col_start, lin_end, col_end, &cursor_range);
+    if (did_find_range)
+      [text_view scrollRangeToVisible:cursor_range];
+  }
+  else
+  {
+    int pos = 1;
+    iupStrToInt(value, &pos);
+    if (pos < 1) pos = 1;
+    pos--;
+    cursor_range = NSMakeRange(pos, 0);
+    [text_view scrollRangeToVisible:cursor_range];
+  }
 
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
+  return 0;
+}
 
+static int cocoaTextSetScrollToPosAttrib(Ihandle* ih, const char* value)
+{
+  if (!value)
+    return 0;
 
-	NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
-	if(NSNotFound == cursor_range.location)
-	{
-		// what do we do?
-		return NULL;
-	}
-	
-	NSUInteger lin_start=1;
-	NSUInteger col_start=1;
-	NSUInteger lin_end=1;
-	NSUInteger col_end=1;
-	bool did_find_range = cocoaTextComputeLineColumnFromRangeForTextView(text_view, cursor_range, &lin_start, &col_start, &lin_end, &col_end);
-	if(!did_find_range)
-	{
-		return NULL;
-	}
-	
-	[text_view scrollRangeToVisible:cursor_range];
+  int pos = 0;
+  iupStrToInt(value, &pos);
+  if (pos < 0) pos = 0;
 
+  NSTextView* text_view = nil;
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
 
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-			return iupStrReturnIntInt((int)lin_start, (int)col_start, ':');
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      text_view = cocoaTextGetTextView(ih);
+      break;
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+    {
+      NSTextField* text_field = cocoaTextGetTextField(ih);
+      NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+      if ([field_editor isKindOfClass:[NSTextView class]])
+        text_view = (NSTextView*)field_editor;
+      break;
+    }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+    {
+      NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+      NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+      if ([field_editor isKindOfClass:[NSTextView class]])
+        text_view = (NSTextView*)field_editor;
+      break;
+    }
+    default:
+      return 0;
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// FIXME: There is an edge case where a \n is snuck into the NSTextField. This will break things.
-			// This algorithm may be overkill.
-			if(lin_end > 1)
-			{
-				did_find_range = cocoaTextComputeRangeFromLineColumnForTextView(text_view, 1, col_start, 1, col_end, &cursor_range);
-				if(did_find_range)
-				{
-					// pos is 0 indexed, col is 1 indexed, so we need to add 1
-					col_start = cursor_range.location + 1;
-//					col_end = col_start + cursor_range.length;
-				}
-				else
-				{
-					return NULL;
-				}
-			}
-			
-			// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-   			 return iupStrReturnInt((int)col_start);
+  if (!text_view)
+    return 0;
 
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
-	
-	return NULL;
+  NSRange cursor_range = NSMakeRange(pos, 0);
+  [text_view scrollRangeToVisible:cursor_range];
+
+  return 0;
 }
 
-// TODO: This is almost identical to ScrollPos. (Caret also sets the cursor.) Should make Caret call ScrollPos.
 static int cocoaTextSetCaretPosAttrib(Ihandle* ih, const char* value)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return 0;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSRange cursor_range = NSMakeRange(0, 0);
 
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
-	
-	NSRange cursor_range = NSMakeRange(0, 0);
-	
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	int pos = 0;
-	if(!iupStrToInt(value, &pos))
-	{
-		return 0;
-	}
-	if(pos<0)
-	{
-		return 0;
-	}
-	cursor_range = NSMakeRange(pos, 0);
-	
-	[text_view setSelectedRange:cursor_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
+  int pos = 0;
+  if(!iupStrToInt(value, &pos))
+  {
+    return 0;
+  }
+  if(pos<0)
+  {
+    return 0;
+  }
+  cursor_range = NSMakeRange(pos, 0);
 
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			[text_view scrollRangeToVisible:cursor_range];
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
+  [text_view setSelectedRange:cursor_range affinity:NSSelectionAffinityDownstream stillSelecting:NO];
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-
-			break;
-		}
-		default:
-		{
-			return 0;
-			break;
-		}
-	}
-	return 0;
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        [text_view scrollRangeToVisible:cursor_range];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        break;
+      }
+    default:
+      {
+        return 0;
+      }
+  }
+  return 0;
 }
 
 static char* cocoaTextGetCaretPosAttrib(Ihandle* ih)
 {
-	NSTextView* text_view = nil;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			text_view = cocoaTextGetTextView(ih);
+  NSTextView* text_view = nil;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        text_view = cocoaTextGetTextView(ih);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        text_view = (NSTextView*)field_editor;
+        break;
+      }
+    default:
+      {
+        return NULL;
+        break;
+      }
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			text_view = (NSTextView*)field_editor;
+  NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
+  if(NSNotFound == cursor_range.location)
+  {
+    return NULL;
+  }
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        [text_view scrollRangeToVisible:cursor_range];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+  case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        break;
+      }
+  default:
+      {
+        return NULL;
+        break;
+      }
+  }
+  return iupStrReturnInt((int)cursor_range.location);
+}
 
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
-	
-	NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
-	if(NSNotFound == cursor_range.location)
-	{
-		// what do we do?
-		return NULL;
-	}
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			[text_view scrollRangeToVisible:cursor_range];
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
+static char* cocoaTextGetLineValueAttrib(Ihandle* ih)
+{
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
+        NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
+        if(NSNotFound == cursor_range.location)
+        {
+          return NULL;
+        }
 
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	return iupStrReturnInt((int)cursor_range.location);
-}
+        cursor_range.length = 0;
 
+        NSTextStorage* text_storage = [text_view textStorage];
+        NSString* text_string = [text_storage string];
+        NSUInteger start_index = 0;
+        NSUInteger contents_end_index = 0;
 
-static char* cocoaTextGetLineValueAttrib(Ihandle* ih)
-{
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
+        [text_string getLineStart:&start_index end:NULL contentsEnd:&contents_end_index forRange:cursor_range];
 
-			
-			NSRange cursor_range = [[[text_view selectedRanges] lastObject] rangeValue];
-			if(NSNotFound == cursor_range.location)
-			{
-				// what do we do?
-				return NULL;
-			}
-			
-			// We don't want the entire range, just the start cursor position (in case the user has selected multiple lines)
-			cursor_range.length = 0;
-			
-			NSTextStorage* text_storage = [text_view textStorage];
-			NSString* text_string = [text_storage string];
-			NSUInteger start_index = 0;
-			NSUInteger contents_end_index = 0;
-			
-			[text_string getLineStart:&start_index end:NULL contentsEnd:&contents_end_index forRange:cursor_range];
-			
-			NSRange line_range = NSMakeRange(start_index, contents_end_index - start_index);
-			NSString* selected_string = [text_string substringWithRange:line_range];
-			return iupStrReturnStr([selected_string UTF8String]);
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			// I originally tried to do the overkill thing and worry about injected newlines.
-			// So I used the field editor and tried to share the textview code.
-			// But unless the field is selected, there is no string in the field editor, so that approach won't work.
-			return cocoaTextGetValueAttrib(ih);
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// I originally tried to do the overkill thing and worry about injected newlines.
-			// So I used the field editor and tried to share the textview code.
-			// But unless the field is selected, there is no string in the field editor, so that approach won't work.
-			return cocoaTextGetValueAttrib(ih);
-			break;
-		}
-		default:
-		{
-			return NULL;
-			break;
-		}
-	}
-	
-	
+        NSRange line_range = NSMakeRange(start_index, contents_end_index - start_index);
+        NSString* selected_string = [text_string substringWithRange:line_range];
+        return iupStrReturnStr([selected_string UTF8String]);
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+  case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        return cocoaTextGetValueAttrib(ih);
+        break;
+      }
+  default:
+      {
+        return NULL;
+        break;
+      }
+  }
 }
 
 static int cocoaTextSetCueBannerAttrib(Ihandle *ih, const char *value)
 {
-	NSString* ns_string;
-	
-	if(NULL == value)
-	{
-		ns_string = @"";
-	}
-	else
-	{
-		ns_string = [NSString stringWithUTF8String:value];
-	}
-	
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			[text_field setPlaceholderString:ns_string];
+  NSString* ns_string;
 
-			return  1;
-			
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			[text_field setPlaceholderString:ns_string];
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
+  if(NULL == value)
+  {
+    ns_string = @"";
+  }
+  else
+  {
+    ns_string = [NSString stringWithUTF8String:value];
+  }
 
-	return 0;
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        [text_field setPlaceholderString:ns_string];
+        return 1;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        [text_field setPlaceholderString:ns_string];
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return 0;
 }
 
-
-
-
-// NSControl's setEnabled didn't seem to do anything on NSTextField. Also, NSTextView isn't an NSControl.
 static int cocoaTextSetActiveAttrib(Ihandle* ih, const char* value)
 {
-	BOOL is_active = (BOOL)iupStrBoolean(value);
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			[text_view setSelectable:is_active];
+  BOOL is_active = (BOOL)iupStrBoolean(value);
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			[text_field setSelectable:is_active];
-			// This doesn't seem to have any visible effect
-			[text_field setEnabled:is_active];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        [text_view setSelectable:is_active];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        [text_field setSelectable:is_active];
+        [text_field setEnabled:is_active];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        [text_field setSelectable:is_active];
+        [text_field setEnabled:is_active];
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return 0;
+        NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+        [stepper_view setEnabled:is_active];
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return 0;
 }
 
 static char* cocoaTextGetActiveAttrib(Ihandle* ih)
 {
-	int is_active = true;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			is_active = [text_view isSelectable];
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-//			is_active = [text_field isEditable];
-			is_active = [text_field isSelectable];
+  int is_active = true;
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-//			is_active = [text_field isEditable];
-			is_active = [text_field isSelectable];
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        is_active = [text_view isSelectable];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        is_active = [text_field isSelectable];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+        is_active = [text_field isSelectable] && [stepper_view isEnabled];
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
-	return iupStrReturnBoolean(is_active);
+  return iupStrReturnBoolean(is_active);
 }
 
 static int cocoaTextSetReadOnlyAttrib(Ihandle* ih, const char* value)
 {
-	BOOL is_editable = !(BOOL)iupStrBoolean(value);
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			[text_view setEditable:is_editable];
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			[text_field setEditable:is_editable];
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			[text_field setEditable:is_editable];
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return 0;
+  BOOL is_editable = !(BOOL)iupStrBoolean(value);
+
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        [text_view setEditable:is_editable];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        [text_field setEditable:is_editable];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        [text_field setEditable:is_editable];
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return 0;
 }
 
 static char* cocoaTextGetReadOnlyAttrib(Ihandle* ih)
 {
-	int is_editable = true;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			is_editable = [text_view isEditable];
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			is_editable = [text_field isEditable];
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			is_editable = [text_field isEditable];
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+  int is_editable = true;
 
-	return iupStrReturnBoolean(!is_editable);
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        is_editable = [text_view isEditable];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        is_editable = [text_field isEditable];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        is_editable = [text_field isEditable];
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  return iupStrReturnBoolean(!is_editable);
 }
 
 static int cocoaTextSetAppendAttrib(Ihandle* ih, const char* value)
 {
-  if (!ih->handle)  /* do not do the action before map */
+  if (!ih->handle)
   {
-    	return 0;
+    return 0;
   }
-	
-	if(value == NULL)
-	{
-		return 0;
-	}
-	
+
+  if(value == NULL)
+  {
+    return 0;
+  }
+
   ih->data->disable_callbacks = 1;
   if(ih->data->is_multiline)
   {
-	  NSTextView* text_view = cocoaTextGetTextView(ih);
+    NSTextView* text_view = cocoaTextGetTextView(ih);
+    NSTextStorage* text_storage = [text_view textStorage];
 
-	  NSTextStorage* text_storage = [text_view textStorage];
+    NSString* ns_append_string = nil;
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
 
-	  
-	  NSString* ns_append_string = nil;
-		IupCocoaFont* iup_font = iupCocoaGetFont(ih);
+    if(ih->data->append_newline && ([text_storage length] > 0))
+    {
+      NSString* temp = [NSString stringWithUTF8String:value];
+      ns_append_string = [@"\n" stringByAppendingString:temp];
+    }
+    else
+    {
+      ns_append_string = [NSString stringWithUTF8String:value];
+    }
 
-		// NSTextStorage is a NSMutableAttributedString
-//	  NSMutableString* mutable_string = [text_storage mutableString];
-	  
-	  if(ih->data->append_newline && ([text_storage length] > 0))
-	  {
-		  ns_append_string = [NSString stringWithFormat:@"\n%s", value];
+    NSRange change_range = NSMakeRange([text_storage length], 0);
 
+    NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
+    [attribute_dict autorelease];
+    NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = nil;
+    if(change_range.location == 0)
+    {
+      text_storage_attributes = [iup_font attributeDictionary];
+    }
+    else
+    {
+      text_storage_attributes = [text_storage attributesAtIndex:change_range.location-1 effectiveRange:NULL];
+    }
 
-	  }
-	  else
-	  {
-		  ns_append_string = [NSString stringWithUTF8String:value];
+    [attribute_dict addEntriesFromDictionary:text_storage_attributes];
 
-	  }
-	  
-	  
-	  // We need to mark the proposed change range (before we change it) in order to call shouldChangeTextInRange:
-	  NSRange change_range = NSMakeRange([text_storage length], 0);
-	  
-	  
-	  // Use the current set font as the baseline. We will modify a local copy of its attributes from there.
-	  NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
-	  [attribute_dict autorelease];
-	  // Set the selection range to be at the very last character.
-	  // Get the attributes (if any) for the selected range, and merge it into our copy of the font's attributes.
-	  // This will overwrite/merge the current attributes into our font copy attributes.
-	  // Needs to be 1 character or it raises an exception
+    NSAttributedString* attributed_append_string = [[NSAttributedString alloc] initWithString:ns_append_string attributes:attribute_dict];
+    [attributed_append_string autorelease];
 
-		
-	  // This throws an exception if:
-	  // - We are the last character (we must use -1)
-	  // - But then we have a problem if the view is empty
-	  NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = nil;
-	  if(change_range.location == 0)
-	  {
-		  text_storage_attributes = [iup_font attributeDictionary];
-	  }
-	  else
-	  {
-		  text_storage_attributes = [text_storage attributesAtIndex:change_range.location-1 effectiveRange:NULL];
-	  }
-	  
-	  [attribute_dict addEntriesFromDictionary:text_storage_attributes];
+    NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+    [undo_manager beginUndoGrouping];
 
-	  
-	  NSAttributedString* attributed_append_string = [[NSAttributedString alloc] initWithString:ns_append_string attributes:attribute_dict];
-	  [attributed_append_string autorelease];
+    ih->data->disable_callbacks = 1;
+    [text_view shouldChangeTextInRange:change_range replacementString:[attributed_append_string string]];
+    [text_storage beginEditing];
 
-	  NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-	  [undo_manager beginUndoGrouping];
-	  
-	  ih->data->disable_callbacks = 1;
-  	  [text_view shouldChangeTextInRange:change_range replacementString:[attributed_append_string string]];
-	  [text_storage beginEditing];
+    [text_storage appendAttributedString:attributed_append_string];
 
-	  [text_storage appendAttributedString:attributed_append_string];
+    ih->data->disable_callbacks = 0;
 
-	  ih->data->disable_callbacks = 0;
+    [text_storage endEditing];
+    [text_view didChangeText];
+    [undo_manager endUndoGrouping];
 
-	  [text_storage endEditing];
+    /* Scroll to end to show the appended text */
+    NSRange end_range = NSMakeRange([[text_view string] length], 0);
+    [text_view scrollRangeToVisible:end_range];
+  }
+  else
+  {
+    IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+    switch(sub_type)
+    {
+      case IUPCOCOATEXTSUBTYPE_FIELD:
+        {
+          NSTextField* text_field = cocoaTextGetTextField(ih);
+          IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+          NSMutableAttributedString* old_string_value = [[[text_field attributedStringValue] mutableCopy] autorelease];
 
-		// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-	  [text_view didChangeText];
-	  [undo_manager endUndoGrouping];
+          NSString* ns_append_string = [NSString stringWithUTF8String:value];
 
+          NSAttributedString* attributed_append_string = [[NSAttributedString alloc] initWithString:ns_append_string attributes:[iup_font attributeDictionary]];
+          [attributed_append_string autorelease];
 
+          [old_string_value appendAttributedString:attributed_append_string];
 
+          break;
+        }
+      default:
+        {
+          break;
+        }
+    }
   }
-  else
-  {
-	  
-	  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	  switch(sub_type)
-	  {
-		  case IUPCOCOATEXTSUBTYPE_FIELD:
-		  {
-			  NSTextField* text_field = cocoaTextGetTextField(ih);
-			  IupCocoaFont* iup_font = iupCocoaGetFont(ih);
-			  // I don't know if the old string is attributed or not, so I need to assume it is
-			  NSMutableAttributedString* old_string_value = [[[text_field attributedStringValue] mutableCopy] autorelease];
-			  
-			  NSString* ns_append_string = [NSString stringWithUTF8String:value];
-			  
-			  
-			  NSAttributedString* attributed_append_string = [[NSAttributedString alloc] initWithString:ns_append_string attributes:[iup_font attributeDictionary]];
-			  [attributed_append_string autorelease];
-			  
-			  [old_string_value appendAttributedString:attributed_append_string];
-			  
-			  
-			  
-			  break;
-		  }
-		  default:
-		  {
-			  break;
-		  }
-	  }
-  }
-	
+
   ih->data->disable_callbacks = 0;
   return 0;
 }
 
-
 static int cocoaTextSetInsertAttrib(Ihandle* ih, const char* value)
 {
-	if(NULL == ih->handle)  /* do not do the action before map */
-	{
-		return 0;
-	}
-	if(NULL == value)
-	{
-		return 0;
-	}
+  if(NULL == ih->handle)
+  {
+    return 0;
+  }
+  if(NULL == value)
+  {
+    return 0;
+  }
 
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			NSTextStorage* text_storage = [text_view textStorage];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        NSTextStorage* text_storage = [text_view textStorage];
 
-			NSRange insertion_point = [[[text_view selectedRanges] lastObject] rangeValue];
-			if(NSNotFound == insertion_point.location)
-			{
-				// I guess we append if there is no cursor location?
-				// A bit of a hack...cocoaTextSetAppendAttrib does extra stuff I don't want, so this will temporarily disable those features.
-				int saved_newline = ih->data->append_newline;
-				ih->data->append_newline = 0;
-				int ret_val = cocoaTextSetAppendAttrib(ih, value);
-				ih->data->append_newline = saved_newline;
-				return ret_val;
-			}
-			else if([text_storage length] == insertion_point.location)
-			{
-				// We are appending
-				// A bit of a hack...cocoaTextSetAppendAttrib does extra stuff I don't want, so this will temporarily disable those features.
-				int saved_newline = ih->data->append_newline;
-				ih->data->append_newline = 0;
-				int ret_val = cocoaTextSetAppendAttrib(ih, value);
-				ih->data->append_newline = saved_newline;
-				return ret_val;
-			}
-			else if(insertion_point.length > 0)
-			{
-				// We do selected text
-				return cocoaTextSetSelectedTextAttrib(ih, value);
-			}
-			
-			// We can't use NSTextView insertText because
-			// if this is used to programmatically alter text while the widget is disabled,
-			// then the insert will fail.
-			// So we must alter NSTextStorage directly.
-			
-			IupCocoaFont* iup_font = iupCocoaGetFont(ih);
+        NSRange insertion_point = [[[text_view selectedRanges] lastObject] rangeValue];
+        if(NSNotFound == insertion_point.location)
+        {
+          int saved_newline = ih->data->append_newline;
+          ih->data->append_newline = 0;
+          int ret_val = cocoaTextSetAppendAttrib(ih, value);
+          ih->data->append_newline = saved_newline;
+          return ret_val;
+        }
+        else if([text_storage length] == insertion_point.location)
+        {
+          int saved_newline = ih->data->append_newline;
+          ih->data->append_newline = 0;
+          int ret_val = cocoaTextSetAppendAttrib(ih, value);
+          ih->data->append_newline = saved_newline;
+          return ret_val;
+        }
+        else if(insertion_point.length > 0)
+        {
+          return cocoaTextSetSelectedTextAttrib(ih, value);
+        }
 
-			// Use the current set font as the baseline. We will modify a local copy of its attributes from there.
-			NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
-			[attribute_dict autorelease];
-			// Set the selection range to be at the very last character.
-			// Get the attributes (if any) for the selected range, and merge it into our copy of the font's attributes.
-			// This will overwrite/merge the current attributes into our font copy attributes.
-			// Needs to be 1 character or it raises an exception
-			// We already know our location is not at the end and length==0
-			NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[text_storage attributedSubstringFromRange:NSMakeRange(insertion_point.location, 1)] attributesAtIndex:0 effectiveRange:NULL];
-			[attribute_dict addEntriesFromDictionary:text_storage_attributes];
-			
-			NSString* ns_insert_string = [NSString stringWithUTF8String:value];
-			
-			NSAttributedString* attributed_insert_string = [[NSAttributedString alloc] initWithString:ns_insert_string attributes:attribute_dict];
-			[attributed_insert_string autorelease];
-			
-			
-			NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-			[undo_manager beginUndoGrouping];
-			
-			ih->data->disable_callbacks = 1;
-			[text_view shouldChangeTextInRange:insertion_point replacementString:[attributed_insert_string string]];
-			[text_storage beginEditing];
-			
-			[text_storage insertAttributedString:attributed_insert_string atIndex:insertion_point.location];
-			
-			ih->data->disable_callbacks = 0;
-			
-			[text_storage endEditing];
-			
-			// We must call both shouldChangeTextInRange and didChangeText to keep the undo manager consistent
-			[text_view didChangeText];
-			[undo_manager endUndoGrouping];
-			
-			
+        IupCocoaFont* iup_font = iupcocoaGetFont(ih);
 
-			return 0;
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
-			NSRange selected_range = [field_editor selectedRange];
-			if(NSNotFound == selected_range.location)
-			{
-				// I guess we append if there is no cursor location?
-				return cocoaTextSetAppendAttrib(ih, value);
-			}
-			else if(selected_range.length > 0)
-			{
-				// We do selected text
-				return cocoaTextSetSelectedTextAttrib(ih, value);
-			}
-			
-			NSString* ns_string = [NSString stringWithUTF8String:value];
-			NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
-			[(NSTextView*)field_editor insertText:ns_string replacementRange:selected_range];
-			return 0;
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	return 0;
+        NSMutableDictionary* attribute_dict = [[iup_font attributeDictionary] mutableCopy];
+        [attribute_dict autorelease];
+        NSDictionary<NSAttributedStringKey, id>* text_storage_attributes = [[text_storage attributedSubstringFromRange:NSMakeRange(insertion_point.location, 1)] attributesAtIndex:0 effectiveRange:NULL];
+        [attribute_dict addEntriesFromDictionary:text_storage_attributes];
+
+        NSString* ns_insert_string = [NSString stringWithUTF8String:value];
+
+        NSAttributedString* attributed_insert_string = [[NSAttributedString alloc] initWithString:ns_insert_string attributes:attribute_dict];
+        [attributed_insert_string autorelease];
+
+        NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+        [undo_manager beginUndoGrouping];
+
+        ih->data->disable_callbacks = 1;
+        [text_view shouldChangeTextInRange:insertion_point replacementString:[attributed_insert_string string]];
+        [text_storage beginEditing];
+
+        [text_storage insertAttributedString:attributed_insert_string atIndex:insertion_point.location];
+
+        ih->data->disable_callbacks = 0;
+
+        [text_storage endEditing];
+
+        [text_view didChangeText];
+        [undo_manager endUndoGrouping];
+
+        return 0;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        NSText* field_editor = [[text_field window] fieldEditor:YES forObject:text_field];
+        NSRange selected_range = [field_editor selectedRange];
+        if(NSNotFound == selected_range.location)
+        {
+          return cocoaTextSetAppendAttrib(ih, value);
+        }
+        else if(selected_range.length > 0)
+        {
+          return cocoaTextSetSelectedTextAttrib(ih, value);
+        }
+
+        NSString* ns_string = [NSString stringWithUTF8String:value];
+        NSCAssert([field_editor isKindOfClass:[NSTextView class]], @"Expected that the field editor is a NSTextView");
+        [(NSTextView*)field_editor insertText:ns_string replacementRange:selected_range];
+        return 0;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+  return 0;
 }
 
-// UNDO, REDO only work for NSTextView
-// New feature: CLEARUNDO
 static int cocoaTextSetClipboardAttrib(Ihandle* ih, const char* value)
 {
-	ih->data->disable_callbacks = 1;
-	
-	NSView* the_view = nil;
-	
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			the_view = text_view;
-			
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			the_view = text_field;
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			the_view = text_field;
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	
-	if(iupStrEqualNoCase(value, "COPY"))
-	{
-		[[NSApplication sharedApplication] sendAction:@selector(copy:) to:the_view from:nil];
-		
-	}
-	else if(iupStrEqualNoCase(value, "CUT"))
-	{
-		[[NSApplication sharedApplication] sendAction:@selector(cut:) to:the_view from:nil];
-		
-	}
-	else if(iupStrEqualNoCase(value, "PASTE"))
-	{
-		[[NSApplication sharedApplication] sendAction:@selector(paste:) to:the_view from:nil];
-		
-	}
-	else if(iupStrEqualNoCase(value, "CLEAR"))
-	{
-		[[NSPasteboard generalPasteboard] clearContents];
-	}
-	else if(iupStrEqualNoCase(value, "UNDO"))
-	{
-		switch(sub_type)
-		{
-			case IUPCOCOATEXTSUBTYPE_VIEW:
-			{
-				NSTextView* text_view = (NSTextView*)the_view;
-				NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-				[undo_manager undo];
-				
-				break;
-			}
-			case IUPCOCOATEXTSUBTYPE_FIELD:
-			case IUPCOCOATEXTSUBTYPE_STEPPER:
-			{
-				// I haven't been able to make this work
-//				[the_view becomeFirstResponder];
-//				[[NSApplication sharedApplication] sendAction:@selector(undo:) to:nil from:nil];
-				
-				break;
-			}
-			default:
-			{
-				break;
-			}
-		}
-	}
-	else if(iupStrEqualNoCase(value, "REDO"))
-	{
-		switch(sub_type)
-		{
-			case IUPCOCOATEXTSUBTYPE_VIEW:
-			{
-				NSTextView* text_view = (NSTextView*)the_view;
-				NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-				[undo_manager redo];
-				
-				break;
-			}
-			case IUPCOCOATEXTSUBTYPE_FIELD:
-			case IUPCOCOATEXTSUBTYPE_STEPPER:
-			{
-				// I haven't been able to make this work
-//				[the_view becomeFirstResponder];
-//				[[NSApplication sharedApplication] sendAction:@selector(redo:) to:nil from:nil];
-				
-				break;
-			}
-			default:
-			{
-				break;
-			}
-		}
-	}
-	else if(iupStrEqualNoCase(value, "CLEARUNDO"))
-	{
-		switch(sub_type)
-		{
-			case IUPCOCOATEXTSUBTYPE_VIEW:
-			{
-				NSTextView* text_view = (NSTextView*)the_view;
-				NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-				[undo_manager removeAllActions];
-				
-				break;
-			}
-			case IUPCOCOATEXTSUBTYPE_FIELD:
-			case IUPCOCOATEXTSUBTYPE_STEPPER:
-			{
+  ih->data->disable_callbacks = 1;
 
-				break;
-			}
-			default:
-			{
-				break;
-			}
-		}
-	}
-	
+  NSView* the_view = nil;
+
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        the_view = text_view;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        the_view = text_field;
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        the_view = text_field;
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  if(iupStrEqualNoCase(value, "COPY"))
+  {
+    [[NSApplication sharedApplication] sendAction:@selector(copy:) to:the_view from:nil];
+  }
+  else if(iupStrEqualNoCase(value, "CUT"))
+  {
+    [[NSApplication sharedApplication] sendAction:@selector(cut:) to:the_view from:nil];
+  }
+  else if(iupStrEqualNoCase(value, "PASTE"))
+  {
+    /* Pasting is handled by the shouldChangeTextInRange: delegate methods. */
+    /* Programmatically triggering paste: will be validated by the delegate. */
+    [[NSApplication sharedApplication] sendAction:@selector(paste:) to:the_view from:nil];
+  }
+  else if(iupStrEqualNoCase(value, "CLEAR"))
+  {
+    [[NSPasteboard generalPasteboard] clearContents];
+  }
+  else if(iupStrEqualNoCase(value, "UNDO"))
+  {
+    switch(sub_type)
+    {
+      case IUPCOCOATEXTSUBTYPE_VIEW:
+        {
+          NSTextView* text_view = (NSTextView*)the_view;
+          NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+          [undo_manager undo];
+          break;
+        }
+      case IUPCOCOATEXTSUBTYPE_FIELD:
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+        {
+          break;
+        }
+    default:
+        {
+          break;
+        }
+    }
+  }
+  else if(iupStrEqualNoCase(value, "REDO"))
+  {
+    switch(sub_type)
+    {
+      case IUPCOCOATEXTSUBTYPE_VIEW:
+        {
+          NSTextView* text_view = (NSTextView*)the_view;
+          NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+          [undo_manager redo];
+          break;
+        }
+      case IUPCOCOATEXTSUBTYPE_FIELD:
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+        {
+          break;
+        }
+    default:
+        {
+          break;
+        }
+    }
+  }
+  else if(iupStrEqualNoCase(value, "CLEARUNDO"))
+  {
+    switch(sub_type)
+    {
+      case IUPCOCOATEXTSUBTYPE_VIEW:
+        {
+          NSTextView* text_view = (NSTextView*)the_view;
+          NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+          [undo_manager removeAllActions];
+          break;
+        }
+      case IUPCOCOATEXTSUBTYPE_FIELD:
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+        {
+          break;
+        }
+    default:
+        {
+          break;
+        }
+    }
+  }
+
   ih->data->disable_callbacks = 0;
   return 0;
 }
 
-
-
 static char* cocoaTextGetCountAttrib(Ihandle* ih)
 {
-	NSString* text_string = nil;
+  NSString* text_string = nil;
 
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			NSTextStorage* text_storage = [text_view textStorage];
-			text_string = [text_storage string];
-			
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      {
+        NSTextView* text_view = cocoaTextGetTextView(ih);
+        NSTextStorage* text_storage = [text_view textStorage];
+        text_string = [text_storage string];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      {
+        NSTextField* text_field = cocoaTextGetTextField(ih);
+        text_string = [text_field stringValue];
+        break;
+      }
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        text_string = [text_field stringValue];
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
-			
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			NSTextField* text_field = cocoaTextGetTextField(ih);
-			text_string = [text_field stringValue];
+  if((nil == text_string) || ([text_string length] == 0))
+  {
+    return iupStrReturnInt(0);
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			text_string = [text_field stringValue];
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	if((nil == text_string) || ([text_string length] == 0))
-	{
-		return iupStrReturnInt(0);
-	}
-	
-	// GOTCHA: Modern characters may be multiple bytes (e.g. emoji characters).
-	// Because of this, [string length] isn't correct, because it tells us the number of bytes, not characters.
-	// The correct thing to do is to iterate through the string and count the glyphs.
-	// But it probably is more expensive than what people think when they call this routine.
-	// See https://www.objc.io/issues/9-strings/unicode/
-	// NSString *s = @"The weather on \U0001F30D is \U0001F31E today.";
-	// The weather on  is  today.
+  NSUInteger glyph_count = cocoaTextCountGlyphsInString(text_string);
+  return iupStrReturnInt((int)glyph_count);
+}
 
-//	NSLog(@"length: %zu\n%@", [text_string length], text_string);
+static char* cocoaTextGetScrollVisibleAttrib(Ihandle* ih)
+{
+  if(!ih->data->is_multiline)
+    return NULL;
 
-	NSUInteger glyph_count = cocoaTextCountGlyphsInString(text_string);
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  if(sub_type == IUPCOCOATEXTSUBTYPE_VIEW)
+  {
+    NSScrollView* scroll_view = (NSScrollView*)cocoaTextGetRootView(ih);
+    if([scroll_view isKindOfClass:[NSScrollView class]])
+    {
+      BOOL has_horizontal = [scroll_view hasHorizontalScroller];
+      BOOL has_vertical = [scroll_view hasVerticalScroller];
 
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	return iupStrReturnInt((int)glyph_count);
+      if(has_horizontal && has_vertical)
+        return "YES";
+      else if(has_vertical)
+        return "VERTICAL";
+      else if(has_horizontal)
+        return "HORIZONTAL";
+      else
+        return "NO";
+    }
+  }
+
+  return "NO";
 }
 
-// This includes wrapped lines in the count.
-// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/Tasks/CountLines.html
-static char* cocoaTextGetLineCountAttrib(Ihandle* ih)
+static int cocoaTextSetOverwriteAttrib(Ihandle* ih, const char* value)
 {
-	if(!ih->data->is_multiline)
-	{
-		return "1";
-	}
-	
-	NSTextView* text_view = cocoaTextGetTextView(ih);
-	
-	NSLayoutManager* layout_manager = [text_view layoutManager];
-	NSUInteger number_of_lines;
-	NSUInteger index;
-	
-	NSUInteger number_of_glyphs = [layout_manager numberOfGlyphs];
-	NSRange line_range = NSMakeRange(0, 0);
-	
-	for(number_of_lines = 0, index = 0; index < number_of_glyphs;)
-	{
-		(void) [layout_manager lineFragmentRectForGlyphAtIndex:index effectiveRange:&line_range];
-		index = NSMaxRange(line_range);
-	}
-	
-	// FIXME: Iup is artificially constraining us to 32-bit by not supporting 64-bit variants.
-	return iupStrReturnInt((int)number_of_lines);
+  if(!ih->data->is_multiline)
+    return 0;
+
+  NSTextView* text_view = cocoaTextGetTextView(ih);
+  if(nil == text_view)
+    return 0;
+
+  if(iupStrBoolean(value))
+    objc_setAssociatedObject(text_view, IUP_COCOA_TEXT_OVERWRITE_KEY, @(YES), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  else
+    objc_setAssociatedObject(text_view, IUP_COCOA_TEXT_OVERWRITE_KEY, @(NO), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+
+  return 1;
 }
 
+static char* cocoaTextGetOverwriteAttrib(Ihandle* ih)
+{
+  if(!ih->data->is_multiline)
+    return NULL;
 
-/************************************** Begin SPIN *****************************************************/
+  NSTextView* text_view = cocoaTextGetTextView(ih);
+  if(nil == text_view)
+    return NULL;
 
-static int cocoaTextSetSpinValueAttrib(Ihandle* ih, const char* value)
+  NSNumber* overwrite = objc_getAssociatedObject(text_view, IUP_COCOA_TEXT_OVERWRITE_KEY);
+  return iupStrReturnBoolean([overwrite boolValue]);
+}
+
+static char* cocoaTextGetLineCountAttrib(Ihandle* ih)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// Neither the field nor the cell work. I think I must change the field editor.
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			
-			int int_value = 0;
-			if(iupStrToInt(value, &int_value))
-			{
-				ih->data->disable_callbacks = 1;
+  if(!ih->data->is_multiline)
+  {
+    return "1";
+  }
 
-				NSStepper* stepper_view = cocoaTextGetStepperView(ih);
-				double max_value = [stepper_view maxValue];
-				if((double)int_value > max_value)
-				{
-					int_value = (int)max_value;
-				}
-				double min_value = [stepper_view minValue];
-				if((double)int_value < min_value)
-				{
-					int_value = (int)min_value;
-				}
-				
-				if(iupAttribGetBoolean(ih, "SPINAUTO"))
-				{
-					// With Cocoa Bindings, we must set the model or controller, not the view.
-					// Otherwise, if we set the view directly,
-					// when we click on the stepper, it will have a stale version of the world
-					// and increment from the stale value instead of the value seen in the field.
-					NSNumber* number_to_set = [NSNumber numberWithInt:int_value];
-					IUPStepperObject* stepper_object = cocoaTextGetStepperObject(ih);
-					[stepper_object setStepperValue:number_to_set];
-				}
-				else
-				{
-					NSString* ns_string = [NSString stringWithFormat:@"%d", int_value];
-					[text_field setStringValue:ns_string];
-				}
+  NSTextView* text_view = cocoaTextGetTextView(ih);
 
-				ih->data->disable_callbacks = 0;
+  NSLayoutManager* layout_manager = [text_view layoutManager];
+  NSUInteger number_of_lines;
+  NSUInteger index;
 
-			}
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return 1;
-}
+  NSUInteger number_of_glyphs = [layout_manager numberOfGlyphs];
+  NSRange line_range = NSMakeRange(0, 0);
 
+  for(number_of_lines = 0, index = 0; index < number_of_glyphs;)
+  {
+    (void) [layout_manager lineFragmentRectForGlyphAtIndex:index effectiveRange:&line_range];
+    index = NSMaxRange(line_range);
+  }
 
-
-static char* cocoaTextGetSpinValueAttrib(Ihandle* ih)
-{
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// Neither the field nor the cell work. I think I must change the field editor.
-			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-			NSString* ns_string = [text_field stringValue];
-			return iupStrReturnStr([ns_string UTF8String]);
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	return NULL;
+  return iupStrReturnInt((int)number_of_lines);
 }
 
+/************************************** Begin SPIN *****************************************************/
 
-static int cocoaTextSetSpinMinAttrib(Ihandle* ih, const char* value)
+static int cocoaTextSetSpinValueAttrib(Ihandle* ih, const char* value)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			int new_min;
-			if(iupStrToInt(value, &new_min))
-			{
-				ih->data->disable_callbacks = 1;
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
 
-				// TODO: What if min > max?
-				// TODO: What if current value is outside new range?
-				NSStepper* stepper_view = cocoaTextGetStepperView(ih);
-				[stepper_view setMinValue:(double)new_min];
+        int int_value = 0;
+        if(iupStrToInt(value, &int_value))
+        {
+          ih->data->disable_callbacks = 1;
 
-				ih->data->disable_callbacks = 0;
-			}
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+          NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+          double max_value = [stepper_view maxValue];
+          if((double)int_value > max_value)
+          {
+            int_value = (int)max_value;
+          }
+          double min_value = [stepper_view minValue];
+          if((double)int_value < min_value)
+          {
+            int_value = (int)min_value;
+          }
 
-	return 1;
-}
+          if(iupAttribGetBoolean(ih, "SPINAUTO"))
+          {
+            NSNumber* number_to_set = [NSNumber numberWithInt:int_value];
+            IUPStepperObject* stepper_object = cocoaTextGetStepperObject(ih);
+            [stepper_object setStepperValue:number_to_set];
+          }
+          else
+          {
+            NSString* ns_string = [NSString stringWithFormat:@"%d", int_value];
+            [text_field setStringValue:ns_string];
+          }
 
-static int cocoaTextSetSpinMaxAttrib(Ihandle* ih, const char* value)
-{
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			int new_max;
-			if(iupStrToInt(value, &new_max))
-			{
-				ih->data->disable_callbacks = 1;
-				
-				// TODO: What if min > max?
-				// TODO: What if current value is outside new range?
-				NSStepper* stepper_view = cocoaTextGetStepperView(ih);
-				[stepper_view setMaxValue:(double)new_max];
+          ih->data->disable_callbacks = 0;
+        }
 
-				ih->data->disable_callbacks = 0;
-			}
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
-	return 1;
+  return 1;
 }
 
-static int cocoaTextSetSpinIncAttrib(Ihandle* ih, const char* value)
+static char* cocoaTextGetSpinValueAttrib(Ihandle* ih)
 {
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			int new_inc;
-			if(iupStrToInt(value, &new_inc))
-			{
-				ih->data->disable_callbacks = 1;
-				
-				NSStepper* stepper_view = cocoaTextGetStepperView(ih);
-				[stepper_view setIncrement:(double)new_inc];
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        NSTextField* text_field = cocoaTextGetStepperTextField(ih);
+        NSString* ns_string = [text_field stringValue];
+        return iupStrReturnStr([ns_string UTF8String]);
 
-				ih->data->disable_callbacks = 0;
-			}
-			
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
-	return 1;
+  return NULL;
 }
 
+static int cocoaTextSetSpinMinAttrib(Ihandle* ih, const char* value)
+{
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        int new_min;
+        if(iupStrToInt(value, &new_min))
+        {
+          ih->data->disable_callbacks = 1;
 
+          NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+          [stepper_view setMinValue:(double)new_min];
 
-/************************************** End SPIN *****************************************************/
+          ih->data->disable_callbacks = 0;
+        }
 
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
+  return 1;
+}
 
-
-// Need to override because the position offsets are wrong otherwise.
-static void cocoaTextLayoutUpdateMethod(Ihandle* ih)
+static int cocoaTextSetSpinMaxAttrib(Ihandle* ih, const char* value)
 {
-	// This may be called before we have a native parent
-	InativeHandle* parent_native_handle_direct = iupChildTreeGetNativeParentHandle(ih);
-	NSView* parent_view = nil;
-	
-	// This may be called before we have a native parent, in which case it returns -1
-	if((void*)-1 == parent_native_handle_direct)
-	{
-		return;
-	}
-	
-	NSObject* parent_native_handle = (NSObject*)parent_native_handle_direct;
-	
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        int new_max;
+        if(iupStrToInt(value, &new_max))
+        {
+          ih->data->disable_callbacks = 1;
 
-	
-	if([parent_native_handle isKindOfClass:[NSWindow class]])
-	{
-		NSWindow* parent_window = (NSWindow*)parent_native_handle;
-		parent_view = [parent_window contentView];
-	}
-	/* // Part of NSBox experiment
-	 else if([parent_native_handle isKindOfClass:[NSBox class]])
-	 {
-		NSBox* box_view = (NSBox*)parent_native_handle;
-		parent_view = [box_view contentView];
-		
-		CGFloat diff_width = NSWidth([box_view frame]) - NSWidth([parent_view frame]);
-		CGFloat diff_height = NSHeight([box_view frame]) - NSHeight([parent_view frame]);
-	 
-		current_width = current_width - diff_width;
-		current_height = current_height - diff_height;
-	 }
-	 */
-	else if([parent_native_handle isKindOfClass:[NSView class]])
-	{
-		parent_view = (NSView*)parent_native_handle;
-	}
-	else
-	{
-		NSCAssert(1, @"Unexpected type for parent widget");
-		@throw @"Unexpected type for parent widget";
-	}
-	
-	NSRect parent_rect = [parent_view frame];
+          NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+          [stepper_view setMaxValue:(double)new_max];
 
-	NSRect the_rect;
-	id child_handle = ih->handle;
-	NSView* the_view = nil;
-	if(!ih->data->is_multiline)
-	{
-//		the_view = (NSView*)child_handle;
-		
-//		NSTextField* text_field = (NSTextField*)child_handle;
+          ih->data->disable_callbacks = 0;
+        }
 
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
-		CGFloat current_width = (CGFloat)ih->currentwidth;
-		CGFloat current_height = (CGFloat)ih->currentheight;
-		
-		NSLog(@"old ih->currentheight=%d", ih->currentheight);
-		CGFloat pos_x = (CGFloat)ih->x;
-		// Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-//		CGFloat pos_y = parent_rect.size.height - (CGFloat)ih->y - (CGFloat)ih->currentheight;
-		
-		// NSTextField is all guess work about how to scale for any font size.
-		// Throw away ih->currentheight because it will EXPAND it.
-		// But for the standard font, we get fontheight=16 and we want the height to be 22
-		int font_height = 0;
-		iupdrvFontGetCharSize(ih, NULL, &font_height);
-		const CGFloat HEIGHT_PADDING = 6.0;
-		const CGFloat WIDTH_PADDING = 12.0;
+  return 1;
+}
 
-		current_height = font_height + HEIGHT_PADDING;
+static int cocoaTextSetSpinIncAttrib(Ihandle* ih, const char* value)
+{
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch(sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      {
+        int new_inc;
+        if(iupStrToInt(value, &new_inc))
+        {
+          ih->data->disable_callbacks = 1;
 
-		current_width = current_width - WIDTH_PADDING;
+          NSStepper* stepper_view = cocoaTextGetStepperView(ih);
+          [stepper_view setIncrement:(double)new_inc];
 
-		// Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-		CGFloat pos_y = parent_rect.size.height - (CGFloat)ih->y - current_height;
+          ih->data->disable_callbacks = 0;
+        }
 
-		
-		pos_x = pos_x + WIDTH_PADDING*0.5;
-//		pos_y = pos_y - HEIGHT_PADDING*0.5; // I don't realy understand the logic of this offset, particularly the -1
-//		pos_y = pos_y - HEIGHT_PADDING*0.5 - 1; // I don't realy understand the logic of this offset, particularly the -1
-//		pos_y = pos_y + HEIGHT_PADDING*0.5 - 1; // I don't realy understand the logic of this offset, particularly the -1
-		
-		the_rect = NSMakeRect(
-									 pos_x,
-									 // Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-									 pos_y,
-									 current_width,
-									 current_height
-									 );
-		
-//		ih->currentheight = current_height;
-//		ih->currentwidth = current_width;
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
 
-//		ih->x = pos_x;
-//		ih->y = pos_y;
-		
-		// for padding
-		// drat, data is private and requires a per-widget header
-		{
-			
-			char* padding_str = iupAttribGet(ih, "PADDING");
-			if((NULL != padding_str) && (padding_str[0] != '\0'))
-			{
-				int horiz_padding = 0;
-				int vert_padding = 0;
-				iupStrToIntInt(padding_str, &horiz_padding, &vert_padding, 'x');
-				
-				NSRect old_frame = the_rect;
-				NSRect new_frame;
-				new_frame.origin.x = old_frame.origin.x + (CGFloat)horiz_padding*0.5;
-				new_frame.origin.y = old_frame.origin.y + (CGFloat)vert_padding*0.5;
-				new_frame.size.width = old_frame.size.width - (CGFloat)horiz_padding;
-				new_frame.size.height = old_frame.size.height - (CGFloat)vert_padding;
-				
-				the_rect = new_frame;
-			}
-			
-		}
-		
-	}
-	else
-	{
-//		NSTextView* text_view = (NSTextView*)child_handle;
-		
-		
-		the_rect = NSMakeRect(
-									 ih->x,
-									 // Need to invert y-axis, and also need to shift/account for height of widget because that is also lower-left instead of upper-left.
-									 parent_rect.size.height - ih->y - ih->currentheight,
-									 ih->currentwidth,
-									 ih->currentheight
-									 );
-		
-		// for padding
-		// drat, data is private and requires a per-widget header
-		{
-			
-			char* padding_str = iupAttribGet(ih, "PADDING");
-			if((NULL != padding_str) && (padding_str[0] != '\0'))
-			{
-				int horiz_padding = 0;
-				int vert_padding = 0;
-				iupStrToIntInt(padding_str, &horiz_padding, &vert_padding, 'x');
-				
-				NSRect old_frame = the_rect;
-				NSRect new_frame;
-				new_frame.origin.x = old_frame.origin.x + (CGFloat)horiz_padding*0.5;
-				new_frame.origin.y = old_frame.origin.y + (CGFloat)vert_padding*0.5;
-				new_frame.size.width = old_frame.size.width - (CGFloat)horiz_padding;
-				new_frame.size.height = old_frame.size.height - (CGFloat)vert_padding;
-				
-				the_rect = new_frame;
-			}
-			
-		}
-
-	}
-
-	
-	
-	//	iupgtkNativeContainerMove((GtkWidget*)parent, widget, x, y);
-	
-	//	iupgtkSetPosSize(GTK_CONTAINER(parent), widget, ih->x, ih->y, ih->currentwidth, ih->currentheight);
-	
-	/*
-	 CGSize fitting_size = [the_view fittingSize];
-	 ih->currentwidth = fitting_size.width;
-	 ih->currentheight = fitting_size.height;
-	 */
-	
-	
-#if 0 // experiment to try to handle NSBox directly instead of using cocoaFrameGetInnerNativeContainerHandleMethod. I think cocoaFrameGetInnerNativeContainerHandleMethod is better, but
-#else
-	
-
-	
-
-	
-	
-	[the_view setFrame:the_rect];
-#endif
-	
+  return 1;
 }
 
+/************************************** End SPIN *****************************************************/
 
 static int cocoaTextSetContextMenuAttrib(Ihandle* ih, const char* value)
 {
-	Ihandle* menu_ih = (Ihandle*)value;
-	
-	IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
-	switch(sub_type)
-	{
-		case IUPCOCOATEXTSUBTYPE_VIEW:
-		{
-			NSTextView* text_view = cocoaTextGetTextView(ih);
-			
-			iupCocoaCommonBaseSetContextMenuForWidget(ih, text_view, menu_ih);
+  Ihandle* menu_ih = (Ihandle*)value;
+  id widget_to_attach = nil;
 
+  IupCocoaTextSubType sub_type = cocoaTextGetSubType(ih);
+  switch (sub_type)
+  {
+    case IUPCOCOATEXTSUBTYPE_VIEW:
+      widget_to_attach = cocoaTextGetTextView(ih);
+      break;
+    case IUPCOCOATEXTSUBTYPE_FIELD:
+      widget_to_attach = cocoaTextGetTextField(ih);
+      break;
+    case IUPCOCOATEXTSUBTYPE_STEPPER:
+      widget_to_attach = cocoaTextGetStepperTextField(ih);
+      break;
+    default:
+      return 0;
+  }
 
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_FIELD:
-		{
-			// Neither the field nor the cell work. I think I must change the field editor.
-//			NSTextField* text_field = cocoaTextGetTextField(ih);
+  iupcocoaCommonBaseSetContextMenuForWidget(ih, widget_to_attach, menu_ih);
 
-			// We can't use iupCocoaCommonBaseSetContextMenuForWidget() because field editors are shared.
-			// We will override textView:menu:forEvent:atIndex: and inject the menu options there.
-			if(NULL != menu_ih)
-			{
-				// FIXME: The Menu might not be IupMap'd yet. (Presumably because we do not attach it directly to a dialog in this case.)
-				// I think calling IupMap() is the correct thing to do and fixes the problem.
-				// But this should be reviewed.
-				if(NULL == menu_ih->handle)
-				{
-					IupMap(menu_ih);
-				}
-			}
-			// Save the menu_ih so we can access it in the callback
-			iupAttribSet(ih, "_COCOA_CONTEXT_MENU_IH", (const char*)menu_ih);
-
-			break;
-		}
-		case IUPCOCOATEXTSUBTYPE_STEPPER:
-		{
-			// Neither the field nor the cell work. I think I must change the field editor.
-//			NSTextField* text_field = cocoaTextGetStepperTextField(ih);
-
-			// We can't use iupCocoaCommonBaseSetContextMenuForWidget() because field editors are shared.
-			// We will override textView:menu:forEvent:atIndex: and inject the menu options there.
-			if(NULL != menu_ih)
-			{
-				// FIXME: The Menu might not be IupMap'd yet. (Presumably because we do not attach it directly to a dialog in this case.)
-				// I think calling IupMap() is the correct thing to do and fixes the problem.
-				// But this should be reviewed.
-				if(NULL == menu_ih->handle)
-				{
-					IupMap(menu_ih);
-				}
-			}
-			// Save the menu_ih so we can access it in the callback
-			iupAttribSet(ih, "_COCOA_CONTEXT_MENU_IH", (const char*)menu_ih);
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-	
-	
-	
-	
-	return 1;
+  return 1;
 }
 
-
 static int cocoaTextMapMethod(Ihandle* ih)
 {
-	NSView* root_view = nil;
-	NSView* main_view = nil;
+  NSView* root_view = nil;
+  NSView* main_view = nil;
 
-	
-	if (ih->data->is_multiline)
-	{
-		// We need to put the textview in a scrollview
-		// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextUILayer/Tasks/TextInScrollView.html
+  if (ih->data->is_multiline)
+  {
+    NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
+    NSSize scrollview_content_size = [scroll_view contentSize];
+    NSTextView* text_view;
 
-		NSScrollView* scroll_view = [[NSScrollView alloc] initWithFrame:NSZeroRect];
-		NSSize scrollview_content_size = [scroll_view contentSize];
-		
-		[scroll_view setBorderType:NSNoBorder];
-		[scroll_view setHasVerticalScroller:YES];
-		[scroll_view setHasHorizontalScroller:NO];
-//		[scroll_view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
-		
-		
-		NSTextView* text_view = [[NSTextView alloc] initWithFrame:NSZeroRect];
-//		NSTextView* text_view = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, 400, 400)];
+    if (iupAttribGetBoolean(ih, "BORDER"))
+      [scroll_view setBorderType:NSBezelBorder];
+    else
+      [scroll_view setBorderType:NSNoBorder];
 
-		
-		text_view = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, scrollview_content_size.width, scrollview_content_size.height)];
+    [scroll_view setHasVerticalScroller:YES];
+    [scroll_view setHasHorizontalScroller:YES];
+    [scroll_view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
 
-		[text_view setMinSize:NSMakeSize(0.0, 0.0)];
-		[text_view setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];
-		[text_view setVerticallyResizable:YES];
-		[text_view setHorizontallyResizable:NO];
-		// This NSViewWidthSizable I still need despite disabling the others. Otherwise using SHRINK with horizontal scrollbars continues to grow and never shrink.
-		[text_view setAutoresizingMask:NSViewWidthSizable];
-//		[[text_view textContainer] setContainerSize:NSMakeSize(scrollview_content_size.width, FLT_MAX)];
-//		[[text_view textContainer] setWidthTracksTextView:YES];
-		// Needed to allow things like Cmd-E (put in search buffer), Cmd-G (find next), and the standard Find panel. Even if you don't want the standard find panel, a broken cmd-e/cmd-g is bad.
-		[text_view setUsesFindPanel:YES];
-		[text_view setAllowsUndo:YES];
+    text_view = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0,
+        scrollview_content_size.width, scrollview_content_size.height)];
 
-		[scroll_view setDocumentView:text_view];
-		[text_view release];
+    [text_view setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];
+    [text_view setVerticallyResizable:YES];
+    [text_view setHorizontallyResizable:YES];
+    [text_view setAutoresizingMask:NSViewWidthSizable];
 
+    [text_view setEditable:!iupAttribGetBoolean(ih, "READONLY")];
+    [text_view setSelectable:YES];
+    [text_view setRichText:ih->data->has_formatting];
+    [text_view setImportsGraphics:NO];
+    [text_view setUsesFindPanel:YES];
+    [text_view setAllowsUndo:YES];
+    [text_view setUsesRuler:NO];
 
-		
-		
-		root_view = scroll_view;
-		main_view = text_view;
+    /* Set text container inset - NSSize(width, height) where width=left+right, height=top+bottom
+     * Use 4.0 for width (2px left + 2px right) and 2.0 for height (1px top + 1px bottom) */
+    [text_view setTextContainerInset:NSMakeSize(4.0, 2.0)];
 
-		
+    NSTextContainer* text_container = [text_view textContainer];
+    [text_container setContainerSize:NSMakeSize(scrollview_content_size.width, FLT_MAX)];
+    [text_container setWidthTracksTextView:YES];
 
-		int wordwrap = 0;
+    [scroll_view setDocumentView:text_view];
 
+    if (iupAttribGetBoolean(ih, "WORDWRAP"))
+    {
+      ih->data->sb &= ~IUP_SB_HORIZ;
 
-		// Make sure the text view is synchronized with the variable.
-		[text_view setRichText:ih->data->has_formatting];
-//		[text_view setImportsGraphics:ih->data->has_formatting];
-		[text_view setImportsGraphics:NO];
+      [scroll_view setHasHorizontalScroller:NO];
+      [text_view setHorizontallyResizable:NO];
+      [text_container setContainerSize:NSMakeSize(scrollview_content_size.width, FLT_MAX)];
+      [text_container setWidthTracksTextView:YES];
+      [text_container setLineFragmentPadding:0.0];
+    }
+    else
+    {
+      [scroll_view setHasHorizontalScroller:YES];
+      [text_view setHorizontallyResizable:YES];
+      [text_container setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];
+      [text_container setWidthTracksTextView:NO];
+      [text_container setLineFragmentPadding:0.0];
+    }
 
-		if (iupAttribGetBoolean(ih, "WORDWRAP"))
-		{
-			wordwrap = 1;
-			ih->data->sb &= ~IUP_SB_HORIZ;  /* must remove the horizontal scroolbar */
-			
-			
-//			[[text_view enclosingScrollView] setHasHorizontalScroller:YES];
-			[[text_view enclosingScrollView] setHasHorizontalScroller:NO];
-			[text_view setHorizontallyResizable:YES];
-//			[text_view setAutoresizingMask:(NSViewWidthSizable | NSViewHeightSizable)];
-			[[text_view textContainer] setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];
-			[[text_view textContainer] setWidthTracksTextView:YES];
+    if (ih->data->sb & IUP_SB_HORIZ)
+      [scroll_view setHasHorizontalScroller:YES];
+    else
+      [scroll_view setHasHorizontalScroller:NO];
 
-		}
-		else
-		{
-			/*
-			NSSize layout_size = [text_view maxSize];
-			layout_size.width = layout_size.height;
-			[text_view setMaxSize:layout_size];
-			[[text_view textContainer] setWidthTracksTextView:NO];
-			[[text_view textContainer] setContainerSize:layout_size];
-			*/
-			
-			[[text_view enclosingScrollView] setHasHorizontalScroller:YES];
-			[text_view setHorizontallyResizable:NO];
-//			[text_view setAutoresizingMask:(NSViewWidthSizable | NSViewHeightSizable)];
-//			[[text_view textContainer] setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];
-//			[[text_view textContainer] setWidthTracksTextView:YES];
-			
-		}
-		
-		
-		IupCocoaTextViewDelegate* text_view_delegate = [[IupCocoaTextViewDelegate alloc] init];
-		[text_view setDelegate:text_view_delegate];
-		[text_view_delegate setIhandle:ih];
-		objc_setAssociatedObject(text_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-		// putting on the text_field just for storage. This is to make it consistent with the regular NSTextField (non-spinner) case.
-		objc_setAssociatedObject(text_view, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, (id)text_view_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
-		[text_view_delegate release];
-		
-		
+    if (!(ih->data->sb & IUP_SB_VERT))
+      [scroll_view setHasVerticalScroller:NO];
 
+    IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+    if (iup_font)
+    {
+      [text_view setFont:[iup_font nativeFont]];
+      [text_view setTypingAttributes:[iup_font attributeDictionary]];
+    }
 
-		
-	}
-	else if(iupAttribGetBoolean(ih, "SPIN"))
-	{
-		// TODO: NSStepper
+    [text_view setTextColor:[NSColor textColor]];
+    [text_view setBackgroundColor:[NSColor textBackgroundColor]];
 
-#if 0
-//		NSView* container_view = [[NSView alloc] initWithFrame:NSZeroRect];
-//		NSView* container_view = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, 200, 27)];
-		NSStackView* container_view = [[NSStackView alloc] initWithFrame:NSZeroRect];
-		[container_view setSpacing:4.0];
-		
-		NSRect stepper_rect = NSMakeRect(0, 0, 19, 27);
-		NSStepper* stepper_view = [[NSStepper alloc] initWithFrame:stepper_rect];
-		IupCocoaTextField* text_field = [[IupCocoaTextField alloc] initWithFrame:NSZeroRect];
-//		NSTextField* text_field = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 200-19, 22)];
+    root_view = scroll_view;
+    main_view = text_view;
 
-		
-//		[container_view addSubview:text_field];
-//		[text_field addSubview:stepper_view];
+    IupCocoaTextViewDelegate* text_view_delegate = [[IupCocoaTextViewDelegate alloc] init];
+    [text_view setDelegate:text_view_delegate];
+    [text_view_delegate setIhandle:ih];
+    objc_setAssociatedObject(text_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+    objc_setAssociatedObject(text_view, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, text_view_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    [text_view_delegate release];
+    [text_view release];
+  }
+  else if(iupAttribGetBoolean(ih, "SPIN"))
+  {
+    NSBundle* framework_bundle = [NSBundle bundleWithIdentifier:@"br.puc-rio.tecgraf.iup"];
+    NSNib* text_spinner_nib = nil;
+    if(!iupAttribGetBoolean(ih, "SPINAUTO"))
+    {
+      text_spinner_nib = [NSNib IupTextSpinnerNoBindings];
+    }
+    else
+    {
+      text_spinner_nib = [NSNib IupTextSpinner];
+    }
 
-		[container_view addView:text_field inGravity:NSStackViewGravityLeading];
-		[container_view addView:stepper_view inGravity:NSStackViewGravityTrailing];
-		[stepper_view release];
-		[text_field release];
-		
-//		[container_view setAutoresizingMask:(NSViewWidthSizable | NSViewHeightSizable)];
-//		[text_field setAutoresizingMask:(NSViewWidthSizable)];
-		
-		root_view = container_view;
-		main_view = text_field;
+    NSArray* top_level_objects = nil;
+    IUPTextSpinnerFilesOwner* files_owner = [[IUPTextSpinnerFilesOwner alloc] init];
+    IUPTextSpinnerContainer* text_spinner_container = [[IUPTextSpinnerContainer alloc] init];
 
-#else
+    [text_spinner_nib instantiateWithOwner:files_owner topLevelObjects:&top_level_objects];
 
-		// The NIB file has setup the NSStackView and also the Cocoa Bindings to connect the textfield and stepper.
-		
-		NSBundle* framework_bundle = [NSBundle bundleWithIdentifier:@"br.puc-rio.tecgraf.iup"];
-		NSNib* text_spinner_nib = nil;
-		if(!iupAttribGetBoolean(ih, "SPINAUTO"))
-		{
-			text_spinner_nib = [[NSNib alloc] initWithNibNamed:@"IupTextSpinnerNoBindings" bundle:framework_bundle];
-		}
-		else
-		{
-			text_spinner_nib = [[NSNib alloc] initWithNibNamed:@"IupTextSpinner" bundle:framework_bundle];
-		}
-		
+    NSStackView* stack_view = [files_owner stackView];
+    NSStepper* stepper_view = [files_owner stepperView];
+    NSTextField* text_field = [files_owner textField];
+    IUPStepperObject* stepper_object = [files_owner stepperObject];
+    IUPStepperObjectController* stepper_object_controller = [files_owner stepperObjectController];
 
+    [text_spinner_container setStepperView:stepper_view];
+    [text_spinner_container setTextField:text_field];
+    [text_spinner_container setStepperObject:stepper_object];
+    [text_spinner_container setStepperObjectController:stepper_object_controller];
 
-		NSArray* top_level_objects = nil;
-		IUPTextSpinnerFilesOwner* files_owner = [[IUPTextSpinnerFilesOwner alloc] init];
-		IUPTextSpinnerContainer* text_spinner_container = [[IUPTextSpinnerContainer alloc] init];
+    objc_setAssociatedObject(stack_view, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY, (id)text_spinner_container, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 
-		// We can either fish out the objects we want (and retain them) in the top_level_objects,
-		// or for my convenience, I made a File's Owner object and wired up all the major elements so I can retrive them easily.
-		// Note: top_level_objects must be explicitly retained if I want to keep it around. (I don't need to keep it around so I don't retain it.))
-		[text_spinner_nib instantiateWithOwner:files_owner topLevelObjects:&top_level_objects];
-		
-		/*
-		Messy: There are multiple objects including an NSObject and NSObjectController in the NIB.
-		I originally thought about making a NSObject subclass which holds all the components and make it the ih->handle.
-		But a non-NSView as the ih->handle breaks an implicit assumption used by the common core.
-		So instead, we'll make the NSStackView the root container object for the ih->handle.
-		But we will still make a NSObject subclass that holds the remaining components.
-		We will use setAssociatedObject to keep these objects connected, while avoiding the need to subclass NSStackView just to hold this property.
-		*/
-		NSStackView* stack_view = [files_owner stackView];
-		NSStepper* stepper_view = [files_owner stepperView];
-		NSTextField* text_field = [files_owner textField];
-		IUPStepperObject* stepper_object = [files_owner stepperObject];
-		IUPStepperObjectController* stepper_object_controller = [files_owner stepperObjectController];
+    root_view = [stack_view retain];
+    main_view = text_field;
 
-		[text_spinner_container setStepperView:stepper_view];
-		[text_spinner_container setTextField:text_field];
-		[text_spinner_container setStepperObject:stepper_object];
-		[text_spinner_container setStepperObjectController:stepper_object_controller];
-		
-		// can't turn off decimals in IB, so do it here.
-		{
-			NSNumberFormatter* number_formatter = [text_field formatter];
-			[number_formatter setMaximumFractionDigits:0];
-		}
+    [text_spinner_container release];
+    [files_owner release];
+    [text_spinner_nib release];
 
-		// We're going to use OBJC_ASSOCIATION_RETAIN because I do believe it will do the right thing for us.
-		objc_setAssociatedObject(stack_view, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY, (id)text_spinner_container, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
+    [number_formatter autorelease];
+    [number_formatter setIhandle:ih];
+    [number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
+    [number_formatter setPartialStringValidationEnabled:YES];
+    [number_formatter setNumberStyle:NSNumberFormatterNoStyle];
+    [text_field setFormatter:number_formatter];
 
-		
-		root_view = [stack_view retain];
-		// This is one of those cases where main_view doesn't fully make sense. nil might be just as appropriate since we will need to manually handle this case any way.
-		main_view = text_field;
+    [stepper_view setValueWraps:(BOOL)iupAttribGetBoolean(ih, "SPINWRAP")];
 
-		[text_spinner_container release];
-		[files_owner release];
-		// do not release top_level_objects because instantiateWithOwner did not retain (is is essentially autoreleased);
-		[text_spinner_nib release];
-		
-		
-		// Attach a number formatter since this is always a number ("INTEGER").
-		// Also supports "NC"
-		IupNumberFormatter* number_formatter = [[IupNumberFormatter alloc] init];
-		[number_formatter autorelease];
-		[number_formatter setIhandle:ih];
-//		[number_formatter setFormattingContext:NSFormattingContextDynamic];
-		[number_formatter setFormatterBehavior:NSNumberFormatterBehavior10_4];
-		[number_formatter setPartialStringValidationEnabled:YES];
-		[number_formatter setNumberStyle:NSNumberFormatterNoStyle];
-		[text_field setFormatter:number_formatter];
-		
-		
-		
-		
-		[stepper_view setValueWraps:(BOOL)iupAttribGetBoolean(ih, "SPINWRAP")];
-		
-		
-		/*
-		// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-		objc_setAssociatedObject(the_toggle, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-		// I also need to track the memory of the buttion action receiver.
-		// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-		// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.
-		// This is generally not good Cocoa as Toggles don't retain their receivers, but this seems like the best option.
-		// Be careful of retain cycles.
-		IupCocoaToggleReceiver* toggle_receiver = [[IupCocoaToggleReceiver alloc] init];
-		[the_toggle setTarget:toggle_receiver];
-		[the_toggle setAction:@selector(myToggleClickAction:)];
-		// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.
-		// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)
-		// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.
-		objc_setAssociatedObject(the_toggle, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY, (id)toggle_receiver, OBJC_ASSOCIATION_ASSIGN);
-*/
-		IupCocoaTextSpinnerDelegate* text_spinner_delegate = [[IupCocoaTextSpinnerDelegate alloc] init];
-//		[stepper_view setDelegate:text_spinner_delegate];
-		[text_field setDelegate:text_spinner_delegate];
-		[text_spinner_delegate setIhandle:ih];
+    IupCocoaTextSpinnerDelegate* text_spinner_delegate = [[IupCocoaTextSpinnerDelegate alloc] init];
+    [text_field setDelegate:text_spinner_delegate];
+    [text_spinner_delegate setIhandle:ih];
 
-		[stepper_view setTarget:text_spinner_delegate];
-		[stepper_view setAction:@selector(mySpinnerClickAction:)];
-		
+    [stepper_view setTarget:text_spinner_delegate];
+    [stepper_view setAction:@selector(mySpinnerClickAction:)];
 
-		objc_setAssociatedObject(stepper_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-		objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-		// putting on the text_field just for storage. This is to make it consistent with the regular NSTextField (non-spinner) case.
-		objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, (id)text_spinner_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
-		[text_spinner_delegate release];
-		
+    objc_setAssociatedObject(stepper_view, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+    objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+    objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, (id)text_spinner_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    [text_spinner_delegate release];
 
-#endif
-		
+    ih->data->has_formatting = 0;
 
-		
-		
+    ih->expand = ih->expand & ~IUP_EXPAND_HEIGHT;
+  }
+  else
+  {
+    NSTextField* text_field;
 
-		/*
-			gtk_spin_button_set_numeric((GtkSpinButton*)ih->handle, FALSE);
-			gtk_spin_button_set_digits((GtkSpinButton*)ih->handle, 0);
-			
-			gtk_spin_button_set_wrap((GtkSpinButton*)ih->handle, iupAttribGetBoolean(ih, "SPINWRAP"));
-			
-			g_signal_connect(G_OBJECT(ih->handle), "value-changed", G_CALLBACK(gtkTextSpinValueChanged), ih);
-			g_signal_connect(G_OBJECT(ih->handle), "output", G_CALLBACK(gtkTextSpinOutput), ih);
-			
-			if (!iupAttribGetBoolean(ih, "SPINAUTO"))
-			{
-		 g_signal_connect(G_OBJECT(ih->handle), "input", G_CALLBACK(gtkTextSpinInput), ih);
-		 iupAttribSet(ih, "_IUPGTK_SPIN_NOAUTO", "1");
-			}
-		 */
-		/* formatting is never supported when MULTILINE=NO */
-		ih->data->has_formatting = 0;
-		
-		// We must not allow IUP to EXPAND the height of the NSTextField so unset the bit flag if it is set.
-		ih->expand = ih->expand & ~IUP_EXPAND_HEIGHT;
-		
-	}
-	else
-	{
-		NSTextField* text_field;
+    if(iupAttribGetBoolean(ih, "PASSWORD"))
+    {
+      text_field = [[IupCocoaSecureTextField alloc] initWithFrame:NSZeroRect];
+    }
+    else
+    {
+      text_field = [[IupCocoaTextField alloc] initWithFrame:NSZeroRect];
+    }
 
-		// IMPORTANT: Secure text fields are not togglable in Cocoa
-		// It might be fakeable, however, since this is security related, mucking with it is ill-advised.
-		// Also Mac App Store may reject ill-advised things.
-		if(iupAttribGetBoolean(ih, "PASSWORD"))
-		{
+    IupCocoaTextFieldDelegate* text_field_delegate = [[IupCocoaTextFieldDelegate alloc] init];
+    [text_field setDelegate:text_field_delegate];
+    objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+    objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, (id)text_field_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    [text_field_delegate release];
 
-			text_field = [[IupCocoaSecureTextField alloc] initWithFrame:NSZeroRect];
-			//text_field = [[NSSecureTextField alloc] initWithFrame:NSMakeRect(0, 0, 140, 40)];
-			[text_field setFont:[NSFont systemFontOfSize:0.0]];
+    ih->expand = ih->expand & ~IUP_EXPAND_HEIGHT;
 
-		}
-		else
-		{
-			
-			//text_field = [[NSTextField alloc] initWithFrame:NSZeroRect];
-			text_field = [[IupCocoaTextField alloc] initWithFrame:NSMakeRect(50, 50, 140, 40)];
-			[text_field setFont:[NSFont systemFontOfSize:0.0]];
+    ih->data->has_formatting = 0;
 
-			
-		}
-		
-		IupCocoaTextFieldDelegate* text_field_delegate = [[IupCocoaTextFieldDelegate alloc] init];
-		[text_field setDelegate:text_field_delegate];
-		objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-		objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, (id)text_field_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
-		[text_field_delegate release];
+    root_view = text_field;
+    main_view = text_field;
+  }
 
-		
-		// We must not allow IUP to EXPAND the height of the NSTextField so unset the bit flag if it is set.
-		ih->expand = ih->expand & ~IUP_EXPAND_HEIGHT;
-		
-		/* formatting is never supported when MULTILINE=NO */
-		ih->data->has_formatting = 0;
-		
-		
-#ifdef USE_NSSTACKVIEW_TEXTFIELD_CONTAINER
-		NSStackView* stack_view = [[NSStackView alloc] initWithFrame:NSZeroRect];
-		[stack_view setOrientation:NSUserInterfaceLayoutOrientationVertical];
-		[stack_view setAlignment:NSLayoutAttributeCenterX];
-		[stack_view setDistribution:NSStackViewDistributionEqualCentering]; // requires 10.11. In a complicated IB test, I needed this to keep the widget vertically centerd. But in practice, I'm not sure if this is needed. Maybe we can use respondsToSelector if 10.9/10.10 compat is needed.
-		[stack_view addView:text_field inGravity:NSStackViewGravityCenter];
-		[text_field release];
-		root_view = stack_view;
-		main_view = text_field;
-#elif defined(USE_CONTAINERVIEW_TEXTFIELD_CONTAINER)
-		NSView* container_view = [[NSView alloc] initWithFrame:NSZeroRect];
-		// Warning: This gets clobbered by AddParent
-		[container_view setAutoresizingMask:NSViewMinXMargin|NSViewMaxXMargin|NSViewMinYMargin|NSViewMaxYMargin|NSViewWidthSizable|NSViewHeightSizable];
-		[text_field setAutoresizingMask:NSViewMinXMargin|NSViewMaxXMargin|NSViewMinYMargin|NSViewMaxYMargin|NSViewWidthSizable];
+  ih->handle = root_view;
+  iupcocoaSetAssociatedViews(ih, main_view, root_view);
 
-		[container_view addSubview:text_field];
-		[text_field release];
-		root_view = container_view;
-		main_view = text_field;
-#else
-		root_view = text_field;
-		main_view = text_field;
+  IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+  if (iup_font && [main_view respondsToSelector:@selector(setFont:)])
+  {
+    [(id)main_view setFont:[iup_font nativeFont]];
+  }
 
-#endif
-		
+  if (iupAttribGet(ih, "BGCOLOR"))
+    cocoaTextSetBgColorAttrib(ih, iupAttribGetStr(ih, "BGCOLOR"));
+  if (iupAttribGet(ih, "FGCOLOR"))
+    cocoaTextSetFgColorAttrib(ih, iupAttribGetStr(ih, "FGCOLOR"));
+  if (iupAttribGet(ih, "ALIGNMENT"))
+    cocoaTextSetAlignmentAttrib(ih, iupAttribGetStr(ih, "ALIGNMENT"));
 
-	}
-	
-	
-	
-	
-	
-	ih->handle = root_view;
-	iupCocoaSetAssociatedViews(ih, main_view, root_view);
+  iupcocoaAddToParent(ih);
 
+  if(ih->data->formattags)
+  {
+    iupTextUpdateFormatTags(ih);
+  }
 
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
-	
+  if(ih->data->is_multiline)
+  {
+    NSTextView* text_view = cocoaTextGetTextView(ih);
+    NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
+    [undo_manager removeAllActions];
+  }
 
-#if 0
-	/* configure for DRAG&DROP */
-	if (IupGetCallback(ih, "DROPFILES_CB"))
-		iupAttribSet(ih, "DROPFILESTARGET", "YES");
-	
-	/* update a mnemonic in a label if necessary */
-	iupgtkUpdateMnemonic(ih);
-#endif
-
-	if(ih->data->formattags)
-	{
-		iupTextUpdateFormatTags(ih);
-	}
-	
-	if(ih->data->is_multiline)
-	{
-		// Reset the undo manager so the user can't undo the initial setup.
-		NSTextView* text_view = cocoaTextGetTextView(ih);
-		NSUndoManager* undo_manager = [[text_view delegate] undoManagerForTextView:text_view];
-		[undo_manager removeAllActions];
-	}
-	
-	return IUP_NOERROR;
+  return IUP_NOERROR;
 }
 
-
 static void cocoaTextUnMapMethod(Ihandle* ih)
 {
-	id the_view = ih->handle;
-	/*
-	id text_receiver = objc_getAssociatedObject(the_view, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY);
-	objc_setAssociatedObject(the_view, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
-	[text_receiver release];
-	*/
-	
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-	
-	// Because we used retain for the delegates, they should automatically release
-	
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[the_view release];
-	ih->handle = NULL;
+  id the_view = ih->handle;
+
+  {
+    Ihandle* context_menu_ih = (Ihandle*)iupcocoaCommonBaseGetContextMenuAttrib(ih);
+    if(NULL != context_menu_ih)
+    {
+      IupDestroy(context_menu_ih);
+    }
+    iupcocoaCommonBaseSetContextMenuAttrib(ih, NULL);
+  }
+
+  if (ih->data->is_multiline)
+  {
+    NSScrollView* scroll_view = (NSScrollView*)the_view;
+    NSTextView* text_view = [scroll_view documentView];
+    if (text_view)
+    {
+      [text_view setDelegate:nil];
+      objc_setAssociatedObject(text_view, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+      objc_setAssociatedObject(text_view, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+    }
+  }
+  else if (iupAttribGetBoolean(ih, "SPIN"))
+  {
+    IUPTextSpinnerContainer* spinner_container = (IUPTextSpinnerContainer*)objc_getAssociatedObject(the_view, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY);
+    if (spinner_container)
+    {
+      NSTextField* text_field = [spinner_container textField];
+      NSStepper* stepper_view = [spinner_container stepperView];
+      if (text_field)
+      {
+        [text_field setDelegate:nil];
+        objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+        objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+      }
+      if (stepper_view)
+      {
+        [stepper_view setTarget:nil];
+        objc_setAssociatedObject(stepper_view, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+      }
+    }
+    objc_setAssociatedObject(the_view, IUP_COCOA_TEXT_SPINNERCONTAINER_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  }
+  else
+  {
+    NSTextField* text_field = (NSTextField*)the_view;
+    [text_field setDelegate:nil];
+    objc_setAssociatedObject(text_field, IUP_COCOA_TEXT_DELEGATE_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+  }
+
+  iupcocoaRemoveFromParent(ih);
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+  [the_view release];
+  ih->handle = NULL;
 }
 
-
-// We need to override iTextComputeNaturalSizeMethod because the metrics only compute the raw string size and not the textbox area around it.
-// On Mac, using the standard computation, we only see 3 'WWWW' instead of 5, presumably because the widget is including whitespace area for the surrounding box.
 static void cocoaTextComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)
 {
-	int natural_w = 0,
-	natural_h = 0,
-	visiblecolumns = iupAttribGetInt(ih, "VISIBLECOLUMNS"),
-	visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
-	(void)children_expand; /* unset if not a container */
-	int single_char_width;
-	
-	/* Since the contents can be changed by the user, the size can not be dependent on it. */
-	iupdrvFontGetCharSize(ih, NULL, &natural_h);  /* one line height */
-	natural_w = iupdrvFontGetStringWidth(ih, "WWWWWWWWWW");
+  int natural_w = 0,
+      natural_h = 0,
+      visiblecolumns = iupAttribGetInt(ih, "VISIBLECOLUMNS"),
+      visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+  (void)children_expand;
+  int single_char_width;
 
-	// Cocoa adjustment here: Let's make the width slightly bigger.
-	// Since we see 3 out of 5 WWW's, let's pad with two more character widths.
-	single_char_width = natural_w / 10;
+  iupdrvFontGetCharSize(ih, NULL, &natural_h);
+  natural_w = iupdrvFontGetStringWidth(ih, "WWWWWWWWWW");
 
-	
-	natural_w = (visiblecolumns*natural_w)/10;
-	
-	
-	// Cocoa adjustment here
-	natural_w += (single_char_width * 2);
-	
-	
-	if (ih->data->is_multiline)
-	{
-		natural_h = visiblelines*natural_h;
-	}
-	else
-	{
-		natural_h = 22;
-	}
-	
-	/* compute the borders space */
-	if (iupAttribGetBoolean(ih, "BORDER"))
-		iupdrvTextAddBorders(ih, &natural_w, &natural_h);
-	
-	if (iupAttribGetBoolean(ih, "SPIN"))
-		iupdrvTextAddSpin(ih, &natural_w, natural_h);
-	
-	natural_w += 2*ih->data->horiz_padding;
-	natural_h += 2*ih->data->vert_padding;
-	
-	/* add scrollbar */
-	if (ih->data->is_multiline && ih->data->sb)
-	{
-		int sb_size = iupdrvGetScrollbarSize();
-		if (ih->data->sb & IUP_SB_HORIZ)
-			natural_h += sb_size;  /* sb horizontal affects vertical size */
-		if (ih->data->sb & IUP_SB_VERT)
-			natural_w += sb_size;  /* sb vertical affects horizontal size */
-	}
-	
-	*w = natural_w;
-	*h = natural_h;
-	
-	Ihandle* child;
+  single_char_width = natural_w / 10;
 
-	for (child = ih->firstchild; child; child = child->brother)
-	{
+  natural_w = (visiblecolumns*natural_w)/10;
 
-		
-		/* update child natural size first */
-		if (!(child->flags & IUP_FLOATING_IGNORE))
-			iupBaseComputeNaturalSize(child);
-	}
-	
+  natural_w += (single_char_width * 2);
+
+  if (ih->data->is_multiline)
+  {
+    natural_h = visiblelines*natural_h;
+  }
+
+  if (iupAttribGetBoolean(ih, "BORDER"))
+    iupdrvTextAddBorders(ih, &natural_w, &natural_h);
+  else
+    iupdrvTextAddExtraPadding(ih, &natural_w, &natural_h);
+
+  if (iupAttribGetBoolean(ih, "SPIN"))
+    iupdrvTextAddSpin(ih, &natural_w, natural_h);
+
+  natural_w += 2*ih->data->horiz_padding;
+  natural_h += 2*ih->data->vert_padding;
+
+  if (ih->data->is_multiline && ih->data->sb)
+  {
+    int sb_size = iupdrvGetScrollbarSize();
+    if (ih->data->sb & IUP_SB_HORIZ)
+      natural_h += sb_size;
+    if (ih->data->sb & IUP_SB_VERT)
+      natural_w += sb_size;
+  }
+
+  *w = natural_w;
+  *h = natural_h;
+
+  Ihandle* child;
+
+  for (child = ih->firstchild; child; child = child->brother)
+  {
+    if (!(child->flags & IUP_FLOATING_IGNORE))
+      iupBaseComputeNaturalSize(child);
+  }
 }
 
-
 void iupdrvTextInitClass(Iclass* ic)
 {
-  /* Driver Dependent Class functions */
   ic->Map = cocoaTextMapMethod;
-	ic->UnMap = cocoaTextUnMapMethod;
+  ic->UnMap = cocoaTextUnMapMethod;
+  ic->ComputeNaturalSize = cocoaTextComputeNaturalSizeMethod;
 
-//	ic->LayoutUpdate = cocoaTextLayoutUpdateMethod;
-	ic->ComputeNaturalSize = cocoaTextComputeNaturalSizeMethod;
-
-
-  /* Driver Dependent Attribute functions */
-
-  /* Visual */
   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, cocoaTextSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTBGCOLOR", IUPAF_DEFAULT);
-  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaTextSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTFGCOLOR", IUPAF_DEFAULT);
 
-  // need to override active behavior for text
   iupClassRegisterAttribute(ic, "ACTIVE", cocoaTextGetActiveAttrib, cocoaTextSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
 
-#if 0
-  /* Special */
-
-  /* IupText only */
-  iupClassRegisterAttribute(ic, "PADDING", iupTextGetPaddingAttrib, gtkTextSetPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED);
-#endif
   iupClassRegisterAttribute(ic, "VALUE", cocoaTextGetValueAttrib, cocoaTextSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 
   iupClassRegisterAttribute(ic, "LINEVALUE", cocoaTextGetLineValueAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
@@ -6612,7 +5652,7 @@
   iupClassRegisterAttribute(ic, "SELECTIONPOS", cocoaTextGetSelectionPosAttrib, cocoaTextSetSelectionPosAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "CARET", cocoaTextGetCaretAttrib, cocoaTextSetCaretAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "CARETPOS", cocoaTextGetCaretPosAttrib, cocoaTextSetCaretPosAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NO_SAVE|IUPAF_NO_INHERIT);
-	
+
   iupClassRegisterAttribute(ic, "INSERT", NULL, cocoaTextSetInsertAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "APPEND", NULL, cocoaTextSetAppendAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 
@@ -6632,27 +5672,18 @@
 
   iupClassRegisterAttribute(ic, "LINECOUNT", cocoaTextGetLineCountAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
 
-  /* IupText Windows and GTK only */
   iupClassRegisterAttribute(ic, "ADDFORMATTAG", NULL, iupTextSetAddFormatTagAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "ADDFORMATTAG_HANDLE", NULL, iupTextSetAddFormatTagHandleAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FORMATTING", cocoaTextGetFormattingAttrib, cocoaTextSetFormattingAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "REMOVEFORMATTING", NULL, cocoaTextSetRemoveFormattingAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "ALIGNMENT", NULL, cocoaTextSetAlignmentAttrib, IUPAF_SAMEASSYSTEM, "ALEFT", IUPAF_NO_INHERIT);
-#if 0
-  iupClassRegisterAttribute(ic, "OVERWRITE", gtkTextGetOverwriteAttrib, gtkTextSetOverwriteAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-// FIXME:
-//  iupClassRegisterAttribute(ic, "TABSIZE", NULL, cocoaTextSetTabSizeAttrib, "8", NULL, IUPAF_DEFAULT);  /* force new default value */
-#endif
+  iupClassRegisterAttribute(ic, "TABSIZE", NULL, cocoaTextSetTabSizeAttrib, "8", NULL, IUPAF_DEFAULT);
   iupClassRegisterAttribute(ic, "PASSWORD", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "CUEBANNER", NULL, cocoaTextSetCueBannerAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-
   iupClassRegisterAttribute(ic, "FILTER", NULL, cocoaTextSetFilterAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", cocoaTextGetScrollVisibleAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "OVERWRITE", cocoaTextGetOverwriteAttrib, cocoaTextSetOverwriteAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, cocoaTextSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
-	// TODO: LAYERBACKED
-	// TODO: ALLOWSUNDO
-	// TODO: CLEARUNDO/REMOVEALLACTIONS
+  iupClassRegisterAttribute(ic, "CONTEXTMENU", iupcocoaCommonBaseGetContextMenuAttrib, cocoaTextSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 }
Index: src/cocoa/iupcocoa_timer.m
===================================================================
--- src/cocoa/iupcocoa_timer.m	(revision 5971)
+++ src/cocoa/iupcocoa_timer.m	(working copy)
@@ -1,15 +1,11 @@
 /** \file
- * \brief Timer for the Mac Driver.
+ * \brief Timer for the macOS Driver.
  *
  * See Copyright Notice in "iup.h"
  */
 
+#import <Cocoa/Cocoa.h>
 
-// TODO: FEATURE: Support Apple 'tolerance' property which controls battery vs. accuracy.
-
-
-#import <Cocoa/Cocoa.h>
- 
 #include <stdio.h>
 #include <stdlib.h>
 
@@ -22,40 +18,46 @@
 #include "iup_assert.h"
 #include "iup_timer.h"
 
+
 @interface IupCocoaTimerController : NSObject
-// CFTimeInterval is a double
 @property (assign) CFTimeInterval startTime;
-@property (retain) NSTimer* theTimer;
-- (void) onTimerCallback:(NSTimer*)theTimer;
+@property (retain) NSTimer* nsTimer;
+- (void) onTimerCallback:(NSTimer*)timer;
 @end
 
+
 @implementation IupCocoaTimerController
-@synthesize theTimer;
 
 - (void) dealloc
 {
-	[self setTheTimer:nil];
-	[super dealloc];
+  [_nsTimer release];
+  _nsTimer = nil;
+  [super dealloc];
 }
 
-- (void) onTimerCallback:(NSTimer*)theTimer
+- (void) onTimerCallback:(NSTimer*)timer
 {
-  Icallback callback_function;
-  Ihandle* ih = (Ihandle*)[[[self theTimer] userInfo] pointerValue];
-  callback_function = IupGetCallback(ih, "ACTION_CB");
-	
-  if(callback_function)
+  Ihandle* ih = (Ihandle*)[timer.userInfo pointerValue];
+
+  if (!iupObjectCheck(ih))
   {
-	  CFTimeInterval start_time = [self startTime];
-	  double current_time = CACurrentMediaTime();
-	  NSUInteger elapsed_time = (NSUInteger)(((current_time - start_time) * 1000.0) + 0.5);
-	  iupAttribSetInt(ih, "ELAPSEDTIME", (int)elapsed_time);
-	  
-    if(callback_function(ih) == IUP_CLOSE)
-	{
-		IupExitLoop();
-	}
+    [timer invalidate];
+    return;
   }
+
+  Icallback action_cb = IupGetCallback(ih, "ACTION_CB");
+  if (action_cb)
+  {
+    CFTimeInterval start_time = [self startTime];
+    double current_time = CACurrentMediaTime();
+    int elapsed_time_ms = (int)(((current_time - start_time) * 1000.0) + 0.5);
+    iupAttribSetInt(ih, "ELAPSEDTIME", elapsed_time_ms);
+
+    if (action_cb(ih) == IUP_CLOSE)
+    {
+      IupExitLoop();
+    }
+  }
 }
 
 @end
@@ -63,73 +65,51 @@
 
 void iupdrvTimerRun(Ihandle* ih)
 {
-  unsigned int time_ms;
+  if (ih->handle != nil)
+    return;
 
-  if (ih->handle != nil) /* timer already started */
+  unsigned int time_ms = iupAttribGetInt(ih, "TIME");
+  if (time_ms > 0)
   {
-	  return;
-  }
-  time_ms = iupAttribGetInt(ih, "TIME");
-  if(time_ms > 0)
-  {
-	  IupCocoaTimerController* timer_controller = [[IupCocoaTimerController alloc] init];
-	  // CACurrentMediaTime is tied to a real time clock. It uses mach_absolute_time() under the hood.
-	  // GNUStep: Neither of these is likely directly portable (CACurrentMediaTime more likely), so we may need an #ifdef here.
-	  // [[NSDate date] timeIntervalSince1970]; isn't so great because it is affected by network clock changes and so forth.
-	  double start_time = CACurrentMediaTime();
+    IupCocoaTimerController* timer_controller = [[IupCocoaTimerController alloc] init];
 
-	  NSTimer* the_timer = [NSTimer timerWithTimeInterval:(time_ms/1000.0)
-		target:timer_controller
-        selector:@selector(onTimerCallback:)
-        userInfo:(id)[NSValue valueWithPointer:ih]
-		repeats:YES
-	];
-	  
+    CFTimeInterval start_time = CACurrentMediaTime();
 
+    NSTimer* ns_timer = [NSTimer timerWithTimeInterval:(time_ms / 1000.0)
+                                                target:timer_controller
+                                              selector:@selector(onTimerCallback:)
+                                              userInfo:[NSValue valueWithPointer:ih]
+                                               repeats:YES];
 
-	  // Cocoa seems to block timers or events sometimes. This can be seen
-	  // when I'm animating (via a timer) and you open an popup box or move a slider.
-	  // Apparently, sheets and dialogs can also block (try printing).
-	  // To work around this, Cocoa provides different run-loop modes. I need to
-	  // specify the modes to avoid the blockage.
-	  // NSDefaultRunLoopMode seems to be the default. I don't think I need to explicitly
-	  // set this one, but just in case, I will set it anyway.
-	  [[NSRunLoop currentRunLoop] addTimer:the_timer forMode:NSRunLoopCommonModes];
+    float tolerance = iupAttribGetFloat(ih, "TOLERANCE");
+    if (tolerance > 0.0f)
+    {
+      [ns_timer setTolerance:(NSTimeInterval)tolerance];
+    }
 
+    [[NSRunLoop currentRunLoop] addTimer:ns_timer forMode:NSRunLoopCommonModes];
 
-	[timer_controller setTheTimer:the_timer];
-	  [timer_controller setStartTime:start_time];
+    [timer_controller setNsTimer:ns_timer];
+    [timer_controller setStartTime:start_time];
 
-	  ih->handle = timer_controller;
-	  ih->serial = (int)(intptr_t)timer_controller; // for WID
+    ih->handle = timer_controller;
   }
-	
 }
 
-static void cocoaTimerDestroy(Ihandle* ih)
-{
-	if(nil != ih->handle)
-	{
-		IupCocoaTimerController* timer_controller = (IupCocoaTimerController*)ih->handle;
-		NSTimer* the_timer = [timer_controller theTimer];
-		
-		[the_timer invalidate];
-		
-		// This will also release the timer instance via the dealloc
-		[timer_controller release];
-		
-		ih->handle = nil;
-	}
-}
-
 void iupdrvTimerStop(Ihandle* ih)
 {
+  if (ih->handle != nil)
+  {
+    IupCocoaTimerController* timer_controller = (IupCocoaTimerController*)ih->handle;
+    NSTimer* ns_timer = [timer_controller nsTimer];
 
-	cocoaTimerDestroy(ih);
+    [ns_timer invalidate];
+    [timer_controller release];
 
+    ih->handle = nil;
+  }
 }
 
-// copied from iTimerSetRunAttrib because it is static, and we needed to override TimerGetRunAttrib, but must also override this to do so.
 static int cocoaSetRunAttrib(Ihandle *ih, const char *value)
 {
   if (iupStrBoolean(value))
@@ -140,6 +120,7 @@
   return 0;
 }
 
+/* The base implementation uses ih->serial, but we use ih->handle. */
 static char* cocoaTimerGetRunAttrib(Ihandle *ih)
 {
   return iupStrReturnBoolean(ih->handle != nil);
@@ -147,25 +128,21 @@
 
 static char* cocoaTimerGetWidAttrib(Ihandle *ih)
 {
-  // WARNING: This is going to truncate the pointer, which means it will be useless by anybody who actually gets the WID.
-  // The WID API is mostly useless, except for maybe checking if the timer is running.
+  /* WARNING: This truncates the controller pointer on 64-bit architectures.
+     It should only be used to check for a non-NULL value. */
   return iupStrReturnInt((int)(intptr_t)ih->handle);
 }
 
 void iupdrvTimerInitClass(Iclass* ic)
 {
-	(void)ic;
-	// This must be UnMap and not Destroy because we're using the ih->handle and UnMap will clear the pointer to NULL before we reach Destroy.
-	ic->UnMap = cocoaTimerDestroy;
-	
-	// We need to override because we don't use ih->serial to store the timer.
-	// We need a full pointer and serial would truncate and be wrong.
-	// The base code assumes serial.
-	iupClassRegisterAttribute(ic, "WID", cocoaTimerGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);
-	iupClassRegisterAttribute(ic, "RUN", cocoaTimerGetRunAttrib, cocoaSetRunAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  ic->UnMap = iupdrvTimerStop;
 
+  iupClassRegisterAttribute(ic, "WID", cocoaTimerGetWidAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT|IUPAF_NO_STRING);
+  iupClassRegisterAttribute(ic, "RUN", cocoaTimerGetRunAttrib, cocoaSetRunAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
-	
-}
-
-
+  /*
+   * TOLERANCE is a macOS-specific attribute to improve power consumption by allowing the system to fire the timer later than scheduled.
+   * The value is a float in seconds.
+   */
+  iupClassRegisterAttribute(ic, "TOLERANCE", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+}
\ No newline at end of file
Index: src/cocoa/iupcocoa_tips.m
===================================================================
--- src/cocoa/iupcocoa_tips.m	(revision 5971)
+++ src/cocoa/iupcocoa_tips.m	(working copy)
@@ -1,48 +1,198 @@
 /** \file
- * \brief MAC Driver TIPS management
+ * \brief macOS Driver TIPS management
  *
  * See Copyright Notice in "iup.h"
  */
 
-#include <stdio.h>
-
 #import <Cocoa/Cocoa.h>
+#import <objc/runtime.h>
 
-#include "iup.h" 
+#include "iup.h"
+#include "iupcbs.h"
+#include "iup_object.h"
+#include "iup_str.h"
+#include "iup_attrib.h"
+#include "iupcocoa_drv.h"
 
-#include "iup_object.h" 
-#include "iup_str.h" 
-#include "iup_attrib.h" 
 
-#include "iupcocoa_drv.h"
+static const void* IUP_COCOA_TOOLTIP_OWNER_KEY = @"IUP_COCOA_TOOLTIP_OWNER_KEY";
 
+@interface IupCocoaToolTipOwner : NSObject
+@property (nonatomic, assign) Ihandle* ihandle;
+@property (nonatomic, assign) NSToolTipTag toolTipTag;
+@end
+
+@implementation IupCocoaToolTipOwner
+
+- (NSString *)view:(NSView *)view stringForToolTip:(NSToolTipTag)tag point:(NSPoint)point userData:(void *)data
+{
+  if (!self.ihandle || !iupObjectCheck(self.ihandle))
+  {
+    return nil;
+  }
+
+  IFnii cb = (IFnii)IupGetCallback(self.ihandle, "TIPS_CB");
+  if (cb)
+  {
+    int x = (int)point.x;
+    int y = (int)point.y;
+
+    if (![view isFlipped])
+    {
+      NSRect view_bounds = [view bounds];
+      y = (int)(view_bounds.size.height - point.y);
+    }
+
+    cb(self.ihandle, x, y);
+  }
+
+  const char* tip_cstr = iupAttribGet(self.ihandle, "TIP");
+  if (!tip_cstr)
+  {
+    return nil;
+  }
+
+  return [NSString stringWithUTF8String:tip_cstr];
+}
+
+@end
+
+void iupcocoaTipsDestroy(Ihandle* ih)
+{
+  NSView* the_view = iupcocoaGetRootView(ih);
+  if (!the_view) return;
+
+  IupCocoaToolTipOwner* owner = objc_getAssociatedObject(the_view, IUP_COCOA_TOOLTIP_OWNER_KEY);
+  if (owner)
+  {
+    if (owner.toolTipTag != 0)
+    {
+      [the_view removeToolTip:owner.toolTipTag];
+    }
+    objc_setAssociatedObject(the_view, IUP_COCOA_TOOLTIP_OWNER_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  }
+}
+
+static void iupCocoaTipsUpdateForView(NSView* the_view, IupCocoaToolTipOwner* owner)
+{
+  if (owner.toolTipTag != 0)
+  {
+    [the_view removeToolTip:owner.toolTipTag];
+    owner.toolTipTag = 0;
+  }
+
+  NSRect tip_rect;
+  const char* tiprect_value = iupAttribGet(owner.ihandle, "TIPRECT");
+
+  if (tiprect_value)
+  {
+    int x1, y1, x2, y2;
+    if (sscanf(tiprect_value, "%d %d %d %d", &x1, &y1, &x2, &y2) == 4)
+    {
+      tip_rect = NSMakeRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+
+      if (![the_view isFlipped])
+      {
+        NSRect view_bounds = [the_view bounds];
+        tip_rect.origin.y = view_bounds.size.height - tip_rect.origin.y - tip_rect.size.height;
+      }
+    }
+    else
+    {
+      tip_rect = [the_view bounds];
+    }
+  }
+  else
+  {
+    tip_rect = [the_view bounds];
+  }
+
+  owner.toolTipTag = [the_view addToolTipRect:tip_rect
+                                        owner:owner
+                                     userData:NULL];
+}
+
+void cocoaUpdateTip(Ihandle* ih)
+{
+  if (!ih) return;
+
+  NSView* the_view = iupcocoaGetRootView(ih);
+  if (!the_view) return;
+
+  IupCocoaToolTipOwner* owner = objc_getAssociatedObject(the_view, IUP_COCOA_TOOLTIP_OWNER_KEY);
+  if (owner)
+  {
+    iupCocoaTipsUpdateForView(the_view, owner);
+  }
+}
+
 int iupdrvBaseSetTipAttrib(Ihandle* ih, const char* value)
 {
-	id widget_handle = ih->handle;
-	NSView* the_view = nil;
-	
-	if([widget_handle isKindOfClass:[NSViewController class]])
-	{
-		widget_handle = [(NSViewController*)widget_handle view];
-		// fall through to next block
-	}
-	
-	if([widget_handle respondsToSelector:@selector(setToolTip:)])
-	{
-		the_view = (NSView*)widget_handle;
-		
-		NSString* tip_string = [NSString stringWithUTF8String:value];
-		[the_view setToolTip:tip_string];
-	}
-	return 1;
+  NSView* the_view = iupcocoaGetRootView(ih);
+  if (!the_view)
+  {
+    return 1;
+  }
+
+  if (value && *value)
+  {
+    IupCocoaToolTipOwner* owner = objc_getAssociatedObject(the_view, IUP_COCOA_TOOLTIP_OWNER_KEY);
+    if (!owner)
+    {
+      owner = [[IupCocoaToolTipOwner alloc] init];
+      owner.ihandle = ih;
+
+      objc_setAssociatedObject(the_view, IUP_COCOA_TOOLTIP_OWNER_KEY, owner, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+      [owner release];
+    }
+
+    iupCocoaTipsUpdateForView(the_view, owner);
+  }
+  else
+  {
+    iupcocoaTipsDestroy(ih);
+  }
+
+  return 1;
 }
 
 int iupdrvBaseSetTipVisibleAttrib(Ihandle* ih, const char* value)
 {
-	return 0;
+  (void)ih;
+  (void)value;
+  return 0;
 }
 
 char* iupdrvBaseGetTipVisibleAttrib(Ihandle* ih)
 {
-	return NULL;
+  (void)ih;
+  return NULL;
 }
+
+int cocoaBaseSetTipRectAttrib(Ihandle* ih, const char* value)
+{
+  (void)value;
+  cocoaUpdateTip(ih);
+  return 0;
+}
+
+int cocoaBaseSetTipBgColorAttrib(Ihandle* ih, const char* value)
+{
+  (void)ih;
+  (void)value;
+  return 0;
+}
+
+int cocoaBaseSetTipFgColorAttrib(Ihandle* ih, const char* value)
+{
+  (void)ih;
+  (void)value;
+  return 0;
+}
+
+int cocoaBaseSetTipFontAttrib(Ihandle* ih, const char* value)
+{
+  (void)ih;
+  (void)value;
+  return 0;
+}
Index: src/cocoa/iupcocoa_toggle.m
===================================================================
--- src/cocoa/iupcocoa_toggle.m	(revision 5971)
+++ src/cocoa/iupcocoa_toggle.m	(working copy)
@@ -5,9 +5,8 @@
  */
 
 #import <Cocoa/Cocoa.h>
+#import <objc/runtime.h>
 
-
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -22,419 +21,953 @@
 #include "iup_attrib.h"
 #include "iup_str.h"
 #include "iup_image.h"
+#include "iup_toggle.h"
 #include "iup_drv.h"
 #include "iup_drvfont.h"
-#include "iup_image.h"
 #include "iup_key.h"
-#include "iup_toggle.h"
 
 #include "iupcocoa_drv.h"
+#include "iupcocoa_keycodes.h"
 
 
-/** \file
- * \brief Toggle Control
- *
- * See Copyright Notice in "iup.h"
- */
+static const void* IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY = "IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY";
 
-#import <Cocoa/Cocoa.h>
-#import <objc/runtime.h>
+@interface IupCocoaToggleButton : NSButton
+@end
 
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <memory.h>
-#include <stdarg.h>
+@implementation IupCocoaToggleButton
 
-#include "iup.h"
-#include "iupcbs.h"
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih)
+    return [super acceptsFirstResponder];
 
-#include "iup_object.h"
-#include "iup_layout.h"
-#include "iup_attrib.h"
-#include "iup_str.h"
-#include "iup_image.h"
-#include "iup_toggle.h"
-#include "iup_drv.h"
-#include "iup_drvfont.h"
-#include "iup_image.h"
-#include "iup_key.h"
+  const char* canfocus = iupAttribGet(ih, "_IUPCOCOA_CANFOCUS");
+  if (canfocus && iupStrEqualNoCase(canfocus, "NO"))
+    return NO;
 
-#include "iupcocoa_drv.h"
+  return [super acceptsFirstResponder];
+}
 
+- (BOOL)becomeFirstResponder
+{
+  BOOL result = [super becomeFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusIn(ih);
+  }
+  return result;
+}
 
-// the point of this is we have a unique memory address for an identifier
-static const void* IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY = "IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY";
+- (BOOL)resignFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+    iupcocoaFocusOut(ih);
 
+  return [super resignFirstResponder];
+}
 
+- (BOOL) needsPanelToBecomeKey
+{
+  return YES;
+}
+
+- (void)mouseDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+
+  if (ih && !ih->data->is_radio && ih->data->type == IUP_TOGGLE_TEXT && [self allowsMixedState])
+  {
+    int current = iupAttribGetInt(ih, "_IUPCOCOA_3STATE_CURRENT");
+
+    if (current == 1)
+    {
+      [self setState:NSControlStateValueMixed];
+      iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", -1);
+    }
+    else if (current == -1)
+    {
+      [self setState:NSControlStateValueOff];
+      iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", 0);
+    }
+    else
+    {
+      [self setState:NSControlStateValueOn];
+      iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", 1);
+    }
+
+    [self sendAction:[self action] to:[self target]];
+    return;
+  }
+
+  [super mouseDown:event];
+}
+
+- (void)keyDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih)
+  {
+    [super keyDown:event];
+    return;
+  }
+
+  int keyCode = [event keyCode];
+  if (iupcocoaKeyEvent(ih, event, keyCode, true))
+    return;
+
+  if (!ih->data->is_radio && ih->data->type == IUP_TOGGLE_TEXT && [self allowsMixedState])
+  {
+    if (keyCode == kVK_Space || keyCode == kVK_Return || keyCode == kVK_ANSI_KeypadEnter)
+    {
+      int current = iupAttribGetInt(ih, "_IUPCOCOA_3STATE_CURRENT");
+
+      if (current == 1)
+      {
+        [self setState:NSControlStateValueMixed];
+        iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", -1);
+      }
+      else if (current == -1)
+      {
+        [self setState:NSControlStateValueOff];
+        iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", 0);
+      }
+      else
+      {
+        [self setState:NSControlStateValueOn];
+        iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", 1);
+      }
+
+      [self sendAction:[self action] to:[self target]];
+      return;
+    }
+  }
+
+  [super keyDown:event];
+}
+
+
+@end
+
+
 @interface IupCocoaToggleReceiver : NSObject
-- (IBAction) myToggleClickAction:(id)the_sender;
+  - (IBAction) myToggleClickAction:(id)the_sender;
 @end
 
 @implementation IupCocoaToggleReceiver
 
-/*
- - (void) dealloc
- {
-	[super dealloc];
- }
- */
+- (IBAction) myToggleClickAction:(id)the_sender;
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+  Ihandle* radio = iupRadioFindToggleParent(ih);
+  NSControlStateValue new_state = [the_sender state];
 
+  if (iupAttribGetBoolean(ih, "IGNOREDOUBLECLICK"))
+  {
+    NSEvent* current_event = [NSApp currentEvent];
+    if (current_event && [current_event clickCount] > 1)
+    {
+      return;
+    }
+  }
 
-- (IBAction) myToggleClickAction:(id)the_sender;
-{
-//	Icallback callback_function;
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
-	
-	NSControlStateValue new_state = [the_sender state];
-	
-	
-	// CONFLICT: Cocoa Toggles don't normally do anything for non-primary click. (Second click is supposed to trigger the contextual menu.)
-	// Also Cocoa doesn't normall give callbacks for both down and up
-	/*
-	 callback_function = IupGetCallback(ih, "toggle_CB");
-	 if(callback_function)
-	 {
-		if(callback_function(ih) == IUP_CLOSE)
-		{
-	 IupExitLoop();
-		}
-		
-	 }
-	 */
-	
-	IFni action_callback_function = (IFni)IupGetCallback(ih, "ACTION");
-	if(action_callback_function)
-	{
-		if(action_callback_function(ih, (int)new_state) == IUP_CLOSE)
-		{
-			IupExitLoop();
-		}
-	}
-	Icallback valuechanged_callback_function = IupGetCallback(ih, "VALUECHANGED_CB");
-	if(valuechanged_callback_function)
-	{
-		if(valuechanged_callback_function(ih) == IUP_CLOSE)
-		{
-			IupExitLoop();
-		}
-	}
+  if ([the_sender isKindOfClass:[NSSwitch class]])
+  {
+    /* NSSwitch is simple, no 3-state, no radio, no image */
+  }
+  else if (!radio && ih->data->type == IUP_TOGGLE_TEXT && [the_sender allowsMixedState])
+  {
+    int state_val = (new_state == NSControlStateValueOn) ? 1 : (new_state == NSControlStateValueMixed) ? -1 : 0;
+    iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", state_val);
+  }
+  else if (radio)
+  {
+    if (new_state == NSControlStateValueOn)
+    {
+      Ihandle* last_tg = (Ihandle*)iupAttribGet(radio, "_IUPCOCOA_LASTTOGGLE");
+      if (iupObjectCheck(last_tg) && last_tg != ih)
+      {
+        NSButton* last_button = (NSButton*)last_tg->handle;
+        [last_button setState:NSControlStateValueOff];
+
+        if (last_tg->data->type == IUP_TOGGLE_IMAGE)
+        {
+          char* name = iupAttribGet(last_tg, "IMAGE");
+          if (name)
+          {
+            int make_inactive = !iupdrvIsActive(last_tg);
+            NSImage* the_bitmap = iupImageGetImage(name, last_tg, make_inactive, NULL);
+            [last_button setImage:the_bitmap];
+          }
+        }
+
+        IFni action_cb = (IFni)IupGetCallback(last_tg, "ACTION");
+        if (action_cb)
+        {
+          if (action_cb(last_tg, 0) == IUP_CLOSE)
+          {
+            IupExitLoop();
+            return;
+          }
+        }
+
+        if (iupObjectCheck(last_tg))
+        {
+          iupBaseCallValueChangedCb(last_tg);
+        }
+      }
+
+      iupAttribSet(radio, "_IUPCOCOA_LASTTOGGLE", (char*)ih);
+
+      if (ih->data->type == IUP_TOGGLE_IMAGE)
+      {
+        char* name = iupAttribGet(ih, "IMPRESS");
+        if (name)
+        {
+          int make_inactive = !iupdrvIsActive(ih);
+          NSImage* the_bitmap = iupImageGetImage(name, ih, make_inactive, NULL);
+          [the_sender setImage:the_bitmap];
+        }
+      }
+    }
+  }
+  else
+  {
+    if (ih->data->type == IUP_TOGGLE_IMAGE)
+    {
+      char* name = NULL;
+      int is_checked = (new_state == NSControlStateValueOn) ? 1 : 0;
+
+      if (is_checked)
+      {
+        name = iupAttribGet(ih, "IMPRESS");
+        if (!name)
+          name = iupAttribGet(ih, "IMAGE");
+      }
+      else
+      {
+        name = iupAttribGet(ih, "IMAGE");
+      }
+
+      if (name)
+      {
+        int make_inactive = !iupdrvIsActive(ih);
+        NSImage* the_bitmap = iupImageGetImage(name, ih, make_inactive, NULL);
+        [the_sender setImage:the_bitmap];
+      }
+    }
+  }
+
+  IFni action_callback_function = (IFni)IupGetCallback(ih, "ACTION");
+  if (action_callback_function)
+  {
+    int state = (int)new_state;
+    if (new_state == NSControlStateValueMixed)
+      state = -1;
+
+    if (action_callback_function(ih, state) == IUP_CLOSE)
+    {
+      IupExitLoop();
+    }
+  }
+
+  if (iupObjectCheck(ih))
+  {
+    iupBaseCallValueChangedCb(ih);
+  }
 }
 
+
 @end
 
-// This only gets called for images
+
 void iupdrvToggleAddBorders(Ihandle* ih, int *x, int *y)
 {
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    if (!ih->data->flat)
+    {
+      *x += 8;
+      *y += 8;
+    }
+    else
+    {
+      *x += 4;
+      *y += 4;
+    }
+  }
 }
 
+void iupdrvToggleAddSwitch(Ihandle* ih, int *x, int *y, const char* str)
+{
+  static int switch_w = -1;
+  static int switch_h = -1;
+  (void)ih;
 
+  if (switch_w < 0)
+  {
+    NSSwitch* temp_switch = [[NSSwitch alloc] initWithFrame:NSZeroRect];
+    NSSize size = [temp_switch intrinsicContentSize];
+    [temp_switch release];
 
+    switch_w = (size.width > 0) ? (int)size.width : 38;
+    switch_h = (size.height > 0) ? (int)size.height : 21;
+  }
+
+  *x += 2 + switch_w + 2;
+  if ((*y) < 2 + switch_h + 2) *y = 2 + switch_h + 2;
+  else *y += 2+2;
+
+  if (str && str[0])
+    *x += 8;
+}
+
 void iupdrvToggleAddCheckBox(Ihandle* ih, int *x, int *y, const char* str)
 {
-	// Includes padding between box and text
-	*x += 20;
-	
-	// Add a little more for border padding because iupdrvToggleAddBorders only calls for images
-	*x += 4;
-	*y += 4;
+  static int check_w = -1;
+  static int check_h = -1;
+  (void)ih;
 
+  if (check_w < 0)
+  {
+    NSButton* temp_button = [[NSButton alloc] initWithFrame:NSZeroRect];
+    [temp_button setButtonType:NSButtonTypeSwitch];
+    [temp_button setTitle:@""];
+    NSSize size = [temp_button intrinsicContentSize];
+    [temp_button release];
+
+    check_w = (size.width > 0) ? (int)size.width : 18;
+    check_h = (size.height > 0) ? (int)size.height : 18;
+  }
+
+  *x += check_w;
+  if (*y < check_h) *y = check_h;
+
+  *x += 4;
+  *y += 4;
+
+  if (str && *str != 0)
+    *x += 8;
 }
 
 
-static int cocoaToggleSetTitleAttrib(Ihandle* ih, const char* value)
+static void cocoaToggleUpdateImageSize(Ihandle* ih)
 {
-	NSButton* the_toggle = ih->handle;
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    NSButton* the_toggle = ih->handle;
+    NSImage* image = [the_toggle image];
 
-	char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);   /* remove & */
+    if (image)
+    {
+      NSSize imageSize = [image size];
 
-	if (ih->data->type == IUP_TOGGLE_TEXT)
-	{
-		if(stripped_str && *stripped_str!=0)
-		{
-			NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
-			[the_toggle setTitle:ns_string];
-			/*
-			 if(ih->data->type == IUP_TOGGLE_IMAGE)
-			 {
-			 // TODO: FEATURE: Cocoa allows text to be placed in different positions
-			 // https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Toggle/Tasks/SettingToggleImage.html
-			 [the_toggle setImagePosition:NSImageLeft];
-			 }
-			 else
-			 {
-			 //			[the_toggle setImagePosition:NSNoImage];
-			 
-			 }
-			 */
-		}
-		else
-		{
-			[the_toggle setTitle:@""];
-		}
+      int width = (int)imageSize.width;
+      int height = (int)imageSize.height;
 
-		return 1;
-	}
-	
-	return 0;
+      width += 2 * ih->data->horiz_padding;
+      height += 2 * ih->data->vert_padding;
+
+      if (!ih->data->flat)
+      {
+        width += 8;
+        height += 8;
+      }
+
+      NSRect frame = [the_toggle frame];
+      frame.size.width = width;
+      frame.size.height = height;
+      [the_toggle setFrame:frame];
+    }
+  }
 }
 
+static void cocoaToggleUpdateImage(Ihandle* ih, int active, int check)
+{
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    NSButton* the_toggle = ih->handle;
+    char* name = NULL;
 
+    if (!active)
+    {
+      name = iupAttribGet(ih, "IMINACTIVE");
+      if (!name)
+      {
+        if (check)
+        {
+          name = iupAttribGet(ih, "IMPRESS");
+          if (!name)
+            name = iupAttribGet(ih, "IMAGE");
+        }
+        else
+          name = iupAttribGet(ih, "IMAGE");
+      }
+    }
+    else
+    {
+      if (check)
+      {
+        name = iupAttribGet(ih, "IMPRESS");
+        if (!name)
+          name = iupAttribGet(ih, "IMAGE");
+      }
+      else
+      {
+        name = iupAttribGet(ih, "IMAGE");
+      }
+    }
 
+    if (name)
+    {
+      int make_inactive = !active;
+      NSImage* the_bitmap = iupImageGetImage(name, ih, make_inactive, NULL);
+      [the_toggle setImage:the_bitmap];
+      cocoaToggleUpdateImageSize(ih);
+    }
+    else
+    {
+      [the_toggle setImage:nil];
+    }
+  }
+}
+
+static int cocoaToggleSetTitleAttrib(Ihandle* ih, const char* value)
+{
+  id the_toggle = ih->handle;
+
+  if ([the_toggle isKindOfClass:[NSSwitch class]])
+  {
+    /* NSSwitch does not have a title */
+    return 0;
+  }
+
+  if (ih->data->type == IUP_TOGGLE_TEXT)
+  {
+    char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);
+
+    if (stripped_str && *stripped_str != 0)
+    {
+      NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
+      [the_toggle setTitle:ns_string];
+    }
+    else
+    {
+      [the_toggle setTitle:@""];
+    }
+
+    if (stripped_str && stripped_str != value)
+    {
+      free(stripped_str);
+    }
+
+    return 1;
+  }
+
+  return 0;
+}
+
 static int cocoaToggleSetValueAttrib(Ihandle* ih, const char* value)
 {
-	NSButton* the_toggle = ih->handle;
+  id the_toggle = ih->handle;
+  Ihandle* radio = iupRadioFindToggleParent(ih);
 
-	if (iupStrEqualNoCase(value,"NOTDEF"))
-	{
-		[the_toggle setState:NSMixedState];
-	}
-	else
-	{
-		if (iupStrEqualNoCase(value,"TOGGLE"))
-		{
-			if([the_toggle state] == NSOffState)
-			{
-				[the_toggle setState:NSOnState];
-			}
-			else
-			{
-				[the_toggle setState:NSOffState];
-			}
-			
-		}
-		else
-		{
-			int new_state = iupStrBoolean(value);
-			[the_toggle setState:new_state];
+  if ([the_toggle isKindOfClass:[NSSwitch class]])
+  {
+    if (iupStrEqualNoCase(value, "NOTDEF"))
+    {
+      /* NSSwitch does not support mixed state */
+      return 0;
+    }
+    else if (iupStrEqualNoCase(value, "TOGGLE"))
+    {
+      NSControlStateValue current_state = [the_toggle state];
+      NSControlStateValue new_state = (current_state == NSControlStateValueOff) ? NSControlStateValueOn : NSControlStateValueOff;
+      [the_toggle setState:new_state];
+    }
+    else
+    {
+      int new_state = iupStrBoolean(value);
+      [the_toggle setState:new_state ? NSControlStateValueOn : NSControlStateValueOff];
+    }
+  }
+  else
+  {
+    /* Existing NSButton logic */
+    if (iupStrEqualNoCase(value, "NOTDEF"))
+    {
+      [the_toggle setAllowsMixedState:YES];
+      [the_toggle setState:NSControlStateValueMixed];
+      if (!radio && ih->data->type == IUP_TOGGLE_TEXT)
+        iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", -1);
+    }
+    else if (iupStrEqualNoCase(value, "TOGGLE"))
+    {
+      if (!radio && ih->data->type == IUP_TOGGLE_TEXT && [the_toggle allowsMixedState])
+      {
+        int current = iupAttribGetInt(ih, "_IUPCOCOA_3STATE_CURRENT");
 
-		}
-	}
-	
-	return 0;
+        if (current == 1)
+        {
+          [the_toggle setState:NSControlStateValueMixed];
+          iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", -1);
+        }
+        else if (current == -1)
+        {
+          [the_toggle setState:NSControlStateValueOff];
+          iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", 0);
+        }
+        else
+        {
+          [the_toggle setState:NSControlStateValueOn];
+          iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", 1);
+        }
+      }
+      else
+      {
+        NSControlStateValue current_state = [the_toggle state];
+        NSControlStateValue new_state = (current_state == NSControlStateValueOff) ? NSControlStateValueOn : NSControlStateValueOff;
+
+        if (radio && new_state == NSControlStateValueOn)
+        {
+          Ihandle* last_tg = (Ihandle*)iupAttribGet(radio, "_IUPCOCOA_LASTTOGGLE");
+          if (iupObjectCheck(last_tg) && last_tg != ih)
+          {
+            NSButton* last_button = (NSButton*)last_tg->handle;
+            [last_button setState:NSControlStateValueOff];
+
+            if (last_tg->data->type == IUP_TOGGLE_IMAGE)
+            {
+              cocoaToggleUpdateImage(last_tg, iupdrvIsActive(last_tg), 0);
+            }
+          }
+          iupAttribSet(radio, "_IUPCOCOA_LASTTOGGLE", (char*)ih);
+        }
+
+        [the_toggle setState:new_state];
+
+        if (ih->data->type == IUP_TOGGLE_IMAGE)
+        {
+          cocoaToggleUpdateImage(ih, iupdrvIsActive(ih), new_state == NSControlStateValueOn);
+        }
+
+        if (!radio && ih->data->type == IUP_TOGGLE_TEXT && [the_toggle allowsMixedState])
+        {
+          int state_val = (new_state == NSControlStateValueOn) ? 1 : 0;
+          iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", state_val);
+        }
+      }
+    }
+    else
+    {
+      int new_state = iupStrBoolean(value);
+
+      if (radio)
+      {
+        if (new_state)
+        {
+          Ihandle* last_tg = (Ihandle*)iupAttribGet(radio, "_IUPCOCOA_LASTTOGGLE");
+          if (iupObjectCheck(last_tg) && last_tg != ih)
+          {
+            NSButton* last_button = (NSButton*)last_tg->handle;
+            [last_button setState:NSControlStateValueOff];
+
+            if (last_tg->data->type == IUP_TOGGLE_IMAGE)
+            {
+              cocoaToggleUpdateImage(last_tg, iupdrvIsActive(last_tg), 0);
+            }
+          }
+          iupAttribSet(radio, "_IUPCOCOA_LASTTOGGLE", (char*)ih);
+          [the_toggle setState:NSControlStateValueOn];
+        }
+        else
+        {
+          if (ih == (Ihandle*)iupAttribGet(radio, "_IUPCOCOA_LASTTOGGLE"))
+            return 0;
+        }
+      }
+      else
+      {
+        [the_toggle setState:new_state ? NSControlStateValueOn : NSControlStateValueOff];
+
+        if (ih->data->type == IUP_TOGGLE_TEXT && [the_toggle allowsMixedState])
+        {
+          iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", new_state ? 1 : 0);
+        }
+      }
+
+      if (ih->data->type == IUP_TOGGLE_IMAGE)
+      {
+        cocoaToggleUpdateImage(ih, iupdrvIsActive(ih), new_state);
+      }
+    }
+  }
+
+  return 0;
 }
 
 static char* cocoaToggleGetValueAttrib(Ihandle* ih)
 {
-	NSButton* the_toggle = ih->handle;
-	int current_state = (int)[the_toggle state];
-	// it happens that iupStrReturnChecked uses the same values for mixed, off, and on
-	return iupStrReturnChecked(current_state);
+  id the_toggle = ih->handle;
+  NSControlStateValue current_state = [the_toggle state];
+
+  if ([the_toggle isKindOfClass:[NSSwitch class]])
+  {
+    if (current_state == NSControlStateValueOn)
+      return iupStrReturnChecked(1);
+    else
+      return iupStrReturnChecked(0);
+  }
+  else
+  {
+    if (current_state == NSControlStateValueMixed)
+      return iupStrReturnChecked(-1);
+    else if (current_state == NSControlStateValueOn)
+      return iupStrReturnChecked(1);
+    else
+      return iupStrReturnChecked(0);
+  }
 }
 
+static int cocoaToggleSetImageAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    NSButton* the_toggle = ih->handle;
 
+    if (value != iupAttribGet(ih, "IMAGE"))
+      iupAttribSet(ih, "IMAGE", (char*)value);
 
+    cocoaToggleUpdateImage(ih, iupdrvIsActive(ih), [the_toggle state] == NSControlStateValueOn);
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaToggleSetImInactiveAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    if (value != iupAttribGet(ih, "IMINACTIVE"))
+      iupAttribSet(ih, "IMINACTIVE", (char*)value);
+
+    if (!iupdrvIsActive(ih))
+    {
+      NSButton* the_toggle = ih->handle;
+      cocoaToggleUpdateImage(ih, 0, [the_toggle state] == NSControlStateValueOn);
+    }
+
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaToggleSetImPressAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    NSButton* the_toggle = ih->handle;
+
+    if (value != iupAttribGet(ih, "IMPRESS"))
+      iupAttribSet(ih, "IMPRESS", (char*)value);
+
+    if ([the_toggle state] == NSControlStateValueOn)
+    {
+      cocoaToggleUpdateImage(ih, iupdrvIsActive(ih), 1);
+    }
+
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaToggleSetActiveAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    NSButton* the_toggle = ih->handle;
+    int active = iupStrBoolean(value);
+    int check = ([the_toggle state] == NSControlStateValueOn) ? 1 : 0;
+    cocoaToggleUpdateImage(ih, active, check);
+  }
+
+  return iupBaseSetActiveAttrib(ih, value);
+}
+
+static int cocoaToggleSetAlignmentAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    iupAttribSet(ih, "ALIGNMENT", (char*)value);
+    return 1;
+  }
+
+  return 0;
+}
+
+static int cocoaToggleSetPaddingAttrib(Ihandle* ih, const char* value)
+{
+  if (iupStrEqual(value, "DEFAULTBUTTONPADDING"))
+    value = IupGetGlobal("DEFAULTBUTTONPADDING");
+
+  iupStrToIntInt(value, &ih->data->horiz_padding, &ih->data->vert_padding, 'x');
+
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    NSButton* the_toggle = ih->handle;
+    [[the_toggle cell] setImageScaling:NSImageScaleProportionallyDown];
+    cocoaToggleUpdateImageSize(ih);
+  }
+
+  return 1;
+}
+
+static int cocoaToggleSetFgColorAttrib(Ihandle* ih, const char* value)
+{
+  unsigned char r, g, b;
+
+  id the_toggle = ih->handle;
+  if ([the_toggle isKindOfClass:[NSSwitch class]])
+  {
+    /* NSSwitch does not have text */
+    return 0;
+  }
+
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
+
+  if (ih->data->type == IUP_TOGGLE_TEXT)
+  {
+    NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+
+    NSMutableAttributedString* attrTitle = [[NSMutableAttributedString alloc]
+      initWithString:[the_toggle title]];
+    NSRange range = NSMakeRange(0, [attrTitle length]);
+    [attrTitle addAttribute:NSForegroundColorAttributeName value:color range:range];
+    [the_toggle setAttributedTitle:attrTitle];
+    [attrTitle release];
+  }
+
+  return 1;
+}
+
+static int cocoaToggleSetFlatAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->data->type == IUP_TOGGLE_IMAGE)
+  {
+    NSButton* the_toggle = ih->handle;
+    ih->data->flat = iupStrBoolean(value);
+
+    if (ih->data->flat)
+    {
+      [the_toggle setBordered:NO];
+      [[the_toggle cell] setImageScaling:NSImageScaleProportionallyDown];
+    }
+    else
+    {
+      [the_toggle setBordered:YES];
+      [the_toggle setBezelStyle:NSBezelStyleRegularSquare];
+    }
+
+    cocoaToggleUpdateImageSize(ih);
+    return 1;
+  }
+
+  return 0;
+}
+
 static int cocoaToggleMapMethod(Ihandle* ih)
 {
-	char* value;
+  Ihandle* radio = iupRadioFindToggleParent(ih);
+  char* value;
+  id the_toggle; /* Use id to hold either NSButton or NSSwitch */
+  NSRect initialFrame = NSMakeRect(0, 0, 0, 0);
+  int initial_checked = 0;
+  int is_switch = 0;
 
-	
-	
-	static int woffset = 0;
-	static int hoffset = 0;
-	
-//	woffset += 30;
-//	hoffset += 30;
-	//	ih->data->type = 0;
-	
-	NSButton* the_toggle = [[NSButton alloc] initWithFrame:NSZeroRect];
-//	NSButton* the_toggle = [[NSButton alloc] initWithFrame:NSMakeRect(woffset, hoffset, 0, 0)];
-	
-	[the_toggle setButtonType:NSSwitchButton];
+  iupAttribSet(ih, "_IUPCOCOA_ACTIVE", "YES");
 
-	
-	
-	if(iupAttribGetBoolean(ih, "3STATE"))
-	{
-		[the_toggle setAllowsMixedState:YES];
-	}
-	else
-	{
-		// too aggressive? should we just leave it alone?
-		[the_toggle setAllowsMixedState:NO];
-	}
-	
-	
+  value = iupAttribGet(ih, "IMAGE");
+  if (value && *value != 0)
+  {
+    ih->data->type = IUP_TOGGLE_IMAGE;
+  }
+  else
+  {
+    ih->data->type = IUP_TOGGLE_TEXT;
+    if (iupAttribGetBoolean(ih, "SWITCH"))
+    {
+      is_switch = 1;
+    }
+  }
 
-	value = iupAttribGet(ih, "IMAGE");
-	if(value && *value!=0)
-	{
-		ih->data->type = IUP_TOGGLE_IMAGE;
-		
-		[the_toggle setButtonType:NSSwitchButton];
-		
-		// I don't know what the style should be for images
-		// https://mackuba.eu/2014/10/06/a-guide-to-nsToggle-styles/
-		//		[the_toggle setBezelStyle:NSRoundedBezelStyle];
-//		[the_toggle setBezelStyle:NSThickSquareBezelStyle];
-		//		[the_toggle setBezelStyle:NSShadowlessSquareBezelStyle];
-		//		[the_toggle setBezelStyle:NSTexturedSquareBezelStyle];
-		//		[the_toggle setBezelStyle:NSThickerSquareBezelStyle];
-		
-		
-		NSImage* the_bitmap;
-		int make_inactive = 0;
-		
-		
-		if(iupAttribGet(ih, "IMINACTIVE"))
-		{
-			make_inactive = 1;
-		}
-		
-		the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
-		[the_toggle setImage:the_bitmap];
-		
-		
-		value = iupAttribGet(ih, "IMPRESS");
-		if(value && *value!=0)
-		{
-			the_bitmap = iupImageGetImage(value, ih, make_inactive, NULL);
-			[the_toggle setAlternateImage:the_bitmap];
-		}
-	}
-	else
-	{
-		ih->data->type = IUP_TOGGLE_TEXT;
-		
-		[the_toggle setButtonType:NSSwitchButton];
-//		[the_toggle setBezelStyle:NSRoundedBezelStyle];
-	}
-    value = iupAttribGet(ih, "TITLE");
-    if(value && *value!=0)
+  if (is_switch)
+  {
+    the_toggle = [[NSSwitch alloc] initWithFrame:initialFrame];
+    /* NSSwitch is only available on 10.10+ but that should be fine */
+  }
+  else
+  {
+    the_toggle = [[IupCocoaToggleButton alloc] initWithFrame:initialFrame];
+
+    if (ih->data->type == IUP_TOGGLE_IMAGE)
     {
-        char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);   /* remove & */
-        
-        // This will return nil if the string can't be converted.
-        NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
-        
-        if(stripped_str && stripped_str != value)
+      [the_toggle setButtonType:NSButtonTypePushOnPushOff];
+
+      if (ih->data->flat)
+      {
+        [the_toggle setBordered:NO];
+        [[the_toggle cell] setImageScaling:NSImageScaleProportionallyDown];
+      }
+      else
+      {
+        [the_toggle setBezelStyle:NSBezelStyleRegularSquare];
+      }
+
+      [[the_toggle cell] setImagePosition:NSImageOnly];
+      [the_toggle setTitle:@""];
+    }
+    else /* IUP_TOGGLE_TEXT and not a switch */
+    {
+      if (radio)
+      {
+        [the_toggle setButtonType:NSButtonTypeRadio];
+        ih->data->is_radio = 1;
+
+        if (!iupAttribGet(radio, "_IUPCOCOA_LASTTOGGLE"))
         {
-            free(stripped_str);
+          iupAttribSet(ih, "VALUE", "ON");
+          initial_checked = 1;
         }
-        
+
+        if (!iupAttribGetHandleName(ih))
+          iupAttribSetHandleName(ih);
+      }
+      else
+      {
+        [the_toggle setButtonType:NSButtonTypeSwitch]; /* This is the checkbox style */
+
+        if (iupAttribGetBoolean(ih, "3STATE"))
+        {
+          [the_toggle setAllowsMixedState:YES];
+        }
+      }
+
+      value = iupAttribGet(ih, "TITLE");
+      if (value && *value != 0)
+      {
+        char* stripped_str = iupStrProcessMnemonic(value, NULL, 0);
+        NSString* ns_string = [NSString stringWithUTF8String:stripped_str];
+
+        if (stripped_str && stripped_str != value)
+          free(stripped_str);
+
         [the_toggle setTitle:ns_string];
-
+      }
     }
+  }
 
-	//	[the_toggle setToggleType:NSMomentaryLightButton];
+  ih->handle = the_toggle;
 
+  objc_setAssociatedObject(the_toggle, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
 
+  IupCocoaToggleReceiver* toggle_receiver = [[IupCocoaToggleReceiver alloc] init];
+  [the_toggle setTarget:toggle_receiver];
+  [the_toggle setAction:@selector(myToggleClickAction:)];
+  objc_setAssociatedObject(the_toggle, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY, (id)toggle_receiver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  [toggle_receiver release];
 
-	
-//	[the_toggle sizeToFit];
-	
-	
-	
-	ih->handle = the_toggle;
-	
-	// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-	objc_setAssociatedObject(the_toggle, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-	// I also need to track the memory of the buttion action receiver.
-	// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-	// So with only one pointer to deal with, this means we need our Toggle to hold a reference to the receiver object.
-	// This is generally not good Cocoa as Toggles don't retain their receivers, but this seems like the best option.
-	// Be careful of retain cycles.
-	IupCocoaToggleReceiver* toggle_receiver = [[IupCocoaToggleReceiver alloc] init];
-	[the_toggle setTarget:toggle_receiver];
-	[the_toggle setAction:@selector(myToggleClickAction:)];
-	// I *think* is we use RETAIN, the object will be released automatically when the Toggle is freed.
-	// However, the fact that this is tricky and I had to look up the rules (not to mention worrying about retain cycles)
-	// makes me think I should just explicitly manage the memory so everybody is aware of what's going on.
-	objc_setAssociatedObject(the_toggle, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY, (id)toggle_receiver, OBJC_ASSOCIATION_ASSIGN);
-	
-	
-	iupCocoaSetAssociatedViews(ih, the_toggle, the_toggle);
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
-	
-	
+  iupcocoaSetAssociatedViews(ih, the_toggle, the_toggle);
 
-	
-	
-	
-	
-	
-	//	cocoa_widget_realize(ih->handle);
-	
-	/* update a mnemonic in a label if necessary */
-	//	iupcocoaUpdateMnemonic(ih);
-	
-	return IUP_NOERROR;
+  if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+    iupcocoaSetCanFocus(ih, 0);
+  else
+    iupcocoaSetCanFocus(ih, 1);
+
+  iupcocoaAddToParent(ih);
+
+  value = iupAttribGet(ih, "VALUE");
+  if (!value && initial_checked)
+    value = "ON";
+
+  if (value)
+  {
+    cocoaToggleSetValueAttrib(ih, value);
+  }
+  else
+  {
+    if (ih->data->type == IUP_TOGGLE_IMAGE)
+    {
+      cocoaToggleUpdateImage(ih, iupdrvIsActive(ih), 0);
+    }
+    else if (ih->data->type == IUP_TOGGLE_TEXT && !is_switch && [the_toggle allowsMixedState])
+    {
+      iupAttribSetInt(ih, "_IUPCOCOA_3STATE_CURRENT", 0);
+    }
+  }
+
+  return IUP_NOERROR;
 }
 
 static void cocoaToggleUnMapMethod(Ihandle* ih)
 {
-	id the_toggle = ih->handle;
-	
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
-	
-	id butten_receiver = objc_getAssociatedObject(the_toggle, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY);
-	objc_setAssociatedObject(the_toggle, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
-	[butten_receiver release];
-	
-	iupCocoaRemoveFromParent(ih);
+  id the_toggle = ih->handle;
 
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[the_toggle release];
-	ih->handle = NULL;
-	
+  Ihandle* context_menu_ih = (Ihandle*)iupcocoaCommonBaseGetContextMenuAttrib(ih);
+  if (context_menu_ih != NULL)
+  {
+    IupDestroy(context_menu_ih);
+    iupcocoaCommonBaseSetContextMenuAttrib(ih, NULL);
+  }
+
+  [the_toggle setTarget:nil];
+  id button_receiver = objc_getAssociatedObject(the_toggle, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY);
+  objc_setAssociatedObject(the_toggle, IUP_COCOA_TOGGLE_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+
+  Ihandle* radio = iupRadioFindToggleParent(ih);
+  if (radio)
+  {
+    Ihandle* last_tg = (Ihandle*)iupAttribGet(radio, "_IUPCOCOA_LASTTOGGLE");
+    if (last_tg == ih)
+      iupAttribSet(radio, "_IUPCOCOA_LASTTOGGLE", NULL);
+  }
+
+  iupcocoaRemoveFromParent(ih);
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+  [the_toggle release];
+  ih->handle = NULL;
 }
 
 
 void iupdrvToggleInitClass(Iclass* ic)
 {
-	/* Driver Dependent Class functions */
-	ic->Map = cocoaToggleMapMethod;
-	ic->UnMap = cocoaToggleUnMapMethod;
-	
-#if 0
+  ic->Map = cocoaToggleMapMethod;
+  ic->UnMap = cocoaToggleUnMapMethod;
 
-	
-  /* Driver Dependent Attribute functions */
-
-  /* Overwrite Common */
-  iupClassRegisterAttribute(ic, "STANDARDFONT", NULL, cocoaToggleSetStandardFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NO_SAVE|IUPAF_NOT_MAPPED);
-
-  /* Overwrite Visual */
-  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, cocoaToggleSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-
-  /* Visual */
   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaToggleSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);
 
-  /* Special */
-  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaToggleSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);  /* black */
-#endif
-
   iupClassRegisterAttribute(ic, "TITLE", NULL, cocoaToggleSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "VALUE", cocoaToggleGetValueAttrib, cocoaToggleSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, cocoaToggleSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
 
-#if 0
-  /* IupToggle only */
-  iupClassRegisterAttribute(ic, "ALIGNMENT", NULL, cocoaToggleSetAlignmentAttrib, "ACENTER:ACENTER", NULL, IUPAF_NO_INHERIT); /* force new default value */
+  iupClassRegisterAttribute(ic, "ALIGNMENT", NULL, cocoaToggleSetAlignmentAttrib, "ACENTER:ACENTER", NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "IMAGE", NULL, cocoaToggleSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "IMINACTIVE", NULL, cocoaToggleSetImInactiveAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "IMPRESS", NULL, cocoaToggleSetImPressAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-#endif
-	
-  iupClassRegisterAttribute(ic, "VALUE", cocoaToggleGetValueAttrib, cocoaToggleSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
-#if 0
   iupClassRegisterAttribute(ic, "PADDING", iupToggleGetPaddingAttrib, cocoaToggleSetPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED);
+  iupClassRegisterAttribute(ic, "FLAT", NULL, cocoaToggleSetFlatAttrib, NULL, NULL, IUPAF_DEFAULT);
   iupClassRegisterAttribute(ic, "MARKUP", NULL, NULL, NULL, NULL, IUPAF_DEFAULT);
 
-  /* NOT supported */
-  iupClassRegisterAttribute(ic, "RIGHTToggle", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-#endif
-	
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, iupCocoaCommonBaseSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupCocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+  iupClassRegisterAttribute(ic, "RIGHTBUTTON", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
 
+  iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupcocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
 }
Index: src/cocoa/iupcocoa_tree.m
===================================================================
--- src/cocoa/iupcocoa_tree.m	(revision 5971)
+++ src/cocoa/iupcocoa_tree.m	(working copy)
@@ -6,6 +6,7 @@
 
 #import <Cocoa/Cocoa.h>
 #import <objc/runtime.h>
+#import <QuartzCore/QuartzCore.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -33,100 +34,114 @@
 #include "iupcocoa_drv.h"
 #import "IupCocoaTreeToggleTableCellView.h"
 
-// TODO:
-// Removing the disclosure triangle, Disable indenting
-// https://stackoverflow.com/questions/4251790/nsoutlineview-remove-disclosure-triangle-and-indent
+@interface NSNib (IupCocoaOutlineView)
++ (instancetype)IupCocoaOutlineView;
+@end
 
-// the point of this is we have a unique memory address for an identifier
+@interface NSNib (IupCocoaOutlineViewToggle)
++ (instancetype)IupCocoaOutlineViewToggle;
+@end
+
 static const void* IUP_COCOA_TREE_DELEGATE_OBJ_KEY = "IUP_COCOA_TREE_DELEGATE_OBJ_KEY";
+static const void* IUP_COCOA_TREE_TEXTFIELD_OWNER_KEY = "IUP_COCOA_TREE_TEXTFIELD_OWNER_KEY";
+static NSString* const IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE = @"br.puc-rio.tecgraf.iup.outlineview.dragdrop";
 
-static  NSString* const IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE = @"iupcocoa.outlineview.dragdrop";
+static void cocoaTreeUpdateDragDrop(Ihandle* ih);
 
-
-
-static NSView* cocoaTreeGetRootView(Ihandle* ih)
+static NSScrollView* cocoaTreeGetScrollView(Ihandle* ih)
 {
-	NSView* root_container_view = (NSView*)ih->handle;
-	NSCAssert([root_container_view isKindOfClass:[NSView class]], @"Expected NSView");
-	return root_container_view;
+  NSScrollView* scroll_view = (NSScrollView*)ih->handle;
+  NSCAssert([scroll_view isKindOfClass:[NSScrollView class]], @"Expected NSScrollView");
+  return scroll_view;
 }
 
-static NSScrollView* cocoaTreeGetScrollView(Ihandle* ih)
+static NSOutlineView* cocoaTreeGetOutlineView(Ihandle* ih)
 {
-	NSScrollView* scroll_view = (NSScrollView*)ih->handle;
-	NSCAssert([scroll_view isKindOfClass:[NSScrollView class]], @"Expected NSScrollView");
-	return scroll_view;
+  NSScrollView* scroll_view = cocoaTreeGetScrollView(ih);
+  NSOutlineView* outline_view = (NSOutlineView*)[scroll_view documentView];
+  NSCAssert([outline_view isKindOfClass:[NSOutlineView class]], @"Expected NSOutlineView");
+  return outline_view;
 }
 
-static NSOutlineView* cocoaTreeGetOutlineView(Ihandle* ih)
+/* Custom row view to handle HLCOLOR attribute for selection */
+@interface IupCocoaTreeRowView : NSTableRowView
+@property(nonatomic, assign) Ihandle* ih;
+@end
+
+@implementation IupCocoaTreeRowView
+@synthesize ih = _ih;
+
+- (void)drawSelectionInRect:(NSRect)dirtyRect
 {
-	
-	NSScrollView* scroll_view = cocoaTreeGetScrollView(ih);
-	NSOutlineView* outline_view = (NSOutlineView*)[scroll_view documentView];
-	NSCAssert([outline_view isKindOfClass:[NSOutlineView class]], @"Expected NSOutlineView");
-	return outline_view;
-	
+  if (self.ih)
+  {
+    char* color_str = iupAttribGetStr(self.ih, "HLCOLOR");
+    if (color_str)
+    {
+      unsigned char r, g, b;
+      if (iupStrToRGB(color_str, &r, &g, &b))
+      {
+        NSColor* color = [NSColor colorWithCalibratedRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+        [color set];
+        NSRectFill(dirtyRect);
+        return;
+      }
+    }
+  }
+  /* Fallback to default selection drawing if HLCOLOR is not set or ih is nil */
+  [super drawSelectionInRect:dirtyRect];
 }
+@end
 
 @class IupCocoaTreeItem;
 
-// Be very careful about retain cycles. Nothing in this class retains anything at the moment.
-// IupCocoaTreeItem retains this.
+/* Be very careful about retain cycles. Nothing in this class retains anything at the moment. */
+/* IupCocoaTreeItem retains this. */
 @interface IupCocoaTreeToggleReceiver : NSObject
 @property(nonatomic, assign) Ihandle* ihandle;
-@property(nonatomic, assign) IupCocoaTreeItem* treeItem; // back pointer to tree item (weak)
+@property(nonatomic, assign) IupCocoaTreeItem* treeItem; /* back pointer to tree item (weak) */
 - (IBAction) myToggleClickAction:(id)the_sender;
 @end
 
 @implementation IupCocoaTreeToggleReceiver
 
-// all properties are assign, so we don't need to override dealloc
-/*
- - (void) dealloc
- {
-	[super dealloc];
- }
- */
-
+/* all properties are assign, so we don't need to override dealloc */
 - (IBAction) myToggleClickAction:(id)the_sender;
 {
-//	Icallback callback_function;
-//	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
-	Ihandle* ih = [self ihandle];
-	IupCocoaTreeItem* tree_item = [self treeItem];
-	NSControlStateValue new_state = [the_sender state];
-	
-	int item_id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
+  Ihandle* ih = [self ihandle];
+  IupCocoaTreeItem* tree_item = [self treeItem];
+  NSControlStateValue new_state = [the_sender state];
 
-	IFnii action_callback_function = (IFnii)IupGetCallback(ih, "TOGGLEVALUE_CB");
-	if(action_callback_function)
-	{
-		if(action_callback_function(ih, item_id, (int)new_state) == IUP_CLOSE)
-		{
-			IupExitLoop();
-		}
-	}
-	
+  int item_id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
+
+  IFnii action_callback_function = (IFnii)IupGetCallback(ih, "TOGGLEVALUE_CB");
+  if(action_callback_function)
+  {
+    action_callback_function(ih, item_id, (int)new_state);
+  }
+
+  if (iupAttribGetBoolean(ih, "MARKWHENTOGGLE"))
+  {
+    IupSetAttributeId(ih, "MARKED", item_id, new_state > 0 ? "Yes" : "No");
+  }
 }
 
 @end
 
-
-
 @interface IupCocoaTreeItem : NSObject
 {
-	IupCocoaTreeItem* parentItem;
-	NSMutableArray* childrenArray;
-	NSString* title;
-	int kind; // ITREE_BRANCH ITREE_LEAF
-	NSControlStateValue checkBoxState;
-	bool checkBoxHidden;
-	BOOL isDeleted;
-	NSImage* bitmapImage;
-	NSImage* collapsedImage;
-	NSTableCellView* tableCellView; // kind of a hack to force layout in heightOf
-	
-	IupCocoaTreeToggleReceiver* toggleReceiver; // For TOGGLE_CB callbacks. cloning is tricky because of (maybe) different ih, so be careful.
+  IupCocoaTreeItem* parentItem;
+  NSMutableArray* childrenArray;
+  NSString* title;
+  int kind; /* ITREE_BRANCH ITREE_LEAF */
+  NSControlStateValue checkBoxState;
+  bool checkBoxHidden;
+  BOOL isDeleted;
+  NSImage* bitmapImage;
+  NSImage* collapsedImage;
+  NSColor* textColor;
+  NSFont* font;
+  IupCocoaTreeToggleReceiver* toggleReceiver; /* For TOGGLE_CB callbacks. */
 }
 
 @property(nonatomic, assign) int kind;
@@ -137,2889 +152,2630 @@
 @property(nonatomic, assign) BOOL isDeleted;
 @property(nonatomic, retain) NSImage* bitmapImage;
 @property(nonatomic, retain) NSImage* collapsedImage;
-@property(nonatomic, weak) NSTableCellView* tableCellView; // this is kind of a hack to force layout in heightOf. I'm not sure if I want to keep a strong reference because I don't know if there is a possible circular reference here.
-@property(nonatomic, retain) IupCocoaTreeToggleReceiver* toggleReceiver; // optional, depending if toggle is used
+@property(nonatomic, retain) NSColor* textColor;
+@property(nonatomic, retain) NSFont* font;
+@property(nonatomic, retain) IupCocoaTreeToggleReceiver* toggleReceiver;
 
 - (instancetype) cloneWithNewParentItem:(IupCocoaTreeItem*)new_parent_item ihandle:(Ihandle*)ih;
-
 - (IupCocoaTreeItem*) childAtIndex:(NSUInteger)the_index;
 
 @end
 
-// forward declaration needed
+/* Forward declaration needed */
 static void cocoaTreeReloadItem(IupCocoaTreeItem* tree_item, NSOutlineView* outline_view);
 
-
 @implementation IupCocoaTreeItem
 
-@synthesize kind = kind;
-@synthesize checkBoxState = checkBoxState;
-@synthesize checkBoxHidden = checkBoxHidden;
-@synthesize title = title;
-@synthesize parentItem = parentItem;
-@synthesize isDeleted = isDeleted;
-@synthesize bitmapImage = bitmapImage; // is the expandedImage for branches
-@synthesize collapsedImage = collapsedImage;
-@synthesize tableCellView = tableCellView;
-@synthesize toggleReceiver = toggleReceiver;
+@synthesize kind;
+@synthesize checkBoxState;
+@synthesize checkBoxHidden;
+@synthesize title;
+@synthesize parentItem;
+@synthesize isDeleted;
+@synthesize bitmapImage; /* is the expandedImage for branches */
+@synthesize collapsedImage;
+@synthesize textColor;
+@synthesize font;
+@synthesize toggleReceiver;
 
-
-// Creates, caches, and returns the array of children
-// Loads children incrementally
+/* Creates, caches, and returns the array of children */
+/* Loads children incrementally */
 - (NSMutableArray*) childrenArray
 {
-	return childrenArray;
+  return childrenArray;
 }
 
 - (void) setChildrenArray:(NSMutableArray*)new_array
 {
-	if(childrenArray == new_array)
-	{
-		return;
-	}
-	[childrenArray release];
-	childrenArray = [new_array retain];
+  if(childrenArray == new_array)
+  {
+    return;
+  }
+  [childrenArray release];
+  childrenArray = [new_array retain];
 }
 
-
 - (IupCocoaTreeItem*) childAtIndex:(NSUInteger)the_index
 {
-	return [[self childrenArray] objectAtIndex:the_index];
+  return [[self childrenArray] objectAtIndex:the_index];
 }
 
-
 - (NSUInteger) numberOfChildren
 {
-	NSArray* tmp = [self childrenArray];
-	return [tmp count];
+  return [[self childrenArray] count];
 }
 
-
 - (instancetype) init
 {
-	self = [super init];
-	if(self)
-	{
-		childrenArray = [[NSMutableArray alloc] init];
-	}
-	return self;
+  self = [super init];
+  if(self)
+  {
+    childrenArray = [[NSMutableArray alloc] init];
+  }
+  return self;
 }
 
 - (void) dealloc
 {
-	//[tableCellView releae];
-	tableCellView = nil; // weak ref
-	
-	[toggleReceiver release];
-	
-	[bitmapImage release];
-	[collapsedImage release];
+  [toggleReceiver release];
 
-	[childrenArray release];
-	[title release];
-	parentItem = nil; // weak ref
-	[super dealloc];
+  [bitmapImage release];
+  [collapsedImage release];
+  [textColor release];
+  [font release];
+
+  [childrenArray release];
+  [title release];
+  parentItem = nil; /* weak ref */
+  [super dealloc];
 }
 
 - (instancetype) cloneWithNewParentItem:(IupCocoaTreeItem*)new_parent_item ihandle:(Ihandle*)ih
 {
-	IupCocoaTreeItem* new_copy = [[IupCocoaTreeItem alloc] init];
-	[new_copy setParentItem:new_parent_item];
-	[new_copy setTableCellView:nil];
-	[new_copy setIsDeleted:NO];
-	
-	[new_copy setBitmapImage:[self bitmapImage]];
-	[new_copy setCollapsedImage:[self collapsedImage]];
+  IupCocoaTreeItem* new_copy = [[IupCocoaTreeItem alloc] init];
+  [new_copy setParentItem:new_parent_item];
+  [new_copy setIsDeleted:NO];
 
-	[new_copy setTitle:[self title]]; // this is a copy property
-	[new_copy setKind:[self kind]];
-	[new_copy setCheckBoxState:[self checkBoxState]];
-	[new_copy setCheckBoxHidden:[self isCheckBoxHidden]];
+  [new_copy setBitmapImage:[self bitmapImage]];
+  [new_copy setCollapsedImage:[self collapsedImage]];
+  [new_copy setTextColor:[self textColor]];
+  [new_copy setFont:[self font]];
 
-	NSMutableArray* new_children_array = [[NSMutableArray alloc] init];
-	[new_copy setChildrenArray:new_children_array];
-	[new_children_array autorelease];
-	
-	for(IupCocoaTreeItem* original_item in childrenArray)
-	{
-		IupCocoaTreeItem* child_copy = [original_item cloneWithNewParentItem:new_copy ihandle:ih];
-		[new_children_array addObject:child_copy];
-	}
+  [new_copy setTitle:[self title]]; /* this is a copy property */
+  [new_copy setKind:[self kind]];
+  [new_copy setCheckBoxState:[self checkBoxState]];
+  [new_copy setCheckBoxHidden:[self isCheckBoxHidden]];
 
-	IupCocoaTreeToggleReceiver* new_toggle_receiver = [[IupCocoaTreeToggleReceiver alloc] init];
-//	IupCocoaTreeToggleReceiver* original_toggle_receiver = [self toggleReceiver];
-	[new_toggle_receiver setTreeItem:new_copy];
-	[new_toggle_receiver setIhandle:ih];
-	[new_copy setToggleReceiver:new_toggle_receiver];
+  NSMutableArray* new_children_array = [[NSMutableArray alloc] init];
+  [new_copy setChildrenArray:new_children_array];
+  [new_children_array release];
 
-	return new_copy;
-}
+  for(IupCocoaTreeItem* original_item in childrenArray)
+  {
+    IupCocoaTreeItem* child_copy = [original_item cloneWithNewParentItem:new_copy ihandle:ih];
+    [new_children_array addObject:child_copy];
+    [child_copy release];
+  }
 
+  IupCocoaTreeToggleReceiver* new_toggle_receiver = [[IupCocoaTreeToggleReceiver alloc] init];
+  [new_toggle_receiver setTreeItem:new_copy];
+  [new_toggle_receiver setIhandle:ih];
+  [new_copy setToggleReceiver:new_toggle_receiver];
+  [new_toggle_receiver release];
 
-
-
-@end
-
-/*
-@interface IupCocoaTreeRoot : NSObject
-{
-	// Array of IupCocoaTreeItems
-	NSMutableArray* topLevelObjects;
+  return new_copy;
 }
-@end
 
-@implementation IupCocoaTreeRoot
-
 @end
-*/
 
-// We need to override NSOutlineView in order to implement things like keyDown for k_any
+/* We need to override NSOutlineView in order to implement things like keyDown for k_any */
 @interface IupCocoaOutlineView : NSOutlineView
-{
-	Ihandle* _ih;
-	NSImage* leafImage;
-	NSImage* expandedImage;
-	NSImage* collapsedImage;
-}
 @property(nonatomic, assign) Ihandle* ih;
 @property(nonatomic, retain) NSImage* leafImage;
 @property(nonatomic, retain) NSImage* expandedImage;
 @property(nonatomic, retain) NSImage* collapsedImage;
-
-// My preference would be to use a zeroing weak reference, but I think that requires ARC
 @property(nonatomic, retain) IupCocoaTreeItem* markStartNode;
 @end
 
 @implementation IupCocoaOutlineView
 @synthesize ih = _ih;
-@synthesize leafImage = leafImage;
-@synthesize expandedImage = expandedImage;
-@synthesize collapsedImage = collapsedImage;
+@synthesize leafImage;
+@synthesize expandedImage;
+@synthesize collapsedImage;
 
 - (void) dealloc
 {
-	[leafImage release];
-	[expandedImage release];
-	[collapsedImage release];
-	[super dealloc];
+  [leafImage release];
+  [expandedImage release];
+  [collapsedImage release];
+  [super dealloc];
 }
-//find which keys are being pressed from the_event object. You will then map these to the Iup keycodes.
-//You invoke the user callback (3), following the usual Iup invoke callback conventions. This too should eventually be factored in a way we can call this for all widgets.
 
+- (NSMenu *)menuForEvent:(NSEvent *)event
+{
+  /* Check if CONTEXTMENU attribute has been configured by the user */
+  if (!iupAttribGet(self.ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    /* Allow default system menu */
+    return [super menuForEvent:event];
+  }
 
-//////// Keyboard stuff
+  /* Retrieve the custom menu */
+  Ihandle* menu_ih = (Ihandle*)iupAttribGet(self.ih, "_COCOA_CONTEXT_MENU_IH");
+  if (menu_ih && menu_ih->handle)
+  {
+    return (NSMenu*)menu_ih->handle;
+  }
 
+  /* CONTEXTMENU was explicitly set to NULL, disable menu */
+  return nil;
+}
+
+/* Intercept right-click to handle RIGHTCLICK_CB */
+- (void) rightMouseDown:(NSEvent *)event
+{
+  NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
+  NSInteger row = [self rowAtPoint:point];
+
+  if (row >= 0)
+  {
+    IFni cb = (IFni)IupGetCallback(self.ih, "RIGHTCLICK_CB");
+    if (cb)
+    {
+      IupCocoaTreeItem *item = [self itemAtRow:row];
+      int item_id = iupTreeFindNodeId(self.ih, (InodeHandle*)item);
+      cb(self.ih, item_id);
+      return; /* Don't call super to prevent context menu */
+    }
+  }
+
+  [super rightMouseDown:event];
+}
+
+- (void) mouseDown:(NSEvent *)event
+{
+  if ([event clickCount] == 2)
+  {
+    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
+    NSInteger row = [self rowAtPoint:point];
+
+    if (row >= 0)
+    {
+      IupCocoaTreeItem *item = [self itemAtRow:row];
+      int kind = [item kind];
+      int item_id = iupTreeFindNodeId(self.ih, (InodeHandle*)item);
+
+      if (kind == ITREE_LEAF)
+      {
+        IFni cb = (IFni)IupGetCallback(self.ih, "EXECUTELEAF_CB");
+        if (cb)
+        {
+          cb(self.ih, item_id);
+          return;
+        }
+      }
+      else
+      {
+        IFni cb = (IFni)IupGetCallback(self.ih, "EXECUTEBRANCH_CB");
+        if (cb)
+        {
+          cb(self.ih, item_id);
+          return;
+        }
+      }
+    }
+  }
+
+  [super mouseDown:event];
+}
+
 - (void) flagsChanged:(NSEvent*)the_event
 {
-//	NSLog(@"flagsChanged: %@", the_event);
-//	NSLog(@"modifierFlags: 0x%X", [the_event modifierFlags]);
-/*
-    NSEventModifierFlagCapsLock           = 1 << 16, // Set if Caps Lock key is pressed.
-    NSEventModifierFlagShift              = 1 << 17, // Set if Shift key is pressed.
-    NSEventModifierFlagControl            = 1 << 18, // Set if Control key is pressed.
-    NSEventModifierFlagOption             = 1 << 19, // Set if Option or Alternate key is pressed.
-    NSEventModifierFlagCommand            = 1 << 20, // Set if Command key is pressed.
-    NSEventModifierFlagNumericPad         = 1 << 21, // Set if any key in the numeric keypad is pressed.
-    NSEventModifierFlagHelp               = 1 << 22, // Set if the Help key is pressed.
-    NSEventModifierFlagFunction           = 1 << 23, // Set if any function key is pressed.
-*/
-	Ihandle* ih = [self ih];
-    unsigned short mac_key_code = [the_event keyCode];
-//    NSLog(@"mac_key_code : %d", mac_key_code);
-	bool should_not_propagate = iupCocoaModifierEvent(ih, the_event, (int)mac_key_code);
-	if(!should_not_propagate)
-	{
-		[super flagsChanged:the_event];
-	}
+  Ihandle* ih = [self ih];
+  unsigned short mac_key_code = [the_event keyCode];
+  bool should_not_propagate = iupcocoaModifierEvent(ih, the_event, (int)mac_key_code);
+  if(!should_not_propagate)
+  {
+    [super flagsChanged:the_event];
+  }
 }
 
 - (void) keyDown:(NSEvent*)the_event
 {
-    // gets ihandle
-    Ihandle* ih = [self ih];
-//	NSLog(@"keyDown: %@", the_event);
-    unsigned short mac_key_code = [the_event keyCode];
-//    NSLog(@"keydown string: %d", mac_key_code);
+  Ihandle* ih = [self ih];
 
-	bool should_not_propagate = iupCocoaKeyEvent(ih, the_event, (int)mac_key_code, true);
-	if(!should_not_propagate)
-	{
-		[super keyDown:the_event];
-	}
+  /* Handle Enter key for EXECUTELEAF/BRANCH callbacks */
+  NSString *chars = [the_event characters];
+  if ([chars length] > 0)
+  {
+    unichar aChar = [chars characterAtIndex:0];
+    if (aChar == NSEnterCharacter || aChar == NSCarriageReturnCharacter)
+    {
+      id delegate = [self delegate];
+      if ([delegate respondsToSelector:@selector(iupCocoaTreeDoubleClickAction:)])
+      {
+        [delegate performSelector:@selector(iupCocoaTreeDoubleClickAction:) withObject:self];
+        return; /* Consume event */
+      }
+    }
+  }
+
+  int mac_key_code = [the_event keyCode];
+  bool should_not_propagate = iupcocoaKeyEvent(ih, the_event, mac_key_code, true);
+  if(!should_not_propagate)
+  {
+    [super keyDown:the_event];
+  }
 }
 
 - (void) keyUp:(NSEvent*)the_event
 {
-	Ihandle* ih = [self ih];
-    unsigned short mac_key_code = [the_event keyCode];
-	bool should_not_propagate = iupCocoaKeyEvent(ih, the_event, (int)mac_key_code, false);
-	if(!should_not_propagate)
-	{
-		[super keyUp:the_event];
-	}
+  Ihandle* ih = [self ih];
+  int mac_key_code = [the_event keyCode];
+  bool should_not_propagate = iupcocoaKeyEvent(ih, the_event, mac_key_code, false);
+  if(!should_not_propagate)
+  {
+    [super keyUp:the_event];
+  }
 }
 
+- (void)updateTrackingAreas
+{
+  [super updateTrackingAreas];
+
+  Ihandle* ih = [self ih];
+  if (!ih)
+    return;
+
+  if (!IupGetCallback(ih, "TIPS_CB"))
+    return;
+
+  for (NSTrackingArea *area in [self trackingAreas]) {
+    if ([area owner] == self) {
+      [self removeTrackingArea:area];
+    }
+  }
+
+  NSTrackingAreaOptions options = NSTrackingMouseMoved | NSTrackingActiveInKeyWindow | NSTrackingInVisibleRect;
+  NSTrackingArea *trackingArea = [[NSTrackingArea alloc] initWithRect:[self bounds] options:options owner:self userInfo:nil];
+  [self addTrackingArea:trackingArea];
+  [trackingArea release];
+}
+
+- (void)mouseMoved:(NSEvent *)event
+{
+  [super mouseMoved:event];
+
+  Ihandle* ih = [self ih];
+  if (!ih)
+    return;
+
+  if (!iupAttribGetBoolean(ih, "INFOTIP"))
+  {
+    IFnii cb = (IFnii)IupGetCallback(ih, "TIPS_CB");
+    if (cb)
+    {
+      NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
+      cb(ih, (int)point.x, (int)point.y);
+    }
+  }
+}
+
+- (BOOL)becomeFirstResponder
+{
+  BOOL result = [super becomeFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusIn(ih);
+  }
+  return result;
+}
+
+- (BOOL)resignFirstResponder
+{
+  BOOL result = [super resignFirstResponder];
+  if (result)
+  {
+    Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+    if (ih)
+      iupcocoaFocusOut(ih);
+  }
+  return result;
+}
+
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    if (iupAttribGet(ih, "_IUPCOCOA_CANFOCUS"))
+      return iupAttribGetBoolean(ih, "_IUPCOCOA_CANFOCUS");
+    return iupAttribGetBoolean(ih, "CANFOCUS");
+  }
+  return [super acceptsFirstResponder];
+}
+
 @end
 
+@interface IupCocoaTreeTextField : NSTextField <NSTextFieldDelegate, NSTextViewDelegate>
+@end
 
-// We are not using NSComboBoxDataSource
-@interface IupCocoaTreeDelegate : NSObject <NSOutlineViewDataSource, NSOutlineViewDelegate>
+@implementation IupCocoaTreeTextField
+
+- (NSMenu *)textView:(NSTextView *)textView menu:(NSMenu *)menu forEvent:(NSEvent *)event atIndex:(NSUInteger)charIndex
 {
-	NSMutableArray* treeRootTopLevelObjects;
-	
-//	NSMutableArray* orderedArrayOfSelections; // TODO: If we decide selection order is important enough and worth the risks of edge cases missing updates (like delnode)
-	NSIndexSet* previousSelections;
-	
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih)
+  {
+    IupCocoaOutlineView* outline_view = objc_getAssociatedObject(self, IUP_COCOA_TREE_TEXTFIELD_OWNER_KEY);
+    if (outline_view)
+    {
+      ih = [outline_view ih];
+    }
+  }
+
+  if (!ih)
+  {
+    return menu;
+  }
+
+  if (!iupAttribGet(ih, "_IUPCOCOA_CONTEXTMENU_SET"))
+  {
+    return menu;
+  }
+
+  Ihandle* menu_ih = (Ihandle*)iupAttribGet(ih, "_COCOA_CONTEXT_MENU_IH");
+  if (menu_ih && menu_ih->handle)
+  {
+    return (NSMenu*)menu_ih->handle;
+  }
+
+  /* CONTEXTMENU was explicitly set to NULL, disable menu */
+  return nil;
 }
-@property(nonatomic, copy) NSArray* treeRootTopLevelObjects; // This is intended for external read-only access to iterate through all items, such as changing the branch/leaf images
+
+- (void)controlTextDidEndEditing:(NSNotification *)notification
+{
+  IupCocoaOutlineView *outlineView = objc_getAssociatedObject(self, IUP_COCOA_TREE_TEXTFIELD_OWNER_KEY);
+  if (!outlineView)
+    return;
+
+  NSInteger row = [outlineView rowForView:self];
+  if (row < 0)
+    return;
+
+  Ihandle* ih = [outlineView ih];
+  if (!ih)
+    return;
+
+  IupCocoaTreeItem* item = [outlineView itemAtRow:row];
+  if (!item)
+    return;
+
+  NSString* oldTitle = [item title];
+  NSString* newTitle = [self stringValue];
+
+  /* No change, nothing to do */
+  if ([oldTitle isEqualToString:newTitle])
+    return;
+
+  IFnis cb = (IFnis)IupGetCallback(ih, "RENAME_CB");
+  if (cb)
+  {
+    int ret = cb(ih, iupTreeFindNodeId(ih, (InodeHandle*)item), (char*)[newTitle UTF8String]);
+    if (ret == IUP_IGNORE)
+    {
+      /* Revert to old title */
+      [self setStringValue:oldTitle];
+      return;
+    }
+  }
+
+  /* Update the title */
+  [item setTitle:newTitle];
+}
+
+- (BOOL)control:(NSControl *)control textShouldBeginEditing:(NSText *)fieldEditor
+{
+    IupCocoaOutlineView* outline_view = objc_getAssociatedObject(self, IUP_COCOA_TREE_TEXTFIELD_OWNER_KEY);
+    if (!outline_view) return YES;
+
+    Ihandle* ih = [outline_view ih];
+    if (!ih) return YES;
+
+    NSInteger row = [outline_view rowForView:self];
+    if (row < 0) return YES;
+
+    IupCocoaTreeItem* item = [outline_view itemAtRow:row];
+    int item_id = iupTreeFindNodeId(ih, (InodeHandle*)item);
+
+    IFni cbShowRename = (IFni)IupGetCallback(ih, "SHOWRENAME_CB");
+    if (cbShowRename && cbShowRename(ih, item_id) == IUP_IGNORE)
+        return NO;
+
+    return YES;
+}
+
+- (void)controlTextDidBeginEditing:(NSNotification *)notification
+{
+    IupCocoaOutlineView* outline_view = objc_getAssociatedObject(self, IUP_COCOA_TREE_TEXTFIELD_OWNER_KEY);
+    if (!outline_view) return;
+
+    Ihandle* ih = [outline_view ih];
+    if (!ih) return;
+
+    NSText* fieldEditor = [[notification userInfo] objectForKey:@"NSFieldEditor"];
+    if (!fieldEditor) return;
+
+    char* value = iupAttribGetStr(ih, "RENAMECARET");
+    if (value)
+    {
+        int pos = 1;
+        if (iupStrToInt(value, &pos))
+        {
+            if (pos < 1) pos = 1;
+            pos--;
+            [fieldEditor setSelectedRange:NSMakeRange(pos, 0)];
+        }
+    }
+
+    value = iupAttribGetStr(ih, "RENAMESELECTION");
+    if (value)
+    {
+        int start = 1, end = 1;
+        if (iupStrToIntInt(value, &start, &end, ':') == 2)
+        {
+            if (start >= 1 && end >= 1)
+            {
+                start--;
+                end--;
+                if (end >= start)
+                    [fieldEditor setSelectedRange:NSMakeRange(start, end - start)];
+            }
+        }
+    }
+}
+
+@end
+
+@interface IupCocoaTreeDelegate : NSObject <NSOutlineViewDataSource, NSOutlineViewDelegate, NSTextFieldDelegate>
+{
+  NSMutableArray* treeRootTopLevelObjects;
+  NSIndexSet* previousSelections;
+}
+@property(nonatomic, retain) NSMutableArray* treeRootTopLevelObjects;
 - (NSUInteger) insertChild:(IupCocoaTreeItem*)tree_item_child withParent:(IupCocoaTreeItem*)tree_item_parent;
 - (NSUInteger) insertChild:(IupCocoaTreeItem*)tree_item_child withParent:(IupCocoaTreeItem*)tree_item_parent targetChildIndex:(NSInteger)target_child_index;
-- (NSUInteger) insertPeer:(IupCocoaTreeItem*)tree_item_new withSibling:(IupCocoaTreeItem*)tree_item_prev;
+- (NSUInteger) insertPeer:(IupCocoaTreeItem*)tree_item_new withSibling:(IupCocoaTreeItem*)tree_item_prev addMode:(int)add;
 - (void) insertAtRoot:(IupCocoaTreeItem*)tree_item_new;
 - (void) removeAllObjects;
 - (NSIndexSet*) removeAllChildrenForItem:(IupCocoaTreeItem*)tree_item;
 - (NSUInteger) removeItem:(IupCocoaTreeItem*)tree_item;
 - (void) moveItem:(IupCocoaTreeItem*)tree_item targetParent:(IupCocoaTreeItem*)tree_item_parent targetChildIndex:(NSInteger)target_child_index;
-
-//- (NSMutableArray*) dataArray;
-
-// NSOutlineViewDataSource
-- (NSInteger) outlineView:(NSOutlineView*)outline_view numberOfChildrenOfItem:(nullable id)the_item;
-//- (id) outlineView:(NSOutlineView*)outline_view child:(NSInteger)index ofItem:(nullable id)the_item;
-- (BOOL) outlineView:(NSOutlineView*)outline_view isItemExpandable:(id)the_item;
-// NSOutlineViewDelegate
-- (nullable NSView *)outlineView:(NSOutlineView*)outline_view viewForTableColumn:(nullable NSTableColumn*)table_column item:(id)the_item;
-// NSOutlineViewDelegate
-- (void) outlineViewSelectionDidChange:(NSNotification*)the_notification;
-// NSOutlineViewDelegate, for CANFOCUS
-- (NSIndexSet*) outlineView:(NSOutlineView*)outline_view selectionIndexesForProposedSelection:(NSIndexSet*)proposed_selection_indexes;
-
+- (void) iupCocoaTreeDoubleClickAction:(id)sender;
 @end
 
-
 static NSUInteger Helper_RecursivelyCountItems(IupCocoaTreeItem* the_item)
 {
-	NSUInteger counter = 1;
-	for(IupCocoaTreeItem* a_item in [the_item childrenArray])
-	{
-		counter += Helper_RecursivelyCountItems(a_item);
-	}
-	return counter;
+  NSUInteger counter = 1;
+  for(IupCocoaTreeItem* a_item in [the_item childrenArray])
+  {
+    counter += Helper_RecursivelyCountItems(a_item);
+  }
+  return counter;
 }
-/*
-static NSUInteger Helper_CountAllItems(IupCocoaTreeDelegate* tree_delegate)
-{
-	NSUInteger counter = 0;
-	for(IupCocoaTreeItem* a_item in [tree_delegate treeRootTopLevelObjects])
-	{
-		counter += Helper_RecursivelyCountItems(a_item);
-	}
-	return counter;
-}
-*/
 
 static bool Helper_RecursivelyCountDepth(IupCocoaTreeItem* current_item, IupCocoaTreeItem* find_item, NSUInteger* depth_counter)
 {
-	*depth_counter += 1;
-	for(IupCocoaTreeItem* a_item in [current_item childrenArray])
-	{
-		if([a_item isEqual:find_item])
-		{
-			return true;
-		}
-		NSUInteger new_depth_counter = *depth_counter;
-		bool did_find = Helper_RecursivelyCountDepth(a_item, find_item, &new_depth_counter);
-		if(did_find)
-		{
-			*depth_counter = new_depth_counter;
-			return true;
-		}
-	}
-	return false;
+  *depth_counter += 1;
+  for(IupCocoaTreeItem* a_item in [current_item childrenArray])
+  {
+    if([a_item isEqual:find_item])
+    {
+      return true;
+    }
+    NSUInteger new_depth_counter = *depth_counter;
+    bool did_find = Helper_RecursivelyCountDepth(a_item, find_item, &new_depth_counter);
+    if(did_find)
+    {
+      *depth_counter = new_depth_counter;
+      return true;
+    }
+  }
+  return false;
 }
 
-/*
-static NSUInteger Helper_RecursivelyCountLeafs(IupCocoaTreeItem* the_item)
-{
-	// If this is a leaf, then there are no children to descend into and count
-	if(ITREE_LEAF == [the_item kind])
-	{
-		return 1;
-	}
-
-	// else we are a branch
-	NSUInteger counter = 0;
-	for(IupCocoaTreeItem* a_item in [the_item childrenArray])
-	{
-		counter += Helper_RecursivelyCountLeafs(a_item);
-	}
-	return counter;
-}
-*/
-
 static bool Helper_CountDepth(IupCocoaTreeDelegate* tree_delegate, IupCocoaTreeItem* find_item, NSUInteger* out_depth_counter)
 {
-	for(IupCocoaTreeItem* a_item in [tree_delegate treeRootTopLevelObjects])
-	{
-		if([a_item isEqual:find_item])
-		{
-			*out_depth_counter = 0;
-			return true;
-		}
-		NSUInteger depth_counter = 0;
-		bool did_find = Helper_RecursivelyCountDepth(a_item, find_item, &depth_counter);
-		if(did_find)
-		{
-			*out_depth_counter = depth_counter;
-			return true;
-		}
-	}
-	*out_depth_counter = 0;
-	return false;
+  for(IupCocoaTreeItem* a_item in [tree_delegate treeRootTopLevelObjects])
+  {
+    if([a_item isEqual:find_item])
+    {
+      *out_depth_counter = 0;
+      return true;
+    }
+    NSUInteger depth_counter = 0;
+    bool did_find = Helper_RecursivelyCountDepth(a_item, find_item, &depth_counter);
+    if(did_find)
+    {
+      *out_depth_counter = depth_counter;
+      return true;
+    }
+  }
+  *out_depth_counter = 0;
+  return false;
 }
 
 static NSInteger Helper_RecursivelyFindFlatIndexofTreeItemInOutlineView(IupCocoaTreeItem* the_item, IupCocoaTreeItem* target_item,NSInteger* out_flat_index)
 {
-	bool is_found = false;
-	for(IupCocoaTreeItem* a_item in [the_item childrenArray])
-	{
-//		NSLog(@"Helper_RecursivelyFindFlatIndexofTreeItemInOutlineView a_item=%@, flat_index=%d", [a_item title], *out_flat_index);
-		if([a_item isEqual:target_item])
-		{
-			is_found = true;
-			break;
-		}
-		else
-		{
-			*out_flat_index = *out_flat_index+1;
-			is_found = Helper_RecursivelyFindFlatIndexofTreeItemInOutlineView(a_item, target_item, out_flat_index);
-		}
-		if(is_found)
-		{
-			break;
-		}
-	}
-	return is_found;
+  bool is_found = false;
+  for(IupCocoaTreeItem* a_item in [the_item childrenArray])
+  {
+    if([a_item isEqual:target_item])
+    {
+      is_found = true;
+      break;
+    }
+    else
+    {
+      *out_flat_index = *out_flat_index+1;
+      is_found = Helper_RecursivelyFindFlatIndexofTreeItemInOutlineView(a_item, target_item, out_flat_index);
+    }
+    if(is_found)
+    {
+      break;
+    }
+  }
+  return is_found;
 }
 
-// This is a helper function that traverses through a NSOutlineView data source delegate looking for a certain item, and returns the array index this would be in for the ordering of the Iup node_cache
+/* This is a helper function that traverses through a NSOutlineView data source delegate looking for a certain item, and returns the array index this would be in for the ordering of the Iup node_cache */
 static NSInteger Helper_FindFlatIndexofTreeItemInOutlineView(IupCocoaTreeDelegate* tree_delegate, IupCocoaTreeItem* tree_item, NSInteger* out_flat_index)
 {
-	bool is_found = false;
-	for(IupCocoaTreeItem* a_item in [tree_delegate treeRootTopLevelObjects])
-	{
-//		NSLog(@"Helper_FindFlatIndexofTreeItemInOutlineView a_item=%@, flat_index=%d", [a_item title], *out_flat_index);
-		if([a_item isEqual:tree_item])
-		{
-			is_found = true;
-			break;
-		}
-		else
-		{
-			*out_flat_index = *out_flat_index+1;
-			is_found = Helper_RecursivelyFindFlatIndexofTreeItemInOutlineView(a_item, tree_item, out_flat_index);
-		}
-		if(is_found)
-		{
-			break;
-		}
-	}
-	return is_found;
+  bool is_found = false;
+  for(IupCocoaTreeItem* a_item in [tree_delegate treeRootTopLevelObjects])
+  {
+    if([a_item isEqual:tree_item])
+    {
+      is_found = true;
+      break;
+    }
+    else
+    {
+      *out_flat_index = *out_flat_index+1;
+      is_found = Helper_RecursivelyFindFlatIndexofTreeItemInOutlineView(a_item, tree_item, out_flat_index);
+    }
+    if(is_found)
+    {
+      break;
+    }
+  }
+  return is_found;
 }
 
-
 @implementation IupCocoaTreeDelegate
-@synthesize treeRootTopLevelObjects = treeRootTopLevelObjects;
+@synthesize treeRootTopLevelObjects;
 
 - (instancetype) init
 {
-	self = [super init];
-	if(self)
-	{
-		treeRootTopLevelObjects = [[NSMutableArray alloc] init];
-	}
-	return self;
+  self = [super init];
+  if(self)
+  {
+    treeRootTopLevelObjects = [[NSMutableArray alloc] init];
+  }
+  return self;
 }
 
 - (void) dealloc
 {
-	[treeRootTopLevelObjects release];
-	[previousSelections release];
-	[super dealloc];
+  [treeRootTopLevelObjects release];
+  [previousSelections release];
+  [super dealloc];
 }
 
 - (NSUInteger) insertChild:(IupCocoaTreeItem*)tree_item_child withParent:(IupCocoaTreeItem*)tree_item_parent
 {
-	[self insertChild:tree_item_child withParent:tree_item_parent targetChildIndex:0];
-	return 0; // always index 0 since we always insert in the first position
+  [self insertChild:tree_item_child withParent:tree_item_parent targetChildIndex:0];
+  return 0; /* always index 0 since we always insert in the first position */
 }
 
 - (NSUInteger) insertChild:(IupCocoaTreeItem*)tree_item_child withParent:(IupCocoaTreeItem*)tree_item_parent targetChildIndex:(NSInteger)target_child_index
 {
-	// IUP always inserts the child in the first position, not the last, when in this parent/child relationship
-	[[tree_item_parent childrenArray] insertObject:tree_item_child atIndex:target_child_index];
-	[tree_item_child setParentItem:tree_item_parent];
-	return target_child_index;
+  [[tree_item_parent childrenArray] insertObject:tree_item_child atIndex:target_child_index];
+  [tree_item_child setParentItem:tree_item_parent];
+  return target_child_index;
 }
 
-- (NSUInteger) insertPeer:(IupCocoaTreeItem*)tree_item_new withSibling:(IupCocoaTreeItem*)tree_item_prev
+- (NSUInteger) insertPeer:(IupCocoaTreeItem*)tree_item_new withSibling:(IupCocoaTreeItem*)tree_item_prev addMode:(int)add
 {
-	IupCocoaTreeItem* tree_item_parent = [tree_item_prev parentItem];
-	if(nil != tree_item_parent)
-	{
-		[tree_item_new setParentItem:tree_item_parent];
-		// insert the new node after reference node
-		NSMutableArray* children_array = [tree_item_parent childrenArray];
-		NSUInteger prev_index = [children_array indexOfObject:tree_item_prev];
-		NSUInteger target_index = prev_index + 1;
+  IupCocoaTreeItem* tree_item_parent = [tree_item_prev parentItem];
+  if(nil != tree_item_parent)
+  {
+    [tree_item_new setParentItem:tree_item_parent];
+    NSMutableArray* children_array = [tree_item_parent childrenArray];
+    NSUInteger prev_index = [children_array indexOfObject:tree_item_prev];
 
-		if(target_index > [children_array count])
-		{
-			target_index = [children_array count];
-			[children_array addObject:tree_item_new];
-		}
-		else
-		{
-			[children_array insertObject:tree_item_new atIndex:target_index];
-		}
-		return target_index;
-	}
-	else
-	{
-		// we are adding a peer to the root (case is ADDROOT=NO)
-		NSUInteger target_index = 0;
+    /* Always insert after the sibling */
+    NSUInteger target_index = prev_index + 1;
 
-		NSUInteger object_index = [treeRootTopLevelObjects indexOfObject:tree_item_prev];
-		if(object_index != NSNotFound)
-		{
-			// insert after the previous (reference) node
-			target_index = object_index + 1;
-		}
-	
-		[treeRootTopLevelObjects insertObject:tree_item_new atIndex:target_index];
-		return target_index;
-	}
+    if(target_index > [children_array count])
+    {
+      target_index = [children_array count];
+      [children_array addObject:tree_item_new];
+    }
+    else
+    {
+      [children_array insertObject:tree_item_new atIndex:target_index];
+    }
+    return target_index;
+  }
+  else
+  {
+    NSUInteger prev_index = [treeRootTopLevelObjects indexOfObject:tree_item_prev];
+    NSUInteger target_index;
+    if(prev_index != NSNotFound)
+    {
+      /* Always insert after the sibling */
+      target_index = prev_index + 1;
+    }
+    else
+    {
+      /* Fallback: append if reference node not found */
+      target_index = [treeRootTopLevelObjects count];
+    }
+
+    [treeRootTopLevelObjects insertObject:tree_item_new atIndex:target_index];
+    return target_index;
+  }
 }
 
 - (void) insertAtRoot:(IupCocoaTreeItem*)tree_item_new
 {
-	// IUP always inserts the child in the first position, not the last
-	[treeRootTopLevelObjects insertObject:tree_item_new atIndex:0];
+  [treeRootTopLevelObjects addObject:tree_item_new];
 }
 
 - (void) removeAllObjects
 {
-	[treeRootTopLevelObjects removeAllObjects];
+  [treeRootTopLevelObjects removeAllObjects];
 }
 
-// Returns the indexes of the top-level children that get removed
 - (NSIndexSet*) removeAllChildrenForItem:(IupCocoaTreeItem*)tree_item
 {
-	if(nil == tree_item)
-	{
-		return nil;
-	}
+  if(nil == tree_item)
+  {
+    return nil;
+  }
 
-	NSMutableArray* children_array = [tree_item childrenArray];
-	NSIndexSet* top_level_children_indexes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, [children_array count])];
-	[children_array removeAllObjects];
-	return top_level_children_indexes;
+  NSMutableArray* children_array = [tree_item childrenArray];
+  NSIndexSet* top_level_children_indexes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, [children_array count])];
+  [children_array removeAllObjects];
+  return top_level_children_indexes;
 }
 
-// This is a helper for removeItem:
-// This is a special helper because when using fast enumeration in removeItem: we can't change the parent's childrenArray to remove this node.
-// So in this helper, we don't try and assume removeItem: will handle that last step itself.
-// So this method is here so we can clear the children data and update the count.
 - (void) removeRecursiveChildItemHelper:(IupCocoaTreeItem*)tree_item
 {
-	// First, if this node has any children, recursively traverse through all the children and remove them.
-	NSMutableArray* children_array = [tree_item childrenArray];
-	for(IupCocoaTreeItem* an_item in children_array)
-	{
-		[self removeRecursiveChildItemHelper:an_item];
-	}
-	// clear the children array so in case there is another reference that is still using this pointer, it will have updated info that there are no children.
-	[children_array removeAllObjects];
-	[tree_item setIsDeleted:YES];
+  NSMutableArray* children_array = [tree_item childrenArray];
+  for(IupCocoaTreeItem* an_item in children_array)
+  {
+    [self removeRecursiveChildItemHelper:an_item];
+  }
+  [children_array removeAllObjects];
+  [tree_item setIsDeleted:YES];
 }
 
 - (NSUInteger) removeItem:(IupCocoaTreeItem*)tree_item
 {
-	if(nil == tree_item)
-	{
-		return NSNotFound;
-	}
-	// If we already removed this item, the parentItem is nil.
-	if(YES == [tree_item isDeleted])
-	{
-		return NSNotFound;
-	}
-	
-	// First, if this node has any children, recursively traverse through all the children and remove them.
-	NSMutableArray* children_array = [tree_item childrenArray];
-	for(IupCocoaTreeItem* an_item in children_array)
-	{
-		[self removeRecursiveChildItemHelper:an_item];
-	}
-	// clear the children array so in case there is another reference that is still using this pointer, it will have updated info that there are no children.
-	[children_array removeAllObjects];
+  if(nil == tree_item || YES == [tree_item isDeleted])
+  {
+    return NSNotFound;
+  }
 
-	// now remove this node by going to the parent and removing this from the parent's childrenArray
-	IupCocoaTreeItem* tree_item_parent = [tree_item parentItem];
-	if(nil != tree_item_parent)
-	{
-		NSUInteger object_index = [[tree_item_parent childrenArray] indexOfObject:tree_item];
-		if(object_index != NSNotFound)
-		{
-			[[tree_item_parent childrenArray] removeObjectAtIndex:object_index];
-		}
-		return object_index;
-	}
-	else
-	{
-		// this is top level node
-		NSUInteger object_index = [treeRootTopLevelObjects indexOfObject:tree_item];
-		if(object_index != NSNotFound)
-		{
-			[treeRootTopLevelObjects removeObjectAtIndex:object_index];
-		}
-		return object_index;
-	}
+  NSMutableArray* children_array = [tree_item childrenArray];
+  for(IupCocoaTreeItem* an_item in children_array)
+  {
+    [self removeRecursiveChildItemHelper:an_item];
+  }
+  [children_array removeAllObjects];
+
+  IupCocoaTreeItem* tree_item_parent = [tree_item parentItem];
+  if(nil != tree_item_parent)
+  {
+    NSUInteger object_index = [[tree_item_parent childrenArray] indexOfObject:tree_item];
+    if(object_index != NSNotFound)
+    {
+      [[tree_item_parent childrenArray] removeObjectAtIndex:object_index];
+    }
+    return object_index;
+  }
+  else
+  {
+    NSUInteger object_index = [treeRootTopLevelObjects indexOfObject:tree_item];
+    if(object_index != NSNotFound)
+    {
+      [treeRootTopLevelObjects removeObjectAtIndex:object_index];
+    }
+    return object_index;
+  }
 }
 
 - (void) moveItem:(IupCocoaTreeItem*)tree_item targetParent:(IupCocoaTreeItem*)target_parent_tree_item targetChildIndex:(NSInteger)target_child_index
 {
-	IupCocoaTreeItem* parent_tree_item = [tree_item parentItem];
+  IupCocoaTreeItem* parent_tree_item = [tree_item parentItem];
 
-	// remove from the old location (don't call removeItem: because it kills the children)
-	if(parent_tree_item)
-	{
-		[[parent_tree_item childrenArray] removeObject:tree_item];
-	}
-	else
-	{
-		[treeRootTopLevelObjects removeObject:tree_item];
-	}
-	
-	// insert to the new location
-	if(target_parent_tree_item)
-	{
-		[[target_parent_tree_item childrenArray] insertObject:tree_item atIndex:target_child_index];
-	}
-	else
-	{
-		[treeRootTopLevelObjects insertObject:tree_item atIndex:target_child_index];
-	}
+  if(parent_tree_item)
+  {
+    [[parent_tree_item childrenArray] removeObject:tree_item];
+  }
+  else
+  {
+    [treeRootTopLevelObjects removeObject:tree_item];
+  }
 
-	// Now that the node is moved, it has a new parent
-	[tree_item setParentItem:target_parent_tree_item];
+  if(target_parent_tree_item)
+  {
+    [[target_parent_tree_item childrenArray] insertObject:tree_item atIndex:target_child_index];
+  }
+  else
+  {
+    [treeRootTopLevelObjects insertObject:tree_item atIndex:target_child_index];
+  }
+
+  [tree_item setParentItem:target_parent_tree_item];
 }
 
-- (NSInteger) outlineView:(NSOutlineView*)outline_view numberOfChildrenOfItem:(nullable id)the_item
+- (NSInteger) outlineView:(NSOutlineView*)outline_view numberOfChildrenOfItem:(id)the_item
 {
-	// FIXME: temp placeholder
-	// FIXME: temp placeholder
-	if(nil == the_item)
-	{
-		NSInteger the_count = [treeRootTopLevelObjects count];
-		return the_count;
-	}
-	else
-	{
-		NSInteger the_count = [the_item numberOfChildren];
-		return the_count;
-	}
+  if(nil == the_item)
+  {
+    return [treeRootTopLevelObjects count];
+  }
+  else
+  {
+    return [the_item numberOfChildren];
+  }
 }
 
-- (id) outlineView:(NSOutlineView*)outline_view child:(NSInteger)the_index ofItem:(nullable id)the_item
+- (id) outlineView:(NSOutlineView*)outline_view child:(NSInteger)the_index ofItem:(id)the_item
 {
-	// FIXME: temp placeholder
-	if(nil == the_item)
-	{
-//		return nil;
-//		IupCocoaTreeItem* dummy = [[[IupCocoaTreeItem alloc] init] autorelease];
-// return dummy;
-		IupCocoaTreeItem* tree_item = [treeRootTopLevelObjects objectAtIndex:the_index];
-		return tree_item;
-	}
-	else
-	{
-		return [the_item childAtIndex:the_index];
-	}
+  if(nil == the_item)
+  {
+    return [treeRootTopLevelObjects objectAtIndex:the_index];
+  }
+  else
+  {
+    return [the_item childAtIndex:the_index];
+  }
 }
 
 - (BOOL) outlineView:(NSOutlineView*)outline_view isItemExpandable:(id)the_item
 {
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
+  NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"Expected IupCocoaTreeItem");
 
-	NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"Expected IupCocoaTreeItem");
-		
-#if 0
-		// This is the basic implementation.
-		// The problem is if you add children after this gets called, this happens too late.
-		// The workaround would be to use dispatch_async, but that causes a delay and flicker.
-		// One other possible solution to to force a reload on the parent item on delete and add node events.
-		if([tree_item numberOfChildren] > 0)
-		{
-			return YES;
-		}
-		else
-		{
-			return NO;
-		}
-#else
-		// We are preferring this implementation over the numberOfChildren > 0
-		// because when we first add a branch without children, expandItem won't work.
-		// The workaround for that is to use dispatch_async, but this causes a delay and flicker.
-		// Since IUP makes users declare the difference between a leaf & branch, we can assume all branches should be expandable.
-		// And we have that information immediately.
-		// The downside "bug" with this implementation is empty branches always show the triangle which is not typical.
-		// One other possible solution is to go back to the above or do a hybrid, and try the reload parent idea.
-		if([tree_item kind] == ITREE_BRANCH)
-		{
-#if 0
-			// UPDATE1: This might work now an only show the triangle when has children, due to all the other changes I made with adding/deleting.
-			// UPDATE2: UPDATE1 seemed to work, but it caused a different problem. For moving (reordering) nodes via drag-and-drop,
-			// if a branch is empty, we are unable to move nodes under it.
-			// So I think I must keep this path disabled unless there is a different workaround.
-			if([tree_item numberOfChildren] > 0)
-			{
-				return YES;
-			}
-			else
-			{
-				return NO;
-			}
-#else
-			return YES;
-#endif
-		}
-		else
-		{
-			return NO;
-		}
-#endif
+  /* IUP requires explicitly defining nodes as branches, so we can assume all branches */
+  /* are expandable, even if they currently have no children. This allows dropping items into an empty branch. */
+  if([tree_item kind] == ITREE_BRANCH)
+  {
+    return YES;
+  }
+  else
+  {
+    return NO;
+  }
 }
 
-/* // Not needed for View based NSOutlineView
-- (nullable id)outlineView:(NSOutlineView *)outline_view objectValueForTableColumn:(nullable NSTableColumn *)table_column byItem:(nullable id)the_item
+static NSImage* helperGetActiveImageForTreeItem(IupCocoaTreeItem* tree_item, IupCocoaOutlineView* outline_view, CGFloat* out_width, CGFloat* out_height)
 {
-	//return (the_item == nil) ? @"/" : @"lower";
-	if(nil == the_item)
-	{
-		return @"Hello World";
-	}
-	else
-	{
-		IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
-		NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"Expected IupCocoaTreeItem");
-		return [tree_item title];
-	}
-	
-}
-*/
+  NSImage* active_image = nil;
+  int kind = [tree_item kind];
+  if(ITREE_BRANCH == kind)
+  {
 
+    if([outline_view isItemExpanded:tree_item])
+    {
+      active_image = [tree_item bitmapImage];
+      if(nil == active_image)
+      {
+        active_image = [(IupCocoaOutlineView*)outline_view expandedImage];
+      }
+    }
+    else
+    {
+      active_image = [tree_item collapsedImage];
+      if(nil == active_image)
+      {
+        active_image = [(IupCocoaOutlineView*)outline_view collapsedImage];
+      }
+    }
+  }
+  else if(ITREE_LEAF == kind)
+  {
+    active_image = [tree_item bitmapImage];
+    if(nil == active_image)
+    {
+      active_image = [(IupCocoaOutlineView*)outline_view leafImage];
+    }
+  }
 
-static NSImage* helperGetActiveImageForTreeItem(IupCocoaTreeItem* tree_item, IupCocoaOutlineView* outline_view, CGFloat* out_width, CGFloat* out_height)
-{
-	NSImage* active_image = nil;
-	int kind = [tree_item kind];
-	if(ITREE_BRANCH == kind)
-	{
-	
-		if([outline_view isItemExpanded:tree_item])
-		{
-			active_image = [tree_item bitmapImage];
-			if(nil == active_image)
-			{
-				active_image = [(IupCocoaOutlineView*)outline_view expandedImage];
-			}
-		}
-		else
-		{
-			active_image = [tree_item collapsedImage];
-			if(nil == active_image)
-			{
-				active_image = [(IupCocoaOutlineView*)outline_view collapsedImage];
-			}
-		}
-	}
-	else if(ITREE_LEAF == kind)
-	{
-		active_image = [tree_item bitmapImage];
-		if(nil == active_image)
-		{
-			active_image = [(IupCocoaOutlineView*)outline_view leafImage];
-		}
-	}
+  NSSize image_size = NSMakeSize(0.0, 0.0);
+  if(active_image)
+  {
+    image_size = [active_image size];
+  }
 
-	NSSize image_size = NSMakeSize(0.0, 0.0);
-	if(active_image)
-	{
-		image_size = [active_image size];
-	}
+  if(NULL != out_width)
+  {
+    *out_width = image_size.width;
+  }
 
-	if(NULL != out_width)
-	{
-		*out_width = image_size.width;
-	}
-
-	if(NULL != out_height)
-	{
-		*out_height = image_size.height;
-	}
-	return active_image;
+  if(NULL != out_height)
+  {
+    *out_height = image_size.height;
+  }
+  return active_image;
 }
 
-// WARNING: This method needs to be fast for performance.
-// I'm worried the image support is already a bit too complicated because it allows for any image size. But I think it will be fine for desktop.
+/* WARNING: This method needs to be fast for performance. */
 - (CGFloat) outlineView:(NSOutlineView*)outline_view heightOfRowByItem:(id)the_item
 {
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
-	CGFloat text_height = 17.0;
-	
-	// TODO: Height needs to also account for font if the user changed it
-	CGFloat image_width = 0.0;
-	CGFloat image_height = 0.0;
-	NSImage* active_image = helperGetActiveImageForTreeItem(tree_item, (IupCocoaOutlineView*)outline_view, &image_width, &image_height);
-	
-	
-	// This is a ugly hack keeping the table cell view in the item.
-	// All my other attempts to get the table cell view have failed.
-	// DOC: If you call viewAtColumn:row:makeIfNecessary: or rowViewAtRow:makeIfNecessary: within your implementation of this method, an exception is thrown.
-	// Perhaps I could compute the raw string height if I know the font and hard code a value for the textfield padding.
-	NSTableCellView* table_cell_view = [tree_item tableCellView];
+  Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
+  CGFloat text_height = 17.0; /* Default height */
 
-	NSTextField* text_field = [table_cell_view textField];
-	NSSize text_field_size = { 0, 0 };
-	if(text_field)
-	{
-		text_field_size = [text_field fittingSize];
-	}
-	
-	if(text_field_size.height > text_height)
-	{
-		text_height = text_field_size.height;
-	}
-	else if(text_field_size.height == 0)
-	{
-		// don't allow 0
-	}
-	else
-	{
-		// should I allow smaller text heights?
-		text_height = text_field_size.height;
-	}
+  CGFloat image_width = 0.0;
+  CGFloat image_height = 0.0;
+  helperGetActiveImageForTreeItem(tree_item, (IupCocoaOutlineView*)outline_view, &image_width, &image_height);
 
+  /* Use item's custom font if available to calculate text height */
+  NSFont *font = [tree_item font];
+  if (font)
+  {
+    text_height = [font capHeight] + 2; /* Approximate height from font */
+  }
 
-	if(active_image)
-	{
-		if(image_height < text_height)
-		{
-			return text_height;
-		}
-		else
-		{
-			return image_height;
-		}
-	}
-	else
-	{
-		return text_height;
-	}
+  CGFloat final_height;
+  if(image_height > 0)
+  {
+    final_height = MAX(text_height, image_height);
+  }
+  else
+  {
+    final_height = text_height;
+  }
 
+  return final_height + ih->data->spacing;
 }
 
-// NSOutlineViewDelegate
-// WARNING: This is another method that should be fast for performance.
-- (nullable NSView *)outlineView:(NSOutlineView*)outline_view viewForTableColumn:(nullable NSTableColumn*)table_column item:(id)the_item
+/* WARNING: This is another method that should be fast for performance. */
+- (NSView *)outlineView:(NSOutlineView*)outline_view viewForTableColumn:(NSTableColumn*)table_column item:(id)the_item
 {
-	Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
-	NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"Expected IupCocoaTreeItem");
-	NSString* string_item = [tree_item title];
+  Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
+  NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"Expected IupCocoaTreeItem");
+  NSString* string_item = [tree_item title];
 
+  NSTableCellView* table_cell_view = nil;
+  BOOL is_enabled = [outline_view isEnabled];
 
-	NSTableCellView* table_cell_view = nil;
-	
-	BOOL is_enabled = [outline_view isEnabled];
+  if(ih->data->show_toggle > 0)
+  {
+    table_cell_view = [outline_view makeViewWithIdentifier:@"IupCocoaTreeToggleTableCellView" owner:self];
+    if(nil == table_cell_view)
+    {
+      table_cell_view = [[[IupCocoaTreeToggleTableCellView alloc] initWithFrame:NSZeroRect] autorelease];
+      [table_cell_view setIdentifier:@"IupCocoaTreeToggleTableCellView"];
+    }
+    IupCocoaTreeToggleTableCellView* toggle_cell_view = (IupCocoaTreeToggleTableCellView*)table_cell_view;
 
-	
-	// 0 for no toggle, 1 for toggle, 2 for toggle with 3-state
-	if(ih->data->show_toggle > 0)
-	{
-		// Get an existing cell with the MyView identifier if it exists
-		table_cell_view = [outline_view makeViewWithIdentifier:@"IupCocoaTreeToggleTableCellView" owner:self];
-		if(nil == table_cell_view)
-		{
-			table_cell_view = [[IupCocoaTreeToggleTableCellView alloc] initWithFrame:NSZeroRect];
+    NSButton* check_box = [toggle_cell_view checkBox];
+    if (check_box)
+    {
+      [check_box setAllowsMixedState:(ih->data->show_toggle == 2)];
+      [check_box setState:[tree_item checkBoxState]];
+      [check_box setHidden:[tree_item isCheckBoxHidden]];
 
-			// The identifier of the NSTextField instance is set to MyView.
-			// This allows the cell to be reused.
-			
-			[table_cell_view setIdentifier:@"IupCocoaTreeToggleTableCellView"];
-		}
-		IupCocoaTreeToggleTableCellView* toggle_cell_view = (IupCocoaTreeToggleTableCellView*)table_cell_view;
+      IupCocoaTreeToggleReceiver* toggle_receiver = [tree_item toggleReceiver];
+      [toggle_receiver setIhandle:ih];
+      [check_box setTarget:toggle_receiver];
+      [check_box setAction:@selector(myToggleClickAction:)];
+      [check_box setEnabled:is_enabled];
+    }
+  }
+  else
+  {
+    table_cell_view = [outline_view makeViewWithIdentifier:@"IupCocoaTreeTableCellView" owner:self];
+    if(nil == table_cell_view)
+    {
+      table_cell_view = [[[NSTableCellView alloc] initWithFrame:NSZeroRect] autorelease];
+      [table_cell_view setIdentifier:@"IupCocoaTreeTableCellView"];
 
-		NSButton* check_box = [toggle_cell_view checkBox];
-		if(ih->data->show_toggle == 2)
-		{
-			[check_box setAllowsMixedState:YES];
-		}
-		else
-		{
-			[check_box setAllowsMixedState:NO];
-		}
-		NSControlStateValue check_box_value = [tree_item checkBoxState];
-		[check_box setState:check_box_value];
-		
-		bool check_box_hidden = [tree_item isCheckBoxHidden];
-		[check_box setHidden:check_box_hidden];
-		
-		// Set up the TOGGLE_CB. This requires use to use a delegate object, hence a lot of relationships to set up.
-		IupCocoaTreeToggleReceiver* toggle_receiver = [tree_item toggleReceiver];
-		if(nil == toggle_receiver)
-		{
-			toggle_receiver = [[IupCocoaTreeToggleReceiver alloc] init];
-			[toggle_receiver setTreeItem:tree_item];
-			[tree_item setToggleReceiver:toggle_receiver];
-		}
-		[toggle_receiver setIhandle:ih];
-		[check_box setTarget:toggle_receiver];
-		[check_box setAction:@selector(myToggleClickAction:)];
+      /* Initialize ImageView */
+      NSImageView* image_view = [[NSImageView alloc] initWithFrame:NSZeroRect];
+      [image_view setImageScaling:NSImageScaleProportionallyUpOrDown];
+      [image_view setTranslatesAutoresizingMaskIntoConstraints:NO];
+      [table_cell_view addSubview:image_view];
+      [table_cell_view setImageView:image_view];
+      [image_view release]; /* Retained by superview and property */
 
-		[check_box setEnabled:is_enabled];
-		
-	}
-	else
-	{
-		table_cell_view = [outline_view makeViewWithIdentifier:@"IupCocoaTreeTableCellView" owner:self];
-		// There is no existing cell to reuse so create a new one
-		if(nil == table_cell_view)
-		{
-			table_cell_view = [[NSTableCellView alloc] initWithFrame:NSZeroRect];
+      /* Initialize TextField */
+      IupCocoaTreeTextField* text_field = [[IupCocoaTreeTextField alloc] initWithFrame:NSZeroRect];
+      [text_field setBezeled:NO];
+      [text_field setDrawsBackground:NO];
+      [text_field setEditable:NO];
+      [text_field setSelectable:YES]; /* Good practice for standard cells */
+      [text_field setTranslatesAutoresizingMaskIntoConstraints:NO];
 
-			// The identifier of the NSTextField instance is set to MyView.
-			// This allows the cell to be reused.
-			
-			[table_cell_view setIdentifier:@"IupCocoaTreeTableCellView"];
-			
-			IupCocoaTreeToggleReceiver* toggle_receiver = [tree_item toggleReceiver];
-			if(nil != toggle_receiver)
-			{
-				[toggle_receiver setTreeItem:nil];
-				[toggle_receiver setIhandle:nil];
-				[tree_item setToggleReceiver:nil];
-			}
-		}
-	
-	}
-	
+      /* Increase compression resistance to prevent the text field from collapsing when space is tight. */
+      [text_field setContentCompressionResistancePriority:NSLayoutPriorityRequired forOrientation:NSLayoutConstraintOrientationHorizontal];
 
-	
+      [table_cell_view addSubview:text_field];
+      [table_cell_view setTextField:text_field];
+      [text_field release]; /* Retained by superview and property */
 
+      /* Center vertically */
+      [NSLayoutConstraint constraintWithItem:image_view attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:table_cell_view attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0.0].active = YES;
+      [NSLayoutConstraint constraintWithItem:text_field attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:table_cell_view attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0.0].active = YES;
 
+      /* Set a standard size constraint for the image view (e.g., 16x16). */
+      [NSLayoutConstraint constraintWithItem:image_view attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:16.0].active = YES;
+      [NSLayoutConstraint constraintWithItem:image_view attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:16.0].active = YES;
 
-	// table_cell_view is now guaranteed to be valid, either as a reused cell
-	// or as a new cell, so set the stringValue of the cell to the
-	// nameArray value at row
-	NSTextField* text_field = nil;
-	text_field = [table_cell_view textField];
-	NSImageView* image_view = nil;
-	image_view = [table_cell_view imageView];
-	[text_field setStringValue:string_item];
+      /* Horizontal layout: |-[Image]-[Text]-| */
+      [NSLayoutConstraint constraintWithItem:image_view attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:table_cell_view attribute:NSLayoutAttributeLeading multiplier:1.0 constant:2.0].active = YES;
+      [NSLayoutConstraint constraintWithItem:text_field attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:image_view attribute:NSLayoutAttributeTrailing multiplier:1.0 constant:5.0].active = YES;
+      [NSLayoutConstraint constraintWithItem:text_field attribute:NSLayoutAttributeTrailing relatedBy:NSLayoutRelationEqual toItem:table_cell_view attribute:NSLayoutAttributeTrailing multiplier:1.0 constant:-2.0].active = YES;
+    }
+  }
 
-	BOOL show_rename = (BOOL)ih->data->show_rename;
-	[text_field setEditable:show_rename];
+  IupCocoaTreeTextField* text_field = (IupCocoaTreeTextField*)[table_cell_view textField];
+  NSImageView* image_view = [table_cell_view imageView];
 
+  if (text_field)
+  {
+    objc_setAssociatedObject(text_field, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
+    objc_setAssociatedObject(text_field, IUP_COCOA_TREE_TEXTFIELD_OWNER_KEY, outline_view, OBJC_ASSOCIATION_ASSIGN);
 
-	CGFloat image_width = 0.0;
-	CGFloat image_height = 0.0;
-	NSImage* active_image = helperGetActiveImageForTreeItem(tree_item, (IupCocoaOutlineView*)outline_view, &image_width, &image_height);
-	
-	if(nil == active_image)
-	{
-		[image_view setHidden:YES];
-		[image_view setImage:nil];
-	}
-	else
-	{
-		[image_view setHidden:NO];
-		[image_view setImage:active_image];
-	}
-	
-	
-	[text_field setEnabled:is_enabled];
-	[image_view setEnabled:is_enabled];
+    [text_field setStringValue:string_item];
 
-	[tree_item setTableCellView:table_cell_view]; // kind of a hack. We need it to compute the size in heightOf
- 
-	// Return the result
-	return table_cell_view;
+    [text_field setEditable:(BOOL)ih->data->show_rename];
+    if (ih->data->show_rename)
+    {
+      /* The text field handles its own editing callbacks. */
+      [text_field setDelegate:text_field];
+    }
+    else
+    {
+      /* Clear delegate when recycling a view if rename is off. */
+      [text_field setDelegate:nil];
+    }
+
+    /* Apply custom font and color */
+    NSFont* item_font = [tree_item font];
+    if (!item_font)
+    {
+      IupCocoaFont* iup_font = iupcocoaGetFont(ih);
+      if (!iup_font)
+      {
+        const char* default_font = IupGetGlobal("DEFAULTFONT");
+        iup_font = iupcocoaFindFont(default_font);
+      }
+      item_font = iup_font ? [iup_font nativeFont] : [NSFont systemFontOfSize:13];
+    }
+    [text_field setFont:item_font];
+    [text_field setTextColor:([tree_item textColor] ?: [NSColor controlTextColor])];
+    [text_field setEnabled:is_enabled];
+  }
+
+  if (image_view)
+  {
+    NSImage* active_image = helperGetActiveImageForTreeItem(tree_item, (IupCocoaOutlineView*)outline_view, NULL, NULL);
+    /* Hide the image view if the new item doesn't have an image. */
+    [image_view setHidden:(nil == active_image)];
+    [image_view setImage:active_image];
+    [image_view setEnabled:is_enabled];
+  }
+
+  return table_cell_view;
 }
 
-// I think it is a really bad idea to change images based on expanded or closed
-// because this creates another potential reload (which loses selection data)
-// and another potential performance bottleneck.
-// This is not a typical Mac/Cocoa behavior.
-// But the IUP API demands it.
-// There is an optimization here to not swap images if the image is the same.
-// However, this is a pointer comparison and requires both the user and IUP implementation to not accidentally load the same image twice
-// or create two separate object wrappers around the same image.
-// I recommend we add something to the official API documation that separate images is a bad idea.
-- (void) outlineViewItemWillExpand:(NSNotification*)the_notification
+- (void) outlineViewItemDidExpand:(NSNotification*)the_notification
 {
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)[the_notification object];
-		NSDictionary* user_info = [the_notification userInfo];
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)[user_info objectForKey:@"NSObject"];
-//	Ihandle* ih = [outline_view ih];
-	
-	if(nil == tree_item)
-	{
-		return;
-	}
-	
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)[the_notification object];
+  NSDictionary* user_info = [the_notification userInfo];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)[user_info objectForKey:@"NSObject"];
 
+  if(nil == tree_item)
+  {
+    return;
+  }
 
-	NSImage* expanded_image = [tree_item bitmapImage];
-	NSImage* collapsed_image = [tree_item collapsedImage];
-	NSImage* fallback_expanded_image = [outline_view expandedImage];
-	NSImage* fallback_collapsed_image = [outline_view collapsedImage];
+  NSImage* expanded_image = [tree_item bitmapImage] ?: [outline_view expandedImage];
+  NSImage* collapsed_image = [tree_item collapsedImage] ?: [outline_view collapsedImage];
 
-	if(expanded_image || fallback_expanded_image)
-	{
-		NSImage* which_expanded_image = nil;
-		if(expanded_image)
-		{
-			which_expanded_image = expanded_image;
-		}
-		else
-		{
-			which_expanded_image = fallback_expanded_image;
-		}
-		NSImage* which_collapsed_image = nil;
-		if(collapsed_image)
-		{
-			which_collapsed_image = collapsed_image;
-		}
-		else
-		{
-			which_collapsed_image = fallback_collapsed_image;
-		}
-
-		// Only reload if the expanded and collapsed images are different
-		// (I'm worried that switching images is not a typical Mac behavior and may hurt built-in performance optimizations.
-		// Also, reloading may reset selection which is not nice.)
-		// Note: I've been using retain, hoping that we just have a simple pointer comparison and it will avoid doing slow pixel comparisons.
-		if(![which_expanded_image isEqual:which_collapsed_image])
-		{
-			cocoaTreeReloadItem(tree_item, outline_view);
-		}
-	}
-	
-
+  /* Only reload if the images are different to avoid flicker. */
+  if(![expanded_image isEqual:collapsed_image])
+  {
+    cocoaTreeReloadItem(tree_item, outline_view);
+  }
 }
 
-// I think it is a really bad idea to change images based on expanded or closed
-// because this creates another potential reload (which loses selection data)
-// and another potential performance bottleneck.
-// This is not a typical Mac/Cocoa behavior.
-// But the IUP API demands it.
-// There is an optimization here to not swap images if the image is the same.
-// However, this is a pointer comparison and requires both the user and IUP implementation to not accidentally load the same image twice
-// or create two separate object wrappers around the same image.
-// I recommend we add something to the official API documation that separate images is a bad idea.
-- (void) outlineViewItemWillCollapse:(NSNotification*)the_notification
+- (void) outlineViewItemDidCollapse:(NSNotification*)the_notification
 {
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)[the_notification object];
+  NSDictionary* user_info = [the_notification userInfo];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)[user_info objectForKey:@"NSObject"];
 
-	IupCocoaOutlineView* outline_view = [the_notification object];
-	NSDictionary* user_info = [the_notification userInfo];
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)[user_info objectForKey:@"NSObject"];
-//	Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
-	
-	if(nil == tree_item)
-	{
-		return;
-	}
-	
-	
-	
-	NSImage* expanded_image = [tree_item bitmapImage];
-	NSImage* collapsed_image = [tree_item collapsedImage];
-	NSImage* fallback_expanded_image = [outline_view expandedImage];
-	NSImage* fallback_collapsed_image = [outline_view collapsedImage];
+  if(nil == tree_item)
+  {
+    return;
+  }
 
-	if(collapsed_image || fallback_collapsed_image)
-	{
-		NSImage* which_expanded_image = nil;
-		if(expanded_image)
-		{
-			which_expanded_image = expanded_image;
-		}
-		else
-		{
-			which_expanded_image = fallback_expanded_image;
-		}
-		NSImage* which_collapsed_image = nil;
-		if(collapsed_image)
-		{
-			which_collapsed_image = collapsed_image;
-		}
-		else
-		{
-			which_collapsed_image = fallback_collapsed_image;
-		}
+  NSImage* expanded_image = [tree_item bitmapImage] ?: [outline_view expandedImage];
+  NSImage* collapsed_image = [tree_item collapsedImage] ?: [outline_view collapsedImage];
 
-		// Only reload if the expanded and collapsed images are different
-		// (I'm worried that switching images is not a typical Mac behavior and may hurt built-in performance optimizations.
-		// Also, reloading may reset selection which is not nice.)
-		// Note: I've been using retain, hoping that we just have a simple pointer comparison and it will avoid doing slow pixel comparisons.
-		if(![which_expanded_image isEqual:which_collapsed_image])
-		{
-			cocoaTreeReloadItem(tree_item, outline_view);
-		}
-	}
-	
-
-
+  if(![expanded_image isEqual:collapsed_image])
+  {
+    cocoaTreeReloadItem(tree_item, outline_view);
+  }
 }
 
-- (void) handleSelectionDidChange:(NSOutlineView*)outline_view
+- (void)handleSelectionDidChange:(NSOutlineView*)outline_view
 {
-	// Rules:
-	// If we are in single selection mode, we use the single_cb
-	// If we are in multiple selection mode, then one of the following:
-	// - If it is a single selection, then use single_cb
-	// - If it is a multiple selection, then use multi_cb and skip single_cb
-	//     - but if multi_cb is not defined, invoke multiple callbacks of single_cb
-	// Also, we need to remember that to do multi-unselection_cb.
-	// - This fires if there was a multi-selection from the last time.
-	
-	// Additional notes:
-	
-	// (1) Multi_cb is supposed to be a contiguous range for a single action.
-	// While I expect that will be the typical case on Mac,
-	// I do worry that Apple may have or introduce some built-in key-shortcut (e.g. cmd-a selects all) that can create a non-contiguous selection.
-	// For example, what if there is an "invert selection" option?
-	// So say you pick the middle item. Then you invert it which gets you everything except the middle item.
-	// You now have a discontinuous selection created in one-shot.
+  NSCAssert([outline_view isKindOfClass:[IupCocoaOutlineView class]], @"Expected IupCocoaOutlineView");
+  Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
 
-	// (2) Delete nodes and selection.
-	// I asked Scuri if we are supposed to trigger a selection callback when nodes are deleted,
-	// since this will alter the list of selected items.
-	// He says that IUP does not do a callback for this case.
-	// But this is why I broke this into a helper method, in case it needs to be called directly instead of just on Apple's selection notification.
-	// (Apple does not seem to give selection notification callbacks for changes caused by delete or reloadData either.)
+  if (NULL == ih || iupAttribGet(ih, "_IUPTREE_IGNORE_SELECTION_CB"))
+    return;
 
-	NSCAssert([outline_view isKindOfClass:[IupCocoaOutlineView class]], @"Expected IupCocoaOutlineView");
-	Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
-	if(NULL == ih)
-	{
-		return;
-	}
-	
-	if(iupAttribGet(ih, "_IUPTREE_IGNORE_SELECTION_CB"))
-	{
-		return;
-	}
+  IFnii single_selection_cb = (IFnii)IupGetCallback(ih, "SELECTION_CB");
+  IFnIi multi_selection_cb = (IFnIi)IupGetCallback(ih, "MULTISELECTION_CB");
+  IFnIi multi_unselection_cb = (IFnIi)IupGetCallback(ih, "MULTIUNSELECTION_CB");
 
+  if (!single_selection_cb && !multi_selection_cb && !multi_unselection_cb)
+    return;
 
-	// May not be the best way to determine callback type since the user can change this on the fly.
-//	BOOL in_mulitple_selection_mode = [outline_view allowsMultipleSelection];
-	IFnii single_selection_cb = (IFnii)IupGetCallback(ih, "SELECTION_CB");
-    IFnIi multi_selection_cb = (IFnIi)IupGetCallback(ih, "MULTISELECTION_CB");
-    IFnIi multi_unselection_cb = (IFnIi)IupGetCallback(ih, "MULTIUNSELECTION_CB");
+  NSIndexSet* currentSelections = [outline_view selectedRowIndexes];
 
-	// No sense doing any work if callbacks are not set.
-	// NOTE: setting previousSelection will also be skipped in this case.
-	if((single_selection_cb == NULL) && (multi_selection_cb == NULL) && (multi_unselection_cb == NULL))
-	{
-		return;
-	}
+  if (previousSelections)
+  {
+    NSMutableIndexSet* unselected_set = [previousSelections mutableCopy];
+    [unselected_set removeIndexes:currentSelections];
 
-#if 0
-	// debug: print all currently selected items
-	{
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		while(selected_i != NSNotFound)
-		{
-			id selected_item = [outline_view itemAtRow:selected_i];
-			NSLog(@"all selected_item: %@", [selected_item title]);
-			// get the next index in the set
-			selected_i = [selected_index indexGreaterThanIndex:selected_i];
-		}
-	}
-#endif
-	
-	// First handle the unselections
-	{
-		// We will get a copy of the previous selections.
-		NSMutableIndexSet* unselected_set = [previousSelections mutableCopy];
-		if(unselected_set != nil)
-		{
-			// Then remove the current selections from the previous selections.
-			// This will leave the unselected items.
-			[unselected_set removeIndexes:[outline_view selectedRowIndexes]];
-			
-			NSUInteger number_of_items = [unselected_set count];
+    if ([unselected_set count] > 0)
+    {
+      if (multi_unselection_cb)
+      {
+        NSUInteger count = [unselected_set count];
+        int* ids = malloc(sizeof(int) * count);
+        if (ids)
+        {
+          __block int i = 0;
+          [unselected_set enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
+            if (idx < [outline_view numberOfRows])
+            {
+              IupCocoaTreeItem *item = [outline_view itemAtRow:idx];
+              if (item)
+                ids[i++] = iupTreeFindNodeId(ih, (InodeHandle*)item);
+            }
+          }];
 
-			// If the previous selection had more than 1, it was a multi-selection.
-			// That means we need to do a multi-unselection to balance it.
-			// This is safer than testing for whether the outlineview is in multi-mode or not because the user could have changed it on the fly.
-			if(number_of_items == 0)
-			{
-				// do nothing
-			}
-			else if([previousSelections count] > 1)
-			{
-				if((NULL != multi_unselection_cb) || (NULL != single_selection_cb))
-				{
-					// We are in the multiple unselection case
-					// VLA
-					int array_of_ids[number_of_items];
-					NSUInteger selected_i = [unselected_set firstIndex];
-					size_t i = 0;
-					while(selected_i != NSNotFound)
-					{
-						NSCAssert(i<number_of_items, @"Overflow: More indexes than expected.");
+          if (i > 0)
+            multi_unselection_cb(ih, ids, i);
 
-						array_of_ids[i] = (int)selected_i;
-						i++;
-						// id selected_item = [outline_view itemAtRow:selected_i];
-						//	NSLog(@"removed selected_item: %@", [selected_item title]);
-						// get the next index in the set
-						selected_i = [unselected_set indexGreaterThanIndex:selected_i];
-					}
+          free(ids);
+        }
+      }
+      else if (single_selection_cb)
+      {
+        [unselected_set enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
+          if (idx < [outline_view numberOfRows])
+          {
+            IupCocoaTreeItem *item = [outline_view itemAtRow:idx];
+            if (item)
+              single_selection_cb(ih, iupTreeFindNodeId(ih, (InodeHandle*)item), 0);
+          }
+        }];
+      }
+    }
+    [unselected_set release];
+  }
 
-					if(NULL != multi_unselection_cb)
-					{
-						multi_unselection_cb(ih, array_of_ids, (int)number_of_items);
-					}
-					else if(NULL != single_selection_cb)
-					{
-						for(size_t j=0; j<number_of_items; j++)
-						{
-							single_selection_cb(ih, array_of_ids[j], 1);
-						}
-					}
-				}
+  NSMutableIndexSet* added_selected_set = [currentSelections mutableCopy];
+  if (previousSelections)
+  {
+    [added_selected_set removeIndexes:previousSelections];
+  }
 
-			
-			}
-			else
-			{
-				// We are in the single unselection case
-				// This should be 0, but just in case there are more, use the first one.
-				if(number_of_items > 0)
-				{
-					if(NULL != single_selection_cb)
-					{
-						NSUInteger selected_i = [unselected_set firstIndex];
-			           	single_selection_cb(ih, (int)selected_i, 0);
-					}
-				}
-				// else do nothing since there was nothing unselected
+  if ([added_selected_set count] > 0)
+  {
+    if (multi_selection_cb)
+    {
+      NSUInteger count = [added_selected_set count];
+      int* ids = malloc(sizeof(int) * count);
+      if (ids)
+      {
+        __block int i = 0;
+        [added_selected_set enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
+          if (idx < [outline_view numberOfRows])
+          {
+            IupCocoaTreeItem *item = [outline_view itemAtRow:idx];
+            if (item)
+              ids[i++] = iupTreeFindNodeId(ih, (InodeHandle*)item);
+          }
+        }];
 
-			}
-			
-			[unselected_set release];
-		}
-	} // end unselections
-	
-	
-	
-	// handle the selections
-	{
-		// Get a copy of all the current selections
-		NSMutableIndexSet* added_selected_set = [[outline_view selectedRowIndexes] mutableCopy];
-		// Subtract out the previousSelections from the current selections which leaves just the newly added selections.
-		[added_selected_set removeIndexes:previousSelections];
+        if (i > 0)
+          multi_selection_cb(ih, ids, i);
 
-		if(added_selected_set != nil)
-		{
-			NSUInteger number_of_items = [added_selected_set count];
+        free(ids);
+      }
+    }
+    else if (single_selection_cb)
+    {
+      [added_selected_set enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
+        if (idx < [outline_view numberOfRows])
+        {
+          IupCocoaTreeItem *item = [outline_view itemAtRow:idx];
+          if (item)
+            single_selection_cb(ih, iupTreeFindNodeId(ih, (InodeHandle*)item), 1);
+        }
+      }];
+    }
+  }
+  [added_selected_set release];
 
-			if(number_of_items == 0)
-			{
-				// do nothing
-			}
-			else if(number_of_items > 1)
-			{
-				if((NULL != multi_selection_cb) || (NULL != single_selection_cb))
-				{
-					// We are in the multiple selection case
-					// VLA
-					int array_of_ids[number_of_items];
-					NSUInteger selected_i = [added_selected_set firstIndex];
-					size_t i = 0;
-					while(selected_i != NSNotFound)
-					{
-						NSCAssert(i<number_of_items, @"Overflow: More indexes than expected.");
-
-						array_of_ids[i] = (int)selected_i;
-						i++;
-						// id selected_item = [outline_view itemAtRow:selected_i];
-						// NSLog(@"added selected_item: %@", [selected_item title]);
-						// get the next index in the set
-						selected_i = [added_selected_set indexGreaterThanIndex:selected_i];
-					}
-
-					if(NULL != multi_selection_cb)
-					{
-						multi_selection_cb(ih, array_of_ids, (int)number_of_items);
-					}
-					else if(NULL != single_selection_cb)
-					{
-						for(size_t j=0; j<number_of_items; j++)
-						{
-							single_selection_cb(ih, array_of_ids[j], 1);
-						}
-					}
-				}
-			}
-			else // number_of_items == 1
-			{
-				// We are in the single selection case
-
-				if(NULL != single_selection_cb)
-				{
-					NSUInteger selected_i = [added_selected_set firstIndex];
-					single_selection_cb(ih, (int)selected_i, 1);
-				}
-			}
-			
-			[added_selected_set release];
-		}
-	} // end selections
-	
-	
-	// Release the old previousSelections and save the new/current selections as previousSelections for the next time this is called.
-	[previousSelections release];
-	previousSelections = [[outline_view selectedRowIndexes] copy];
+  [previousSelections release];
+  previousSelections = [currentSelections copy];
 }
 
 - (void) outlineViewSelectionDidChange:(NSNotification*)the_notification
 {
-	NSOutlineView* outline_view = [the_notification object];
-	[self handleSelectionDidChange:outline_view];
-
+  NSOutlineView* outline_view = [the_notification object];
+  [self handleSelectionDidChange:outline_view];
 }
 
-- (NSIndexSet*) outlineView:(NSOutlineView*)outline_view selectionIndexesForProposedSelection:(NSIndexSet*)proposed_selection_indexes
+- (NSTableRowView *)outlineView:(NSOutlineView *)outlineView rowViewForItem:(id)item
 {
-	Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
-	if(iupAttribGetBoolean(ih, "CANFOCUS"))
-	{
-		return proposed_selection_indexes;
-	}
-	else
-	{
-		return nil;
-	}
+  IupCocoaOutlineView* iup_outline_view = (IupCocoaOutlineView*)outlineView;
+  IupCocoaTreeRowView* row_view = [outlineView makeViewWithIdentifier:@"IupTreeRow" owner:self];
+  if (!row_view) {
+    row_view = [[[IupCocoaTreeRowView alloc] init] autorelease];
+    row_view.identifier = @"IupTreeRow";
+  }
+  [row_view setIh:[iup_outline_view ih]];
+  return row_view;
 }
 
-@end // IupCocoaTreeDelegate
-
-
-/*****************************************************************************/
-/* DRAG AND DROP                                                             */
-/*****************************************************************************/
-// We need to make a separate delegate subclass because there is no way to toggle the drag-and-drop behavior directly.
-// Those who want drag-and-drop must use a delegate instance of this subclass type,
-// whereas those who don't must use the base class.
-
-@interface IupCocoaTreeDragDropDelegate : IupCocoaTreeDelegate
+- (BOOL) outlineView:(NSOutlineView*)outline_view shouldExpandItem:(id)item
 {
-	id itemBeingDragged; // This is used to compare whether the item being dragged ends up dragging onto itself so we can reject it in validation
-
+  IFni cbBranchOpen = (IFni)IupGetCallback([(IupCocoaOutlineView*)outline_view ih], "BRANCHOPEN_CB");
+  if (cbBranchOpen)
+  {
+    IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)item;
+    Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
+    int id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
+    if (cbBranchOpen(ih, id) == IUP_IGNORE)
+      return NO;
+  }
+  return YES;
 }
-@property(nonatomic, weak) id itemBeingDragged;
-@end
 
-
-@implementation IupCocoaTreeDragDropDelegate
-
-@synthesize itemBeingDragged = itemBeingDragged;
-
-// Drag and drop
-// Cocoa makes you do overkill for moving/copying nodes via drag-and-drop and you must implement full blown pasteboard support.
-// General idea here:
-// https://stackoverflow.com/questions/42315288/how-to-create-nspasteboardwriting-for-drag-and-drop-in-nscollectionview
-// Also, suggestions for putting a pointer in NSData
-// https://stackoverflow.com/questions/38890174/use-nsvalue-to-wrap-a-c-pointer
-
-static NSData* helperDataWithValue(NSValue* the_value)
+- (BOOL) outlineView:(NSOutlineView*)outline_view shouldCollapseItem:(id)item
 {
-    NSUInteger size;
-    const char* encoding = [the_value objCType];
-    NSGetSizeAndAlignment(encoding, &size, NULL);
-
-    void* ptr = malloc(size);
-    [the_value getValue:ptr];
-    NSData* ret_data = [NSData dataWithBytes:ptr length:size];
-    free(ptr);
-
-    return ret_data;
+  IFni cbBranchClose = (IFni)IupGetCallback([(IupCocoaOutlineView*)outline_view ih], "BRANCHCLOSE_CB");
+  if (cbBranchClose)
+  {
+    IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)item;
+    Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
+    int id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
+    if (cbBranchClose(ih, id) == IUP_IGNORE)
+      return NO;
+  }
+  return YES;
 }
 
-- (id <NSPasteboardWriting>)outlineView:(NSOutlineView *)outlineView pasteboardWriterForItem:(id)the_item
+- (NSIndexSet*) outlineView:(NSOutlineView*)outline_view selectionIndexesForProposedSelection:(NSIndexSet*)proposed_selection_indexes
 {
-    // No dragging if <some condition isn't met>
-	if(![the_item isKindOfClass:[IupCocoaTreeItem class]])
-	{
-		return nil;
-	}
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
-	
-	
-//    Book *book = (Book *)(((NSTreeNode *)item).representedObject);
-//    NSString *identifier = book.title;
-	
-    NSPasteboardItem* paste_board_item = [[NSPasteboardItem alloc] init];
-    [paste_board_item autorelease];
-//    NSString* unique_id_string = [NSString stringWithFormat:@"%p", tree_item];
-//    [paste_board_item setString:unique_id_string forType:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE];
-
-	NSValue* pointer_value = [NSValue valueWithPointer:tree_item];
-	NSData* data_value = helperDataWithValue(pointer_value);
-	
-	// archivedDataWithRootObject throws an exception using a pointer
-//	NSData* data_value = [NSKeyedArchiver archivedDataWithRootObject:pointer_value];
-    [paste_board_item setData:data_value forType:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE];
-    return paste_board_item;
+  Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
+  return iupAttribGetBoolean(ih, "CANFOCUS") ? proposed_selection_indexes : nil;
 }
 
-
-- (void)outlineView:(NSOutlineView *)outlineView draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint forItems:(NSArray *)dragged_items
+- (void) iupCocoaTreeDoubleClickAction:(id)sender
 {
-	[self setItemBeingDragged:nil];
+  IupCocoaOutlineView *outlineView = (IupCocoaOutlineView*)sender;
+  NSInteger clickedRow = [outlineView clickedRow];
+  if (clickedRow < 0)
+  {
+    clickedRow = [outlineView selectedRow];
+  }
 
-    // If only one item is being dragged, mark it so we can reorder it with a special pboard indicator
-    if([dragged_items count] == 1)
+  if (clickedRow >= 0)
+  {
+    IupCocoaTreeItem *item = [outlineView itemAtRow:clickedRow];
+    Ihandle* ih = [outlineView ih];
+    int item_id = iupTreeFindNodeId(ih, (InodeHandle*)item);
+
+    if ([item kind] == ITREE_LEAF)
     {
-    	[self setItemBeingDragged:[dragged_items lastObject]];
-	}
+      IFni cb = (IFni)IupGetCallback(ih, "EXECUTELEAF_CB");
+      if (cb) cb(ih, item_id);
+    }
+    else
+    {
+      IFni cb = (IFni)IupGetCallback(ih, "EXECUTEBRANCH_CB");
+      if (cb) cb(ih, item_id);
+    }
+  }
 }
 
-
-static int helperCallDragDropCb(Ihandle* ih, IupCocoaTreeItem* tree_item_drag, IupCocoaTreeItem* tree_item_drop, NSInteger child_index, bool is_copy)
+- (NSString *)outlineView:(NSOutlineView *)outlineView toolTipForCell:(NSCell *)cell rect:(NSRectPointer)rect tableColumn:(NSTableColumn *)tableColumn item:(id)item mouseLocation:(NSPoint)mouseLocation
 {
-	IFniiii drag_drop_cb = (IFniiii)IupGetCallback(ih, "DRAGDROP_CB");
-	int is_shift = 0;
+  Ihandle* ih = [(IupCocoaOutlineView*)outlineView ih];
+  if (!ih)
+    return nil;
 
-	// Cocoa has higher-level APIs to determine move vs. copy to support track pads and acessibility.
-	// Also Cocoa uses 'Option', not Control for copy-drag.
-	// So I will not use the key states.
-	// (They also aren't implemented yet as I do this.)
-	// For consistency, I think I rather always pass is_shift=0 because we aren't reading the keyboard for control,
-	// and shift doesn't do anything natively for this operation.
-  /*
-  char key[5];
-  iupdrvGetKeyState(key);
-  if (key[0] == 'S')
-    is_shift = 1;
-  if (key[1] == 'C')
-    *is_ctrl = 1;
-  else
-    *is_ctrl = 0;
-*/
+  IFnii cbTips = (IFnii)IupGetCallback(ih, "TIPS_CB");
+  if (cbTips)
+  {
+    /* mouseLocation is already in outline view coordinates */
+    int x = (int)mouseLocation.x;
+    int y = (int)mouseLocation.y;
+    cbTips(ih, x, y);
+  }
 
-	if(drag_drop_cb)
-	{
-		int drag_id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item_drag);
-		int drop_id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item_drop) + (int)child_index;
-		return drag_drop_cb(ih, drag_id, drop_id, is_shift, (int)is_copy);
-	}
+  /* Check for custom TIP attribute set by TIPS_CB or user */
+  char* tip = iupAttribGet(ih, "TIP");
+  if (tip)
+    return [NSString stringWithUTF8String:tip];
 
-	return IUP_CONTINUE; /* allow to move by default if callback not defined */
-}
+  /* If INFOTIP is not enabled, don't show automatic tooltips */
+  if (!iupAttribGetBoolean(ih, "INFOTIP"))
+    return nil;
 
-- (NSDragOperation)outlineView:(NSOutlineView *)outline_view validateDrop:(id < NSDraggingInfo >)drag_info proposedItem:(id)target_item proposedChildIndex:(NSInteger)child_index
-{
-//NSLog(@"%@", NSStringFromSelector(_cmd));
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)item;
+  NSString* title = [tree_item title];
 
-	NSArray<NSPasteboardType>* drag_types = [[drag_info draggingPasteboard] types];
-	Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
+  if (!title)
+    return nil;
 
-    if([drag_types containsObject:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE])
-    {
-		// If the sender is ourselves, then we accept it as a move or copy, depending on the modifier key
-        if([drag_info draggingSource] == outline_view)
-        {
-        	// Since this is callback shared with DRAGDROPTREE, do an extra check to make sure this feature is on.
-			if(!ih->data->show_dragdrop)
-			{
-				return NSDragOperationNone;
-			}
-			
-			
-            if([drag_info draggingSourceOperationMask] == NSDragOperationCopy)
-            {
-				BOOL can_drag = child_index >= 0 && target_item;
-				if(can_drag)
-				{
-					if(IUP_CONTINUE == helperCallDragDropCb(ih, [self itemBeingDragged], target_item, child_index, true))
-					{
-	                	return NSDragOperationCopy;
-					}
-					else
-					{
-						return NSDragOperationNone;
-					}
-				}
-				else
-				{
-					// This seems to prevent copying under a leaf which would force us to convert branches to leaves, which I don't think IUP allows.
-					return NSDragOperationNone;
-				}
-            }
-            else
-            {
-            	BOOL can_drag = child_index >= 0 && target_item;
+  /* Calculate if text is truncated */
+  NSTableCellView* cellView = [outlineView viewAtColumn:[outlineView columnWithIdentifier:@"MainColumn"] row:[outlineView rowForItem:item] makeIfNecessary:NO];
+  if (!cellView)
+    return title;
 
-				if(can_drag)
-				{
-					//	NSInteger index_of_target_item = [outline_view rowForItem:target_item];
+  NSTextField* textField = [cellView textField];
+  if (!textField)
+    return title;
 
-					// This code (from Apple example) seems to be to prevent dragging a branch as a child of itself (which will throw an exception if allowed).
-					if([self itemBeingDragged])
-					{
-						// We have a single item being dragged to move; validate if we can move it or not
-						// A move is only valid if the target isn't a child of the thing being dragged. We validate that now
-						id item_walker = target_item;
-						while(item_walker)
-						{
-							if(item_walker == [self itemBeingDragged])
-							{
-								return NSDragOperationNone; // Can't do it!
-							}
-							item_walker = [outline_view parentForItem:item_walker];
-						}
-						
-						if(IUP_CONTINUE == helperCallDragDropCb(ih, [self itemBeingDragged], target_item, child_index, false))
-						{
-							return NSDragOperationMove;
-						}
-						else
-						{
-							return NSDragOperationNone;
-						}
-					}
-					else
-					{
-						// For multiple items, what do we do?
-						return NSDragOperationNone;
-					}
-				}
-				else
-				{
-					return NSDragOperationNone;
-				}
-			}
-		}
-		// Dragging an item from one NSOutlineView to another NSOutlineView
-		else
-		{
-			if(0 == IupGetInt(ih, "DRAGDROPTREE"))
-			{
-				return NSDragOperationNone;
-			}
-		
-		
-			if([drag_info draggingSourceOperationMask] == NSDragOperationCopy)
-            {
-				BOOL can_drag = child_index >= 0 && target_item;
-				if(can_drag)
-				{
-                	return NSDragOperationCopy;
-				}
-				else if((-1 == child_index) && (nil == target_item))
-				{
-					// special check for dragging onto an empty outlineview
-					IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-					if([[data_source_delegate treeRootTopLevelObjects] count] == 0)
-					{
-						return NSDragOperationCopy;
-					}
-					else
-					{
-						return NSDragOperationNone;
-					}
-				}
-				else
-				{
-					// This seems to prevent copying under a leaf which would force us to convert branches to leaves, which I don't think IUP allows.
-					return NSDragOperationNone;
-				}
-            }
-            else
-            {
-            	BOOL can_drag = child_index >= 0 && target_item;
+  NSSize textSize = [[textField stringValue] sizeWithAttributes:@{NSFontAttributeName: [textField font]}];
+  NSRect textRect = [textField frame];
 
-				if(can_drag)
-				{
-					return NSDragOperationMove;
-				}
-				else if((-1 == child_index) && (nil == target_item))
-				{
-					// special check for dragging onto an empty outlineview
-					IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-					if([[data_source_delegate treeRootTopLevelObjects] count] == 0)
-					{
-						return NSDragOperationMove;
-					}
-					else
-					{
-						return NSDragOperationNone;
-					}
-				}
-				else
-				{
-					return NSDragOperationNone;
-				}
-			}
-		}
-		
-		
-	}
-	return NSDragOperationNone;
+  /* Show tooltip only if text is truncated */
+  if (textSize.width > textRect.size.width)
+    return title;
+
+  return nil;
 }
 
+@end
 
 /*****************************************************************************/
-/* AUXILIAR FUNCTIONS                                                        */
+/* DRAG AND DROP                                                             */
 /*****************************************************************************/
 
-#if 0
-static void cocoaTreeChildRebuildCacheRec(Ihandle* ih, IupCocoaTreeItem* tree_item, int* object_id)
+static void cocoaTreeUpdateDragDrop(Ihandle* ih)
 {
-	for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
-	{
-    (*object_id)++;
-    ih->data->node_cache[*object_id].node_handle = tree_item; // I don't think should be retained
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  if (!outline_view) return;
 
-    /* go recursive to children */
-    cocoaTreeChildRebuildCacheRec(ih, a_item, object_id);
+  /* Internal DND (SHOWDRAGDROP=YES) */
+  BOOL enable_internal_dnd = ih->data->show_dragdrop;
+  /* Cross-tree DND (DRAGDROPTREE=YES) */
+  BOOL enable_crosstree_dnd = iupAttribGetBoolean(ih, "DRAGDROPTREE");
 
-		
- 	 }
-}
+  /* DRAGSOURCE: Enabled if internal DND is on OR (cross-tree DND is on AND DRAGSOURCE=YES). */
+  BOOL enable_drag_source = enable_internal_dnd || (enable_crosstree_dnd && iupAttribGetBoolean(ih, "DRAGSOURCE"));
+  /* DROPTARGET: Enabled if internal DND is on OR (cross-tree DND is on AND DROPTARGET=YES). */
+  BOOL enable_drop_target = enable_internal_dnd || (enable_crosstree_dnd && iupAttribGetBoolean(ih, "DROPTARGET"));
 
-static void cocoaTreeRebuildNodeCache(Ihandle* ih, int object_id, IupCocoaTreeItem* tree_item)
-{
-  ih->data->node_cache[object_id].node_handle = tree_item;
-  cocoaTreeChildRebuildCacheRec(ih, tree_item, &object_id);
-}
-#endif
+  if (enable_drag_source)
+  {
+    NSDragOperation source_mask = NSDragOperationMove | NSDragOperationCopy;
+    /* Enable for local drags (within the application, including between different trees). */
+    [outline_view setDraggingSourceOperationMask:source_mask forLocal:YES];
 
-static void iupCocoaTreeRecursivelyCreateFlatItemArray(IupCocoaTreeItem* the_item, NSMutableArray<IupCocoaTreeItem*>* flattened_array_of_items)
-{
-	for(IupCocoaTreeItem* a_item in [the_item childrenArray])
-	{
-		[flattened_array_of_items addObject:a_item];
-		iupCocoaTreeRecursivelyCreateFlatItemArray(a_item, flattened_array_of_items);
-	}
+    /* Disable for external drags (to other applications), as we use internal types. */
+    [outline_view setDraggingSourceOperationMask:NSDragOperationNone forLocal:NO];
+
+    /* Allow dragging to start. */
+    [outline_view setVerticalMotionCanBeginDrag:YES];
+  }
+  else
+  {
+    /* Disable drag source entirely. */
+    [outline_view setDraggingSourceOperationMask:NSDragOperationNone forLocal:YES];
+    [outline_view setDraggingSourceOperationMask:NSDragOperationNone forLocal:NO];
+    [outline_view setVerticalMotionCanBeginDrag:NO];
+  }
+
+  /* Configure Drop Target */
+  /* Register only if the target role is enabled AND DND is active. */
+  if (enable_drop_target && (enable_internal_dnd || enable_crosstree_dnd))
+  {
+    /* Register for the custom IUP tree DND type. */
+    [outline_view registerForDraggedTypes:[NSArray arrayWithObjects:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE, nil]];
+    /* Use standard feedback style for outline views. */
+    [outline_view setDraggingDestinationFeedbackStyle:NSTableViewDraggingDestinationFeedbackStyleRegular];
+  }
+  else
+  {
+    /* Disable drop target entirely. */
+    [outline_view unregisterDraggedTypes];
+  }
 }
 
-static NSArray<IupCocoaTreeItem*>* iupCocoaTreeCreateFlatItemArray(IupCocoaTreeItem* the_item)
+static int cocoaTreeSetShowDragDropAttrib(Ihandle* ih, const char* value)
 {
-	NSMutableArray* flattened_array_of_items = [[[NSMutableArray alloc] init] autorelease];
-	[flattened_array_of_items addObject:the_item];
+  if (iupStrBoolean(value))
+    ih->data->show_dragdrop = 1;
+  else
+    ih->data->show_dragdrop = 0;
 
-	for(IupCocoaTreeItem* a_item in [the_item childrenArray])
-	{
-		[flattened_array_of_items addObject:a_item];
-		iupCocoaTreeRecursivelyCreateFlatItemArray(a_item, flattened_array_of_items);
-	}
-	return flattened_array_of_items;
+  if (ih->handle)
+  {
+    cocoaTreeUpdateDragDrop(ih);
+    return 0;
+  }
+  return 1;
 }
 
-// This will compile-in a runtime check to make sure the data source delegate and the Iup node_cache are consistent.
-// The check is kind of slow, so it should only be used for debugging.
-// define to 1 to use. define to 0 to disable.
-#define IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE 0
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-
-// This is a helper function that traverses through a NSOutlineView data source delegate looking for a certain item, and returns the array index this would be in for the ordering of the Iup node_cache
-static NSArray<IupCocoaTreeItem*>* testValidateCocoaTreeCreateFlatItemArray(IupCocoaTreeDelegate* tree_delegate)
+/* Generic handler for DRAGDROPTREE, DRAGSOURCE, DROPTARGET */
+static int cocoaTreeSetDndControlAttrib(Ihandle* ih, const char* value)
 {
-	NSMutableArray* flattened_array_of_items = [[[NSMutableArray alloc] init] autorelease];
-	
-	for(IupCocoaTreeItem* a_item in [tree_delegate treeRootTopLevelObjects])
-	{
-		[flattened_array_of_items addObject:a_item];
-		iupCocoaTreeRecursivelyCreateFlatItemArray(a_item, flattened_array_of_items);
-	}
-	return flattened_array_of_items;
+  (void)value;
+  if (ih->handle)
+  {
+    cocoaTreeUpdateDragDrop(ih);
+  }
+  return 1;
 }
 
-// Returns true if passes test
-static bool testValidateCocoaTreeNodeCache(Ihandle* ih, IupCocoaTreeDelegate* tree_delegate)
+@interface IupCocoaTreeDragDropDelegate : IupCocoaTreeDelegate
 {
-	NSArray<IupCocoaTreeItem*>* flattened_array_of_items = testValidateCocoaTreeCreateFlatItemArray(tree_delegate);
-	bool found_error = false;
+  /* This is used to compare whether the item being dragged ends up dragging onto itself so we can reject it in validation */
+  id itemBeingDragged;
+}
+@property(nonatomic, weak) id itemBeingDragged;
+@end
 
-	if(ih->data->node_count != [flattened_array_of_items count])
-	{
-		found_error = true;
-		NSLog(@"INTERNAL ERROR in testValidateCocoaTreeNodeCache: Number of elements in data source does not equal the number in the node_cache.");
-	}
+@implementation IupCocoaTreeDragDropDelegate
 
-	int i = 0;
-	for(IupCocoaTreeItem* a_item in flattened_array_of_items)
-	{
-		IupCocoaTreeItem* node_cache_item = (IupCocoaTreeItem*)ih->data->node_cache[i].node_handle;
-		if(![a_item isEqual:node_cache_item])
-		{
-			found_error = true;
-		}
-		i++;
-	}
+@synthesize itemBeingDragged = itemBeingDragged;
 
-	if(found_error)
-	{
-		i = 0;
-		NSLog(@"INTERNAL ERROR in testValidateCocoaTreeNodeCache: Arrays do not match");
-		NSLog(@"DataSource:");
-		for(IupCocoaTreeItem* a_item in flattened_array_of_items)
-		{
-			NSLog(@"DataSource: [%d] = %@", i, [a_item title]);
-			i++;
-		}
-		NSLog(@"node_cache:");
-		for(i=0; i<ih->data->node_count;i++)
-		{
-			IupCocoaTreeItem* node_cache_item = (IupCocoaTreeItem*)ih->data->node_cache[i].node_handle;
-			NSLog(@"node_cache: [%d] = %@", i, [node_cache_item title]);
-		}
-		
-		NSLog(@"Interleaved:");
-		i = 0;
-		for(IupCocoaTreeItem* a_item in flattened_array_of_items)
-		{
-			NSLog(@"DataSource: [%d] = %@ [%p]", i, [a_item title], a_item);
-			IupCocoaTreeItem* node_cache_item = (IupCocoaTreeItem*)ih->data->node_cache[i].node_handle;
-			NSLog(@"node_cache: [%d] = %@ [%p]", i, [node_cache_item title], node_cache_item);
-			i++;
-		}
+static NSData* helperDataWithValue(NSValue* the_value)
+{
+  NSUInteger size;
+  const char* encoding = [the_value objCType];
+  NSGetSizeAndAlignment(encoding, &size, NULL);
 
-		NSCAssert(0, @"INTERNAL ERROR in testValidateCocoaTreeNodeCache: Arrays do not match");
-	}
-	else
-	{
-		NSLog(@"testValidateCocoaTreeNodeCache passed.");
-	}
-	
+  void* ptr = malloc(size);
+  [the_value getValue:ptr];
+  NSData* ret_data = [NSData dataWithBytes:ptr length:size];
+  free(ptr);
 
-	return !found_error;
+  return ret_data;
 }
 
-#endif
-
-// iupTreeCopyMoveCache doesn't work for Cocoa.
-// I think the main problem is NSOutlineView allows the user to insert into positions that IUP does not support.
-// There are ambiguities about whether something is added as a sibling or child.
-// IUP overspecifies the UI interaction rules which don't apply to NSOutlineView.
-// And NSOutlineView provides UI that does distinguish between sibling or child and the user has fine control over where it is dropped.
-// So I think the problem is that we cannot express this in terms of IUP.
-// Additionally, iupTreeCopyMoveCache seems to imply I copied the nodes, and then will delete.
-// But Cocoa directly moved, so there is another impedience mismatch.
-//
-// (The bigger problem I think is we shouldn't have a node_cache.
-// "The two biggest problems in computer science are naming things and cache invalidation."
-// Because Cocoa already has two representations (the NSOutlineView and the data source delegate),
-// with a different internal layout than the third IUP node_cache, it is really hard to keep these in sync.
-// But for now, we are stuck with the node_cache.
-// So I need to create my own variants of iupTreeCopyMoveCache to properly update the node_cache so it stays in sync with
-// how Cocoa allows the user to manipulate the NSOutlineView.)
-static void iupCocoaTreeMoveCache(Ihandle* ih, int flat_index_before, int flat_index_after, int count_of_nodes_to_move)
+- (id <NSPasteboardWriting>)outlineView:(NSOutlineView *)outlineView pasteboardWriterForItem:(id)the_item
 {
-	// I need to rearrange the internal IUP node_cache array.
-	// Just in case the table is huge and we are moving a huge number of elements, I don't want to blow the stack.
-	// TODO: The node_cache does seem to have a notion of extra elements beyond the ones in use, which we might be able to use, but I don't know the internal use of it well enough to be sure I won't break other assumptions by growing it and using it.
-	bool is_malloc = false;
-	InodeData* tmp_array = NULL;
-	if(count_of_nodes_to_move > 128) // 128 is a number I pulled out of the air
-	{
-		is_malloc = false;
-		tmp_array = (InodeData*)alloca(count_of_nodes_to_move*sizeof(InodeData));
-	}
-	else
-	{
-		is_malloc = true;
-		tmp_array = (InodeData*)malloc(count_of_nodes_to_move*sizeof(InodeData));
-	}
+  if(![the_item isKindOfClass:[IupCocoaTreeItem class]])
+  {
+    return nil;
+  }
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)the_item;
 
-	/*
-		Exmaple 1a: Let's move 7,8,9 to go after 4 (move higher address to lower)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) We need to copy 7,8,9 to the tmp_array to save the original values
-	 	tmp_array: [7 8 9]
-	 
-	 	2) memmove items after 4 and before 7,8,9 to the right by the number of items to move (3). (*Edge Case: Do we need a bounds check?)
-	 	node_cache: [0 1 2 3 4 5 6 7 5 6]
-	 
-	 	3) copy 7 8 9 after 4
-	 	node_cache: [0 1 2 3 4 7 8 9 5 6]
-	 
-	 
-		Exmaple 1b: Let's move 5,6,7 to go after 0 (move higher address to lower)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) We need to copy 5,6,7 to the tmp_array to save the original values
-	 	tmp_array: [5 6 7]
-	 
-	 	2) memmove items after 0 and before 5,6,7 to the right by the number of items to move (3)
-	 	node_cache: [0 1 2 3 1 2 3 4 8 9]
-	 
-	 	3) copy 5,6,7 after the 0
-	 	node_cache: [0 5 6 7 1 2 3 4 8 9]
-	 
-	 
-		Exmaple 2a: Let's move 0,1,2 to go after 9 (move lower address to higher)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) We need to copy 0,1,2 to the tmp_array to save the original values
-	 	tmp_array: [0 1 2]
-	 
-	 	2) memmove everything left the number of elements being moved (3)
-	 	node_cache: [3 4 5 6 7 8 9 7 8 9]
-	 
-	 	3) copy 0,1,2 after the 7 8 9
-	 	node_cache: [3 4 5 6 7 8 9 0 1 2]
-	 
-	 
-		Exmaple 2b: Let's move 1,2,3 to go after 5 (move lower address to higher)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) We need to copy 1,2,3 to the tmp_array to save the original values
-	 	tmp_array: [1 2 3]
-	 
-	 	2) memmove everything before the 6 and after the 1,2,3 to the left, the number of elements being moved (3)
-	 	node_cache: [0 4 5 3 4 5 6 7 8 9]
-	 
-	 	3) copy 1,2,3 after the 5
-	 	node_cache: [0 4 5 1 2 3 6 7 8 9]
+  NSPasteboardItem* paste_board_item = [[NSPasteboardItem alloc] init];
+  [paste_board_item autorelease];
 
+  NSValue* pointer_value = [NSValue valueWithPointer:tree_item];
+  NSData* data_value = helperDataWithValue(pointer_value);
 
-		Exmaple 2c: Let's move 1,2,3,4 to go after 7 (move lower address to higher)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) We need to copy 1,2,3,4 to the tmp_array to save the original values
-	 	tmp_array: [1 2 3 4]
-	 
-	 	2) memmove everything after the 1,2,3,4 and before the 8 to the left, the number of elements being moved (3)
-	 	node_cache: [0 X X X X 5 6 7 Y Y]
-	 	node_cache: [0 5 6 7 4 5 6 7 8 9]
+  [paste_board_item setData:data_value forType:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE];
+  return paste_board_item;
+}
 
-	 	3) copy 1,2,3,4 after the newly moved 7 (i.e. end of the just moved ranged)
-	 	node_cache: [0 5 6 7 1 2 3 4 8 9]
-	 
-	 	Algorithm:
-	 	- If we are moving from a higher address to a lower address,
-	 		- Copy the elements we want to move to tmp_array
-	 		- move all elements that are right of target point but before our moving elements to the right, the number of positions being moved
-		 	- Copy back the elements from the tmp_array to the target position
-	 	- Else if we are moving from a lower address to a higher address,
-	 		- Copy the elements we want to move to tmp_array
-	 		- move all elements that are right of our start elements but before the target point to the left, the number of positions being moved
-	 		- Copy back the elements from the tmp_array to the specified target position
-	*/
-	
-#if 0
-		NSLog(@"node_count %d", ih->data->node_count);
-		for(size_t j=0; j<ih->data->node_count; j++)
-		{
-			NSLog(@"bef: node_cache[%zu]=0x%p, %@", j, &ih->data->node_cache[j], [(IupCocoaTreeItem*)(ih->data->node_cache[j].node_handle) title]);
-		}
-#endif
+- (void)outlineView:(NSOutlineView *)outlineView draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint forItems:(NSArray *)dragged_items
+{
+  [self setItemBeingDragged:nil];
 
+  /* If only one item is being dragged, mark it so we can reorder it with a special pboard indicator */
+  if([dragged_items count] == 1)
+  {
+    [self setItemBeingDragged:[dragged_items lastObject]];
+  }
+}
 
-	if(flat_index_before > flat_index_after) // moving from a higher address to a lower
-	{
-//		NSLog(@"moving from a higher address to a lower");
+static int helperCallDragDropCb(Ihandle* ih, IupCocoaTreeItem* tree_item_drag, IupCocoaTreeItem* tree_item_drop, NSInteger child_index, bool is_copy)
+{
+  IFniiii drag_drop_cb = (IFniiii)IupGetCallback(ih, "DRAGDROP_CB");
+  int is_shift = 0; /* Shift key doesn't have a standard D&D meaning on macOS */
 
-		memcpy(tmp_array, ih->data->node_cache+flat_index_before, count_of_nodes_to_move*sizeof(InodeData));
+  if(drag_drop_cb)
+  {
+    int drag_id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item_drag);
+    /* The drop_id is the identifier of the node where the item was dropped. */
+    /* The actual position (as child or sibling) is determined later. */
+    int drop_id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item_drop);
+    return drag_drop_cb(ih, drag_id, drop_id, is_shift, (int)is_copy);
+  }
 
-		int number_of_nodes_to_move_over = flat_index_before - flat_index_after;
-//		NSLog(@"number_of_nodes_to_move_over:%d", number_of_nodes_to_move_over);
+  return IUP_CONTINUE; /* allow to move by default if callback not defined */
+}
 
-		memmove(ih->data->node_cache+flat_index_after+count_of_nodes_to_move, ih->data->node_cache+flat_index_after, number_of_nodes_to_move_over*sizeof(InodeData));
-		memcpy(ih->data->node_cache+(flat_index_after), tmp_array, count_of_nodes_to_move*sizeof(InodeData));
-	}
-	else // moving from a lower address to a higher
-	{
-//		NSLog(@"moving from a lower address to a higher");
+- (NSDragOperation)outlineView:(NSOutlineView *)outline_view validateDrop:(id < NSDraggingInfo >)drag_info proposedItem:(id)target_item proposedChildIndex:(NSInteger)child_index
+{
+  NSArray<NSPasteboardType>* drag_types = [[drag_info draggingPasteboard] types];
+  Ihandle* ih = [(IupCocoaOutlineView*)outline_view ih];
 
-		memcpy(tmp_array, ih->data->node_cache+flat_index_before, count_of_nodes_to_move*sizeof(InodeData));
+  if([drag_types containsObject:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE])
+  {
+    /* If the sender is ourselves, then we accept it as a move or copy, depending on the modifier key */
+    if([drag_info draggingSource] == outline_view)
+    {
+      /* Since this is callback shared with DRAGDROPTREE, do an extra check to make sure this feature is on. */
+      if(!ih->data->show_dragdrop)
+      {
+        return NSDragOperationNone;
+      }
 
-		int number_of_nodes_to_move_over = flat_index_after - flat_index_before;
-//		NSLog(@"number_of_nodes_to_move_over:%d", number_of_nodes_to_move_over);
+      if([drag_info draggingSourceOperationMask] == NSDragOperationCopy)
+      {
+        BOOL can_drag = child_index >= 0 && target_item;
+        if(can_drag)
+        {
+          if(IUP_CONTINUE == helperCallDragDropCb(ih, [self itemBeingDragged], target_item, child_index, true))
+          {
+            return NSDragOperationCopy;
+          }
+          else
+          {
+            return NSDragOperationNone;
+          }
+        }
+        else
+        {
+          return NSDragOperationNone;
+        }
+      }
+      else
+      {
+        BOOL can_drag = child_index >= 0 && target_item;
 
-		memmove(ih->data->node_cache+flat_index_before, ih->data->node_cache+flat_index_before+count_of_nodes_to_move, number_of_nodes_to_move_over*sizeof(InodeData));
-		memcpy(ih->data->node_cache+(flat_index_before+number_of_nodes_to_move_over), tmp_array, count_of_nodes_to_move*sizeof(InodeData));
-	}
+        if(can_drag)
+        {
+          if([self itemBeingDragged])
+          {
+            /* We have a single item being dragged to move; validate if we can move it or not */
+            /* A move is only valid if the target isn't a child of the thing being dragged. We validate that now */
+            id item_walker = target_item;
+            while(item_walker)
+            {
+              if(item_walker == [self itemBeingDragged])
+              {
+                return NSDragOperationNone;
+              }
+              item_walker = [outline_view parentForItem:item_walker];
+            }
 
+            if(IUP_CONTINUE == helperCallDragDropCb(ih, [self itemBeingDragged], target_item, child_index, false))
+            {
+              return NSDragOperationMove;
+            }
+            else
+            {
+              return NSDragOperationNone;
+            }
+          }
+          else
+          {
+            /* For multiple items, what do we do? */
+            return NSDragOperationNone;
+          }
+        }
+        else
+        {
+          return NSDragOperationNone;
+        }
+      }
+    }
+    /* Dragging an item from one NSOutlineView to another NSOutlineView */
+    else
+    {
+      if(0 == IupGetInt(ih, "DRAGDROPTREE"))
+      {
+        return NSDragOperationNone;
+      }
 
-	if(is_malloc)
-	{
-		free(tmp_array);
-	}
-	tmp_array = NULL;
 
-#if 0
-	for(size_t j=0; j<ih->data->node_count; j++)
-	{
-		NSLog(@"aft: node_cache[%zu]=0x%p, %@", j, &ih->data->node_cache[j], [(IupCocoaTreeItem*)(ih->data->node_cache[j].node_handle) title]);
-	}
-#endif
+      if([drag_info draggingSourceOperationMask] == NSDragOperationCopy)
+      {
+        BOOL can_drag = child_index >= 0 && target_item;
+        if(can_drag)
+        {
+          return NSDragOperationCopy;
+        }
+        else if((-1 == child_index) && (nil == target_item))
+        {
+          /* special check for dragging onto an empty outlineview */
+          IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+          if([[data_source_delegate treeRootTopLevelObjects] count] == 0)
+          {
+            return NSDragOperationCopy;
+          }
+          else
+          {
+            return NSDragOperationNone;
+          }
+        }
+        else
+        {
+          return NSDragOperationNone;
+        }
+      }
+      else
+      {
+        BOOL can_drag = child_index >= 0 && target_item;
 
-	iupAttribSet(ih, "LASTADDNODE", NULL);
+        if(can_drag)
+        {
+          return NSDragOperationMove;
+        }
+        else if((-1 == child_index) && (nil == target_item))
+        {
+          /* special check for dragging onto an empty outlineview */
+          IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+          if([[data_source_delegate treeRootTopLevelObjects] count] == 0)
+          {
+            return NSDragOperationMove;
+          }
+          else
+          {
+            return NSDragOperationNone;
+          }
+        }
+        else
+        {
+          return NSDragOperationNone;
+        }
+      }
+    }
 
+
+  }
+  return NSDragOperationNone;
 }
 
+/*****************************************************************************/
+/* DRAGDROPTREE - Cross-tree drag and drop support                          */
+/*****************************************************************************/
 
-// iupTreeCopyMoveCache doesn't work for Cocoa.
-// I think the main problem is NSOutlineView allows the user to insert into positions that IUP does not support.
-// There are ambiguities about whether something is added as a sibling or child.
-// IUP overspecifies the UI interaction rules which don't apply to NSOutlineView.
-// And NSOutlineView provides UI that does distinguish between sibling or child and the user has fine control over where it is dropped.
-// So I think the problem is that we cannot express this in terms of IUP.
-// Additionally, iupTreeCopyMoveCache seems to imply I copied the nodes, and then will delete.
-// But Cocoa directly moved, so there is another impedience mismatch.
-//
-// (The bigger problem I think is we shouldn't have a node_cache.
-// "The two biggest problems in computer science are naming things and cache invalidation."
-// Because Cocoa already has two representations (the NSOutlineView and the data source delegate),
-// with a different internal layout than the third IUP node_cache, it is really hard to keep these in sync.
-// But for now, we are stuck with the node_cache.
-// So I need to create my own variants of iupTreeCopyMoveCache to properly update the node_cache so it stays in sync with
-// how Cocoa allows the user to manipulate the NSOutlineView.)
-static void iupCocoaTreeCopyCache(Ihandle* ih, int flat_index_source, int flat_index_target, int count_of_nodes_to_copy, IupCocoaTreeItem* new_copy_tree_item)
+static int cocoaTreeDropData_CB(Ihandle *ih, char* type, void* data, int len, int x, int y)
 {
-	/*
-		Exmaple 1a: Let's copy 7,8,9 to go after 4 (copy higher address to lower)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) Increase the size of the array by the number of elements to copy
-	 	node_cache:  [0 1 2 3 4 5 6 7 8 9 X X X]
-	 
-	 	2) memmove items after 4 to the right by the number of elements to copy
-	 	node_cache: [0 1 2 3 4 5 6 7 5 6 7 8 9]
-	 
-	 	3) copy 7 8 9 which is at its (original position + number of elements to copy), to after 4
-	 	node_cache: [0 1 2 3 4 7 8 9 5 6 7 8 9]
-	 
-	 
-		Exmaple 1b: Let's copy 5,6,7 to go after 0 (copy higher address to lower)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) Increase the size of the array by the number of elements to copy
-	 	node_cache: [0 1 2 3 4 5 6 7 8 9 X X X]
+  int id = IupConvertXYToPos(ih, x, y);
+  int is_ctrl = 0;
+  char key[5];
 
-	 	2) memmove items after 0 to the right by the number of elements to copy
-	 	node_cache: [0 1 2 3 1 2 3 4 5 6 7 8 9]
-	 
-	 	3) copy 5,6,7 which is at its (original position + number of elements to copy), to after the 0
-	 	node_cache: [0 5 6 7 1 2 3 4 5 6 7 8 9]
+  Ihandle* ih_source;
+  memcpy((void*)&ih_source, data, len);
 
-	 
-		Exmaple 2a: Let's copy 0,1,2 to go after 9 (copy lower address to higher)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) Increase the size of the array by the number of elements to copy
-	 	node_cache: [0 1 2 3 4 5 6 7 8 9 X X X]
-	 
-	 	2) memmove items after 9 to the right by the number of elements to copy. (*Edge Case: We don't have any items after 9)
-	 	node_cache: [0 1 2 3 4 5 6 7 8 9 X X X]
-	 
-	 	3) copy 0,1,2 which is at its (original position), to after the 9
-	 	node_cache: [0 1 2 3 4 5 6 7 8 9 0 1 2]
+  if (!IupClassMatch(ih_source, "tree"))
+    return IUP_DEFAULT;
 
-	 
-		Exmaple 2b: Let's copy 1,2,3 to go after 5 (copy lower address to higher)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) Increase the size of the array by the number of elements to copy
-	 	node_cache: [0 1 2 3 4 5 6 7 8 9 X X X]
-	 
-	 	2) memmove items after 5 to the right by the number of elements to copy.
-	 	node_cache: [0 1 2 3 4 5 6 7 8 6 7 8 9]
+  /* A copy operation is enabled with the CTRL key pressed, or else a move operation will occur.
+     A move operation will be possible only if the attribute DRAGSOURCEMOVE is Yes.
+     When no key is pressed the default operation is copy when DRAGSOURCEMOVE=No and move when DRAGSOURCEMOVE=Yes. */
+  iupdrvGetKeyState(key);
+  if (key[1] == 'C')
+    is_ctrl = 1;
 
-		3) copy 0,1,2 which is at its (original position), to after the 5
-	 	node_cache: [0 1 2 3 4 5 1 2 3 6 7 8 9]
+  /* Here copy/move of multiple selection is not allowed, only a single node and its children. */
 
+  if (ih_source->data->mark_mode == ITREE_MARK_SINGLE)
+  {
+    int src_id = iupAttribGetInt(ih_source, "_IUPTREE_SOURCEID");
+    InodeHandle *itemDst, *itemSrc;
 
-		Exmaple 2c: Let's copy 1,2,3,4 to go after 7 (copy lower address to higher)
-		node_cache: [0 1 2 3 4 5 6 7 8 9]
-	 
-	 	1) Increase the size of the array by the number of elements to copy
-	 	node_cache: [0 1 2 3 4 5 6 7 8 9 X X X X]
-	 
-	 	2) memmove items after 5 to the right by the number of elements to copy.
-	 	node_cache: [0 1 2 3 4 5 6 7 8 9 6 7 8 9]
+    itemSrc = iupTreeGetNode(ih_source, src_id);
+    if (!itemSrc)
+      return IUP_DEFAULT;
 
-		3) copy 0,1,2,4 which is at its (original position), to after the 7
-	 	node_cache: [0 1 2 3 4 5 6 7 1 2 3 4 8 9]
+    itemDst = iupTreeGetNode(ih, id);
+    if (!itemDst)
+      return IUP_DEFAULT;
 
-	 	Algorithm:
-			- If we are moving from a higher address to a lower address,
- 				- count the number items between the insert position and end_of_the_array
-			 	- Resize the node_cache array
-			 	- memmove from the range (insert_position to end_of_array), to the (insert_position+number_of_elements_to_copy)
-			 	- memmove from the range (insert_position+number_of_elements_to_copy), to the insert_position
-		- Else if we are moving from a lower address to a higher address,
- 				- count the number items between the source position and end_of_the_array
-			 	- Resize the node_cache array
-			 	- memmove from the range (insert_position to end_of_array), to the (insert_position+number_of_elements_to_copy)
-			 	- memmove from the range (insert_position), to the insert_position
-	*/
-	
-#if 0
-		NSLog(@"node_count %d", ih->data->node_count);
-		for(size_t j=0; j<ih->data->node_count; j++)
-		{
-			NSLog(@"bef: node_cache[%zu]=0x%p, %@", j, &ih->data->node_cache[j], [(IupCocoaTreeItem*)(ih->data->node_cache[j].node_handle) title]);
-		}
-#endif
+    /* Copy the node and its children to the new position */
+    iupdrvTreeDragDropCopyNode(ih_source, ih, itemSrc, itemDst);
 
-	int original_node_count = ih->data->node_count;
-	// We must change the node_count and let IUP resize its array as needed.
-	ih->data->node_count += count_of_nodes_to_copy;
-	// iupTreeIncCacheMem expects that the node_count contains the new size
-	iupTreeIncCacheMem(ih);
+    if (IupGetInt(ih_source, "DRAGSOURCEMOVE") && !is_ctrl)
+      IupSetAttribute(ih_source, "DELNODE0", "MARKED");
+  }
 
-	
-//	NSLog(@"flat_index_source: %d", flat_index_source);
-//	NSLog(@"flat_index_target: %d", flat_index_target);
+  (void)type;
+  return IUP_DEFAULT;
+}
 
+static int cocoaTreeDragData_CB(Ihandle *ih, char* type, void *data, int len)
+{
+  int id = iupAttribGetInt(ih, "_IUPTREE_SOURCEID");
+  if (id < 0)
+    return IUP_DEFAULT;
 
-	if(flat_index_source > flat_index_target) // copying from a higher address to a lower
-	{
-//		NSLog(@"copying from a higher address to a lower");
-		int number_of_nodes_to_move_over = (original_node_count-1) - flat_index_target + 1; // we add +1 because we are inserting before the target
-//		NSLog(@"number_of_nodes_to_move_over: %d", number_of_nodes_to_move_over);
-	
-//		NSLog(@"bef: node_cache[%d] %@", flat_index_target+count_of_nodes_to_copy,[(IupCocoaTreeItem*)(ih->data->node_cache[flat_index_target+count_of_nodes_to_copy].node_handle) title]);
-//		NSLog(@"bef: node_cache[%d] %@", flat_index_target,[(IupCocoaTreeItem*)(ih->data->node_cache[flat_index_target].node_handle) title]);
-	
-		memmove(ih->data->node_cache+flat_index_target+count_of_nodes_to_copy, ih->data->node_cache+flat_index_target, number_of_nodes_to_move_over*sizeof(InodeData));
+  if (ih->data->mark_mode == ITREE_MARK_SINGLE)
+  {
+    /* Single selection */
+    IupSetAttributeId(ih, "MARKED", id, "YES");
+  }
 
-//		NSLog(@"mid: node_cache[%d] %@", flat_index_target,[(IupCocoaTreeItem*)(ih->data->node_cache[flat_index_target].node_handle) title]);
-//		NSLog(@"mid: node_cache[%d] %@", flat_index_source+count_of_nodes_to_copy,[(IupCocoaTreeItem*)(ih->data->node_cache[flat_index_source+count_of_nodes_to_copy].node_handle) title]);
-	
-		memmove(ih->data->node_cache+flat_index_target, ih->data->node_cache+flat_index_source+count_of_nodes_to_copy, count_of_nodes_to_copy*sizeof(InodeData));
+  /* Copy source handle */
+  memcpy(data, (void*)&ih, len);
 
+  (void)type;
+  return IUP_DEFAULT;
+}
 
-	}
-	else // copying from a lower address to a higher
-	{
-//		NSLog(@"copying from a lower address to a higher");
-		int number_of_nodes_to_move_over = (original_node_count-1) - flat_index_source;
-//		NSLog(@"number_of_nodes_to_move_over: %d", number_of_nodes_to_move_over);
-	
-		memmove(ih->data->node_cache+flat_index_target+count_of_nodes_to_copy, ih->data->node_cache+flat_index_target, number_of_nodes_to_move_over*sizeof(InodeData));
-		memmove(ih->data->node_cache+flat_index_target, ih->data->node_cache+flat_index_source, count_of_nodes_to_copy*sizeof(InodeData));
+static int cocoaTreeDragDataSize_CB(Ihandle* ih, char* type)
+{
+  (void)ih;
+  (void)type;
+  return sizeof(Ihandle*);
+}
 
-	}
+static int cocoaTreeDragEnd_CB(Ihandle *ih, int del)
+{
+  iupAttribSetInt(ih, "_IUPTREE_SOURCEID", -1);
+  (void)del;
+  return IUP_DEFAULT;
+}
 
-	// The mem-copies above created new nodes in the node_cache for our insertion, but their pointers to the node_handle point to the original objects instead of the new copies of the objects.
-	// So we need to go through those items, and change their node_handle pointers to point to the new copies of each object.
-	NSArray<IupCocoaTreeItem*>* flattened_array_of_new_items = iupCocoaTreeCreateFlatItemArray(new_copy_tree_item);
-	int k=flat_index_target;
-	for(IupCocoaTreeItem* a_item in flattened_array_of_new_items)
-	{
-//		NSLog(@"Fix Pointers: old:%p, new:%p\n%@\n%@\n", ih->data->node_cache[k].node_handle, a_item, [(IupCocoaTreeItem*)ih->data->node_cache[k].node_handle title], [(IupCocoaTreeItem*)a_item title]);
-		ih->data->node_cache[k].node_handle = a_item;
-		k++;
-	}
-	
+static int cocoaTreeDragBegin_CB(Ihandle* ih, int x, int y)
+{
+  int id = IupConvertXYToPos(ih, x, y);
+  iupAttribSetInt(ih, "_IUPTREE_SOURCEID", id);
+  return IUP_DEFAULT;
+}
 
+static int cocoaTreeSetDragDropTreeAttrib(Ihandle* ih, const char* value)
+{
+  if (iupStrBoolean(value))
+  {
+    /* Register callbacks to enable drag and drop between trees */
+    IupSetCallback(ih, "DRAGBEGIN_CB",    (Icallback)cocoaTreeDragBegin_CB);
+    IupSetCallback(ih, "DRAGDATASIZE_CB", (Icallback)cocoaTreeDragDataSize_CB);
+    IupSetCallback(ih, "DRAGDATA_CB",     (Icallback)cocoaTreeDragData_CB);
+    IupSetCallback(ih, "DRAGEND_CB",      (Icallback)cocoaTreeDragEnd_CB);
+    IupSetCallback(ih, "DROPDATA_CB",     (Icallback)cocoaTreeDropData_CB);
+  }
+  else
+  {
+    /* Unregister callbacks */
+    IupSetCallback(ih, "DRAGBEGIN_CB",    NULL);
+    IupSetCallback(ih, "DRAGDATASIZE_CB", NULL);
+    IupSetCallback(ih, "DRAGDATA_CB",     NULL);
+    IupSetCallback(ih, "DRAGEND_CB",      NULL);
+    IupSetCallback(ih, "DROPDATA_CB",     NULL);
+  }
 
-#if 0
-	for(size_t j=0; j<ih->data->node_count; j++)
-	{
-		NSLog(@"aft: node_cache[%zu]=0x%p, %@", j, &ih->data->node_cache[j], [(IupCocoaTreeItem*)(ih->data->node_cache[j].node_handle) title]);
-	}
-#endif
+  /* Update DND configuration if already mapped */
+  if (ih->handle)
+  {
+    cocoaTreeUpdateDragDrop(ih);
+  }
 
-	iupAttribSet(ih, "LASTADDNODE", NULL);
+  return 1;
+}
 
+/*****************************************************************************/
+/* AUXILIAR FUNCTIONS                                                        */
+/*****************************************************************************/
+
+static void iupCocoaTreeRecursivelyCreateFlatItemArray(IupCocoaTreeItem* the_item, NSMutableArray<IupCocoaTreeItem*>* flattened_array_of_items)
+{
+  for(IupCocoaTreeItem* a_item in [the_item childrenArray])
+  {
+    [flattened_array_of_items addObject:a_item];
+    iupCocoaTreeRecursivelyCreateFlatItemArray(a_item, flattened_array_of_items);
+  }
 }
 
-// iupTreeCopyMoveCache doesn't work for Cocoa.
-// I think the main problem is NSOutlineView allows the user to insert into positions that IUP does not support.
-// There are ambiguities about whether something is added as a sibling or child.
-// IUP overspecifies the UI interaction rules which don't apply to NSOutlineView.
-// And NSOutlineView provides UI that does distinguish between sibling or child and the user has fine control over where it is dropped.
-// So I think the problem is that we cannot express this in terms of IUP.
-// Additionally, iupTreeCopyMoveCache seems to imply I copied the nodes, and then will delete.
-// But Cocoa directly moved, so there is another impedience mismatch.
-//
-// (The bigger problem I think is we shouldn't have a node_cache.
-// "The two biggest problems in computer science are naming things and cache invalidation."
-// Because Cocoa already has two representations (the NSOutlineView and the data source delegate),
-// with a different internal layout than the third IUP node_cache, it is really hard to keep these in sync.
-// But for now, we are stuck with the node_cache.
-// So I need to create my own variants of iupTreeCopyMoveCache to properly update the node_cache so it stays in sync with
-// how Cocoa allows the user to manipulate the NSOutlineView.)
-static void iupCocoaTreeCrossInsertCache(Ihandle* source_ih, Ihandle* target_ih, int flat_index_source, int flat_index_target, int count_of_nodes_to_copy, IupCocoaTreeItem* new_copy_tree_item)
+static NSArray<IupCocoaTreeItem*>* iupCocoaTreeCreateFlatItemArray(IupCocoaTreeItem* the_item)
 {
+  NSMutableArray* flattened_array_of_items = [[[NSMutableArray alloc] init] autorelease];
+  [flattened_array_of_items addObject:the_item];
 
-#if 0
-		NSLog(@"node_count %d", ih->data->node_count);
-		for(size_t j=0; j<target_ih->data->node_count; j++)
-		{
-			NSLog(@"bef: node_cache[%zu]=0x%p, %@", j, &target_ih->data->node_cache[j], [(IupCocoaTreeItem*)(target_ih->data->node_cache[j].node_handle) title]);
-		}
-#endif
+  for(IupCocoaTreeItem* a_item in [the_item childrenArray])
+  {
+    [flattened_array_of_items addObject:a_item];
+    iupCocoaTreeRecursivelyCreateFlatItemArray(a_item, flattened_array_of_items);
+  }
+  return flattened_array_of_items;
+}
 
-	int original_node_count = target_ih->data->node_count;
-	// We must change the node_count and let IUP resize its array as needed.
-	target_ih->data->node_count += count_of_nodes_to_copy;
-	// iupTreeIncCacheMem expects that the node_count contains the new size
-	iupTreeIncCacheMem(target_ih);
+/* iupTreeCopyMoveCache doesn't work for Cocoa. */
+/* The main problem is NSOutlineView allows the user to insert into positions that IUP does not support. */
+/* There are ambiguities about whether something is added as a sibling or child. */
+/* IUP overspecifies the UI interaction rules which don't apply to NSOutlineView. */
+/* And NSOutlineView provides UI that does distinguish between sibling or child and the user has fine control over where it is dropped. */
+/* So I think the problem is that we cannot express this in terms of IUP. */
+/* Additionally, iupTreeCopyMoveCache seems to imply I copied the nodes, and then will delete. */
+/* But Cocoa directly moved, so there is another impedience mismatch. */
+/*  */
+/* (The bigger problem I think is we shouldn't have a node_cache. */
+/* "The two biggest problems in computer science are naming things and cache invalidation." */
+/* Because Cocoa already has two representations (the NSOutlineView and the data source delegate), */
+/* with a different internal layout than the third IUP node_cache, it is really hard to keep these in sync. */
+/* But for now, we are stuck with the node_cache. */
+/* So I need to create my own variants of iupTreeCopyMoveCache to properly update the node_cache so it stays in sync with */
+/* how Cocoa allows the user to manipulate the NSOutlineView.) */
+static void iupCocoaTreeMoveCache(Ihandle* ih, int flat_index_before, int flat_index_after, int count_of_nodes_to_move)
+{
+  /* I need to rearrange the internal IUP node_cache array.
+     For large moves, use heap allocation to avoid stack overflow. */
+  bool is_malloc = false;
+  InodeData* tmp_array = NULL;
 
-	
-//	NSLog(@"flat_index_target: %d", flat_index_target);
+  if(count_of_nodes_to_move > 128)
+  {
+    is_malloc = true;
+    tmp_array = (InodeData*)malloc(count_of_nodes_to_move*sizeof(InodeData));
+  }
+  else
+  {
+    is_malloc = false;
+    tmp_array = (InodeData*)alloca(count_of_nodes_to_move*sizeof(InodeData));
+  }
 
-	
+  /* Algorithm:
+   * - If moving from higher to lower address: copy to temp, shift right, copy back
+   * - If moving from lower to higher address: copy to temp, shift left, copy back */
+  if(flat_index_before > flat_index_after)
+  {
+    memcpy(tmp_array, ih->data->node_cache+flat_index_before, count_of_nodes_to_move*sizeof(InodeData));
 
+    int number_of_nodes_to_move_over = flat_index_before - flat_index_after;
+    memmove(ih->data->node_cache+flat_index_after+count_of_nodes_to_move,
+            ih->data->node_cache+flat_index_after,
+            number_of_nodes_to_move_over*sizeof(InodeData));
+    memcpy(ih->data->node_cache+flat_index_after, tmp_array, count_of_nodes_to_move*sizeof(InodeData));
+  }
+  else
+  {
+    memcpy(tmp_array, ih->data->node_cache+flat_index_before, count_of_nodes_to_move*sizeof(InodeData));
 
-	int number_of_nodes_to_move_over = (original_node_count-1) - flat_index_target + 1; // we add +1 because we are inserting before the target
-//	NSLog(@"number_of_nodes_to_move_over: %d", number_of_nodes_to_move_over);
-	
-	memmove(target_ih->data->node_cache+flat_index_target+count_of_nodes_to_copy, target_ih->data->node_cache+flat_index_target, number_of_nodes_to_move_over*sizeof(InodeData));
-	
-	memcpy(target_ih->data->node_cache+flat_index_target, source_ih->data->node_cache+flat_index_source, count_of_nodes_to_copy*sizeof(InodeData));
+    int number_of_nodes_to_move_over = flat_index_after - flat_index_before;
+    memmove(ih->data->node_cache+flat_index_before,
+            ih->data->node_cache+flat_index_before+count_of_nodes_to_move,
+            number_of_nodes_to_move_over*sizeof(InodeData));
+    memcpy(ih->data->node_cache+(flat_index_before+number_of_nodes_to_move_over),
+            tmp_array, count_of_nodes_to_move*sizeof(InodeData));
+  }
 
+  if(is_malloc)
+  {
+    free(tmp_array);
+  }
 
-	// The mem-copies above created new nodes in the node_cache for our insertion, but their pointers to the node_handle point to the original objects instead of the new copies of the objects.
-	// So we need to go through those items, and change their node_handle pointers to point to the new copies of each object.
-	NSArray<IupCocoaTreeItem*>* flattened_array_of_new_items = iupCocoaTreeCreateFlatItemArray(new_copy_tree_item);
-	int k=flat_index_target;
-	for(IupCocoaTreeItem* a_item in flattened_array_of_new_items)
-	{
-//		NSLog(@"Fix Pointers: old:%p, new:%p\n%@\n%@\n", target_ih->data->node_cache[k].node_handle, a_item, [(IupCocoaTreeItem*)target_ih->data->node_cache[k].node_handle title], [(IupCocoaTreeItem*)a_item title]);
-		target_ih->data->node_cache[k].node_handle = a_item;
-		k++;
-	}
-	
+  iupAttribSet(ih, "LASTADDNODE", NULL);
+}
 
+/* iupTreeCopyMoveCache doesn't work for Cocoa. */
+/* (See comments in iupCocoaTreeMoveCache for rationale.) */
+static void iupCocoaTreeCopyCache(Ihandle* ih, int flat_index_source, int flat_index_target, int count_of_nodes_to_copy, IupCocoaTreeItem* new_copy_tree_item)
+{
+  /*
+Algorithm:
+- If we are moving from a higher address to a lower address,
+- count the number items between the insert position and end_of_the_array
+- Resize the node_cache array
+- memmove from the range (insert_position to end_of_array), to the (insert_position+number_of_elements_to_copy)
+- memmove from the range (insert_position+number_of_elements_to_copy), to the insert_position
+- Else if we are moving from a lower address to a higher address,
+- count the number items between the source position and end_of_the_array
+- Resize the node_cache array
+- memmove from the range (insert_position to end_of_array), to the (insert_position+number_of_elements_to_copy)
+- memmove from the range (insert_position), to the insert_position
+*/
+  int original_node_count = ih->data->node_count;
+  /* We must change the node_count and let IUP resize its array as needed. */
+  ih->data->node_count += count_of_nodes_to_copy;
+  /* iupTreeIncCacheMem expects that the node_count contains the new size */
+  iupTreeIncCacheMem(ih);
 
-#if 0
-	for(size_t j=0; j<target_ih->data->node_count; j++)
-	{
-		NSLog(@"aft: node_cache[%zu]=0x%p, %@", j, &target_ih->data->node_cache[j], [(IupCocoaTreeItem*)(target_ih->data->node_cache[j].node_handle) title]);
-	}
-#endif
+  if(flat_index_source > flat_index_target) /* copying from a higher address to a lower */
+  {
+    int number_of_nodes_to_move_over = (original_node_count-1) - flat_index_target + 1; /* we add +1 because we are inserting before the target */
+    memmove(ih->data->node_cache+flat_index_target+count_of_nodes_to_copy, ih->data->node_cache+flat_index_target, number_of_nodes_to_move_over*sizeof(InodeData));
+    memmove(ih->data->node_cache+flat_index_target, ih->data->node_cache+flat_index_source+count_of_nodes_to_copy, count_of_nodes_to_copy*sizeof(InodeData));
+  }
+  else /* copying from a lower address to a higher */
+  {
+    int number_of_nodes_to_move_over = (original_node_count-1) - flat_index_source;
+    memmove(ih->data->node_cache+flat_index_target+count_of_nodes_to_copy, ih->data->node_cache+flat_index_target, number_of_nodes_to_move_over*sizeof(InodeData));
+    memmove(ih->data->node_cache+flat_index_target, ih->data->node_cache+flat_index_source, count_of_nodes_to_copy*sizeof(InodeData));
+  }
 
-	iupAttribSet(target_ih, "LASTADDNODE", NULL);
+  /* The mem-copies above created new nodes in the node_cache for our insertion, but their pointers to the node_handle point to the original objects instead of the new copies of the objects. */
+  /* So we need to go through those items, and change their node_handle pointers to point to the new copies of each object. */
+  NSArray<IupCocoaTreeItem*>* flattened_array_of_new_items = iupCocoaTreeCreateFlatItemArray(new_copy_tree_item);
+  int k=flat_index_target;
+  for(IupCocoaTreeItem* a_item in flattened_array_of_new_items)
+  {
+    ih->data->node_cache[k].node_handle = a_item;
+    k++;
+  }
 
+  iupAttribSet(ih, "LASTADDNODE", NULL);
 }
 
-static void helperMoveNode(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, IupCocoaTreeItem* parent_target_tree_item, NSInteger target_child_index)
+/* iupTreeCopyMoveCache doesn't work for Cocoa. */
+/* (See comments in iupCocoaTreeMoveCache for rationale.) */
+static void iupCocoaTreeCrossInsertCache(Ihandle* source_ih, Ihandle* target_ih, int flat_index_source, int flat_index_target, int count_of_nodes_to_copy, IupCocoaTreeItem* new_copy_tree_item)
 {
-	if(!tree_item)
-	{
-		return;
-	}
-	IupCocoaOutlineView* iup_outline_view = (IupCocoaOutlineView*)outline_view;
-	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	Ihandle* ih = [iup_outline_view ih];
-	
-	// These conversions don't work fully because of the sibling/child ambiguity.
-//	int id_dst = iupTreeFindNodeId(ih, (InodeHandle*)parent_target_tree_item) + (int)target_child_index;
-//	int id_src = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
-//	int id_new = id_dst+1; /* contains the position for a copy operation */
-	
-	
-//	int count_of_all_nodes = (int)Helper_CountAllItems(data_source_delegate);
-	int count_of_nodes_to_move = (int)Helper_RecursivelyCountItems(tree_item);
-	IupCocoaTreeItem* parent_tree_item  = [tree_item parentItem];
+  int original_node_count = target_ih->data->node_count;
+  /* We must change the node_count and let IUP resize its array as needed. */
+  target_ih->data->node_count += count_of_nodes_to_copy;
+  /* iupTreeIncCacheMem expects that the node_count contains the new size */
+  iupTreeIncCacheMem(target_ih);
 
-	NSUInteger object_index;
-	if(parent_tree_item)
-	{
-		object_index = [[parent_tree_item childrenArray] indexOfObject:tree_item];
+  int number_of_nodes_to_move_over = (original_node_count-1) - flat_index_target + 1; /* we add +1 because we are inserting before the target */
 
-	}
-	else
-	{
-		object_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:tree_item];
-	}
-	
-	// IUP doc:
-	// If the destination node is a branch and it is expanded,
-	// then the specified node is inserted as the first child of the destination node.
-	// If the branch is not expanded or the destination node is a leaf,
-	// then it is inserted as the next brother of the leaf.
-	
-	// Me: I don't think this works for Cocoa because the NSOutlineView allows the user direct control over insertion points that distinguish between sibling and child.
-	// I don't think it is possible to conform to the IUP doc, nor do I think it would be a good idea even if we could because it would break native behavior users expect on Cocoa.
-	
-	
-	NSInteger adjusted_index = target_child_index;
+  memmove(target_ih->data->node_cache+flat_index_target+count_of_nodes_to_copy, target_ih->data->node_cache+flat_index_target, number_of_nodes_to_move_over*sizeof(InodeData));
+  memcpy(target_ih->data->node_cache+flat_index_target, source_ih->data->node_cache+flat_index_source, count_of_nodes_to_copy*sizeof(InodeData));
 
-	// NSLog(@"parent_tree: %@, parent_target: %@", [parent_tree_item title], [parent_target_tree_item title]);
+  /* The mem-copies above created new nodes in the node_cache for our insertion, but their pointers to the node_handle point to the original objects instead of the new copies of the objects. */
+  /* So we need to go through those items, and change their node_handle pointers to point to the new copies of each object. */
+  NSArray<IupCocoaTreeItem*>* flattened_array_of_new_items = iupCocoaTreeCreateFlatItemArray(new_copy_tree_item);
+  int k=flat_index_target;
+  for(IupCocoaTreeItem* a_item in flattened_array_of_new_items)
+  {
+    target_ih->data->node_cache[k].node_handle = a_item;
+    k++;
+  }
 
-	// If the node is being moved under the same immediate parent,
-	// we need to subtract 1 if
-	// the current placement of the node is earlier than the target.
-	// because the node's current placement counts against us
-	// and target_child_index is +1 too much.
-	if([parent_tree_item isEqual:parent_target_tree_item])
-	{
-		if(object_index < target_child_index)
-		{
-			adjusted_index = target_child_index - 1;
-		}
-	}
-	if(adjusted_index < 0)
-	{
-		adjusted_index = 0;
-	}
+  iupAttribSet(target_ih, "LASTADDNODE", NULL);
+}
 
-//NSLog(@"adjusted_index: %d, target_child_index: %d, object_index: %d", adjusted_index, target_child_index, object_index);
-//NSLog(@"tree_item: %@", [tree_item title]);
-//NSLog(@"parent_target_tree_item: %@", [parent_target_tree_item title]);
-//NSLog(@"parent_tree_item: %@", [parent_tree_item title]);
+static void helperMoveNode(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, IupCocoaTreeItem* parent_target_tree_item, NSInteger target_child_index)
+{
+  if(!tree_item)
+  {
+    return;
+  }
+  IupCocoaOutlineView* iup_outline_view = (IupCocoaOutlineView*)outline_view;
+  IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+  Ihandle* ih = [iup_outline_view ih];
 
-	// Quick exit if the user didn't actually change the location
-	if( (object_index == adjusted_index)
-		&& [parent_target_tree_item isEqual:parent_tree_item]
-	)
-	{
-		return;
-	}
+  int count_of_nodes_to_move = (int)Helper_RecursivelyCountItems(tree_item);
+  IupCocoaTreeItem* parent_tree_item  = [tree_item parentItem];
 
+  NSUInteger object_index;
+  if(parent_tree_item)
+  {
+    object_index = [[parent_tree_item childrenArray] indexOfObject:tree_item];
 
-	NSInteger flat_index_before = 0;
-	// This will get an index that is compatible with the node_cache
-	bool is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, tree_item, &flat_index_before);
-//	NSLog(@"flat_index_before: %d, is_found: %d", flat_index_before, is_found);
-	NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
+  }
+  else
+  {
+    object_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:tree_item];
+  }
 
-#if 0
-		{
-			NSArray* testarray = testValidateCocoaTreeCreateFlatItemArray(data_source_delegate);
-			int k=0;
-			for(IupCocoaTreeItem* a_item in testarray)
-			{
-				NSLog(@"bef DataSource: [%d] = %@", k, [a_item title]);
-				k++;
-			}
-		}
-#endif
+  NSInteger adjusted_index = target_child_index;
 
-	// update the data source
-	[data_source_delegate moveItem:tree_item targetParent:parent_target_tree_item targetChildIndex:adjusted_index];
-	[outline_view moveItemAtIndex:object_index inParent:parent_tree_item toIndex:adjusted_index inParent:parent_target_tree_item];
+  /* If the node is being moved under the same immediate parent, */
+  /* we need to subtract 1 if the current placement of the node is earlier than the target. */
+  /* because the node's current placement counts against us and target_child_index is +1 too much. */
+  if([parent_tree_item isEqual:parent_target_tree_item])
+  {
+    if(object_index < target_child_index)
+    {
+      adjusted_index = target_child_index - 1;
+    }
+  }
+  if(adjusted_index < 0)
+  {
+    adjusted_index = 0;
+  }
 
-#if 0
-		{
-			NSArray* testarray = testValidateCocoaTreeCreateFlatItemArray(data_source_delegate);
-			int k=0;
-			for(IupCocoaTreeItem* a_item in testarray)
-			{
-				NSLog(@"aft DataSource: [%d] = %@", k, [a_item title]);
-				k++;
-			}
-		}
-#endif
+  /* Quick exit if the user didn't actually change the location */
+  if( (object_index == adjusted_index)
+      && [parent_target_tree_item isEqual:parent_tree_item]
+    )
+  {
+    return;
+  }
 
-	NSInteger flat_index_after = 0;
-	// This will get an index that is compatible with the node_cache
-	is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, tree_item, &flat_index_after);
-//	NSLog(@"flat_index_after: %d, is_found: %d", flat_index_after, is_found);
-	NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
+  NSInteger flat_index_before = 0;
+  /* This will get an index that is compatible with the node_cache */
+  bool is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, tree_item, &flat_index_before);
+  NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
 
+  /* update the data source */
+  [data_source_delegate moveItem:tree_item targetParent:parent_target_tree_item targetChildIndex:adjusted_index];
+  [outline_view moveItemAtIndex:object_index inParent:parent_tree_item toIndex:adjusted_index inParent:parent_target_tree_item];
 
-	iupCocoaTreeMoveCache(ih, (int)flat_index_before, (int)flat_index_after, count_of_nodes_to_move);
-	
+  NSInteger flat_index_after = 0;
+  /* This will get an index that is compatible with the node_cache */
+  is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, tree_item, &flat_index_after);
+  NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
 
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-	testValidateCocoaTreeNodeCache(ih, data_source_delegate);
-#endif
 
+  iupCocoaTreeMoveCache(ih, (int)flat_index_before, (int)flat_index_after, count_of_nodes_to_move);
 }
 
 static void helperExpandedItemArrayRecursive(IupCocoaTreeItem* original_item, NSOutlineView* original_tree, NSMutableArray<NSNumber*>* expanded_info_array)
 {
-	if([original_tree isExpandable:original_item])
-	{
-		// BUG: Apple seems to return NO if a parent is collapsed, even if the actual item is expanded.
-		// But when Apple expands the parent, it remembers and restores the child state.
-		// This is a problem for us because we are trying to copy the state to apply to new copies of the node.
-		// I don't know how to workaround this.
-		// Tested 10.13.6
-		BOOL is_expanded = [original_tree isItemExpanded:original_item];
-		[expanded_info_array addObject:[NSNumber numberWithBool:is_expanded]];
-//		NSLog(@"%@ expand state is: %d", [original_item title], is_expanded);
-	}
-	else
-	{
-		[expanded_info_array addObject:[NSNumber numberWithBool:NO]];
-//		NSLog(@"%@ expand state is: %d", [original_item title], 0);
-	}
-	
-	NSArray* original_children_array = [original_item childrenArray];
-//	NSUInteger array_count = [original_children_array count];
+  if([original_tree isExpandable:original_item])
+  {
+    /* Note: Cocoa returns NO for expanded state if parent is collapsed, but restores child state when parent is expanded */
+    BOOL is_expanded = [original_tree isItemExpanded:original_item];
+    [expanded_info_array addObject:[NSNumber numberWithBool:is_expanded]];
+  }
+  else
+  {
+    [expanded_info_array addObject:[NSNumber numberWithBool:NO]];
+  }
 
-	for(IupCocoaTreeItem* a_item in original_children_array)
-	{
-		helperExpandedItemArrayRecursive(a_item, original_tree, expanded_info_array);
-	}
+  for(IupCocoaTreeItem* a_item in [original_item childrenArray])
+  {
+    helperExpandedItemArrayRecursive(a_item, original_tree, expanded_info_array);
+  }
 }
 
 static NSArray<NSNumber*>* helperExpandedItemArray(IupCocoaTreeItem* original_item, NSOutlineView* original_tree)
 {
-	NSMutableArray<NSNumber*>* expanded_info_array = [[[NSMutableArray alloc] init] autorelease];
-	helperExpandedItemArrayRecursive(original_item, original_tree, expanded_info_array);
-	return expanded_info_array;
+  NSMutableArray<NSNumber*>* expanded_info_array = [[[NSMutableArray alloc] init] autorelease];
+  helperExpandedItemArrayRecursive(original_item, original_tree, expanded_info_array);
+  return expanded_info_array;
 }
 
 static void helperSyncExpandedItemsRecursive(NSUInteger* in_out_current_index, NSArray<NSNumber*>* expanded_info_array, IupCocoaTreeItem* copy_item, NSOutlineView* copy_tree)
 {
-	NSNumber* is_expandable = [expanded_info_array objectAtIndex:*in_out_current_index];
-	if([copy_tree isExpandable:copy_item])
-	{
-//		NSLog(@"[%lu] %@ expand state is: %d", (unsigned long)*in_out_current_index, [copy_item title], [is_expandable boolValue]);
-		if([is_expandable boolValue])
-		{
-			[copy_tree expandItem:copy_item];
-		}
-		else
-		{
-			[copy_tree collapseItem:copy_item];
-		}
-	}
-	else
-	{
-//		NSLog(@"[%lu] %@ expand state is: %d", (unsigned long)*in_out_current_index, [copy_item title], 0);
-	}
+  NSNumber* is_expandable = [expanded_info_array objectAtIndex:*in_out_current_index];
+  if([copy_tree isExpandable:copy_item])
+  {
+    if([is_expandable boolValue])
+      [copy_tree expandItem:copy_item];
+    else
+      [copy_tree collapseItem:copy_item];
+  }
 
-	*in_out_current_index = *in_out_current_index+1;
+  *in_out_current_index = *in_out_current_index + 1;
 
-	NSArray* copy_children_array = [copy_item childrenArray];
-	NSUInteger array_count = [copy_children_array count];
+  NSArray* copy_children_array = [copy_item childrenArray];
+  for(IupCocoaTreeItem* next_copy_item in copy_children_array)
+  {
+    helperSyncExpandedItemsRecursive(in_out_current_index, expanded_info_array, next_copy_item, copy_tree);
+  }
+}
 
-	for(NSInteger i=0; i<array_count; i++)
-	{
-		IupCocoaTreeItem* next_copy_item = [copy_children_array objectAtIndex:i];
-		helperSyncExpandedItemsRecursive(in_out_current_index, expanded_info_array, next_copy_item, copy_tree);
-	}
-}
 static void helperSyncExpandedItems(NSArray<NSNumber*>* expanded_info_array, IupCocoaTreeItem* copy_item, NSOutlineView* copy_tree)
 {
-	NSUInteger current_index = 0;
-	helperSyncExpandedItemsRecursive(&current_index, expanded_info_array, copy_item, copy_tree);
+  NSUInteger current_index = 0;
+  helperSyncExpandedItemsRecursive(&current_index, expanded_info_array, copy_item, copy_tree);
 }
 
-// tree_item should be a copy
 static void helperCopyAndInsertNode(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, IupCocoaTreeItem* parent_target_tree_item, NSInteger target_child_index, NSTableViewAnimationOptions copy_insert_animation)
 {
-	if(!tree_item)
-	{
-		return;
-	}
-	IupCocoaOutlineView* iup_outline_view = (IupCocoaOutlineView*)outline_view;
-	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	Ihandle* ih = [iup_outline_view ih];
-	
-//	int id_src = iupTreeFindNodeId(ih, (InodeHandle*)parent_target_tree_item) + (int)target_child_index;
-//	int id_dst = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
-//	int id_new = id_dst+1; /* contains the position for a copy operation */
-//	int count_of_all_nodes = (int)Helper_CountAllItems(data_source_delegate);
+  if(!tree_item)
+  {
+    return;
+  }
+  IupCocoaOutlineView* iup_outline_view = (IupCocoaOutlineView*)outline_view;
+  IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+  Ihandle* ih = [iup_outline_view ih];
 
-	
-	
-	//IupCocoaTreeItem* new_copy_tree_item = [[IupCocoaTreeItem alloc] init];
-	IupCocoaTreeItem* new_copy_tree_item = [tree_item cloneWithNewParentItem:parent_target_tree_item ihandle:ih];
-		// If the destination node is a branch and it is expanded,
-	// then the specified node is inserted as the first child of the destination node.
-	// If the branch is not expanded or the destination node is a leaf,
-	// then it is inserted as the next brother of the leaf.
-	
-//	BOOL is_target_expanded = NO;
-//	int target_kind = [target_tree_item kind];
-	
-	// Unlike move, we don't seem to need to subtract 1.
-//	NSInteger adjusted_index = target_child_index - 1;
-	NSInteger adjusted_index = target_child_index;
-	if(adjusted_index < 0)
-	{
-		adjusted_index = 0;
-	}
-	
-	
-	// Save the expanded information for the tree_item so we can later apply it to the copies.
-	// We need to do this now because if we insert a copy into the tree_item as a child, they will be out-of-sync.
-	NSArray<NSNumber*>* array_of_expanded_info = helperExpandedItemArray(tree_item, outline_view);
-	
-	NSInteger flat_index_source = 0;
-	// This will get an index that is compatible with the node_cache
-	bool is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, tree_item, &flat_index_source);
-//	NSLog(@"flat_index_before: %d, is_found: %d", flat_index_before, is_found);
-	NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
-	
-	// update the data source
-	[data_source_delegate insertChild:new_copy_tree_item withParent:parent_target_tree_item targetChildIndex:adjusted_index];
+  IupCocoaTreeItem* new_copy_tree_item = [tree_item cloneWithNewParentItem:parent_target_tree_item ihandle:ih];
 
-	// directly update the outlineview so we don't have to reloadData
-	NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:adjusted_index];
-	[outline_view insertItemsAtIndexes:index_set inParent:parent_target_tree_item withAnimation:copy_insert_animation];
-	
-	// Make the new copy match the expanded structure of the original since the Cocoa NSOutlineView is so visual and live-drags.
-	// Anything else just looks wrong.
-	// I think IUP has slightly different rules, but I think this is the right thing to do for Cocoa.
-	helperSyncExpandedItems(array_of_expanded_info, new_copy_tree_item, outline_view);
-	
-	
-	NSInteger flat_index_target = 0;
-	// This will get an index that is compatible with the node_cache
-	is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, new_copy_tree_item, &flat_index_target);
-//	NSLog(@"flat_index_after: %d, is_found: %d", flat_index_after, is_found);
-	NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
+  NSInteger adjusted_index = target_child_index;
+  if(adjusted_index < 0)
+  {
+    adjusted_index = 0;
+  }
 
-	
-	int count_of_nodes_to_copy = (int)Helper_RecursivelyCountItems(new_copy_tree_item);
-	
-//	iupTreeCopyMoveCache(ih, id_src, id_new, count_of_new_nodes, true);
-	iupCocoaTreeCopyCache(ih, (int)flat_index_source, (int)flat_index_target, count_of_nodes_to_copy, new_copy_tree_item);
+  /* Save the expanded information for the tree_item so we can later apply it to the copies. */
+  /* We need to do this now because if we insert a copy into the tree_item as a child, they will be out-of-sync. */
+  NSArray<NSNumber*>* array_of_expanded_info = helperExpandedItemArray(tree_item, outline_view);
 
-	
-	
-//	cocoaTreeRebuildNodeCache(ih, id_new, tree_item);
-	
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-	testValidateCocoaTreeNodeCache(ih, data_source_delegate);
-#endif
+  NSInteger flat_index_source = 0;
+  /* This will get an index that is compatible with the node_cache */
+  bool is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, tree_item, &flat_index_source);
+  NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
 
+  /* update the data source */
+  [data_source_delegate insertChild:new_copy_tree_item withParent:parent_target_tree_item targetChildIndex:adjusted_index];
 
+  /* directly update the outlineview so we don't have to reloadData */
+  NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:adjusted_index];
+  [outline_view insertItemsAtIndexes:index_set inParent:parent_target_tree_item withAnimation:copy_insert_animation];
+
+  /* Make the new copy match the expanded structure of the original since the Cocoa NSOutlineView is so visual and live-drags. */
+  /* Anything else just looks wrong. */
+  /* I think IUP has slightly different rules, but I think this is the right thing to do for Cocoa. */
+  helperSyncExpandedItems(array_of_expanded_info, new_copy_tree_item, outline_view);
+
+
+  NSInteger flat_index_target = 0;
+  /* This will get an index that is compatible with the node_cache */
+  is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, new_copy_tree_item, &flat_index_target);
+  NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
+
+  int count_of_nodes_to_copy = (int)Helper_RecursivelyCountItems(new_copy_tree_item);
+
+  iupCocoaTreeCopyCache(ih, (int)flat_index_source, (int)flat_index_target, count_of_nodes_to_copy, new_copy_tree_item);
+
+  [new_copy_tree_item release];
 }
 
-// tree_item should be a copy
 static void helperCrossCopyNode(NSOutlineView* source_outline_view, IupCocoaTreeItem* source_tree_item, NSOutlineView* target_outline_view, IupCocoaTreeItem* parent_target_tree_item, NSInteger target_child_index, NSTableViewAnimationOptions copy_insert_animation)
 {
-	if(!source_tree_item)
-	{
-		return;
-	}
-	IupCocoaOutlineView* iup_source_outline_view = (IupCocoaOutlineView*)source_outline_view;
-	IupCocoaTreeDelegate* source_data_delegate = (IupCocoaTreeDelegate*)[source_outline_view dataSource];
-	Ihandle* source_ih = [iup_source_outline_view ih];
-	
-	IupCocoaOutlineView* iup_target_outline_view = (IupCocoaOutlineView*)target_outline_view;
-	IupCocoaTreeDelegate* target_data_delegate = (IupCocoaTreeDelegate*)[target_outline_view dataSource];
-	Ihandle* target_ih = [iup_target_outline_view ih];
-	
-	
-	//IupCocoaTreeItem* new_copy_tree_item = [[IupCocoaTreeItem alloc] init];
-	IupCocoaTreeItem* new_copy_tree_item = [source_tree_item cloneWithNewParentItem:parent_target_tree_item ihandle:target_ih];
-		// If the destination node is a branch and it is expanded,
-	// then the specified node is inserted as the first child of the destination node.
-	// If the branch is not expanded or the destination node is a leaf,
-	// then it is inserted as the next brother of the leaf.
-	
-//	BOOL is_target_expanded = NO;
-//	int target_kind = [target_tree_item kind];
-	
-	// Save the expanded information for the tree_item so we can later apply it to the copies.
-	// We need to do this now because if we insert a copy into the tree_item as a child, they will be out-of-sync.
-	NSArray<NSNumber*>* array_of_expanded_info = helperExpandedItemArray(source_tree_item, source_outline_view);
-	
-	
-	// Special edge case: the target outlineview is completely empty.
-	if((-1 == target_child_index)
-		&& (nil == parent_target_tree_item)
-		&& (0 == [[target_data_delegate treeRootTopLevelObjects] count])
-	)
-	{
-		//  add the new node at root
-		[target_data_delegate insertAtRoot:new_copy_tree_item];
-//		[outline_view insertItemsAtIndexes:[NSIndexSet indexSetWithIndex:0] inParent:nil withAnimation:NSTableViewAnimationEffectNone];
-		[iup_target_outline_view insertItemsAtIndexes:[NSIndexSet indexSetWithIndex:0] inParent:nil withAnimation:NSTableViewAnimationEffectGap];
-	}
-	else // normal case
-	{
-		
-		// Unlike move, we don't seem to need to subtract 1.
-	//	NSInteger adjusted_index = target_child_index - 1;
-		NSInteger adjusted_index = target_child_index;
-		if(adjusted_index < 0)
-		{
-			adjusted_index = 0;
-		}
-		
-		// update the data source
-		[target_data_delegate insertChild:new_copy_tree_item withParent:parent_target_tree_item targetChildIndex:adjusted_index];
+  if(!source_tree_item)
+    return;
 
-		// directly update the outlineview so we don't have to reloadData
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:adjusted_index];
-		[target_outline_view insertItemsAtIndexes:index_set inParent:parent_target_tree_item withAnimation:copy_insert_animation];
-	
-	}
-	
+  IupCocoaOutlineView* iup_source_outline_view = (IupCocoaOutlineView*)source_outline_view;
+  IupCocoaTreeDelegate* source_data_delegate = (IupCocoaTreeDelegate*)[source_outline_view dataSource];
+  Ihandle* source_ih = [iup_source_outline_view ih];
 
-//	NSInteger flat_index_source = 0;
-	// This will get an index that is compatible with the node_cache
-//	bool is_found = Helper_FindFlatIndexofTreeItemInOutlineView(data_source_delegate, tree_item, &flat_index_source);
-//	NSLog(@"flat_index_before: %d, is_found: %d", flat_index_before, is_found);
-//	NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
-	
+  IupCocoaOutlineView* iup_target_outline_view = (IupCocoaOutlineView*)target_outline_view;
+  IupCocoaTreeDelegate* target_data_delegate = (IupCocoaTreeDelegate*)[target_outline_view dataSource];
+  Ihandle* target_ih = [iup_target_outline_view ih];
 
-	// Make the new copy match the expanded structure of the original since the Cocoa NSOutlineView is so visual and live-drags.
-	// Anything else just looks wrong.
-	// I think IUP has slightly different rules, but I think this is the right thing to do for Cocoa.
-	helperSyncExpandedItems(array_of_expanded_info, new_copy_tree_item, target_outline_view);
-	
-	
-	NSInteger flat_index_target = 0;
-	// This will get an index that is compatible with the node_cache
-	bool is_found = Helper_FindFlatIndexofTreeItemInOutlineView(target_data_delegate, new_copy_tree_item, &flat_index_target);
-//	NSLog(@"flat_index_after: %d, is_found: %d", flat_index_after, is_found);
-	NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
-	
-	NSInteger flat_index_source = 0;
-	// This will get an index that is compatible with the node_cache
-	is_found = Helper_FindFlatIndexofTreeItemInOutlineView(source_data_delegate, source_tree_item, &flat_index_source);
-//	NSLog(@"flat_index_after: %d, is_found: %d", flat_index_after, is_found);
-	NSCAssert(is_found, @"Internal error: Could not find moved node in outline view");
-	
-	int count_of_nodes_to_copy = (int)Helper_RecursivelyCountItems(new_copy_tree_item);
-	
+  IupCocoaTreeItem* new_copy_tree_item = [source_tree_item cloneWithNewParentItem:parent_target_tree_item ihandle:target_ih];
 
-	iupCocoaTreeCrossInsertCache(source_ih, target_ih, (int)flat_index_source, (int)flat_index_target, count_of_nodes_to_copy, new_copy_tree_item);
+  /* Save expanded state before inserting to maintain visual consistency */
+  NSArray<NSNumber*>* array_of_expanded_info = helperExpandedItemArray(source_tree_item, source_outline_view);
 
-	
-//	cocoaTreeRebuildNodeCache(ih, id_new, tree_item);
-	
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-	testValidateCocoaTreeNodeCache(target_ih, target_data_delegate);
-#endif
+  /* Handle empty target tree special case */
+  if((-1 == target_child_index) && (nil == parent_target_tree_item) && (0 == [[target_data_delegate treeRootTopLevelObjects] count]))
+  {
+    [target_data_delegate insertAtRoot:new_copy_tree_item];
+    [iup_target_outline_view insertItemsAtIndexes:[NSIndexSet indexSetWithIndex:0] inParent:nil withAnimation:NSTableViewAnimationEffectGap];
+  }
+  else
+  {
+    NSInteger adjusted_index = target_child_index;
+    if(adjusted_index < 0)
+      adjusted_index = 0;
 
+    [target_data_delegate insertChild:new_copy_tree_item withParent:parent_target_tree_item targetChildIndex:adjusted_index];
 
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:adjusted_index];
+    [target_outline_view insertItemsAtIndexes:index_set inParent:parent_target_tree_item withAnimation:copy_insert_animation];
+  }
+
+  /* Apply saved expanded state to maintain visual appearance */
+  helperSyncExpandedItems(array_of_expanded_info, new_copy_tree_item, target_outline_view);
+
+  NSInteger flat_index_target = 0;
+  bool is_found = Helper_FindFlatIndexofTreeItemInOutlineView(target_data_delegate, new_copy_tree_item, &flat_index_target);
+  NSCAssert(is_found, @"Internal error: Could not find copied node in outline view");
+
+  NSInteger flat_index_source = 0;
+  is_found = Helper_FindFlatIndexofTreeItemInOutlineView(source_data_delegate, source_tree_item, &flat_index_source);
+  NSCAssert(is_found, @"Internal error: Could not find source node in outline view");
+
+  int count_of_nodes_to_copy = (int)Helper_RecursivelyCountItems(new_copy_tree_item);
+
+  iupCocoaTreeCrossInsertCache(source_ih, target_ih, (int)flat_index_source, (int)flat_index_target, count_of_nodes_to_copy, new_copy_tree_item);
+
+  [new_copy_tree_item release];
 }
 
 static IupCocoaTreeItem* helperRecursiveIsPointerValid(intptr_t look_for_pointer, IupCocoaTreeItem* current_item)
 {
-	if(look_for_pointer == (intptr_t)current_item)
-	{
-		return current_item;
-	}
-	
-	for(IupCocoaTreeItem* a_item in [current_item childrenArray])
-	{
-		IupCocoaTreeItem* is_found = helperRecursiveIsPointerValid(look_for_pointer, a_item);
-		if(is_found)
-		{
-			return is_found;
-		}
-	}
-	return NULL;
+  if(look_for_pointer == (intptr_t)current_item)
+    return current_item;
+
+  for(IupCocoaTreeItem* a_item in [current_item childrenArray])
+  {
+    IupCocoaTreeItem* is_found = helperRecursiveIsPointerValid(look_for_pointer, a_item);
+    if(is_found)
+      return is_found;
+  }
+  return NULL;
 }
 
 static IupCocoaTreeItem* helperIsPointerValid(intptr_t look_for_pointer, IupCocoaTreeDelegate* tree_delegate)
 {
-	for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
-	{
-		IupCocoaTreeItem* is_found = helperRecursiveIsPointerValid(look_for_pointer, tree_item);
-		if(is_found)
-		{
-			return is_found;
-		}
-	}
-	return NULL;
+  for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
+  {
+    IupCocoaTreeItem* is_found = helperRecursiveIsPointerValid(look_for_pointer, tree_item);
+    if(is_found)
+      return is_found;
+  }
+  return NULL;
 }
 
-// need forward declaration
+/* Need forward declaration */
 static void cocoaTreeRemoveNodeData(Ihandle* ih, IupCocoaTreeItem* tree_item, int call_cb);
-- (BOOL) outlineView:(NSOutlineView*)outline_view acceptDrop:(id <NSDraggingInfo>)drag_info item:(id)parent_target_tree_item childIndex:(NSInteger)target_child_index
+
+- (BOOL) outlineView:(NSOutlineView *)outline_view acceptDrop:(id <NSDraggingInfo>)drag_info item:(id)parent_target_tree_item childIndex:(NSInteger)target_child_index
 {
-//NSLog(@"%@", NSStringFromSelector(_cmd));
+  if([drag_info draggingSource] == outline_view)
+  {
+    /* Same tree drag and drop */
+    [self setItemBeingDragged:nil];
 
-	if([drag_info draggingSource] == outline_view)
-	{
-		[self setItemBeingDragged:nil];
-		
-		NSPasteboard* paste_board = [drag_info draggingPasteboard];
-		NSData* data_value = [paste_board dataForType:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE];
-		if(nil == data_value)
-		{
-			return NO;
-		}
-		
-	//	NSValue* pointer_value = [NSKeyedUnarchiver unarchiveObjectWithData:data_value];
-	//	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)[pointer_value pointerValue];
+    NSPasteboard* paste_board = [drag_info draggingPasteboard];
+    NSData* data_value = [paste_board dataForType:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE];
+    if(nil == data_value)
+    {
+      return NO;
+    }
 
-		intptr_t decoded_integer;
-		[data_value getBytes:&decoded_integer length:sizeof(intptr_t)];
+    intptr_t decoded_integer;
+    [data_value getBytes:&decoded_integer length:sizeof(intptr_t)];
 
-		// Could be a wild pointer at this point?
-		// We can iterate through all the nodes to find it if we need to be extra safe.
-	//	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)decoded_integer;
-		IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-		IupCocoaTreeItem* tree_item = helperIsPointerValid(decoded_integer, data_source_delegate);
-		if(nil == tree_item)
-		{
-			return NO;
-		}
+    IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+    IupCocoaTreeItem* tree_item = helperIsPointerValid(decoded_integer, data_source_delegate);
+    if(nil == tree_item)
+    {
+      return NO;
+    }
 
+    if(target_child_index == NSOutlineViewDropOnItemIndex)
+    {
+      target_child_index = 0;
+    }
 
-		// NOTE: Apple has this in their example. I still don't understand what this does.
-		// If it was a drop "on", then we add it at the start
-		if(target_child_index == NSOutlineViewDropOnItemIndex)
-		{
-			target_child_index = 0;
-		}
-		[outline_view beginUpdates];
+    [outline_view beginUpdates];
 
+    IupCocoaTreeItem* new_tree_item = nil;
 
-		// Are we copying the data or moving something?
-		if([drag_info draggingSourceOperationMask] == NSDragOperationCopy)
-		{
-			// Yes, this is an insert from the pasteboard (even if it is a copy of itemBeingDragged)
-			helperCopyAndInsertNode((IupCocoaOutlineView*)outline_view, tree_item, parent_target_tree_item, target_child_index, NSTableViewAnimationEffectGap);
-		}
-		else
-		{
-			helperMoveNode((IupCocoaOutlineView*)outline_view, tree_item, parent_target_tree_item, target_child_index);
-		}
+    if([drag_info draggingSourceOperationMask] == NSDragOperationCopy)
+    {
+      helperCopyAndInsertNode((IupCocoaOutlineView*)outline_view, tree_item, parent_target_tree_item, target_child_index, NSTableViewAnimationEffectGap);
+      new_tree_item = parent_target_tree_item ? [[parent_target_tree_item childrenArray] objectAtIndex:target_child_index] : [[data_source_delegate treeRootTopLevelObjects] objectAtIndex:target_child_index];
+    }
+    else
+    {
+      NSInteger item_row_before = [outline_view rowForItem:tree_item];
+      helperMoveNode((IupCocoaOutlineView*)outline_view, tree_item, parent_target_tree_item, target_child_index);
+      new_tree_item = tree_item;
+    }
 
-		[outline_view endUpdates];
+    [outline_view endUpdates];
 
-		return YES;
-	
-	}
-	// For dragging between two different NSOutlineViews
-	else
-	{
-		NSPasteboard* paste_board = [drag_info draggingPasteboard];
-		NSData* data_value = [paste_board dataForType:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE];
-		if(nil == data_value)
-		{
-			return NO;
-		}
-	
-	//	NSValue* pointer_value = [NSKeyedUnarchiver unarchiveObjectWithData:data_value];
-	//	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)[pointer_value pointerValue];
+    /* Update selection and focus for the new item */
+    if (new_tree_item)
+    {
+      IupCocoaOutlineView* iup_outline_view = (IupCocoaOutlineView*)outline_view;
+      Ihandle* ih = [iup_outline_view ih];
+      NSInteger new_row = [outline_view rowForItem:new_tree_item];
 
-		intptr_t decoded_integer;
-		[data_value getBytes:&decoded_integer length:sizeof(intptr_t)];
+      if (new_row >= 0)
+      {
+        /* Clear all selections */
+        iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+        [outline_view deselectAll:nil];
 
+        /* Select the new item */
+        NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_row];
+        [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
 
-		// FIXME: Because I'm using raw pointers, this won't work for dragging between two different NSOutlineViews from two different IUP-based programs.
-		// To fix this, I need to properly implement serialization/deserialization of IupCocoaTreeItem.
-		IupCocoaTreeDragDropDelegate* source_data_source_delegate = (IupCocoaTreeDragDropDelegate*)[[drag_info draggingSource] dataSource];
+        /* Scroll to make it visible */
+        [outline_view scrollRowToVisible:new_row];
 
-		[self setItemBeingDragged:nil];
-		[source_data_source_delegate setItemBeingDragged:nil];
+        iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+      }
+    }
 
-		IupCocoaTreeItem* tree_item = helperIsPointerValid(decoded_integer, source_data_source_delegate);
-		if(nil == tree_item)
-		{
-			return NO;
-		}
+    return YES;
+  }
+  else
+  {
+    /* Cross-tree drag and drop */
+    NSPasteboard* paste_board = [drag_info draggingPasteboard];
+    NSData* data_value = [paste_board dataForType:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE];
+    if(nil == data_value)
+    {
+      return NO;
+    }
 
+    intptr_t decoded_integer;
+    [data_value getBytes:&decoded_integer length:sizeof(intptr_t)];
 
-/*
-		// NOTE: Apple has this in their example. I still don't understand what this does.
-		// If it was a drop "on", then we add it at the start
-		// UPDATE: I need -1 to tell me when the user drags onto an empty outlineview.
-		// NSOutlineViewDropOnItemIndex is -1.
-		// So I am not going to use this code for now.
-		// If I need it, then I need to do a check on the target data source to see if it is empty first.
-		// parent_target_tree_item is also nil in this case.
-		if(target_child_index == NSOutlineViewDropOnItemIndex)
-		{
-			target_child_index = 0;
-		}
-*/
+    IupCocoaTreeDragDropDelegate* source_data_source_delegate = (IupCocoaTreeDragDropDelegate*)[[drag_info draggingSource] dataSource];
 
-		// Are we copying the data or moving something?
-		if([drag_info draggingSourceOperationMask] == NSDragOperationCopy)
-		{
-			// Yes, this is an insert from the pasteboard (even if it is a copy of itemBeingDragged)
-			[outline_view beginUpdates];
-			helperCrossCopyNode([drag_info draggingSource], tree_item, outline_view, parent_target_tree_item, target_child_index, NSTableViewAnimationEffectGap);
-			[outline_view endUpdates];
-			
-			
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-	IupCocoaOutlineView* iup_outline_view = (IupCocoaOutlineView*)outline_view;
-	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	Ihandle* ih = [iup_outline_view ih];
-	testValidateCocoaTreeNodeCache(ih, data_source_delegate);
-#endif
-		}
-		else
-		{
-			[outline_view beginUpdates];
-//			helperCopyAndInsertNode((IupCocoaOutlineView*)outline_view, tree_item, parent_target_tree_item, target_child_index, NSTableViewAnimationEffectGap);
-			helperCrossCopyNode([drag_info draggingSource], tree_item, outline_view, parent_target_tree_item, target_child_index, NSTableViewAnimationEffectGap);
-			[outline_view endUpdates];
+    [self setItemBeingDragged:nil];
+    [source_data_source_delegate setItemBeingDragged:nil];
 
-			// remove node from source outlineview
-			NSOutlineView* source_outline_view = [drag_info draggingSource];
-			IupCocoaOutlineView* source_iup_outline_view = (IupCocoaOutlineView*)source_outline_view;
-			Ihandle* source_ih = [source_iup_outline_view ih];
+    IupCocoaTreeItem* tree_item = helperIsPointerValid(decoded_integer, source_data_source_delegate);
+    if(nil == tree_item)
+    {
+      return NO;
+    }
 
-			[source_iup_outline_view beginUpdates];
-	
-			cocoaTreeRemoveNodeData(source_ih, tree_item, 0);
-			NSUInteger target_index = [source_data_source_delegate removeItem:tree_item];
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:target_index];
-//			[source_iup_outline_view removeItemsAtIndexes:index_set inParent:[tree_item parentItem] withAnimation:NSTableViewAnimationEffectNone];
-//			[source_iup_outline_view removeItemsAtIndexes:index_set inParent:[tree_item parentItem] withAnimation:NSTableViewAnimationEffectFade];
-			[source_iup_outline_view removeItemsAtIndexes:index_set inParent:[tree_item parentItem] withAnimation:NSTableViewAnimationEffectGap];
+    NSOutlineView* source_outline_view = (NSOutlineView*)[drag_info draggingSource];
+    IupCocoaOutlineView* source_iup_outline_view = (IupCocoaOutlineView*)source_outline_view;
+    Ihandle* source_ih = [source_iup_outline_view ih];
 
-			// removeItem: doesn't seem to update. Need to call reloadData.
-//			[source_iup_outline_view reloadData];
+    IupCocoaOutlineView* dest_iup_outline_view = (IupCocoaOutlineView*)outline_view;
+    Ihandle* dest_ih = [dest_iup_outline_view ih];
 
-			[source_iup_outline_view endUpdates];
-			
+    IFniiii cbDragDrop = (IFniiii)IupGetCallback(dest_ih, "DRAGDROP_CB");
+    if (cbDragDrop)
+    {
+      int source_id = iupTreeFindNodeId(source_ih, (InodeHandle*)tree_item);
+      int dest_id = parent_target_tree_item ? iupTreeFindNodeId(dest_ih, (InodeHandle*)parent_target_tree_item) : 0;
+      int is_shift = 0;
+      int is_ctrl = ([drag_info draggingSourceOperationMask] == NSDragOperationCopy) ? 1 : 0;
 
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-	testValidateCocoaTreeNodeCache(source_ih, source_data_source_delegate);
-	
-	IupCocoaOutlineView* target_iup_outline_view = (IupCocoaOutlineView*)outline_view;
-	IupCocoaTreeDelegate* target_data_source_delegate = (IupCocoaTreeDelegate*)[target_iup_outline_view dataSource];
-	Ihandle* target_ih = [target_iup_outline_view ih];
-	testValidateCocoaTreeNodeCache(target_ih, target_data_source_delegate);
-#endif
-		}
+      if (cbDragDrop(dest_ih, source_id, dest_id, is_shift, is_ctrl) != IUP_CONTINUE)
+      {
+        return NO;
+      }
+    }
 
+    BOOL is_copy = ([drag_info draggingSourceOperationMask] == NSDragOperationCopy);
+    IupCocoaTreeItem* new_tree_item = nil;
 
-		return YES;
-	
-	}
+    [outline_view beginUpdates];
+    helperCrossCopyNode(source_outline_view, tree_item, outline_view, parent_target_tree_item, target_child_index, NSTableViewAnimationEffectGap);
+    [outline_view endUpdates];
+
+    /* Get the newly created item */
+    IupCocoaTreeDelegate* dest_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+    if ((-1 == target_child_index) && (nil == parent_target_tree_item) && (0 < [[dest_delegate treeRootTopLevelObjects] count]))
+    {
+      new_tree_item = [[dest_delegate treeRootTopLevelObjects] objectAtIndex:0];
+    }
+    else
+    {
+      NSInteger adjusted_index = target_child_index;
+      if (adjusted_index < 0)
+        adjusted_index = 0;
+
+      new_tree_item = parent_target_tree_item ? [[parent_target_tree_item childrenArray] objectAtIndex:adjusted_index] : [[dest_delegate treeRootTopLevelObjects] objectAtIndex:adjusted_index];
+    }
+
+    /* Update selection and focus for the new item in destination tree */
+    if (new_tree_item)
+    {
+      NSInteger new_row = [outline_view rowForItem:new_tree_item];
+
+      if (new_row >= 0)
+      {
+        iupAttribSet(dest_ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+        [outline_view deselectAll:nil];
+
+        NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_row];
+        [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+
+        [outline_view scrollRowToVisible:new_row];
+
+        iupAttribSet(dest_ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+      }
+    }
+
+    if (!is_copy)
+    {
+      /* Remove node from source tree for move operation */
+      [source_iup_outline_view beginUpdates];
+
+      cocoaTreeRemoveNodeData(source_ih, tree_item, 1);
+      NSUInteger target_index = [source_data_source_delegate removeItem:tree_item];
+      NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:target_index];
+      [source_iup_outline_view removeItemsAtIndexes:index_set inParent:[tree_item parentItem] withAnimation:NSTableViewAnimationEffectGap];
+
+      [source_iup_outline_view endUpdates];
+    }
+
+    return YES;
+  }
 }
 
-@end // IupCocoaTreeDragDropDelegate
+@end /* IupCocoaTreeDragDropDelegate */
 
 /*****************************************************************************/
 /* ADDING ITEMS                                                              */
 /*****************************************************************************/
 
-static void cocoaTreeReloadItem(IupCocoaTreeItem* tree_item, NSOutlineView* outline_view)
+/* This replicates the functionality of the internal static iTreeAddToCache from iup_tree.c, */
+/* but allows specifying the exact insertion ID. */
+static void cocoaTreeInsertInCache(Ihandle* ih, int id, InodeHandle* node_handle)
 {
-	NSOperatingSystemVersion macosx_1012 = { 10, 12, 0 };
-	
-	// isOperatingSystemAtLeastVersion officially requires 10.10+, but seems available on 10.9
-	if([[NSProcessInfo processInfo] isOperatingSystemAtLeastVersion:macosx_1012])
-	{
-		// Starting in 10.12, reloadItem: was fixed to do the right thing. Must link to 10.12 SDK or higher (which you should always link to the lastest on Mac anyway)
-		[outline_view reloadItem:tree_item];
-	}
-	else
-	{
-//		[outline_view reloadData];
-		NSInteger row_index = [outline_view rowForItem:tree_item];
-		NSIndexSet* row_index_set = [NSIndexSet indexSetWithIndex:row_index];
-		NSIndexSet* column_index_set = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, [outline_view numberOfColumns])];
-		[outline_view reloadDataForRowIndexes:row_index_set columnIndexes:column_index_set];
-	}
+  /* iupTreeIncCacheMem must have been called before, and node_count incremented. */
+
+  /* Ensure id is valid within the new count. */
+  if (id < 0 || id >= ih->data->node_count)
+  {
+    /* Should not happen if called correctly. */
+    return;
+  }
+
+  if (id < ih->data->node_count - 1) /* If not adding at the very end */
+  {
+    /* open space for the new id */
+    /* Calculate the number of existing elements that need to be moved. */
+    /* Old count was ih->data->node_count - 1. */
+    /* We move elements from index 'id' up to 'old_count - 1'. */
+    int remain_count = (ih->data->node_count - 1) - id;
+
+    if (remain_count > 0)
+    {
+      /* Shift existing elements to the right by one position. */
+      memmove(ih->data->node_cache+id+1, ih->data->node_cache+id, remain_count*sizeof(InodeData));
+    }
+  }
+
+  /* Insert the new node handle and clear userdata. */
+  ih->data->node_cache[id].node_handle = node_handle;
+  ih->data->node_cache[id].userdata = NULL;
 }
 
 void iupdrvTreeAddNode(Ihandle* ih, int prev_id, int kind, const char* title, int add)
 {
-/*
- 
- id is the number identifier of a reference node, the reference node is used to position the new node.
- 
- kind is the new node type, if it is a branch or a leaf.
- 
- add means appending a node at the end of the branch, if 0 means inserting the node in the branch
- 
- If the reference node exists then
- if (reference node is a branch and appending)
- insert the new node after the reference node, as first child
- else
- insert the new node after reference node
- else
- add the new node at root
-*/
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	
-	
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
-	
-	
-	InodeHandle* inode_prev = iupTreeGetNode(ih, prev_id);
-	
+  InodeHandle* inode_prev = iupTreeGetNode(ih, prev_id);
 
-	/* the previous node is not necessary only
-	 if adding the root in an empty tree or before the root. */
-	// UPDATE: This check is breaking things for me.
-/*
-	if (!inode_prev && prev_id!=-1)
-	{
-		return;
-	}
-*/
+  if (!inode_prev && prev_id != -1)
+    return;
 
-	if (!title)
-	{
-		title = "";
-	}
-	
+  if (!title)
+    title = "";
 
-	
-	IupCocoaTreeItem* tree_item_new = [[IupCocoaTreeItem alloc] init];
-	[tree_item_new setKind:kind];
-	NSString* ns_title = [NSString stringWithUTF8String:title];
-	[tree_item_new setTitle:ns_title];
-//	InodeHandle* inode_new = (InodeHandle*)calloc(1, sizeof(InodeHandle));
-	InodeHandle* inode_new = (InodeHandle*)tree_item_new; // NOTE: retain count is 1 from alloc. We are not going to retain it again.
-	
-	//  If the reference node exists then
-	if(inode_prev)
-	{
-		IupCocoaTreeItem* tree_item_prev = inode_prev;
-		int kind_prev = [tree_item_prev kind];
-	
-		
-		// if (reference node is a branch and appending)
-		if((ITREE_BRANCH == kind_prev) && (1 == add))
-		{
-			// insert the new node after the reference node, as first child
-			/* depth+1 */
-			// IUP always inserts the child in the first position, not the last
-			// update the data source
-			NSUInteger target_index = [data_source_delegate insertChild:tree_item_new withParent:tree_item_prev];
+  IupCocoaTreeItem* tree_item_new = [[IupCocoaTreeItem alloc] init];
+  [tree_item_new setKind:kind];
+  NSString* ns_title = [NSString stringWithUTF8String:title];
+  [tree_item_new setTitle:ns_title];
 
-			// directly update the outlineview so we don't have to reloadData
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:target_index];
-//			[outline_view insertItemsAtIndexes:index_set inParent:tree_item_prev withAnimation:NSTableViewAnimationEffectNone];
-			[outline_view insertItemsAtIndexes:index_set inParent:tree_item_prev withAnimation:NSTableViewAnimationEffectGap];
+  IupCocoaTreeToggleReceiver* toggle_receiver = [[IupCocoaTreeToggleReceiver alloc] init];
+  [toggle_receiver setIhandle:ih];
+  [toggle_receiver setTreeItem:tree_item_new];
+  [tree_item_new setToggleReceiver:toggle_receiver];
+  [toggle_receiver release];
 
-		}
-		else
-		{
-			// insert the new node after reference node
-			/* same depth */
-			
-			// update the data source
-			NSUInteger target_index = [data_source_delegate insertPeer:tree_item_new withSibling:tree_item_prev];
+  InodeHandle* inode_new = (InodeHandle*)tree_item_new;
 
-			// directly update the outlineview so we don't have to reloadData
-			// It is okay if the parent is nil. This also handles the case where ADDROOT=NO and we are adding another top-level node.
-			IupCocoaTreeItem* tree_item_parent = [tree_item_prev parentItem];
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:target_index];
-//			[outline_view insertItemsAtIndexes:index_set inParent:tree_item_parent withAnimation:NSTableViewAnimationEffectNone];
-			[outline_view insertItemsAtIndexes:index_set inParent:tree_item_parent withAnimation:NSTableViewAnimationEffectGap];
+  [NSAnimationContext beginGrouping];
+  [[NSAnimationContext currentContext] setDuration:0.0];
+  [outline_view beginUpdates];
 
-		}
+  if(inode_prev)
+  {
+    IupCocoaTreeItem* tree_item_prev = inode_prev;
+    int kind_prev = [tree_item_prev kind];
 
-		iupTreeAddToCache(ih, add, kind_prev, inode_prev, inode_new);
+    if((ITREE_BRANCH == kind_prev) && (1 == add))
+    {
+      NSUInteger child_count_before = [tree_item_prev numberOfChildren];
 
-	}
-	else
-	{
-		//  add the new node at root
-		[data_source_delegate insertAtRoot:tree_item_new];
-		// directly update the outlineview so we don't have to reloadData
-//		[outline_view insertItemsAtIndexes:[NSIndexSet indexSetWithIndex:0] inParent:nil withAnimation:NSTableViewAnimationEffectNone];
-		[outline_view insertItemsAtIndexes:[NSIndexSet indexSetWithIndex:0] inParent:nil withAnimation:NSTableViewAnimationEffectGap];
+      NSUInteger new_index = [data_source_delegate insertChild:tree_item_new withParent:tree_item_prev];
 
-		iupTreeAddToCache(ih, 0, 0, NULL, inode_new);
+      NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_index];
+      [outline_view insertItemsAtIndexes:index_set inParent:tree_item_prev withAnimation:NSTableViewAnimationEffectNone];
 
-	}
-	// We don't need to reloadData if we update the outline view directly.
-//	[outline_view reloadData];
+      iupTreeAddToCache(ih, add, kind_prev, inode_prev, inode_new);
 
-	if(ITREE_BRANCH == kind)
-	{
-		BOOL should_expand = IupGetInt(ih, "ADDEXPANDED");
-		if(should_expand)
-		{
-			// Just in case we do have children already, expand now which may skip the animation delay.
-			//[outline_view expandItem:tree_item_new];
-			[outline_view expandItem:tree_item_new expandChildren:YES];
-#if 0
-			// Tricky: This wasn't working until I added dispatch_async.
-			// I think the problem is that when I expand a branch, the children may not be added yet.
-			// So if there are no children at the time, my expand request gets ignored.
-			// The dispatch_async will force the expand to happen on the next event loop pass, after any children have been added from this loop.
-			// So the expand will work now that the children exist.
-			// UPDATE: This is now fixed by using
-			// - (BOOL) outlineView:(NSOutlineView*)outline_view isItemExpandable:(id)the_item
-			// and making it rely on "kind" to determine if expandable instead of number of children.
-			dispatch_async(dispatch_get_main_queue(), ^{
-//				[outline_view expandItem:tree_item_new];
-				[outline_view expandItem:tree_item_new expandChildren:YES];
-				}
-			);
-#endif
-		}
-	}
-	
-	// make sure to release since it should now be retained by the data_source_delegate
-	[tree_item_new release];
-	
-	
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-	testValidateCocoaTreeNodeCache(ih, data_source_delegate);
-#endif
-}
+      if (child_count_before == 0)
+      {
+        iupAttribSet(ih, "_IUPTREE_IGNORE_BRANCH_CB", "1");
+        if (ih->data->add_expanded)
+          [outline_view expandItem:tree_item_prev];
+        else
+          [outline_view collapseItem:tree_item_prev];
+        iupAttribSet(ih, "_IUPTREE_IGNORE_BRANCH_CB", NULL);
+      }
+    }
+    else
+    {
+      NSUInteger new_index = [data_source_delegate insertPeer:tree_item_new withSibling:tree_item_prev addMode:add];
+      IupCocoaTreeItem* tree_item_parent = [tree_item_prev parentItem];
 
+      NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_index];
+      [outline_view insertItemsAtIndexes:index_set inParent:tree_item_parent withAnimation:NSTableViewAnimationEffectNone];
 
+      iupTreeAddToCache(ih, add, kind_prev, inode_prev, inode_new);
+    }
+  }
+  else
+  {
+    NSUInteger new_index = [[data_source_delegate treeRootTopLevelObjects] count];
+    [data_source_delegate insertAtRoot:tree_item_new];
 
-int iupdrvTreeTotalChildCount(Ihandle* ih, InodeHandle* node_handle)
-{
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_index];
+    [outline_view insertItemsAtIndexes:index_set inParent:nil withAnimation:NSTableViewAnimationEffectNone];
 
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)node_handle;
-//	NSUInteger number_of_items = [tree_item numberOfChildren];
+    iupTreeAddToCache(ih, 0, 0, NULL, inode_new);
 
-	NSUInteger number_of_items = Helper_RecursivelyCountItems(tree_item);
-	// subtract one because we don't include 'this' node as part of the children count
-	if(number_of_items > 0)
-	{
-		number_of_items = number_of_items - 1;
-	}
-	return (int)number_of_items;
+    if (ih->data->node_count == 1)
+    {
+        iupAttribSet(ih, "_IUPTREE_MARKSTART_NODE", (char*)inode_new);
+
+        iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+
+        NSInteger row = [outline_view rowForItem:inode_new];
+        if (row >= 0)
+        {
+            NSIndexSet* row_index_set = [NSIndexSet indexSetWithIndex:row];
+            [outline_view selectRowIndexes:row_index_set byExtendingSelection:NO];
+
+            if (ih->data->mark_mode != ITREE_MARK_SINGLE)
+            {
+                [outline_view deselectRow:row];
+            }
+        }
+
+        iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+    }
+  }
+
+  [outline_view endUpdates];
+  [NSAnimationContext endGrouping];
+
+  [CATransaction flush];
+  [outline_view layoutSubtreeIfNeeded];
+
+  [tree_item_new release];
 }
 
+/*****************************************************************************/
+/* AUXILIAR FUNCTIONS                                                        */
+/*****************************************************************************/
+
+int iupdrvTreeTotalChildCount(Ihandle* ih, InodeHandle* node_handle)
+{
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)node_handle;
+  NSUInteger number_of_items = Helper_RecursivelyCountItems(tree_item);
+  /* subtract one because we don't include 'this' node as part of the children count */
+  if(number_of_items > 0)
+  {
+    number_of_items = number_of_items - 1;
+  }
+  return (int)number_of_items;
+}
+
 InodeHandle* iupdrvTreeGetFocusNode(Ihandle* ih)
 {
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
 
-	id selected_item = [outline_view itemAtRow:[outline_view selectedRow]];
+  id selected_item = [outline_view itemAtRow:[outline_view selectedRow]];
 
-	
-	
-	return (InodeHandle*)selected_item;
+  return (InodeHandle*)selected_item;
 }
 
-
-// FIXME: Why does the GTK version look so different?
 void iupdrvTreeUpdateMarkMode(Ihandle *ih)
 {
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	if(ih->data->mark_mode==ITREE_MARK_MULTIPLE)
-	{
-		[outline_view setAllowsMultipleSelection:YES];
-	}
-	else
-	{
-		[outline_view setAllowsMultipleSelection:NO];
-	}
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+
+  if(ih->data->mark_mode == ITREE_MARK_MULTIPLE)
+  {
+    [outline_view setAllowsMultipleSelection:YES];
+  }
+  else
+  {
+    [outline_view setAllowsMultipleSelection:NO];
+  }
 }
 
-
-// FIXME: This has something to do with drag-and-drop between two different trees.
-// However, this interface doesn't match up well with the native Cocoa implementation for this, which is implemented.
-// I don't know how this will be triggered, if at all since the drag-and-drop is handled elsewhere.
-// For now, this is a no-op.
 void iupdrvTreeDragDropCopyNode(Ihandle* src, Ihandle* dst, InodeHandle* item_src, InodeHandle* item_dst)
 {
+  /* This function copies a node from one tree to another.
+     The native Cocoa implementation handles this differently through
+     the drag and drop delegate methods, so we need to bridge the concepts. */
 
+  if (!src || !dst || !item_src || !item_dst)
+    return;
+
+  IupCocoaTreeItem* source_item = (IupCocoaTreeItem*)item_src;
+  IupCocoaTreeItem* dest_item = (IupCocoaTreeItem*)item_dst;
+
+  NSOutlineView* dst_outline_view = cocoaTreeGetOutlineView(dst);
+  IupCocoaTreeDelegate* dst_delegate = (IupCocoaTreeDelegate*)[dst_outline_view dataSource];
+
+  /* Clone the source item with the destination ihandle */
+  IupCocoaTreeItem* new_copy = [source_item cloneWithNewParentItem:nil ihandle:dst];
+
+  /* Determine where to insert based on the destination item type */
+  int dest_kind = [dest_item kind];
+  IupCocoaTreeItem* parent_item = nil;
+  NSInteger insert_index = 0;
+
+  if (dest_kind == ITREE_BRANCH)
+  {
+    /* Check if branch is expanded */
+    if ([dst_outline_view isItemExpanded:dest_item])
+    {
+      /* Insert as first child of expanded branch */
+      parent_item = dest_item;
+      insert_index = 0;
+    }
+    else
+    {
+      /* Insert as sibling after the collapsed branch */
+      parent_item = [dest_item parentItem];
+      if (parent_item)
+      {
+        NSArray* children = [parent_item childrenArray];
+        insert_index = [children indexOfObject:dest_item] + 1;
+      }
+      else
+      {
+        /* Destination is a root-level collapsed branch */
+        NSArray* roots = [dst_delegate treeRootTopLevelObjects];
+        insert_index = [roots indexOfObject:dest_item] + 1;
+      }
+    }
+  }
+  else
+  {
+    /* Destination is a leaf - insert as sibling after it */
+    parent_item = [dest_item parentItem];
+    if (parent_item)
+    {
+      NSArray* children = [parent_item childrenArray];
+      insert_index = [children indexOfObject:dest_item] + 1;
+    }
+    else
+    {
+      /* Destination is a root-level leaf */
+      NSArray* roots = [dst_delegate treeRootTopLevelObjects];
+      insert_index = [roots indexOfObject:dest_item] + 1;
+    }
+  }
+
+  /* Insert the node */
+  if (parent_item)
+  {
+    [dst_delegate insertChild:new_copy withParent:parent_item targetChildIndex:insert_index];
+  }
+  else
+  {
+    /* Insert at root level */
+    [[dst_delegate treeRootTopLevelObjects] insertObject:new_copy atIndex:insert_index];
+  }
+
+  /* Update the view */
+  [dst_outline_view reloadData];
+
+  /* Update the cache */
+  int id_dst = iupTreeFindNodeId(dst, dest_item);
+  int id_new = id_dst + 1;
+  int count = (int)Helper_RecursivelyCountItems(new_copy);
+  iupTreeCopyMoveCache(dst, id_dst, id_new, count, 1);
+
+  [new_copy release];
 }
 
+static void cocoaTreeReloadItem(IupCocoaTreeItem* tree_item, NSOutlineView* outline_view)
+{
+  if (!tree_item || !outline_view)
+  {
+    return;
+  }
+
+  /* Find the row index for the given item. */
+  /* If the item is not visible (e.g., its parent is collapsed), this will be a negative number. */
+  NSInteger row = [outline_view rowForItem:tree_item];
+
+  /* Only proceed if the row is valid and visible. */
+  if (row >= 0)
+  {
+    /* Create an index set for the specific row we want to reload. */
+    NSIndexSet* row_index_set = [NSIndexSet indexSetWithIndex:row];
+
+    /* Create an index set for the column. Our tree only has one column at index 0. */
+    NSIndexSet* column_index_set = [NSIndexSet indexSetWithIndex:0];
+
+    /* Tell the outline view to reload the data for the specific cell, */
+    /* which will cause it to be redrawn with any updated properties. */
+    [outline_view reloadDataForRowIndexes:row_index_set columnIndexes:column_index_set];
+  }
+}
+
 static void cocoaTreeRemoveNodeDataRec(Ihandle* ih, IupCocoaTreeItem* tree_item, IFns cb, int* object_id)
 {
   int node_id = *object_id;
@@ -3026,16 +2782,12 @@
 
   /* Check whether we have child items */
   /* remove from children first */
-	
-	for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
-	{
+  for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
+  {
     (*object_id)++;
     cocoaTreeRemoveNodeDataRec(ih, a_item, cb, object_id);
+  }
 
-		
- 	 }
-	
-	
   /* actually do it for the node */
   cb(ih, (char*)ih->data->node_cache[node_id].userdata);
 
@@ -3047,20 +2799,18 @@
 {
   IFns cb = call_cb? (IFns)IupGetCallback(ih, "NODEREMOVED_CB"): NULL;
   int old_count = ih->data->node_count;
-  int object_id = iupTreeFindNodeId(ih, tree_item);
+  int object_id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
   int start_id = object_id;
 
-
-
   if (cb)
     cocoaTreeRemoveNodeDataRec(ih, tree_item, cb, &object_id);
   else
   {
-    int removed_count = iupdrvTreeTotalChildCount(ih, tree_item)+1;
+    int removed_count = iupdrvTreeTotalChildCount(ih, (InodeHandle*)tree_item) + 1;
     ih->data->node_count -= removed_count;
   }
 
-  iupTreeDelFromCache(ih, start_id, old_count-ih->data->node_count);
+  iupTreeDelFromCache(ih, start_id, old_count - ih->data->node_count);
 }
 
 static void cocoaTreeRemoveAllNodeData(Ihandle* ih, int call_cb)
@@ -3081,1994 +2831,1774 @@
   iupTreeDelFromCache(ih, 0, old_count);
 }
 
-static int cocoaTreeSetDelNodeAttrib(Ihandle* ih, int node_id, const char* value)
+/*****************************************************************************/
+/* MANIPULATING IMAGES                                                       */
+/*****************************************************************************/
+
+static NSImage* helperGetImage(Ihandle* ih, int node_id, const char* value, IupCocoaTreeItem* tree_item)
 {
-	if (!ih->handle)  /* do not do the action before map */
-		return 0;
+  if(!tree_item)
+  {
+    return nil;
+  }
 
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+  NSImage* bitmap_image = nil;
 
+  if(iupStrEqualNoCase("IMGEMPTY", value))
+  {
+    bitmap_image = nil;
+  }
+  else
+  {
+    bitmap_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
+  }
 
-	if (iupStrEqualNoCase(value, "ALL"))
-	{
-		NSUInteger number_of_root_items = [[data_source_delegate treeRootTopLevelObjects] count];
-		if(number_of_root_items > 0)
-		{
-			cocoaTreeRemoveAllNodeData(ih, 1);
+  return bitmap_image;
+}
 
-			[data_source_delegate removeAllObjects];
+static int cocoaTreeSetImageExpandedAttrib(Ihandle* ih, int node_id, const char* value)
+{
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
 
-			// Scuri says not required to handle for delete.
-			// [data_source_delegate handleSelectionDidChange:outline_view];
+  NSImage* bitmap_image = helperGetImage(ih, node_id, value, tree_item);
 
-			// If there are multiple nodes at the root (ADDROOT=NO), it seems easier to reloadData than to hunt down and remove each node.
-			[outline_view reloadData];
+  [tree_item setBitmapImage:bitmap_image];
+  cocoaTreeReloadItem(tree_item, outline_view);
 
-		}
+  return 1;
+}
 
-		return 0;
-	}
-	if (iupStrEqualNoCase(value, "SELECTED"))  /* selected here means the reference node */
-	{
+static int cocoaTreeSetImageAttrib(Ihandle* ih, int node_id, const char* value)
+{
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
 
-		IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
+  NSImage* bitmap_image = helperGetImage(ih, node_id, value, tree_item);
 
-		if(!tree_item)
-		{
-			return 0;
-		}
-		NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"expecting class IupCocoaTreeItem");
+  if([tree_item kind] == ITREE_LEAF)
+  {
+    [tree_item setBitmapImage:bitmap_image];
+  }
+  else
+  {
+    [tree_item setCollapsedImage:bitmap_image];
+  }
+  cocoaTreeReloadItem(tree_item, outline_view);
 
-		[outline_view beginUpdates];
-    cocoaTreeRemoveNodeData(ih, tree_item, 1);
+  return 0;
+}
 
-		IupCocoaTreeItem* parent_tree_item = [tree_item parentItem]; // get parent before removing because it may nil out the parent in removeItem
-		NSUInteger target_index = [data_source_delegate removeItem:tree_item];
-		//	[outline_view reloadData];
+static void helperSetImageBranchExpanded(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, NSImage* ns_image)
+{
+  for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
+  {
+    helperSetImageBranchExpanded(outline_view, a_item, ns_image);
+  }
+  if([tree_item kind] == ITREE_BRANCH)
+  {
+    /* only need to reload if the user hasn't overridden with a custom-per-node image. */
+    if(![tree_item bitmapImage])
+    {
+      cocoaTreeReloadItem(tree_item, outline_view);
+    }
+  }
+}
 
-		if(NSNotFound != target_index)
-		{
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:target_index];
-			// I don't think the animations are working for remove
-//			[outline_view removeItemsAtIndexes:index_set inParent:parent_tree_item withAnimation:NSTableViewAnimationEffectNone];
-//			[outline_view removeItemsAtIndexes:index_set inParent:parent_tree_item withAnimation:NSTableViewAnimationEffectFade];
-			[outline_view removeItemsAtIndexes:index_set inParent:parent_tree_item withAnimation:NSTableViewAnimationEffectGap];
-		}
+static int cocoaTreeSetImageBranchExpandedAttrib(Ihandle* ih, const char* value)
+{
+  NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
 
-		// Scuri says not required to handle for delete.
-		// [data_source_delegate handleSelectionDidChange:outline_view];
+  [outline_view beginUpdates];
 
-		[outline_view endUpdates];
+  [outline_view setExpandedImage:ns_image];
 
-	}
-	else if(iupStrEqualNoCase(value, "CHILDREN"))  /* children of the reference node */
-	{
-		IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
+  /* Update all images */
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+  for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
+  {
+    helperSetImageBranchExpanded(outline_view, tree_item, ns_image);
+  }
 
-		if(!tree_item)
-		{
-			return 0;
-		}
-		NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"expecting class IupCocoaTreeItem");
-		
-		[outline_view beginUpdates];
-    cocoaTreeRemoveNodeData(ih, tree_item, 1);
+  [outline_view endUpdates];
 
-		NSIndexSet* index_set = [data_source_delegate removeAllChildrenForItem:tree_item];
-//		[outline_view removeItemsAtIndexes:index_set inParent:tree_item withAnimation:NSTableViewAnimationEffectNone];
-//		[outline_view removeItemsAtIndexes:index_set inParent:tree_item withAnimation:NSTableViewAnimationEffectFade];
-		[outline_view removeItemsAtIndexes:index_set inParent:tree_item withAnimation:NSTableViewAnimationEffectGap];
+  return 1;
+}
 
-		//[outline_view reloadData];
+static void helperSetImageBranchCollapsed(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, NSImage* ns_image)
+{
+  for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
+  {
+    helperSetImageBranchCollapsed(outline_view, a_item, ns_image);
+  }
+  if([tree_item kind] == ITREE_BRANCH)
+  {
+    /* only need to reload if the user hasn't overridden with a custom-per-node image. */
+    if(![tree_item collapsedImage])
+    {
+      cocoaTreeReloadItem(tree_item, outline_view);
+    }
+  }
+}
 
-		// Scuri says not required to handle for delete.
-		// [data_source_delegate handleSelectionDidChange:outline_view];
+static int cocoaTreeSetImageBranchCollapsedAttrib(Ihandle* ih, const char* value)
+{
+  NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
 
-		[outline_view endUpdates];
+  [outline_view beginUpdates];
 
-		return 0;
-		
-	}
-	else if(iupStrEqualNoCase(value, "MARKED"))  /* Delete the array of marked nodes */
-	{
-		[outline_view beginUpdates];
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+  [outline_view setCollapsedImage:ns_image];
 
-		// TODO: For multiple selection, I should figure out how to handle the case where
-		// both the parent and children are selected.
-		// The naive solution might double delete, or index positions may shift.
-		// I can use reloadData to work around some of this,
-		// but I lose animations and other potential UI state with it.
-		// For now, I can special case single selection so it can avoid reloadData.
-		
-		if([selected_index count] == 1)
-		{
-			NSUInteger selected_i = [selected_index firstIndex];
-			id selected_item = [outline_view itemAtRow:selected_i];
-			cocoaTreeRemoveNodeData(ih, selected_item, 1);
-			IupCocoaTreeItem* parent_tree_item  = [(IupCocoaTreeItem*)selected_item parentItem];
-			NSUInteger target_index = [data_source_delegate removeItem:selected_item];
-			
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:target_index];
-//			[outline_view removeItemsAtIndexes:index_set inParent:parent_tree_item withAnimation:NSTableViewAnimationEffectFade];
-			[outline_view removeItemsAtIndexes:index_set inParent:parent_tree_item withAnimation:NSTableViewAnimationEffectGap];
-		}
-		else
-		{
-			NSUInteger selected_i = [selected_index firstIndex];
-			while(selected_i != NSNotFound)
-			{
-				id selected_item = [outline_view itemAtRow:selected_i];
-				cocoaTreeRemoveNodeData(ih, selected_item, 1);
+  /* Update all images */
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+  for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
+  {
+    helperSetImageBranchCollapsed(outline_view, tree_item, ns_image);
+  }
 
-				// I can't figure out how to make this work correctly when you select both parents and its children to be deleted.
-				// Use reloadData for now.
-	#if 0
-				IupCocoaTreeItem* parent_tree_item  = [(IupCocoaTreeItem*)selected_item parentItem];
-				NSUInteger target_index = [data_source_delegate removeItem:selected_item];
-				
-				NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:target_index];
-	//			[outline_view removeItemsAtIndexes:index_set inParent:parent_tree_item withAnimation:NSTableViewAnimationEffectFade];
-				[outline_view removeItemsAtIndexes:index_set inParent:parent_tree_item withAnimation:NSTableViewAnimationEffectGap];
-	#else
-				[data_source_delegate removeItem:selected_item];
-	#endif
+  [outline_view endUpdates];
 
-				
-				// get the next index in the set
-				selected_i = [selected_index indexGreaterThanIndex:selected_i];
-			}
+  return 1;
+}
 
-			// WARNING: I seem to get a crash somewhere else when the outlineview reloads later if I both call remoeItemsAtIndexes and reloadData. This may imply some other bug.
-			[outline_view reloadData];
+static void helperSetImageLeaf(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, NSImage* ns_image)
+{
+  for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
+  {
+    helperSetImageLeaf(outline_view, a_item, ns_image);
+  }
+  if([tree_item kind] == ITREE_LEAF)
+  {
+    /* only need to reload if the user hasn't overridden with a custom-per-node image. */
+    if(![tree_item bitmapImage])
+    {
+      cocoaTreeReloadItem(tree_item, outline_view);
+    }
+  }
+}
 
-		}
-		// Scuri says not required to handle for delete.
-		// [data_source_delegate handleSelectionDidChange:outline_view];
-		[outline_view endUpdates];
+static int cocoaTreeSetImageLeafAttrib(Ihandle* ih, const char* value)
+{
+  NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
 
-	}
-	
-#if IUPCOCOA_TREE_TEST_VALIDATE_NODE_CACHE
-	testValidateCocoaTreeNodeCache(ih, data_source_delegate);
-#endif
+  [outline_view beginUpdates];
 
+  [outline_view setLeafImage:ns_image];
 
-	return 0;
+  /* Update all images */
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+  for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
+  {
+    helperSetImageLeaf(outline_view, tree_item, ns_image);
+  }
+
+  [outline_view endUpdates];
+
+  return 1;
 }
 
+/*****************************************************************************/
+/* GET AND SET ATTRIBUTES                                                    */
+/*****************************************************************************/
 
-static int cocoaTreeSetMoveNodeAttrib(Ihandle* ih, int node_id, const char* value)
+static char* cocoaTreeGetStateAttrib(Ihandle* ih, int item_id)
 {
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return NULL;
 
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
 
-	if(!ih->handle)  /* do not do the action before map */
-	{
-		return 0;
-	}
+  if ([outline_view isExpandable:tree_item])
+  {
+    BOOL is_expanded = [outline_view isItemExpanded:tree_item];
+    if (is_expanded)
+      return "EXPANDED";
+    else
+      return "COLLAPSED";
+  }
+  else
+    return NULL;
+}
 
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+static int cocoaTreeSetStateAttrib(Ihandle* ih, int id, const char* value)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return 0;
 
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
 
-	if(!tree_item)
-	{
-		return 0;
-	}
-	IupCocoaTreeItem* parent_tree_item  = [tree_item parentItem];
+  if ([outline_view isExpandable:tree_item])
+  {
+    [NSAnimationContext beginGrouping];
+    [[NSAnimationContext currentContext] setDuration:0.0];
 
-	IupCocoaTreeItem* target_tree_item = (IupCocoaTreeItem*)iupTreeGetNodeFromString(ih, value);
-	IupCocoaTreeItem* parent_target_tree_item = [target_tree_item parentItem];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_BRANCH_CB", "1");
+    if (iupStrEqualNoCase(value, "EXPANDED"))
+      [outline_view expandItem:tree_item];
+    else
+      [outline_view collapseItem:tree_item];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_BRANCH_CB", NULL);
 
-	/* If Drag item is an ancestor of Drop item then return */
-	if([tree_item isEqual:target_tree_item])
-	{
-		return 0;
-	}
-#if 0
-	if([tree_item isEqual:parent_target_tree_item])
-	{
-		return 0;
-	}
-#endif
+    [NSAnimationContext endGrouping];
 
-	NSUInteger object_index;
-	if(parent_tree_item)
-	{
-		object_index = [[parent_tree_item childrenArray] indexOfObject:tree_item];
+    [CATransaction flush];
+    [outline_view layoutSubtreeIfNeeded];
+  }
 
-	}
-	else
-	{
-		object_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:tree_item];
-	}
+  return 0;
+}
 
-	// If the destination node is a branch and it is expanded,
-	// then the specified node is inserted as the first child of the destination node.
-	// If the branch is not expanded or the destination node is a leaf,
-	// then it is inserted as the next brother of the leaf.
-	
-	BOOL is_target_expanded = NO;
-	int target_kind = [target_tree_item kind];
-	if(ITREE_BRANCH == target_kind)
-	{
-		is_target_expanded = [outline_view isItemExpanded:target_tree_item];
+static char* cocoaTreeGetDepthAttrib(Ihandle* ih, int item_id)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return NULL;
 
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
-		if(is_target_expanded)
-		{
-		
+  NSUInteger out_depth_counter = 0;
+  bool did_find = Helper_CountDepth(tree_delegate, tree_item, &out_depth_counter);
 
-			// update the data source
-			
-			helperMoveNode(outline_view, tree_item, parent_target_tree_item, 0);
+  if (did_find)
+    return iupStrReturnInt((int)out_depth_counter);
+  else
+    return NULL;
+}
 
+static char* cocoaTreeGetKindAttrib(Ihandle* ih, int item_id)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return NULL;
 
-		}
-		else
-		{
-			NSUInteger target_index;
-			if(parent_target_tree_item)
-			{
-				target_index = [[parent_target_tree_item childrenArray] indexOfObject:target_tree_item];
-			}
-			else
-			{
-				target_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:target_tree_item];
-			}
-			// update the data source
-			helperMoveNode(outline_view, tree_item, parent_target_tree_item, target_index);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
 
-		}
-	}
-	else
-	{
-		NSUInteger target_index;
-		if(parent_target_tree_item)
-		{
-			target_index = [[parent_target_tree_item childrenArray] indexOfObject:target_tree_item];
-		}
-		else
-		{
-			target_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:target_tree_item];
-		}
-		// update the data source
-		helperMoveNode(outline_view, tree_item, parent_target_tree_item, target_index);
+  if ([tree_item kind] == ITREE_LEAF)
+    return "LEAF";
+  else
+    return "BRANCH";
+}
 
-	
-	}
-	
-	
+static char* cocoaTreeGetParentAttrib(Ihandle* ih, int item_id)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return NULL;
 
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  IupCocoaTreeItem* parent_item = [tree_item parentItem];
 
-  return 0;
+  if (parent_item == nil)
+    return NULL;
+
+  int parent_id = iupTreeFindNodeId(ih, (InodeHandle*)parent_item);
+  return iupStrReturnInt(parent_id);
 }
 
-static int cocoaTreeSetCopyNodeAttrib(Ihandle* ih, int node_id, const char* value)
+static char* cocoaTreeGetNextAttrib(Ihandle* ih, int id)
 {
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return NULL;
 
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  IupCocoaTreeItem* parent_item = [tree_item parentItem];
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
-	if(!ih->handle)  /* do not do the action before map */
-	{
-		return 0;
-	}
+  NSArray* siblings_array;
+  if (parent_item)
+    siblings_array = [parent_item childrenArray];
+  else
+    siblings_array = [tree_delegate treeRootTopLevelObjects];
 
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+  NSUInteger index = [siblings_array indexOfObject:tree_item];
+  if (index != NSNotFound && index + 1 < [siblings_array count])
+  {
+    IupCocoaTreeItem* next_item = [siblings_array objectAtIndex:index + 1];
+    int next_id = iupTreeFindNodeId(ih, (InodeHandle*)next_item);
+    return iupStrReturnInt(next_id);
+  }
 
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
+  return NULL;
+}
 
-	if(!tree_item)
-	{
-		return 0;
-	}
-	IupCocoaTreeItem* parent_tree_item  = [tree_item parentItem];
+static char* cocoaTreeGetPreviousAttrib(Ihandle* ih, int id)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return NULL;
 
-	IupCocoaTreeItem* target_tree_item = (IupCocoaTreeItem*)iupTreeGetNodeFromString(ih, value);
-	IupCocoaTreeItem* parent_target_tree_item = [target_tree_item parentItem];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  IupCocoaTreeItem* parent_item = [tree_item parentItem];
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
+  NSArray* siblings_array;
+  if (parent_item)
+    siblings_array = [parent_item childrenArray];
+  else
+    siblings_array = [tree_delegate treeRootTopLevelObjects];
 
+  NSUInteger index = [siblings_array indexOfObject:tree_item];
+  if (index != NSNotFound && index > 0)
+  {
+    IupCocoaTreeItem* previous_item = [siblings_array objectAtIndex:index - 1];
+    int previous_id = iupTreeFindNodeId(ih, (InodeHandle*)previous_item);
+    return iupStrReturnInt(previous_id);
+  }
 
-	NSUInteger object_index;
-	if(parent_tree_item)
-	{
-		object_index = [[parent_tree_item childrenArray] indexOfObject:tree_item];
+  return NULL;
+}
 
-	}
-	else
-	{
-		object_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:tree_item];
-	}
+static char* cocoaTreeGetFirstAttrib(Ihandle* ih, int id)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return NULL;
 
-	// If the destination node is a branch and it is expanded,
-	// then the specified node is inserted as the first child of the destination node.
-	// If the branch is not expanded or the destination node is a leaf,
-	// then it is inserted as the next brother of the leaf.
-	
-	BOOL is_target_expanded = NO;
-	int target_kind = [target_tree_item kind];
-	if(ITREE_BRANCH == target_kind)
-	{
-		is_target_expanded = [outline_view isItemExpanded:target_tree_item];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  IupCocoaTreeItem* parent_item = [tree_item parentItem];
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
+  NSArray* siblings_array;
+  if (parent_item)
+    siblings_array = [parent_item childrenArray];
+  else
+    siblings_array = [tree_delegate treeRootTopLevelObjects];
 
-		if(is_target_expanded)
-		{
-			// update the data source
-			helperCopyAndInsertNode(outline_view, tree_item, parent_target_tree_item, 0, NSTableViewAnimationEffectGap);
-		}
-		else
-		{
-			NSUInteger target_index;
-			if(parent_target_tree_item)
-			{
-				target_index = [[parent_target_tree_item childrenArray] indexOfObject:target_tree_item];
-			}
-			else
-			{
-				target_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:target_tree_item];
-			}
-			// update the data source
-			helperCopyAndInsertNode(outline_view, tree_item, parent_target_tree_item, target_index, NSTableViewAnimationEffectGap);
-		}
-	}
-	else
-	{
-		NSUInteger target_index;
-		if(parent_target_tree_item)
-		{
-			target_index = [[parent_target_tree_item childrenArray] indexOfObject:target_tree_item];
-		}
-		else
-		{
-			target_index = [[data_source_delegate treeRootTopLevelObjects] indexOfObject:target_tree_item];
-		}
-		// update the data source
-		helperCopyAndInsertNode(outline_view, tree_item, parent_target_tree_item, target_index, NSTableViewAnimationEffectGap);
-	}
-	return 0;
+  if ([siblings_array count] > 0)
+  {
+    IupCocoaTreeItem* first_item = [siblings_array objectAtIndex:0];
+    int first_id = iupTreeFindNodeId(ih, (InodeHandle*)first_item);
+    return iupStrReturnInt(first_id);
+  }
+
+  return NULL;
 }
-/*****************************************************************************/
-/* MANIPULATING IMAGES                                                       */
-/*****************************************************************************/
 
-/* Apple has a built-in Folder image we are supposed to use.
-	Also, the default IUP one looks awful on Mac. (The resolution is too low and the colors are wrong.)
- 	So we will override the default IUP one here.
- 	IUP has different images for expanded and collaspsed, but that is not a normal thing for Mac.
- 	Additionally, there is a performance cost and possible issues with losing selections due to reloading items when we switch on Mac.
- 	And Apple does not provide an 'open' folder image.
-	So we will make the expanded and collapsed images point to the same image here.
-	This will allow us to get back a little performance by default.
- 	TODO: Redesign the core iup_tree.c code to not load the default images for performance.
-*/
-static void helperLoadReplacementDefaultImages()
+static char* cocoaTreeGetLastAttrib(Ihandle* ih, int id)
 {
-	NSImage* ns_folder_image = [NSImage imageNamed:NSImageNameFolder];
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return NULL;
 
-	// The default IUP image 16x16.
-	// The default table cell height accomodates height=16 perfectly.
-	// But the Apple icon is currently 32x32 (subject to get bigger over time).
-	// So we will scale the image down to 16x16.
-	CGRect resize_rect = { 0, 0, 16, 16 };
-	
-	CGImageRef cg_image = [ns_folder_image CGImageForProposedRect:&resize_rect context:nil hints:nil];
-//	CGImageRef cg_image = [ns_folder_image CGImageForProposedRect:nil context:nil hints:nil];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  IupCocoaTreeItem* parent_item = [tree_item parentItem];
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
-	NSUInteger bytes_per_row  = resize_rect.size.width * 4; // rgba
-  	NSUInteger total_bytes  = bytes_per_row * resize_rect.size.height;
+  NSArray* siblings_array;
+  if (parent_item)
+    siblings_array = [parent_item childrenArray];
+  else
+    siblings_array = [tree_delegate treeRootTopLevelObjects];
 
-  	void* copy_pixel_buffer = malloc(total_bytes);
-	CGColorSpaceRef color_space = CGColorSpaceCreateDeviceRGB();
-	
-	 CGContextRef offscreen_context_ref = CGBitmapContextCreate(
-		copy_pixel_buffer,
-		resize_rect.size.width,
-		resize_rect.size.height,
-		8, // bits per component
-		bytes_per_row,
-		color_space,
-		kCGImageAlphaPremultipliedLast
-	);
-	CGColorSpaceRelease(color_space);
-	CGContextDrawImage(offscreen_context_ref, resize_rect, cg_image);
-	
-//	CFDataRef raw_data = CGDataProviderCopyData(CGImageGetDataProvider(offscreen_context_ref));
-//	unsigned char* raw_data = CGBitmapContextGetData(offscreen_context_ref);
+  NSUInteger count = [siblings_array count];
+  if (count > 0)
+  {
+    IupCocoaTreeItem* last_item = [siblings_array objectAtIndex:count - 1];
+    int last_id = iupTreeFindNodeId(ih, (InodeHandle*)last_item);
+    return iupStrReturnInt(last_id);
+  }
 
-//	CFIndex data_length = CFDataGetLength(raw_data);
-  	Ihandle* ih_folder_image = IupImageRGBA(resize_rect.size.width, resize_rect.size.height, (unsigned char*)copy_pixel_buffer);
-//	CFRelease(raw_data);
-	CFRelease(offscreen_context_ref);
-	free(copy_pixel_buffer);
-	// Copied from collapsed_image. I don't know if these colors make sense, or if they are ever used.
-#if 1
-	IupSetAttribute(ih_folder_image, "0", "BGCOLOR");
-	IupSetAttribute(ih_folder_image, "1", "255 206 156");
-	IupSetAttribute(ih_folder_image, "2", "156 156 0");
-	IupSetAttribute(ih_folder_image, "3", "0 0 0");
-	IupSetAttribute(ih_folder_image, "4", "206 206 99");
-	IupSetAttribute(ih_folder_image, "5", "255 255 206");
-	IupSetAttribute(ih_folder_image, "6", "247 247 247");
-	IupSetAttribute(ih_folder_image, "7", "255 255 156");
-#endif
+  return NULL;
+}
 
-	IupSetHandle("IMGCOLLAPSED", ih_folder_image);
-	IupSetHandle("IMGEXPANDED",  ih_folder_image);
+static char* cocoaTreeGetTitleAttrib(Ihandle* ih, int item_id)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (inode_handle)
+  {
+    IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+    NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"expecting class IupCocoaTreeItem");
+    NSString* ns_title = [tree_item title];
+    return iupStrReturnStr([ns_title UTF8String]);
+  }
+  else
+    return NULL;
 }
 
-static void helperReplaceDefaultImages(Ihandle* ih, IupCocoaOutlineView* outline_view)
+static int cocoaTreeSetTitleAttrib(Ihandle* ih, int item_id, const char* value)
 {
-	// This was loaded in helperLoadReplacementDefaultImages.
-	// Round-tripping the image through IUP is intentional in case IUP does any additional transformations.
-	NSImage* ns_folder_image_roundtrip = iupImageGetImage(iupAttribGetStr(ih, "IMAGEBRANCHCOLLAPSED"), ih, 0, NULL);
-	
-	// We use the same pointer for both. This allows for an optimization to kick in to not reload items when expand/collapse happens.
-	[outline_view setCollapsedImage:ns_folder_image_roundtrip];
-	[outline_view setExpandedImage:ns_folder_image_roundtrip];
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (inode_handle)
+  {
+    NSString* ns_title = @"";
+    if (value)
+      ns_title = [NSString stringWithUTF8String:value];
 
+    IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+    NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"expecting class IupCocoaTreeItem");
+    [tree_item setTitle:ns_title];
+
+    NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+    cocoaTreeReloadItem(tree_item, outline_view);
+  }
+
+  return 0;
 }
 
-static NSImage* helperGetImage(Ihandle* ih, int node_id, const char* value, IupCocoaTreeItem* tree_item)
+static char* cocoaTreeGetRootCountAttrib(Ihandle* ih)
 {
-	if(!tree_item)
-	{
-		return nil;
-	}
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
-	NSImage* bitmap_image = nil;
-	
-	if(iupStrEqualNoCase("IMGEMPTY", value))
-	{
-		bitmap_image = nil;
-	}
-	else
-	{
-		bitmap_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
-	}
-
-	return bitmap_image;
+  NSArray* root_items = [tree_delegate treeRootTopLevelObjects];
+  return iupStrReturnInt((int)[root_items count]);
 }
 
-static int cocoaTreeSetImageExpandedAttrib(Ihandle* ih, int node_id, const char* value)
+static char* cocoaTreeGetChildCountAttrib(Ihandle* ih, int item_id)
 {
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return NULL;
 
-	NSImage* bitmap_image = helperGetImage(ih, node_id, value, tree_item);
-	
-	// Oh how ironic and tragic.
-	// I combined expanded and leaf into the same variable and made collapsed separate.
-	// But IUP combined collpased and leaf into the same variable and made expanded separate.
-	[tree_item setBitmapImage:bitmap_image];
-	cocoaTreeReloadItem(tree_item, outline_view);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
 
-	return 1;
+  return iupStrReturnInt((int)[[tree_item childrenArray] count]);
 }
 
-static int cocoaTreeSetImageAttrib(Ihandle* ih, int node_id, const char* value)
+static char* cocoaTreeGetColorAttrib(Ihandle* ih, int id)
 {
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)iupTreeGetNode(ih, node_id);
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return NULL;
 
-	NSImage* bitmap_image = helperGetImage(ih, node_id, value, tree_item);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  NSColor* color = [tree_item textColor];
 
-	
-	// Oh how ironic and tragic.
-	// I combined expanded and leaf into the same variable and made collapsed separate.
-	// But IUP combined collpased and leaf into the same variable and made expanded separate.
-	if([tree_item kind] == ITREE_LEAF)
-	{
-		[tree_item setBitmapImage:bitmap_image];
-	}
-	else
-	{
-		[tree_item setCollapsedImage:bitmap_image];
-	}
-	cocoaTreeReloadItem(tree_item, outline_view);
+  if (color == nil)
+    return NULL;
 
-	return 0;
+  CGFloat r, g, b, a;
+  [color getRed:&r green:&g blue:&b alpha:&a];
+
+  return iupStrReturnStrf("%d %d %d", (int)(r * 255.0), (int)(g * 255.0), (int)(b * 255.0));
 }
 
-static void helperSetImageBranchExpanded(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, NSImage* ns_image)
+static int cocoaTreeSetColorAttrib(Ihandle* ih, int id, const char* value)
 {
-	for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
-	{
-		helperSetImageBranchExpanded(outline_view, a_item, ns_image);
-	}
-	if([tree_item kind] == ITREE_BRANCH)
-	{
-		// only need to reload if the user hasn't overridden with a custom-per-node image.
-		if(![tree_item bitmapImage])
-		{
-			cocoaTreeReloadItem(tree_item, outline_view);
-		}
-	}
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return 0;
+
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+
+  unsigned char r, g, b;
+  if (iupStrToRGB(value, &r, &g, &b))
+  {
+    NSColor* color = [NSColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+    [tree_item setTextColor:color];
+    cocoaTreeReloadItem(tree_item, outline_view);
+  }
+
+  return 0;
 }
 
-static int cocoaTreeSetImageBranchExpandedAttrib(Ihandle* ih, const char* value)
+static char* cocoaTreeGetTitleFontAttrib(Ihandle* ih, int id)
 {
-	NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return NULL;
 
-	[outline_view beginUpdates];
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  NSFont* font = [tree_item font];
 
-	[outline_view setExpandedImage:ns_image];
+  if (font == nil)
+    return NULL;
 
-	/* Update all images */
-	IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
-	{
-		helperSetImageBranchExpanded(outline_view, tree_item, ns_image);
-	}
-	
-	[outline_view endUpdates];
-
-	return 1;
+  return iupStrReturnStr([[font fontName] UTF8String]);
 }
 
+static int cocoaTreeSetTitleFontAttrib(Ihandle* ih, int id, const char* value)
+{
+  InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+  if (NULL == inode_handle)
+    return 0;
 
-static void helperSetImageBranchCollapsed(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, NSImage* ns_image)
-{
-	for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
-	{
-		helperSetImageBranchCollapsed(outline_view, a_item, ns_image);
-	}
-	// only need to reload if the user hasn't overridden with a custom-per-node image.
-	if([tree_item kind] == ITREE_BRANCH)
-	{
-		// only need to reload if the user hasn't overridden with a custom-per-node image.
-		if(![tree_item collapsedImage])
-		{
-			cocoaTreeReloadItem(tree_item, outline_view);
-		}
-	}
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+
+  if (value)
+  {
+    IupCocoaFont* iup_font = iupcocoaFindFont(value);
+    if (nil != iup_font)
+    {
+      [tree_item setFont:[iup_font nativeFont]];
+      cocoaTreeReloadItem(tree_item, outline_view);
+    }
+  }
+  else
+  {
+    /* Setting to nil reverts to the default font handled by viewForTableColumn. */
+    [tree_item setFont:nil];
+    cocoaTreeReloadItem(tree_item, outline_view);
+  }
+
+  return 0;
 }
 
-static int cocoaTreeSetImageBranchCollapsedAttrib(Ihandle* ih, const char* value)
+static char* cocoaTreeGetMarkedAttrib(Ihandle* ih, int item_id)
 {
-	NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
 
-	[outline_view beginUpdates];
+  if (NULL == inode_handle)
+  {
+    IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+    NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+    NSUInteger selected_i = [selected_index firstIndex];
 
-	[outline_view setCollapsedImage:ns_image];
+    if (selected_i != NSNotFound)
+      return iupStrReturnBoolean(true);
+    else
+      return iupStrReturnBoolean(false);
+  }
 
-	/* Update all images */
-	IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
-	{
-		helperSetImageBranchCollapsed(outline_view, tree_item, ns_image);
-	}
-	
-	[outline_view endUpdates];
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
 
-	return 1;
+  NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+  NSUInteger selected_i = [selected_index firstIndex];
+
+  while (selected_i != NSNotFound)
+  {
+    IupCocoaTreeItem* selected_item = [outline_view itemAtRow:selected_i];
+    if ([selected_item isEqual:tree_item])
+      return iupStrReturnBoolean(true);
+
+    selected_i = [selected_index indexGreaterThanIndex:selected_i];
+  }
+
+  return iupStrReturnBoolean(false);
 }
 
-static void helperSetImageLeaf(IupCocoaOutlineView* outline_view, IupCocoaTreeItem* tree_item, NSImage* ns_image)
+static int cocoaTreeSetMarkedAttrib(Ihandle* ih, int item_id, const char* value)
 {
-	for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
-	{
-		helperSetImageLeaf(outline_view, a_item, ns_image);
-	}
-	if([tree_item kind] == ITREE_LEAF)
-	{
-		// only need to reload if the user hasn't overridden with a custom-per-node image.
-		if(![tree_item bitmapImage])
-		{
-			cocoaTreeReloadItem(tree_item, outline_view);
-		}
-	}
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  bool should_select = iupStrBoolean(value);
+
+  if (NULL == inode_handle)
+  {
+    if (should_select)
+      return 0;
+
+    IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+    [outline_view deselectAll:nil];
+    return 0;
+  }
+
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  NSInteger item_row = [outline_view rowForItem:tree_item];
+
+  iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+  if (should_select)
+  {
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:item_row];
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+  }
+  else
+    [outline_view deselectRow:item_row];
+
+  iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+
+  return 0;
 }
 
-static int cocoaTreeSetImageLeafAttrib(Ihandle* ih, const char* value)
+static int cocoaTreeSetMarkAttrib(Ihandle* ih, const char* value)
 {
-	NSImage* ns_image = (NSImage*)iupImageGetImage(value, ih, 0, NULL);
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  if (ih->data->mark_mode == ITREE_MARK_SINGLE)
+    return 0;
 
-	[outline_view beginUpdates];
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
 
-	[outline_view setLeafImage:ns_image];
+  if (iupStrEqualNoCase(value, "BLOCK"))
+  {
+    IupCocoaTreeItem* mark_start_node = (IupCocoaTreeItem*)iupAttribGet(ih, "_IUPTREE_MARKSTART_NODE");
+    if (nil == mark_start_node)
+      return 0;
 
-	/* Update all images */
-	IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	for(IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
-	{
-		helperSetImageLeaf(outline_view, tree_item, ns_image);
-	}
-	
-	[outline_view endUpdates];
+    NSInteger mark_start_node_row = [outline_view rowForItem:mark_start_node];
+    if (mark_start_node_row < 0)
+      return 0;
 
-	return 1;
-}
+    NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+    NSUInteger selected_i = [selected_index firstIndex];
+    if (selected_i == NSNotFound)
+      return 0;
 
-/*****************************************************************************/
-/* GET AND SET ATTRIBUTES                                                    */
-/*****************************************************************************/
+    if (selected_i == mark_start_node_row)
+      return 1;
 
+    NSUInteger start_row;
+    NSUInteger number_of_rows;
 
-static char* cocoaTreeGetStateAttrib(Ihandle* ih, int item_id)
-{
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	if([outline_view isExpandable:tree_item])
-	{
-		// BUG: Apple seems to return NO if a parent is collapsed, even if the actual item is expanded.
-		// But when Apple expands the parent, it remembers and restores the child state.
-		// This is a problem for us because we are trying to copy the state to apply to new copies of the node.
-		// I don't know how to workaround this.
-		// Tested 10.13.6
-		BOOL is_expanded = [outline_view isItemExpanded:tree_item];
-		if(is_expanded)
-		{
-			return "EXPANDED";
-		}
-		else
-		{
-			return "COLLAPSED";
-		}
-	}
-	else
-	{
-		return NULL;
-	}
-}
+    if (mark_start_node_row > selected_i)
+    {
+      start_row = selected_i;
+      number_of_rows = mark_start_node_row - selected_i + 1;
+    }
+    else
+    {
+      start_row = mark_start_node_row;
+      number_of_rows = selected_i - mark_start_node_row + 1;
+    }
 
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(start_row, number_of_rows)];
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "CLEARALL"))
+  {
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view deselectAll:nil];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "MARKALL"))
+  {
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view selectAll:nil];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "INVERTALL"))
+  {
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+    [outline_view selectAll:nil];
+    NSUInteger selected_i = [selected_index firstIndex];
 
-static int cocoaTreeSetStateAttrib(Ihandle* ih, int item_id, const char* value)
-{
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return 0;
-	}
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	if([outline_view isExpandable:tree_item])
-	{
-		if(iupStrEqualNoCase(value, "EXPANDED"))
-		{
-			[outline_view expandItem:tree_item];
-		}
-		else
-		{
-			[outline_view collapseItem:tree_item];
-		}
-	}
-	return 0;
-}
+    while (selected_i != NSNotFound)
+    {
+      [outline_view deselectRow:selected_i];
+      selected_i = [selected_index indexGreaterThanIndex:selected_i];
+    }
 
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualPartial(value, "INVERT"))
+  {
+    const char* id_string = &value[strlen("INVERT")];
+    InodeHandle* inode_handle = iupTreeGetNodeFromString(ih, id_string);
 
-static char* cocoaTreeGetDepthAttrib(Ihandle* ih, int item_id)
-{
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	NSUInteger out_depth_counter = 0;
-	bool did_find = Helper_CountDepth(tree_delegate, tree_item, &out_depth_counter);
-	if(did_find)
-	{
-		return iupStrReturnInt((int)out_depth_counter);
-	}
-	else
-	{
-	    return NULL;
-	}
+    if (NULL == inode_handle)
+    {
+      NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+      NSUInteger selected_i = [selected_index firstIndex];
+
+      while (selected_i != NSNotFound)
+      {
+        [outline_view deselectRow:selected_i];
+        selected_i = [selected_index indexGreaterThanIndex:selected_i];
+      }
+    }
+    else
+    {
+      IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+      NSInteger item_row = [outline_view rowForItem:tree_item];
+      bool was_item_selected = false;
+      NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+      NSUInteger selected_i = [selected_index firstIndex];
+
+      while (selected_i != NSNotFound)
+      {
+        IupCocoaTreeItem* selected_item = [outline_view itemAtRow:selected_i];
+        if ([selected_item isEqual:tree_item])
+        {
+          was_item_selected = true;
+          break;
+        }
+        selected_i = [selected_index indexGreaterThanIndex:selected_i];
+      }
+
+      iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+
+      if (was_item_selected)
+        [outline_view deselectRow:item_row];
+      else
+      {
+        NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:item_row];
+        [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+      }
+
+      iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+    }
+  }
+  else
+  {
+    char str1[50], str2[50];
+
+    if (iupStrToStrStr(value, str1, str2, '-') != 2)
+      return 0;
+
+    InodeHandle* inode_handle1 = iupTreeGetNodeFromString(ih, str1);
+    InodeHandle* inode_handle2 = iupTreeGetNodeFromString(ih, str2);
+    NSInteger item_row1 = [outline_view rowForItem:inode_handle1];
+    NSInteger item_row2 = [outline_view rowForItem:inode_handle2];
+
+    NSUInteger start_row;
+    NSUInteger number_of_rows;
+
+    if (item_row2 > item_row1)
+    {
+      start_row = item_row1;
+      number_of_rows = item_row2 - item_row1 + 1;
+    }
+    else
+    {
+      start_row = item_row2;
+      number_of_rows = item_row1 - item_row2 + 1;
+    }
+
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(start_row, number_of_rows)];
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+
+  return 1;
 }
 
-static char* cocoaTreeGetKindAttrib(Ihandle* ih, int item_id)
+static int cocoaTreeSetMarkStartAttrib(Ihandle* ih, const char* value)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	
-	if([tree_item kind] == ITREE_LEAF)
-	{
-		return "LEAF";
-	}
-	else
-	{
-		return "BRANCH";
-	}
+  InodeHandle* inode_handle = iupTreeGetNodeFromString(ih, value);
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+
+  if (NULL == inode_handle)
+  {
+    [outline_view setMarkStartNode:nil];
+    return 0;
+  }
+
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  [outline_view setMarkStartNode:tree_item];
+  iupAttribSet(ih, "_IUPTREE_MARKSTART_NODE", (char*)tree_item);
+
+  return 1;
 }
 
-static char* cocoaTreeGetParentAttrib(Ihandle* ih, int item_id)
+static char* cocoaTreeGetMarkedNodesAttrib(Ihandle* ih)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	IupCocoaTreeItem* parent_item = [tree_item parentItem];
-	int parent_id = iupTreeFindNodeId(ih, (InodeHandle*)parent_item);
-	return iupStrReturnInt(parent_id);
+  char* str = iupStrGetMemory(ih->data->node_count + 1);
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+
+  for (size_t i = 0; i < ih->data->node_count; i++)
+  {
+    IupCocoaTreeItem* iter_node = (IupCocoaTreeItem*)ih->data->node_cache[i].node_handle;
+    NSUInteger selected_i = [selected_index firstIndex];
+    bool is_found = false;
+
+    while (selected_i != NSNotFound)
+    {
+      IupCocoaTreeItem* selected_item = (IupCocoaTreeItem*)[outline_view itemAtRow:selected_i];
+      if ([iter_node isEqual:selected_item])
+      {
+        is_found = true;
+        break;
+      }
+      selected_i = [selected_index indexGreaterThanIndex:selected_i];
+    }
+
+    if (is_found)
+      str[i] = '+';
+    else
+      str[i] = '-';
+  }
+
+  str[ih->data->node_count] = 0;
+  return str;
 }
 
-// returns the next brother (same depth) of the specified node. Returns NULLs if at last child node of the parent (at the same depth)
-static char* cocoaTreeGetNextAttrib(Ihandle* ih, int item_id)
+static int cocoaTreeSetMarkedNodesAttrib(Ihandle* ih, const char* value)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	IupCocoaTreeItem* parent_item = [tree_item parentItem];
-	if(nil == parent_item)
-	{
-		return NULL;
-	}
-	NSArray* children_array = [parent_item childrenArray];
-	
-	bool found_current_item = false;
-	NSUInteger index_count = 0;
-	for(IupCocoaTreeItem* a_item in children_array)
-	{
-		index_count += 1;
-		if([tree_item isEqual:a_item])
-		{
-			found_current_item = true;
-			break;
-		}
-	}
+  int count, i;
 
-	if(index_count >= [children_array count])
-	{
-		// our item was the last node, so return NULL
-		return NULL;
-	}
-	IupCocoaTreeItem* next_item = [children_array objectAtIndex:index_count];
-	int next_id = iupTreeFindNodeId(ih, (InodeHandle*)next_item);
-	return iupStrReturnInt(next_id);
+  if (ih->data->mark_mode == ITREE_MARK_SINGLE || !value)
+    return 0;
+
+  count = (int)strlen(value);
+  if (count > ih->data->node_count)
+    count = ih->data->node_count;
+
+  iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  [outline_view deselectAll:nil];
+
+  for (i = 0; i < count; i++)
+  {
+    if (value[i] == '+')
+    {
+      IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)ih->data->node_cache[i].node_handle;
+      NSInteger item_row = [outline_view rowForItem:tree_item];
+      NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:item_row];
+      [outline_view selectRowIndexes:index_set byExtendingSelection:YES];
+    }
+  }
+
+  iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+
+  return 0;
 }
 
-// returns the previous brother (same depth) of the specified node. Returns NULLs if at first child node of the parent (at the same depth).
-static char* cocoaTreeGetPreviousAttrib(Ihandle* ih, int item_id)
+static int cocoaTreeSetTopItemAttrib(Ihandle* ih, const char* value)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	IupCocoaTreeItem* parent_item = [tree_item parentItem];
-	if(nil == parent_item)
-	{
-		return NULL;
-	}
-	NSArray* children_array = [parent_item childrenArray];
-	
-	bool found_current_item = false;
-	NSUInteger index_count = 0;
-	for(IupCocoaTreeItem* a_item in children_array)
-	{
-		if([tree_item isEqual:a_item])
-		{
-			found_current_item = true;
-			break;
-		}
-		index_count += 1;
-	}
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  InodeHandle* inode_handle = iupTreeGetNodeFromString(ih, value);
 
-	if(index_count == 0)
-	{
-		// our item was the first node, so return NULL
-		return NULL;
-	}
-	IupCocoaTreeItem* previous_item = [children_array objectAtIndex:index_count-1];
-	int previous_id = iupTreeFindNodeId(ih, (InodeHandle*)previous_item);
-	return iupStrReturnInt(previous_id);
+  if (nil == inode_handle)
+    return 0;
+
+  NSMutableArray<IupCocoaTreeItem*>* parent_node_array = [[NSMutableArray alloc] initWithCapacity:ih->data->node_count];
+  {
+    IupCocoaTreeItem* parent_tree_item = [(IupCocoaTreeItem*)inode_handle parentItem];
+    while (parent_tree_item != nil)
+    {
+      [parent_node_array insertObject:parent_tree_item atIndex:0];
+      parent_tree_item = [parent_tree_item parentItem];
+    }
+  }
+
+  for (IupCocoaTreeItem* a_item in parent_node_array)
+    [outline_view expandItem:a_item];
+
+  [parent_node_array release];
+
+  NSInteger item_row = [outline_view rowForItem:inode_handle];
+  if (item_row < 0)
+    return 0;
+
+  [outline_view scrollRowToVisible:item_row];
+
+  return 0;
 }
 
-static char* cocoaTreeGetFirstAttrib(Ihandle* ih, int item_id)
+static int cocoaTreeSetValueAttrib(Ihandle* ih, const char* value)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	IupCocoaTreeItem* parent_item = [tree_item parentItem];
-	if(nil == parent_item)
-	{
-		return NULL;
-	}
-	NSArray* children_array = [parent_item childrenArray];
-	IupCocoaTreeItem* next_item = [children_array firstObject];
-	int next_id = iupTreeFindNodeId(ih, (InodeHandle*)next_item);
-	return iupStrReturnInt(next_id);
-}
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  NSUInteger number_of_visible_rows = [outline_view numberOfRows];
 
-static char* cocoaTreeGetLastAttrib(Ihandle* ih, int item_id)
-{
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	IupCocoaTreeItem* parent_item = [tree_item parentItem];
-	if(nil == parent_item)
-	{
-		return NULL;
-	}
-	NSArray* children_array = [parent_item childrenArray];
-	IupCocoaTreeItem* next_item = [children_array lastObject];
-	int next_id = iupTreeFindNodeId(ih, (InodeHandle*)next_item);
-	return iupStrReturnInt(next_id);
+  if (0 == number_of_visible_rows)
+    return 0;
+
+  if (cocoaTreeSetMarkAttrib(ih, value))
+    return 0;
+
+  NSUInteger new_selected_row;
+
+  if (iupStrEqualNoCase(value, "ROOT") || iupStrEqualNoCase(value, "FIRST"))
+  {
+    new_selected_row = 0;
+    [outline_view scrollRowToVisible:0];
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:0];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "LAST"))
+  {
+    new_selected_row = number_of_visible_rows - 1;
+    [outline_view scrollRowToVisible:new_selected_row];
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "PGUP"))
+  {
+    NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+    NSUInteger selected_i = [selected_index firstIndex];
+    if (selected_i == NSNotFound)
+      return 0;
+
+    if (selected_i < 10)
+      new_selected_row = 0;
+    else
+      new_selected_row = selected_i - 10;
+
+    [outline_view scrollRowToVisible:new_selected_row];
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "PGDN"))
+  {
+    NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+    NSUInteger selected_i = [selected_index firstIndex];
+    if (selected_i == NSNotFound)
+      return 0;
+
+    if ((selected_i + 10) > (number_of_visible_rows - 1))
+      new_selected_row = number_of_visible_rows - 1;
+    else
+      new_selected_row = selected_i + 10;
+
+    [outline_view scrollRowToVisible:new_selected_row];
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "NEXT"))
+  {
+    NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+    NSUInteger selected_i = [selected_index firstIndex];
+    if (selected_i == NSNotFound)
+      return 0;
+
+    if ((selected_i + 1) > (number_of_visible_rows - 1))
+      new_selected_row = number_of_visible_rows - 1;
+    else
+      new_selected_row = selected_i + 1;
+
+    [outline_view scrollRowToVisible:new_selected_row];
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "PREVIOUS"))
+  {
+    NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+    NSUInteger selected_i = [selected_index firstIndex];
+    if (selected_i == NSNotFound)
+      return 0;
+
+    if (selected_i < 1)
+      new_selected_row = 0;
+    else
+      new_selected_row = selected_i - 1;
+
+    [outline_view scrollRowToVisible:new_selected_row];
+    NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view selectRowIndexes:index_set byExtendingSelection:NO];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+  else if (iupStrEqualNoCase(value, "CLEAR"))
+  {
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
+    [outline_view deselectAll:nil];
+    iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  }
+
+  return 0;
 }
 
-static char* cocoaTreeGetTitleAttrib(Ihandle* ih, int item_id)
+static void cocoaTreeCallNodeRemovedAll(Ihandle* ih)
 {
-//	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-//	IupCocoaTreeDelegate* data_source_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
-	
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  IFns cb = (IFns)IupGetCallback(ih, "NODEREMOVED_CB");
+  int old_count = ih->data->node_count;
 
-	if(inode_handle)
-	{
-		IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-		NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"expecting class IupCocoaTreeItem");
-		NSString* ns_title = [tree_item title];
-		return iupStrReturnStr([ns_title UTF8String]);
-	}
-	else
-	{
-		return NULL;
-	}
+  if (cb)
+  {
+    int i;
+    for (i = 0; i < ih->data->node_count; i++)
+    {
+      cb(ih, (char*)ih->data->node_cache[i].userdata);
+    }
+  }
+
+  ih->data->node_count = 0;
+  iupTreeDelFromCache(ih, 0, old_count);
 }
 
-static int cocoaTreeSetTitleAttrib(Ihandle* ih, int item_id, const char* value)
+static void cocoaTreeCallNodeRemovedRec(Ihandle* ih, IupCocoaTreeItem* tree_item, IFns cb, int* id)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	
-	if(inode_handle)
-	{
-		NSString* ns_title = @"";
-		if(value)
-		{
-			ns_title = [NSString stringWithUTF8String:value];
-		}
-		
-		IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-		NSCAssert([tree_item isKindOfClass:[IupCocoaTreeItem class]], @"expecting class IupCocoaTreeItem");
-		[tree_item setTitle:ns_title];
-		NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  int node_id = *id;
 
-		cocoaTreeReloadItem(tree_item, outline_view);
-	}
+  /* Check whether we have child items */
+  /* remove from children first */
+  for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
+  {
+    (*id)++;
+    cocoaTreeCallNodeRemovedRec(ih, a_item, cb, id);
+  }
 
-	return 0;
+  /* actually do it for the node */
+  if (cb)
+    cb(ih, (char*)ih->data->node_cache[node_id].userdata);
+
+  /* update count */
+  ih->data->node_count--;
 }
 
-
-// I think this is supposed to return the number nodes immediately under the root node (not recursive).
-static char* cocoaTreeGetRootCountAttrib(Ihandle* ih)
+static void cocoaTreeCallNodeRemoved(Ihandle* ih, IupCocoaTreeDelegate* tree_delegate, IupCocoaTreeItem* tree_item)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, 0);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	
-	
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	
-	// If this is a leaf, then there are no children to descend into and count
-	if(ITREE_LEAF == [tree_item kind])
-	{
-		return iupStrReturnInt(0);
-	}
+  IFns cb = (IFns)IupGetCallback(ih, "NODEREMOVED_CB");
+  int old_count = ih->data->node_count;
+  int id = iupTreeFindNodeId(ih, (InodeHandle*)tree_item);
+  int start_id = id;
 
-	return iupStrReturnInt((int)[[tree_item childrenArray] count]);
+  if (cb)
+    cocoaTreeCallNodeRemovedRec(ih, tree_item, cb, &id);
+  else
+  {
+    int removed_count = Helper_RecursivelyCountItems(tree_item);
+    ih->data->node_count -= removed_count;
+  }
+
+  iupTreeDelFromCache(ih, start_id, old_count - ih->data->node_count);
+  (void)tree_delegate;
 }
 
-// returns the immediate children count of the specified branch. It does not count children of child that are branches.
-static char* cocoaTreeGetChildCountAttrib(Ihandle* ih, int item_id)
+/* Load replacement default images if needed */
+/* This is primarily for consistent look across platforms */
+static void helperReplaceDefaultImages(Ihandle* ih, IupCocoaOutlineView* outline_view)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	
-	
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	
-	// If this is a leaf, then there are no children to descend into and count
-	if(ITREE_LEAF == [tree_item kind])
-	{
-		return iupStrReturnInt(0);
-	}
+  NSImage* leaf_image = nil;
+  char* leaf_img_name = iupAttribGet(ih, "IMAGELEAF");
+  if(leaf_img_name && !iupStrEqualNoCase(leaf_img_name, "IMGLEAF"))
+    leaf_image = (NSImage*)iupImageGetImage(leaf_img_name, ih, 0, NULL);
+  else
+  {
+    leaf_image = [NSImage imageNamed:NSImageNameIChatTheaterTemplate];
+    [leaf_image setSize:NSMakeSize(16, 16)];
+  }
+  [outline_view setLeafImage:leaf_image];
 
-	
-	// else we are a branch
-	int leaf_counter = 0;
-	for(IupCocoaTreeItem* a_item in [tree_item childrenArray])
-	{
-		if(ITREE_LEAF == [a_item kind])
-		{
-			leaf_counter++;
-		}
-	}
-	return iupStrReturnInt(leaf_counter);
-}
+  NSImage* collapsed_image = nil;
+  char* collapsed_img_name = iupAttribGet(ih, "IMAGEBRANCHCOLLAPSED");
+  if(collapsed_img_name && !iupStrEqualNoCase(collapsed_img_name, "IMGCOLLAPSED"))
+    collapsed_image = (NSImage*)iupImageGetImage(collapsed_img_name, ih, 0, NULL);
+  else
+  {
+    collapsed_image = [NSImage imageNamed:NSImageNameFolder];
+    [collapsed_image setSize:NSMakeSize(16, 16)];
+  }
+  [outline_view setCollapsedImage:collapsed_image];
 
-
-static char* cocoaTreeGetMarkedAttrib(Ihandle* ih, int item_id)
-{
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	// If id is empty or invalid, then the focus node is used as reference node.
-	if(NULL == inode_handle)
-	{
-		IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		if(selected_i != NSNotFound)
-		{
-			return iupStrReturnBoolean(true);
-		}
-		else
-		{
-			return iupStrReturnBoolean(false);
-		}
-	}
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	
-	NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-	NSUInteger selected_i = [selected_index firstIndex];
-	while(selected_i != NSNotFound)
-	{
-		IupCocoaTreeItem* selected_item = [outline_view itemAtRow:selected_i];
-		if([selected_item isEqual:tree_item])
-		{
-			return iupStrReturnBoolean(true);
-		}
-		// get the next index in the set
-		selected_i = [selected_index indexGreaterThanIndex:selected_i];
-	}
-	return iupStrReturnBoolean(false);
+  NSImage* expanded_image = nil;
+  char* expanded_img_name = iupAttribGet(ih, "IMAGEBRANCHEXPANDED");
+  if(expanded_img_name && !iupStrEqualNoCase(expanded_img_name, "IMGEXPANDED"))
+    expanded_image = (NSImage*)iupImageGetImage(expanded_img_name, ih, 0, NULL);
+  else
+  {
+    expanded_image = [NSImage imageNamed:NSImageNameFolder]; /* No public "Open Folder" icon, use the same for consistency */
+    [expanded_image setSize:NSMakeSize(16, 16)];
+  }
+  [outline_view setExpandedImage:expanded_image];
 }
 
-// TODO: We might need to disable selection callbacks while doing this.
-static int cocoaTreeSetMarkedAttrib(Ihandle* ih, int item_id, const char* value)
+static char* cocoaTreeGetValueAttrib(Ihandle* ih)
 {
-	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	bool should_select = iupStrBoolean(value);
-	
-	// If id is empty or invalid, then the focus node is used as reference node.
-	if(NULL == inode_handle)
-	{
-		// On Mac, our focus node is the selected node.
-		// If should_select, then it is already selected, so there is nothing to do.
-		if(should_select)
-		{
-			return 0;
-		}
-		// Otherwise, I guess we deselect it?
-		// not sure what to do with multiple selection
-		IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-		[outline_view deselectAll:nil];
-	}
-	
-	
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	NSInteger item_row = [outline_view rowForItem:tree_item];
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+  NSUInteger selected_i = [selected_index firstIndex];
 
-	iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-	if(should_select)
-	{
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:item_row];
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-	}
-	else
-	{
-		[outline_view deselectRow:item_row];
-	}
-	iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	return 0;
+  if (selected_i != NSNotFound)
+  {
+    InodeHandle* selected_item = (InodeHandle*)[outline_view itemAtRow:selected_i];
+    int object_id = iupTreeFindNodeId(ih, selected_item);
+    return iupStrReturnInt(object_id);
+  }
+  else
+  {
+    if (ih->data->node_count > 0)
+      return "0";
+    else
+      return "-1";
+  }
 }
 
-// TODO: We might need to disable selection callbacks while doing this.
-static int cocoaTreeSetMarkAttrib(Ihandle* ih, const char* value)
+static char* cocoaTreeGetToggleValueAttrib(Ihandle* ih, int item_id)
 {
-	if(ih->data->mark_mode==ITREE_MARK_SINGLE)
-	{
-		return 0;
-	}
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  if (ih->data->show_toggle < 1)
+    return NULL;
 
-	
-	if(iupStrEqualNoCase(value, "BLOCK"))
-	{
-	/*
-    GtkTreeIter iterItem1, iterItem2;
-    GtkTreePath* pathFocus;
-    gtk_tree_view_get_cursor(GTK_TREE_VIEW(ih->handle), &pathFocus, NULL);
-    gtk_tree_model_get_iter(model, &iterItem1, pathFocus);
-    gtk_tree_path_free(pathFocus);
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return NULL;
 
-    gtkTreeIterInit(ih, &iterItem2, iupAttribGet(ih, "_IUPTREE_MARKSTART_NODE"));
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  NSControlStateValue check_box_state = [tree_item checkBoxState];
+  return iupStrReturnChecked((int)check_box_state);
+}
 
-    gtkTreeSelectRange(ih, model, selection, &iterItem1, &iterItem2, 0);
-    */
-    	IupCocoaTreeItem* mark_start_node = (IupCocoaTreeItem*)iupAttribGet(ih, "_IUPTREE_MARKSTART_NODE");
-		if(nil == mark_start_node)
-		{
-			
-			return 0;
+static int cocoaTreeSetToggleValueAttrib(Ihandle* ih, int item_id, const char* value)
+{
+  if (ih->data->show_toggle < 1)
+    return 0;
 
-		}
-		// There might be a possibility that mark_start_node is not in the NSOutlineView because the user removed it, but we still have a pointer to it.
-		// So make sure it is in the tree.
-		NSInteger mark_start_node_row = [outline_view rowForItem:mark_start_node];
-		if(mark_start_node_row <= 0)
-		{
-			return 0;
-		}
-		// I don't know what the "focus" node should be if there are multiple selections.
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		if(selected_i == NSNotFound)
-		{
-			return 0;
-		}
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return 0;
 
-		if(selected_i == mark_start_node_row)
-		{
-			// only one item is needed, and it is already selected
-			return 1;
-		}
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  NSControlStateValue check_box_state;
 
-		NSUInteger start_row;
-		NSUInteger number_of_rows;
-		if(mark_start_node_row > selected_i)
-		{
-			start_row = selected_i;
-			number_of_rows = mark_start_node_row - selected_i + 1; // +1 to include the end node
-		}
-		else
-		{
-			start_row = mark_start_node_row;
-			number_of_rows = selected_i - mark_start_node_row + 1; // +1 to include the end node
-		}
+  if ((ih->data->show_toggle == 2) && iupStrEqualNoCase(value, "NOTDEF"))
+    check_box_state = NSControlStateValueMixed;
+  else if (iupStrEqualNoCase(value, "ON"))
+    check_box_state = NSControlStateValueOn;
+  else if (iupStrEqualNoCase(value, "OFF"))
+    check_box_state = NSControlStateValueOff;
+  else
+    return 0;
 
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(start_row, number_of_rows)];
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+  [tree_item setCheckBoxState:check_box_state];
 
-	}
-	else if(iupStrEqualNoCase(value, "CLEARALL"))
-	{
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view deselectAll:nil];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if(iupStrEqualNoCase(value, "MARKALL"))
-	{
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view selectAll:nil];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if(iupStrEqualNoCase(value, "INVERTALL")) /* INVERTALL *MUST* appear before INVERT, or else INVERTALL will never be called. */
-	{
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		[outline_view selectAll:nil];
-		NSUInteger selected_i = [selected_index firstIndex];
-		while(selected_i != NSNotFound)
-		{
-			[outline_view deselectRow:selected_i];
-			// get the next index in the set
-			selected_i = [selected_index indexGreaterThanIndex:selected_i];
-		}
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if(iupStrEqualPartial(value, "INVERT"))
-	{
-    	/* iupStrEqualPartial allows the use of "INVERTid" form */
-    	const char* id_string = &value[strlen("INVERT")];
-		InodeHandle* inode_handle = iupTreeGetNodeFromString(ih, id_string);
-		
-		// If id is empty or invalid, then the focus node is used as reference node.
-		if(NULL == inode_handle)
-		{
-			// Conundrum: if nothing is selected, there is no focus node, so there is nothing to select.
-			// Do nothing for that case, so we only worry about deselecting?
-			// Or do we select all?
-			NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-			NSUInteger selected_i = [selected_index firstIndex];
-			while(selected_i != NSNotFound)
-			{
-				[outline_view deselectRow:selected_i];
-				// get the next index in the set
-				selected_i = [selected_index indexGreaterThanIndex:selected_i];
-			}
-		}
-		else
-		{
-		
-			IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-			NSInteger item_row = [outline_view rowForItem:tree_item];
-			bool was_item_selected = false;
-			NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-			NSUInteger selected_i = [selected_index firstIndex];
-			while(selected_i != NSNotFound)
-			{
-				IupCocoaTreeItem* selected_item = [outline_view itemAtRow:selected_i];
-				if([selected_item isEqual:tree_item])
-				{
-					was_item_selected = true;
-					break;
-				}
-				// get the next index in the set
-				selected_i = [selected_index indexGreaterThanIndex:selected_i];
-			}
-			
-			iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-			if(was_item_selected)
-			{
-				[outline_view deselectRow:item_row];
-			}
-			else
-			{
-				NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:item_row];
-				[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-			}
-			iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-		}
-	}
-	else
-	{
-		// I don't know what this case is, but it was in the GTK code.
-		// This is a guess translation to Cocoa.
- 
-//		GtkTreeIter iterItem1, iterItem2;
-		char str1[50], str2[50];
-		if(iupStrToStrStr(value, str1, str2, '-') != 2)
-		{
-			return 0;
-		}
-//		if (!gtkTreeFindNodeFromString(ih, str1, &iterItem1))
-//			return 0;
-//		if (!gtkTreeFindNodeFromString(ih, str2, &iterItem2))
-//			return 0;
-//		gtkTreeSelectRange(ih, model, selection, &iterItem1, &iterItem2, 0);
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  cocoaTreeReloadItem(tree_item, outline_view);
 
-		InodeHandle* inode_handle1 = iupTreeGetNodeFromString(ih, str1);
-		InodeHandle* inode_handle2 = iupTreeGetNodeFromString(ih, str2);
-		NSInteger item_row1 = [outline_view rowForItem:inode_handle1];
-		NSInteger item_row2 = [outline_view rowForItem:inode_handle2];
+  return 0;
+}
 
-		NSUInteger start_row;
-		NSUInteger number_of_rows;
-		if(item_row2 > item_row1)
-		{
-			start_row = item_row1;
-			number_of_rows = item_row2 - item_row1 + 1; // +1 to include the end node
-		}
-		else
-		{
-			start_row = item_row2;
-			number_of_rows = item_row1 - item_row2 + 1; // +1 to include the end node
-		}
+static char* cocoaTreeGetToggleVisibleAttrib(Ihandle* ih, int item_id)
+{
+  if (ih->data->show_toggle < 1)
+    return NULL;
 
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(start_row, number_of_rows)];
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return NULL;
 
-	return 1;
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  bool check_box_hidden = [tree_item isCheckBoxHidden];
+  return iupStrReturnBoolean((int)!check_box_hidden);
 }
 
-static int cocoaTreeSetMarkStartAttrib(Ihandle* ih, const char* value)
+static int cocoaTreeSetToggleVisibleAttrib(Ihandle* ih, int item_id, const char* value)
 {
-	InodeHandle* inode_handle = iupTreeGetNodeFromString(ih, value);
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	if(NULL == inode_handle)
-	{
-		[outline_view setMarkStartNode:nil];
-		return 0;
-	}
-	
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  if (ih->data->show_toggle < 1)
+    return 0;
 
-	// I'm concerned about dangling pointers or memory leaks.
-	// Because we are keeping a raw pointer indefinately, it could go away and we are left with a dangling pointer.
-	// We could retain it, but we need to be sure to release it.
-	// An alternative solution is to use a weak reference that automatically nils when the object is dealloc'd.
-	// Unfortunately, I think zeroing weak references are only available with ARC.
-	// So we will ratain it in the outline_view so it should be released when the outline_view goes away in the worse case.
-	[outline_view setMarkStartNode:tree_item];
-	iupAttribSet(ih, "_IUPTREE_MARKSTART_NODE", (char*)tree_item);
+  InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
+  if (NULL == inode_handle)
+    return 0;
 
-	return 1;
-}
+  IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+  bool check_box_hidden = !iupStrBoolean(value);
 
-static char* cocoaTreeGetMarkedNodesAttrib(Ihandle* ih)
-{
-	char* str = iupStrGetMemory(ih->data->node_count+1);
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  [tree_item setCheckBoxHidden:check_box_hidden];
 
-	NSIndexSet* selected_index = [outline_view selectedRowIndexes];
+  /* Reload the item to reflect the change in visibility. */
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  cocoaTreeReloadItem(tree_item, outline_view);
 
-	// This is O(n^2).
-	// Iterate through all the nodes,
-	// 		foreach node, check the entire set of selected nodes to learn if it is selected
-	for(size_t i=0; i<ih->data->node_count; i++)
-	{
-		IupCocoaTreeItem* iter_node = (IupCocoaTreeItem*)ih->data->node_cache[i].node_handle;
-		
-		NSUInteger selected_i = [selected_index firstIndex];
-		bool is_found = false;
-		while(selected_i != NSNotFound)
-		{
-			IupCocoaTreeItem* selected_item = (IupCocoaTreeItem*)[outline_view itemAtRow:selected_i];
-			if([iter_node isEqual:selected_item])
-			{
-				is_found = true;
-				break;
-			}
-			// get the next index in the set
-			selected_i = [selected_index indexGreaterThanIndex:selected_i];
-		}
-		if(is_found)
-		{
-			str[i] = '+';
-		}
-		else
-		{
-			str[i] = '-';
-		}
-	}
-	str[ih->data->node_count] = 0;
-	return str;
+  return 0;
 }
 
-static int cocoaTreeSetMarkedNodesAttrib(Ihandle* ih, const char* value)
+static int cocoaTreeSetDelNodeAttrib(Ihandle* ih, int id, const char* value)
 {
-	int count;
+  if (!ih->handle)
+    return 0;
 
-	if(ih->data->mark_mode==ITREE_MARK_SINGLE || !value)
-	{
-		return 0;
-	}
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
 
-	count = (int)strlen(value);
-	if(count > ih->data->node_count)
-	{
-		count = ih->data->node_count;
-	}
+  if (iupStrEqualNoCase(value, "ALL"))
+  {
+    cocoaTreeCallNodeRemovedAll(ih);
+    [tree_delegate removeAllObjects];
+    [outline_view reloadData];
+    return 0;
+  }
 
+  if (iupStrEqualNoCase(value, "SELECTED"))
+  {
+    InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+    if (!inode_handle)
+      return 0;
 
-	iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-	
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	[outline_view deselectAll:nil];
+    IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+    cocoaTreeCallNodeRemoved(ih, tree_delegate, tree_item);
+    [tree_delegate removeItem:tree_item];
+    [outline_view reloadData];
+  }
+  else if (iupStrEqualNoCase(value, "CHILDREN"))
+  {
+    InodeHandle* inode_handle = iupTreeGetNode(ih, id);
+    if (!inode_handle)
+      return 0;
 
-	for(int i=0; i<count; i++)
-	{
-		if(value[i] == '+')
-		{
-			IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)ih->data->node_cache[i].node_handle;
-			NSInteger item_row = [outline_view rowForItem:tree_item];
-			NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:item_row];
-			[outline_view selectRowIndexes:index_set byExtendingSelection:YES];
-		}
-	}
+    IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
+    NSIndexSet* removed_indexes = [tree_delegate removeAllChildrenForItem:tree_item];
 
-	iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
+    if (removed_indexes)
+    {
+      [outline_view removeItemsAtIndexes:removed_indexes inParent:tree_item withAnimation:NSTableViewAnimationEffectFade];
 
-	return 0;
+      NSMutableArray* children_array = [tree_item childrenArray];
+      for (IupCocoaTreeItem* child_item in children_array)
+      {
+        cocoaTreeCallNodeRemoved(ih, tree_delegate, child_item);
+      }
+    }
+  }
+  else if (iupStrEqualNoCase(value, "MARKED"))
+  {
+    NSIndexSet* selected_indexes = [outline_view selectedRowIndexes];
+    NSMutableArray* items_to_remove = [NSMutableArray array];
+
+    [selected_indexes enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
+IupCocoaTreeItem* item = [outline_view itemAtRow:idx];
+if (item)
+  [items_to_remove addObject:item];
+    }];
+
+    for (IupCocoaTreeItem* item in items_to_remove)
+    {
+      cocoaTreeCallNodeRemoved(ih, tree_delegate, item);
+      [tree_delegate removeItem:item];
+    }
+
+    [outline_view reloadData];
+  }
+
+  return 0;
 }
 
-
-static int cocoaTreeSetTopItemAttrib(Ihandle* ih, const char* value)
+static int cocoaTreeSetMoveNodeAttrib(Ihandle* ih, int id, const char* value)
 {
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	InodeHandle* inode_handle = iupTreeGetNodeFromString(ih, value);
-	if(nil == inode_handle)
-	{
-		return 0;
-	}
+  if (!ih->handle)
+    return 0;
 
-	// First, make sure all the parent nodes that contain this item are expanded.
-	// WATCH OUT: Apple ignores expanding nodes where the parent is collapsed.
-	// So even though we need to go bottom-up to find all the parents,
-	// we must then go top-down to expand all the nodes.
-	// Use a temporary array to store all the parents
-	{
-		NSMutableArray<IupCocoaTreeItem*>* parent_node_array = [[NSMutableArray alloc] initWithCapacity:ih->data->node_count];
-		{
-			IupCocoaTreeItem* parent_tree_item = [(IupCocoaTreeItem*)inode_handle parentItem];
-			while(parent_tree_item != nil)
-			{
-				// NOTE: I could check for isExpandable: and isItemExpanded:,
-				// but I have become distrustful of this information with collapsed parents.
-				// So I'm just going to always expand every parent.
-				[parent_node_array insertObject:parent_tree_item atIndex:0];
-				parent_tree_item = [parent_tree_item parentItem];
-			}
-		}
-		for(IupCocoaTreeItem* a_item in parent_node_array)
-		{
-			// NOTE: I could check for isExpandable: and isItemExpanded:,
-			// but I have become distrustful of this information with collapsed parents.
-			// So I'm just going to always expand every parent.
-			[outline_view expandItem:a_item];
-		}
-		[parent_node_array release];
-	}
+  InodeHandle* src_handle = iupTreeGetNode(ih, id);
+  if (!src_handle)
+    return 0;
 
-	// Now scroll to the item
-	NSInteger item_row = [outline_view rowForItem:inode_handle];
-	if(item_row < 0)
-	{
-		return 0;
-	}
-	[outline_view scrollRowToVisible:item_row];
+  InodeHandle* dst_handle = iupTreeGetNodeFromString(ih, value);
+  if (!dst_handle)
+    return 0;
 
-	return 0;
+  IupCocoaTreeItem* src_item = (IupCocoaTreeItem*)src_handle;
+  IupCocoaTreeItem* dst_item = (IupCocoaTreeItem*)dst_handle;
+
+  IupCocoaTreeItem* parent = dst_item;
+  while (parent != nil)
+  {
+    if (parent == src_item)
+      return 0;
+    parent = [parent parentItem];
+  }
+
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+
+  IupCocoaTreeItem* dst_parent = [dst_item parentItem];
+  NSInteger dst_index = 0;
+
+  if ([dst_item kind] == ITREE_BRANCH && [outline_view isItemExpanded:dst_item])
+  {
+    dst_parent = dst_item;
+    dst_index = 0;
+  }
+  else if (dst_parent)
+  {
+    NSArray* siblings = [dst_parent childrenArray];
+    dst_index = [siblings indexOfObject:dst_item] + 1;
+  }
+  else
+  {
+    NSArray* roots = [tree_delegate treeRootTopLevelObjects];
+    dst_index = [roots indexOfObject:dst_item] + 1;
+  }
+
+  helperMoveNode((IupCocoaOutlineView*)outline_view, src_item, dst_parent, dst_index);
+
+  return 0;
 }
 
-static int cocoaTreeSetValueAttrib(Ihandle* ih, const char* value)
+static int cocoaTreeSetCopyNodeAttrib(Ihandle* ih, int id, const char* value)
 {
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	NSUInteger number_of_visible_rows = [outline_view numberOfRows];
-	
-	if(0 == number_of_visible_rows)
-	{
-		return 0;
-	}
+  if (!ih->handle)
+    return 0;
 
-	NSUInteger new_selected_row;
-	
+  InodeHandle* src_handle = iupTreeGetNode(ih, id);
+  if (!src_handle)
+    return 0;
 
+  InodeHandle* dst_handle = iupTreeGetNodeFromString(ih, value);
+  if (!dst_handle)
+    return 0;
 
-	if(iupStrEqualNoCase(value, "ROOT") || iupStrEqualNoCase(value, "FIRST"))
-	{
-		new_selected_row = 0;
-		[outline_view scrollRowToVisible:0];
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:0];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-	}
-	else if(iupStrEqualNoCase(value, "LAST"))
-	{
-		new_selected_row = number_of_visible_rows-1;
-		[outline_view scrollRowToVisible:new_selected_row];
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if(iupStrEqualNoCase(value, "PGUP"))
-	{
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		if(selected_i == NSNotFound)
-		{
-			return 0;
-		}
-		if(selected_i < 10)
-		{
-			new_selected_row = 0;
-		}
-		else
-		{
-			new_selected_row = selected_i - 10;
-		}
-		[outline_view scrollRowToVisible:new_selected_row];
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if(iupStrEqualNoCase(value, "PGDN"))
-	{
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		if(selected_i == NSNotFound)
-		{
-			return 0;
-		}
-		if((selected_i+10) > (number_of_visible_rows-1))
-		{
-			new_selected_row = number_of_visible_rows-1;
-		}
-		else
-		{
-			new_selected_row = selected_i+10;
-		}
-		[outline_view scrollRowToVisible:new_selected_row];
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if(iupStrEqualNoCase(value, "NEXT"))
-	{
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		if(selected_i == NSNotFound)
-		{
-			return 0;
-		}
-		if((selected_i+1) > (number_of_visible_rows-1))
-		{
-			new_selected_row = number_of_visible_rows-1;
-		}
-		else
-		{
-			new_selected_row = selected_i+1;
-		}
-		[outline_view scrollRowToVisible:new_selected_row];
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if(iupStrEqualNoCase(value, "PREVIOUS"))
-	{
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		if(selected_i == NSNotFound)
-		{
-			return 0;
-		}
-		if(selected_i < 1)
-		{
-			new_selected_row = 0;
-		}
-		else
-		{
-			new_selected_row = selected_i - 1;
-		}
-		[outline_view scrollRowToVisible:new_selected_row];
-		NSIndexSet* index_set = [NSIndexSet indexSetWithIndex:new_selected_row];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view selectRowIndexes:index_set byExtendingSelection:NO];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
-	else if (iupStrEqualNoCase(value, "CLEAR"))
-	{
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-		[outline_view deselectAll:nil];
-		iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
-	}
+  IupCocoaTreeItem* src_item = (IupCocoaTreeItem*)src_handle;
+  IupCocoaTreeItem* dst_item = (IupCocoaTreeItem*)dst_handle;
 
-	return 0;
+  IupCocoaTreeItem* parent = dst_item;
+  while (parent != nil)
+  {
+    if (parent == src_item)
+      return 0;
+    parent = [parent parentItem];
+  }
+
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+
+  IupCocoaTreeItem* dst_parent = [dst_item parentItem];
+  NSInteger dst_index = 0;
+
+  if ([dst_item kind] == ITREE_BRANCH && [outline_view isItemExpanded:dst_item])
+  {
+    dst_parent = dst_item;
+    dst_index = 0;
+  }
+  else if (dst_parent)
+  {
+    NSArray* siblings = [dst_parent childrenArray];
+    dst_index = [siblings indexOfObject:dst_item] + 1;
+  }
+  else
+  {
+    NSArray* roots = [tree_delegate treeRootTopLevelObjects];
+    dst_index = [roots indexOfObject:dst_item] + 1;
+  }
+
+  helperCopyAndInsertNode((IupCocoaOutlineView*)outline_view, src_item, dst_parent, dst_index, NSTableViewAnimationEffectGap);
+
+  return 0;
 }
 
+static char* cocoaTreeGetIndentationAttrib(Ihandle* ih)
+{
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  CGFloat indent = [outline_view indentationPerLevel];
+  return iupStrReturnInt((int)indent);
+}
 
-static char* cocoaTreeGetValueAttrib(Ihandle* ih)
+static int cocoaTreeSetIndentationAttrib(Ihandle* ih, const char* value)
 {
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-	NSUInteger selected_i = [selected_index firstIndex];
-	if(selected_i != NSNotFound)
-	{
-		InodeHandle* selected_item = (InodeHandle*)[outline_view itemAtRow:selected_i];
-		int object_id = iupTreeFindNodeId(ih, selected_item);
-		return iupStrReturnInt(object_id);
-	}
-	else
-	{
-		if(ih->data->node_count > 0)
-		{
-			return "0"; /* default VALUE is root */
-		}
-		else
-		{
-			return "-1";
-		}
-	}
+  int indent;
+  if (iupStrToInt(value, &indent))
+  {
+    IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+    [outline_view setIndentationPerLevel:(CGFloat)indent];
+  }
+
+  return 0;
 }
 
+static int cocoaTreeSetSpacingAttrib(Ihandle* ih, const char* value)
+{
+  iupStrToInt(value, &ih->data->spacing);
 
-static char* cocoaTreeGetToggleValueAttrib(Ihandle* ih, int item_id)
-{
-	if(ih->data->show_toggle < 1)
-	{
-		return NULL;
-	}
-  	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	// it happens that iupStrReturnChecked uses the same values for mixed, off, and on
-	NSControlStateValue check_box_state = [tree_item checkBoxState];
-	return iupStrReturnChecked((int)check_box_state);
+  if (ih->handle)
+  {
+    NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+    [outline_view reloadData];
+    return 0;
+  }
+  else
+    return 1;
 }
 
-static int cocoaTreeSetToggleValueAttrib(Ihandle* ih, int item_id, const char* value)
+static int cocoaTreeSetFgColorAttrib(Ihandle* ih, const char* value)
 {
-	if(ih->data->show_toggle < 1)
-	{
-		return 0;
-	}
-  	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return 0;
-	}
-	
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	NSControlStateValue check_box_state;
-	
-	if((ih->data->show_toggle == 2) && iupStrEqualNoCase(value, "NOTDEF"))
-	{
-		check_box_state = NSControlStateValueMixed;
-	}
-	else if(iupStrEqualNoCase(value, "ON"))
-	{
-		check_box_state = NSControlStateValueOn;
-	}
-	else if(iupStrEqualNoCase(value, "OFF"))
-	{
-		check_box_state = NSControlStateValueOff;
-	}
-	else
-	{
-		return 0;
-	}
-	
-	[tree_item setCheckBoxState:check_box_state];
+  unsigned char r, g, b;
 
-	NSTableCellView* table_cell_view = [tree_item tableCellView];
-	// Because the user might try to dynamically switch the type after creation (not allowed by spec), we should add a safety check.
-	// Also, I think it might be possible that the item is off-screen so there is no actual cell available to set
-	if((nil != table_cell_view) && [table_cell_view respondsToSelector:@selector(checkBox)])
-	{
-		IupCocoaTreeToggleTableCellView* toggle_cell_view = (IupCocoaTreeToggleTableCellView*)table_cell_view;
-		NSButton* check_box = [toggle_cell_view checkBox];
-		[check_box setState:check_box_state];
-	}
-	return 0;
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
+
+  NSColor* color = [NSColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  IupCocoaTreeDelegate* tree_delegate = (IupCocoaTreeDelegate*)[outline_view dataSource];
+
+  for (IupCocoaTreeItem* tree_item in [tree_delegate treeRootTopLevelObjects])
+  {
+    [tree_item setTextColor:color];
+  }
+
+  [outline_view reloadData];
+
+  return 1;
 }
 
-static char* cocoaTreeGetToggleVisibleAttrib(Ihandle* ih, int item_id)
+static int cocoaTreeSetHlColorAttrib(Ihandle* ih, const char* value)
 {
-	if(ih->data->show_toggle < 1)
-	{
-		return NULL;
-	}
-  	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return NULL;
-	}
-	
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	// it happens that iupStrReturnChecked uses the same values for mixed, off, and on
-	bool check_box_hidden = [tree_item isCheckBoxHidden];
-	return iupStrReturnBoolean((int)!check_box_hidden);
+  if (ih->handle)
+  {
+    /* Redraw rows to apply the new highlight color */
+    NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+    [outline_view setNeedsDisplay:YES];
+  }
+  (void)value;
+  return 1; /* Mark as stored */
 }
 
-static int cocoaTreeSetToggleVisibleAttrib(Ihandle* ih, int item_id, const char* value)
+static int cocoaTreeSetBgColorAttrib(Ihandle* ih, const char* value)
 {
-	if(ih->data->show_toggle < 1)
-	{
-		return 0;
-	}
-  	InodeHandle* inode_handle = iupTreeGetNode(ih, item_id);
-	if(NULL == inode_handle)
-	{
-		return 0;
-	}
-	
-	IupCocoaTreeItem* tree_item = (IupCocoaTreeItem*)inode_handle;
-	bool check_box_hidden = !iupStrBoolean(value);
-	
-	
-	[tree_item setCheckBoxHidden:check_box_hidden];
+  unsigned char r, g, b;
 
-	NSTableCellView* table_cell_view = [tree_item tableCellView];
-	// Because the user might try to dynamically switch the type after creation (not allowed by spec), we should add a safety check.
-	// Also, I think it might be possible that the item is off-screen so there is no actual cell available to set
-	if((nil != table_cell_view) && [table_cell_view respondsToSelector:@selector(checkBox)])
-	{
-		IupCocoaTreeToggleTableCellView* toggle_cell_view = (IupCocoaTreeToggleTableCellView*)table_cell_view;
-		NSButton* check_box = [toggle_cell_view checkBox];
-		[check_box setHidden:!check_box_hidden];
-	}
-	return 0;
-}
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
 
+  NSColor* bgcolor = [NSColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1.0];
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
 
+  [outline_view setBackgroundColor:bgcolor];
+  [outline_view setNeedsDisplay:YES];
 
+  return 1;
+}
 
 static int cocoaTreeSetExpandAllAttrib(Ihandle* ih, const char* value)
 {
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	bool should_expand = iupStrBoolean(value);
-	
-	if(should_expand)
-	{
-		// item=nil should do all root items
-		[outline_view expandItem:nil expandChildren:YES];
-	}
-	else
-	{
-		// item=nil should do all root items
-		[outline_view collapseItem:nil collapseChildren:YES];
-	}
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  bool should_expand = iupStrBoolean(value);
 
+  if (should_expand)
+    [outline_view expandItem:nil expandChildren:YES];
+  else
+    [outline_view collapseItem:nil collapseChildren:YES];
+
   return 0;
 }
 
 static int cocoaTreeSetRenameAttrib(Ihandle* ih, const char* value)
 {
-	bool show_rename = iupStrBoolean(value);
-	ih->data->show_rename = show_rename;
-	
-	// Because this is needed for Map, we might not have a handle yet
-	if(ih->handle && ih->data->show_rename)
-	{
-		NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-		
-		NSIndexSet* selected_index = [outline_view selectedRowIndexes];
-		NSUInteger selected_i = [selected_index firstIndex];
-		if(selected_i != NSNotFound)
-		{
-			id selected_item = [outline_view itemAtRow:selected_i];
-			NSTableCellView* table_cell_view = [selected_item tableCellView];
-			NSTextField* text_field = [table_cell_view textField];
-			[text_field becomeFirstResponder];
-		}
-	}
-	(void)value;
-	return 0;
+  /* This is an ACTION attribute to start editing */
+  if (ih->handle && ih->data->show_rename)
+  {
+    NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+    NSInteger selected_row = [outline_view selectedRow];
+
+    if (selected_row >= 0)
+    {
+      /* The view needs to be the first responder to begin editing */
+      [[outline_view window] makeFirstResponder:outline_view];
+      [outline_view editColumn:0 row:selected_row withEvent:nil select:YES];
+    }
+  }
+  (void)value; /* value is not used for this action */
+  return 0;
 }
 
 static int cocoaTreeSetShowRenameAttrib(Ihandle* ih, const char* value)
 {
-	bool show_rename = iupStrBoolean(value);
-	ih->data->show_rename = show_rename;
-	
-	// Because this is needed for Map, we might not have a handle yet
-	if(ih->handle)
-	{
-		NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-		// I don't know how to traverse through all active cells.
-		// Apple may only loads cells that are currently visible.
-		// It appears that reloadData triggers all the cells to be recreated so we can call setEditable there.
-		[outline_view reloadData];
-	}
-	return 0;
+  bool show_rename = iupStrBoolean(value);
+  ih->data->show_rename = show_rename;
+
+  if (ih->handle)
+  {
+    NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+    [outline_view reloadData];
+  }
+
+  return 0;
 }
 
-// TODO: Individual cells and maybe columns may be able to get their own context menus.
-// For now, we do the simple thing of applying a singular menu for the entire OutlineView.
-// Several ideas (unconfirmed):
-// - https://stackoverflow.com/questions/1309602/how-do-you-add-context-senstive-menu-to-nsoutlineview-ie-right-click-menu
-// - attach a menu to each cell view or row view
-// - override menuForEvent: in the NSOutlineView subclass
-// - 10.11 APIs? https://stackoverflow.com/questions/12494489/nstableview-right-clicked-row-index
 static int cocoaTreeSetContextMenuAttrib(Ihandle* ih, const char* value)
 {
-	Ihandle* menu_ih = (Ihandle*)value;
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	iupCocoaCommonBaseSetContextMenuForWidget(ih, outline_view, menu_ih);
-	return 1;
+  Ihandle* menu_ih = (Ihandle*)value;
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  iupcocoaCommonBaseSetContextMenuForWidget(ih, outline_view, menu_ih);
+
+  /* Record that the user explicitly set this attribute, even if to NULL. */
+  iupAttribSet(ih, "_IUPCOCOA_CONTEXTMENU_SET", "1");
+
+  return 1;
 }
 
 static char* cocoaTreeGetLayerBackedAttrib(Ihandle* ih)
 {
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	BOOL layer_state = [outline_view wantsLayer];
-	return iupStrReturnInt(layer_state);
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  BOOL layer_state = [outline_view wantsLayer];
+  return iupStrReturnInt(layer_state);
 }
 
 static int cocoaTreeSetLayerBackedAttrib(Ihandle* ih, const char* value)
 {
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	bool layer_state = iupStrBoolean(value);
-	[outline_view setWantsLayer:layer_state];
-	[cocoaTreeGetRootView(ih) setWantsLayer:layer_state];
-	[cocoaTreeGetOutlineView(ih) setWantsLayer:layer_state];
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  bool layer_state = iupStrBoolean(value);
+  [outline_view setWantsLayer:layer_state];
+  [cocoaTreeGetScrollView(ih) setWantsLayer:layer_state];
 
-	return 1;
+  return 1;
 }
 
-
 static char* cocoaTreeGetActiveAttrib(Ihandle *ih)
 {
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
-	BOOL was_enabled = [outline_view isEnabled];
-	return iupStrReturnBoolean(was_enabled);
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  BOOL was_enabled = [outline_view isEnabled];
+  return iupStrReturnBoolean(was_enabled);
 }
 
-
 static int cocoaTreeSetActiveAttrib(Ihandle* ih, const char* value)
 {
-	bool enable = iupStrBoolean(value);
-	NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  bool enable = iupStrBoolean(value);
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
 
-	BOOL was_enabled = [outline_view isEnabled];
-	if(was_enabled == enable)
-	{
-		return 0;
-	}
-	[outline_view setEnabled:enable];
-	[outline_view reloadData];
+  BOOL was_enabled = [outline_view isEnabled];
+  if (was_enabled == enable)
+    return 0;
 
-	
-	return 0;
+  [outline_view setEnabled:enable];
+  [outline_view reloadData];
+
+  return 0;
 }
 
+static char* cocoaTreeGetScrollVisibleAttrib(Ihandle* ih)
+{
+  NSScrollView* scroll_view = cocoaTreeGetScrollView(ih);
+  NSScroller* scroller_h = [scroll_view horizontalScroller];
+  NSScroller* scroller_v = [scroll_view verticalScroller];
 
+  int scroll_visible = 0;
+
+  if (scroller_h && ![scroller_h isHidden])
+    scroll_visible |= 1;
+  if (scroller_v && ![scroller_v isHidden])
+    scroll_visible |= 2;
+
+  if (scroll_visible == 3)
+    return "YES";
+  else if (scroll_visible == 1)
+    return "HORIZONTAL";
+  else if (scroll_visible == 2)
+    return "VERTICAL";
+  else
+    return "NO";
+}
+
+static int cocoaTreeSetTipAttrib(Ihandle* ih, const char* value)
+{
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+
+  if (value)
+    [outline_view setToolTip:[NSString stringWithUTF8String:value]];
+  else
+    [outline_view setToolTip:nil];
+
+  return 1;
+}
+
+static char* cocoaTreeGetTipAttrib(Ihandle* ih)
+{
+  NSOutlineView* outline_view = cocoaTreeGetOutlineView(ih);
+  NSString* tip = [outline_view toolTip];
+
+  if (tip)
+    return iupStrReturnStr([tip UTF8String]);
+
+  return NULL;
+}
+
+static int cocoaTreeSetHideLinesAttrib(Ihandle* ih, const char* value)
+{
+  /* NSOutlineView does not draw connecting lines between nodes like GTK TreeView. */
+  (void)ih;
+  (void)value;
+  return 0;
+}
+
+static int cocoaTreeSetHideButtonsAttrib(Ihandle* ih, const char* value)
+{
+  /* NSOutlineView does not provide a straightforward way to hide disclosure triangles. */
+  (void)ih;
+  (void)value;
+  return 0;
+}
+
 static int cocoaTreeMapMethod(Ihandle* ih)
 {
-	NSBundle* framework_bundle = [NSBundle bundleWithIdentifier:@"br.puc-rio.tecgraf.iup"];
-	
-	NSNib* outline_nib = nil;
-	
-	// 0 for no toggle, 1 for toggle, 2 for toggle with 3-state
-	if(ih->data->show_toggle > 0)
-	{
-		outline_nib = [[NSNib alloc] initWithNibNamed:@"IupCocoaOutlineViewToggle" bundle:framework_bundle];
-	}
-	else
-	{
-		outline_nib = [[NSNib alloc] initWithNibNamed:@"IupCocoaOutlineView" bundle:framework_bundle];
-	}
+  NSNib* outline_nib = nil;
 
-	
-	NSArray* top_level_objects = nil;
-	
-	
-	IupCocoaOutlineView* outline_view = nil;
-	NSScrollView* scroll_view = nil;
-	
-	if([outline_nib instantiateWithOwner:nil topLevelObjects:&top_level_objects])
-	{
-		for(id current_object in top_level_objects)
-		{
+  if (ih->data->show_toggle > 0)
+    outline_nib = [NSNib IupCocoaOutlineViewToggle];
+  else
+    outline_nib = [NSNib IupCocoaOutlineView];
 
-			if([current_object isKindOfClass:[NSScrollView class]])
-			{
-				scroll_view = current_object;
-				break;
-			}
-		}
-	}
-	
-	outline_view = (IupCocoaOutlineView*)[scroll_view documentView];
-	NSCAssert([outline_view isKindOfClass:[IupCocoaOutlineView class]], @"Expected IupCocoaOutlineView");
-	
-	// ScrollView is expected to hold on to all the other objects we need
-	[scroll_view retain];
-	[outline_nib release];
-	
-	// We need a way to get the ih during Cocoa callbacks, such as for selection changed notifications.
-	[outline_view setIh:ih];
+  NSArray* top_level_objects = nil;
+  IupCocoaOutlineView* outline_view = nil;
+  NSScrollView* scroll_view = nil;
 
+  if ([outline_nib instantiateWithOwner:nil topLevelObjects:&top_level_objects])
+  {
+    for (id current_object in top_level_objects)
+    {
+      if ([current_object isKindOfClass:[NSScrollView class]])
+      {
+        scroll_view = current_object;
+        break;
+      }
+    }
+  }
 
-	IupCocoaTreeDelegate* tree_delegate = nil;
-	// This line is not working. (Why not?) Use ih->data->show_dragdrop instead.
-//	if(iupAttribGetInt(ih, "SHOWDRAGDROP")==1)
-	if(ih->data->show_dragdrop || IupGetInt(ih, "DRAGDROPTREE"))
-	{
-		tree_delegate = [[IupCocoaTreeDragDropDelegate alloc] init];
-	}
-	else
-	{
-		tree_delegate = [[IupCocoaTreeDelegate alloc] init];
+  outline_view = (IupCocoaOutlineView*)[scroll_view documentView];
+  NSCAssert([outline_view isKindOfClass:[IupCocoaOutlineView class]], @"Expected IupCocoaOutlineView");
 
-	}
-	
-	[outline_view setDataSource:tree_delegate];
-	[outline_view setDelegate:tree_delegate];
-	
+  [scroll_view retain];
 
-	
-	// We're going to use OBJC_ASSOCIATION_RETAIN because I do believe it will do the right thing for us.
-	// I'm attaching to the scrollview instead of the outline view because I'm a little worried about circular references and I'm hoping this helps a little
-	objc_setAssociatedObject(scroll_view, IUP_COCOA_TREE_DELEGATE_OBJ_KEY, (id)tree_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
-	[tree_delegate release];
-	
-	ih->handle = scroll_view;
-	iupCocoaSetAssociatedViews(ih, outline_view, scroll_view);
+  [outline_view setIh:ih];
 
-	
-	
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
-	
-	
-	
-	// turn off the header
-	[outline_view setHeaderView:nil];
+  IupCocoaTreeDragDropDelegate* tree_delegate = [[IupCocoaTreeDragDropDelegate alloc] init];
 
-	/* Initialize the default images */
-	NSImage* leaf_image = iupImageGetImage(iupAttribGetStr(ih, "IMAGELEAF"), ih, 0, NULL);
-//	NSImage* collapsed_image = iupImageGetImage(iupAttribGetStr(ih, "IMAGEBRANCHCOLLAPSED"), ih, 0);
-//	NSImage* expanded_image = iupImageGetImage(iupAttribGetStr(ih, "IMAGEBRANCHEXPANDED"), ih, 0);
+  [outline_view setDataSource:tree_delegate];
+  [outline_view setDelegate:tree_delegate];
 
+  objc_setAssociatedObject(scroll_view, IUP_COCOA_TREE_DELEGATE_OBJ_KEY, (id)tree_delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  [tree_delegate release];
 
+  ih->handle = scroll_view;
+  iupcocoaSetAssociatedViews(ih, outline_view, scroll_view);
 
+  iupcocoaAddToParent(ih);
 
-	[outline_view setLeafImage:leaf_image];
+  [outline_view setHeaderView:nil];
 
-#if 1
-	helperReplaceDefaultImages(ih, outline_view);
-#else
-	NSImage* collapsed_image = [NSImage imageNamed:NSImageNameFolder];
-//	NSImage* expanded_image = [NSImage imageNamed:NSImageNameFolder];
-	NSImage* expanded_image = collapsed_image;
-	
-	[outline_view setCollapsedImage:collapsed_image];
-	[outline_view setExpandedImage:expanded_image];
-#endif
+  if (iupAttribGetBoolean(ih, "HIDELINES"))
+  {
+    /* NSOutlineView does not draw lines by default */
+  }
 
-	if (iupAttribGetInt(ih, "ADDROOT"))
-	{
-		iupdrvTreeAddNode(ih, -1, ITREE_BRANCH, "", 0);
-	}
-	
-	/* configure for DRAG&DROP of files */
-	if (IupGetCallback(ih, "DROPFILES_CB"))
-	{
-		iupAttribSet(ih, "DROPFILESTARGET", "YES");
-	}
-	
-//	IupSetCallback(ih, "_IUP_XY2POS_CB", (Icallback)cocoaTreeConvertXYToPos);
-	
-	iupdrvTreeUpdateMarkMode(ih);
+  if (iupAttribGetBoolean(ih, "HIDEBUTTONS"))
+  {
+    /* NSOutlineView disclosure triangles cannot be easily hidden */
+  }
 
-	
-	
-	// Registering a custom type so we can do internal drag-and-drop (reordering)
-	[outline_view registerForDraggedTypes:[NSArray arrayWithObjects:IUPCOCOA_OUTLINEVIEW_DRAGANDDROP_TYPE, nil]];
+  NSImage* leaf_image = iupImageGetImage(iupAttribGetStr(ih, "IMAGELEAF"), ih, 0, NULL);
+  [outline_view setLeafImage:leaf_image];
 
-	
-	
-	return IUP_NOERROR;
+  helperReplaceDefaultImages(ih, outline_view);
+
+  if (iupAttribGetInt(ih, "ADDROOT"))
+    iupdrvTreeAddNode(ih, -1, ITREE_BRANCH, "", 0);
+
+  if (IupGetCallback(ih, "DROPFILES_CB"))
+    iupAttribSet(ih, "DROPFILESTARGET", "YES");
+
+  iupdrvTreeUpdateMarkMode(ih);
+
+  cocoaTreeUpdateDragDrop(ih);
+
+  if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+  {
+    [outline_view setRefusesFirstResponder:YES];
+    iupcocoaSetCanFocus(ih, 0);
+  }
+  else
+  {
+    iupcocoaSetCanFocus(ih, 1);
+  }
+
+  return IUP_NOERROR;
 }
 
 static void cocoaTreeUnMapMethod(Ihandle* ih)
 {
-	id root_view = ih->handle;
-	
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
+  id root_view = ih->handle;
 
+  {
+    Ihandle* context_menu_ih = (Ihandle*)iupcocoaCommonBaseGetContextMenuAttrib(ih);
+    if (NULL != context_menu_ih)
+    {
+      IupDestroy(context_menu_ih);
+    }
+    iupcocoaCommonBaseSetContextMenuAttrib(ih, NULL);
+  }
 
-	IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
-	[outline_view setMarkStartNode:nil];
+  IupCocoaOutlineView* outline_view = (IupCocoaOutlineView*)cocoaTreeGetOutlineView(ih);
+  [outline_view setMarkStartNode:nil];
+  [outline_view setDataSource:nil];
+  [outline_view setDelegate:nil];
 
+  NSScrollView* scroll_view = (NSScrollView*)root_view;
+  objc_setAssociatedObject(scroll_view, IUP_COCOA_TREE_DELEGATE_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	iupCocoaRemoveFromParent(ih);
-	[root_view release];
-	ih->handle = NULL;
+  iupcocoaSetAssociatedViews(ih, nil, nil);
+  iupcocoaRemoveFromParent(ih);
+  [root_view release];
+  ih->handle = NULL;
 }
 
+void iupdrvTreeInitClass(Iclass* ic)
+{
+  /* Driver Dependent Class functions */
+  ic->Map = cocoaTreeMapMethod;
+  ic->UnMap = cocoaTreeUnMapMethod;
 
+  /* Visual */
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, cocoaTreeSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaTreeSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTFGCOLOR", IUPAF_DEFAULT);
 
+  /* IupTree Attributes - GENERAL */
+  iupClassRegisterAttribute(ic, "EXPANDALL", NULL, cocoaTreeSetExpandAllAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "INDENTATION", cocoaTreeGetIndentationAttrib, cocoaTreeSetIndentationAttrib, NULL, NULL, IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "SPACING", iupTreeGetSpacingAttrib, cocoaTreeSetSpacingAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED);
+  iupClassRegisterAttribute(ic, "TOPITEM", NULL, cocoaTreeSetTopItemAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 
-void iupdrvTreeInitClass(Iclass* ic)
-{
-	/* Driver Dependent Class functions */
-	ic->Map = cocoaTreeMapMethod;
-	ic->UnMap = cocoaTreeUnMapMethod;
-#if 0
-	
-	/* Visual */
-	iupClassRegisterAttribute(ic, "BGCOLOR", NULL, cocoaTreeSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTBGCOLOR", IUPAF_DEFAULT);
-	iupClassRegisterAttribute(ic, "FGCOLOR", NULL, cocoaTreeSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "TXTFGCOLOR", IUPAF_DEFAULT);
-#endif
-	/* IupTree Attributes - GENERAL */
-	iupClassRegisterAttribute(ic, "EXPANDALL", NULL, cocoaTreeSetExpandAllAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-#if 0
-	iupClassRegisterAttribute(ic, "INDENTATION", cocoaTreeGetIndentationAttrib, cocoaTreeSetIndentationAttrib, NULL, NULL, IUPAF_DEFAULT);
-	iupClassRegisterAttribute(ic, "SPACING", iupTreeGetSpacingAttrib, cocoaTreeSetSpacingAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED);
-#endif
-	iupClassRegisterAttribute(ic, "TOPITEM", NULL, cocoaTreeSetTopItemAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", cocoaTreeGetScrollVisibleAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
 
-	/* IupTree Attributes - IMAGES */
-	iupClassRegisterAttributeId(ic, "IMAGE", NULL, cocoaTreeSetImageAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "IMAGEEXPANDED", NULL, cocoaTreeSetImageExpandedAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	
-	iupClassRegisterAttribute(ic, "IMAGELEAF",            NULL, cocoaTreeSetImageLeafAttrib, IUPAF_SAMEASSYSTEM, "IMGLEAF", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "IMAGEBRANCHCOLLAPSED", NULL, cocoaTreeSetImageBranchCollapsedAttrib, IUPAF_SAMEASSYSTEM, "IMGCOLLAPSED", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "IMAGEBRANCHEXPANDED",  NULL, cocoaTreeSetImageBranchExpandedAttrib, IUPAF_SAMEASSYSTEM, "IMGEXPANDED", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
+  /* IupTree Attributes - IMAGES */
+  iupClassRegisterAttributeId(ic, "IMAGE", NULL, cocoaTreeSetImageAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "IMAGEEXPANDED", NULL, cocoaTreeSetImageExpandedAttrib, IUPAF_IHANDLENAME|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 
+  iupClassRegisterAttribute(ic, "IMAGELEAF", NULL, cocoaTreeSetImageLeafAttrib, IUPAF_SAMEASSYSTEM, "IMGLEAF", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMAGEBRANCHCOLLAPSED", NULL, cocoaTreeSetImageBranchCollapsedAttrib, IUPAF_SAMEASSYSTEM, "IMGCOLLAPSED", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMAGEBRANCHEXPANDED", NULL, cocoaTreeSetImageBranchExpandedAttrib, IUPAF_SAMEASSYSTEM, "IMGEXPANDED", IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
 
-	/* IupTree Attributes - NODES */
-	iupClassRegisterAttributeId(ic, "STATE",  cocoaTreeGetStateAttrib,  cocoaTreeSetStateAttrib, IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "DEPTH",  cocoaTreeGetDepthAttrib,  NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "KIND",   cocoaTreeGetKindAttrib,   NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "PARENT", cocoaTreeGetParentAttrib, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "NEXT", cocoaTreeGetNextAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "LAST", cocoaTreeGetLastAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "PREVIOUS", cocoaTreeGetPreviousAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "FIRST", cocoaTreeGetFirstAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
- #if 0
-	iupClassRegisterAttributeId(ic, "COLOR",  cocoaTreeGetColorAttrib,  cocoaTreeSetColorAttrib, IUPAF_NO_INHERIT);
-#endif
-	
-	iupClassRegisterAttributeId(ic, "TITLE",  cocoaTreeGetTitleAttrib,  cocoaTreeSetTitleAttrib, IUPAF_NO_INHERIT);
-	
-	iupClassRegisterAttributeId(ic, "TOGGLEVALUE", cocoaTreeGetToggleValueAttrib, cocoaTreeSetToggleValueAttrib, IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "TOGGLEVISIBLE", cocoaTreeGetToggleVisibleAttrib, cocoaTreeSetToggleVisibleAttrib, IUPAF_NO_INHERIT);
+  /* IupTree Attributes - NODES */
+  iupClassRegisterAttributeId(ic, "STATE", cocoaTreeGetStateAttrib,  cocoaTreeSetStateAttrib, IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "DEPTH", cocoaTreeGetDepthAttrib,  NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "KIND", cocoaTreeGetKindAttrib,   NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "PARENT", cocoaTreeGetParentAttrib, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "NEXT", cocoaTreeGetNextAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "LAST", cocoaTreeGetLastAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "PREVIOUS", cocoaTreeGetPreviousAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "FIRST", cocoaTreeGetFirstAttrib, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "COLOR", cocoaTreeGetColorAttrib, cocoaTreeSetColorAttrib, IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "TITLE", cocoaTreeGetTitleAttrib,  cocoaTreeSetTitleAttrib, IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "TOGGLEVALUE", cocoaTreeGetToggleValueAttrib, cocoaTreeSetToggleValueAttrib, IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "TOGGLEVISIBLE", cocoaTreeGetToggleVisibleAttrib, cocoaTreeSetToggleVisibleAttrib, IUPAF_NO_INHERIT);
 
-	/* Change the set method for Cocoa */
-	iupClassRegisterReplaceAttribFunc(ic, "SHOWRENAME", NULL, cocoaTreeSetShowRenameAttrib);
+  iupClassRegisterReplaceAttribFunc(ic, "SHOWRENAME", NULL, cocoaTreeSetShowRenameAttrib);
 
-	iupClassRegisterAttribute(ic, "ROOTCOUNT", cocoaTreeGetRootCountAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "CHILDCOUNT", cocoaTreeGetChildCountAttrib, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
-#if 0
-	iupClassRegisterAttributeId(ic, "TITLEFONT",  cocoaTreeGetTitleFontAttrib,  cocoaTreeSetTitleFontAttrib, IUPAF_NO_INHERIT);
-#endif
+  iupClassRegisterAttribute(ic, "ROOTCOUNT", cocoaTreeGetRootCountAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "CHILDCOUNT", cocoaTreeGetChildCountAttrib, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "TITLEFONT", cocoaTreeGetTitleFontAttrib,  cocoaTreeSetTitleFontAttrib, IUPAF_NO_INHERIT);
 
-	/* IupTree Attributes - MARKS */
-	iupClassRegisterAttributeId(ic, "MARKED", cocoaTreeGetMarkedAttrib, cocoaTreeSetMarkedAttrib, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute  (ic, "MARK",      NULL, cocoaTreeSetMarkAttrib,      NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute  (ic, "STARTING",  NULL, cocoaTreeSetMarkStartAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute  (ic, "MARKSTART", NULL, cocoaTreeSetMarkStartAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  /* IupTree Attributes - MARKS */
+  iupClassRegisterAttributeId(ic, "MARKED", cocoaTreeGetMarkedAttrib, cocoaTreeSetMarkedAttrib, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute  (ic, "MARK",      NULL, cocoaTreeSetMarkAttrib,      NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute  (ic, "STARTING",  NULL, cocoaTreeSetMarkStartAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute  (ic, "MARKSTART", NULL, cocoaTreeSetMarkStartAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute  (ic, "MARKEDNODES", cocoaTreeGetMarkedNodesAttrib, cocoaTreeSetMarkedNodesAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 
-	iupClassRegisterAttribute  (ic, "MARKEDNODES", cocoaTreeGetMarkedNodesAttrib, cocoaTreeSetMarkedNodesAttrib, NULL, NULL, IUPAF_NO_SAVE|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-#if 0
-	iupClassRegisterAttribute(ic, "MARKWHENTOGGLE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-#endif
+  iupClassRegisterAttribute(ic, "MARKWHENTOGGLE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 
-	iupClassRegisterAttribute  (ic, "VALUE", cocoaTreeGetValueAttrib, cocoaTreeSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute  (ic, "VALUE", cocoaTreeGetValueAttrib, cocoaTreeSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 
-	// The default implementation does a bunch of things that I don't think do anything useful for Cocoa. So I'm overriding/disabling the default implementation.
-//	iupClassRegisterAttribute(ic, "DRAGDROPTREE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-	iupClassRegisterReplaceAttribFunc(ic, "DRAGDROPTREE", NULL, NULL);
+  /* IupTree Attributes - ACTION */
+  iupClassRegisterAttributeId(ic, "DELNODE", NULL, cocoaTreeSetDelNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "RENAME", NULL, cocoaTreeSetRenameAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "MOVENODE", NULL, cocoaTreeSetMoveNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
+  iupClassRegisterAttributeId(ic, "COPYNODE", NULL, cocoaTreeSetCopyNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
 
-	iupClassRegisterReplaceAttribFunc(ic, "ACTIVE", cocoaTreeGetActiveAttrib, cocoaTreeSetActiveAttrib);
+  /* IupTree Attributes - macOS specific */
+  iupClassRegisterAttribute(ic, "RUBBERBAND", NULL, NULL, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "HIDELINES", NULL, cocoaTreeSetHideLinesAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "HIDEBUTTONS", NULL, cocoaTreeSetHideButtonsAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "INFOTIP", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 
-	/* IupTree Attributes - ACTION */
-	iupClassRegisterAttributeId(ic, "DELNODE", NULL, cocoaTreeSetDelNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "RENAME", NULL, cocoaTreeSetRenameAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "MOVENODE", NULL, cocoaTreeSetMoveNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	iupClassRegisterAttributeId(ic, "COPYNODE", NULL, cocoaTreeSetCopyNodeAttrib, IUPAF_NOT_MAPPED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-	
-#if 0
-	/* IupTree Attributes - GTK Only */
-	iupClassRegisterAttribute  (ic, "RUBBERBAND", NULL, NULL, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
-#endif
+  /* Tooltip attributes */
+  iupClassRegisterAttribute(ic, "TIP", cocoaTreeGetTipAttrib, cocoaTreeSetTipAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, cocoaTreeSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "LAYERBACKED", cocoaTreeGetLayerBackedAttrib, cocoaTreeSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
+  /* New API for view specific contextual menus */
+  iupClassRegisterAttribute(ic, "CONTEXTMENU", iupcocoaCommonBaseGetContextMenuAttrib, cocoaTreeSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "LAYERBACKED", cocoaTreeGetLayerBackedAttrib, cocoaTreeSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
 
+  iupClassRegisterReplaceAttribFunc(ic, "ACTIVE", cocoaTreeGetActiveAttrib, cocoaTreeSetActiveAttrib);
 
-	helperLoadReplacementDefaultImages();
+  /* Drag and Drop attributes */
+  iupClassRegisterReplaceAttribFunc(ic, "SHOWDRAGDROP", NULL, cocoaTreeSetShowDragDropAttrib);
+  iupClassRegisterAttribute(ic, "DRAGDROPTREE", NULL, cocoaTreeSetDragDropTreeAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterReplaceAttribFunc(ic, "DRAGSOURCE", NULL, cocoaTreeSetDndControlAttrib);
+  iupClassRegisterReplaceAttribFunc(ic, "DROPTARGET", NULL, cocoaTreeSetDndControlAttrib);
 }
Index: src/cocoa/iupcocoa_val.m
===================================================================
--- src/cocoa/iupcocoa_val.m	(revision 5971)
+++ src/cocoa/iupcocoa_val.m	(working copy)
@@ -10,382 +10,510 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
-#include <memory.h>
-#include <stdarg.h>
 
 #include "iup.h"
 #include "iupcbs.h"
 
 #include "iup_object.h"
-#include "iup_layout.h"
 #include "iup_attrib.h"
 #include "iup_str.h"
 #include "iup_val.h"
 #include "iup_drv.h"
-#include "iup_drvfont.h"
-#include "iup_key.h"
 
 #include "iupcocoa_drv.h"
+#include "iupcocoa_keycodes.h"
 
-// the point of this is we have a unique memory address for an identifier
+
 static const void* IUP_COCOA_SLIDER_RECEIVER_OBJ_KEY = "IUP_COCOA_SLIDER_RECEIVER_OBJ_KEY";
 
-@interface IupCocoaSlider : NSSlider
+@interface IupCocoaValSlider : NSSlider
+@property (nonatomic, assign) double incrementValue;
 @end
 
-@implementation IupCocoaSlider
+@interface IupCocoaSliderReceiver : NSObject
+- (IBAction)sliderAction:(id)sender;
+@end
 
-/*
-I was mistaken about what acceptsFirstMouse does and what CANFOCUS is supposed to do.
-This controls whether the widget will immediately respond to a click when the app/window is in the background.
-The default is NO.
+@implementation IupCocoaValSlider
 
-So for example, Xcode is in the foreground, and my slider app is in the background.
-I click on my slider app to bring it forward. I happen to click on the slider in my app.
-acceptsFirstMouse==YES would cause both my application to come forward and also move the slider position.
-acceptsFirstMouse==NO would cause just the application to come forward, but the slider position will be ignored. This is a safety/focus behavior by default to avoid accidentally changing things.
+@synthesize incrementValue = _incrementValue;
 
-I suppose a reason to make it YES is if you have a multiple window app, and you want to manipulate the slider in a second window, without losing focus on the main window.
+- (BOOL)acceptsFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih)
+    return [super acceptsFirstResponder];
 
-However, this is not what the CANFOCUS feature is about.
-CANFOCUS seems to mostly be about getting the focus ring and being able to get keyboard control of it.
+  const char* canfocus = iupAttribGet(ih, "_IUPCOCOA_CANFOCUS");
+  if (canfocus && iupStrEqualNoCase(canfocus, "NO"))
+    return NO;
 
-*/
-/*
-- (BOOL) acceptsFirstMouse:(NSEvent*)the_event
+  return [super acceptsFirstResponder];
+}
+
+- (BOOL)becomeFirstResponder
 {
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
-  	if(iupAttribGetBoolean(ih, "CANFOCUS"))
-  	{
-  		return YES;
-	}
-	else
-	{
-		return NO;
-	}
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    iupcocoaFocusIn(ih);
+  }
+  return [super becomeFirstResponder];
 }
-*/
 
-@end
+- (BOOL)resignFirstResponder
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    iupcocoaFocusOut(ih);
+  }
+  return [super resignFirstResponder];
+}
 
-@interface IupCocoaSliderReceiver : NSObject
-- (IBAction) mySliderDidMove:(id)the_sender;
-@end
+- (BOOL) needsPanelToBecomeKey
+{
+  return YES;
+}
 
-@implementation IupCocoaSliderReceiver
+- (void)mouseDown:(NSEvent *)event
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    iupAttribSet(ih, "_IUPCOCOA_VAL_DRAGGING", "1");
+    iupAttribSet(ih, "_IUPCOCOA_VAL_BUTTONRELEASE", NULL);
+  }
+  [super mouseDown:event];
+}
 
-/*
-- (void) dealloc
+- (void)mouseUp:(NSEvent *)event
 {
-	[super dealloc];
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (ih)
+  {
+    iupAttribSet(ih, "_IUPCOCOA_VAL_BUTTONRELEASE", "1");
+    iupAttribSet(ih, "_IUPCOCOA_VAL_DRAGGING", NULL);
+  }
+  [super mouseUp:event];
 }
-*/
 
-
-- (IBAction) mySliderDidMove:(id)the_sender;
+- (void)keyDown:(NSEvent *)event
 {
-	Icallback callback_function;
-	Ihandle* ih = (Ihandle*)objc_getAssociatedObject(the_sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(self, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih)
+  {
+    [super keyDown:event];
+    return;
+  }
 
-	NSSlider* the_slider = (NSSlider*)the_sender;
-	double new_value = [the_slider doubleValue];;
-	if(ih->data->val == new_value)
-	{
-		// no change
-		return;
-	}
-	ih->data->val = new_value;
-	
-	callback_function = IupGetCallback(ih, "VALUECHANGED_CB");
-	if(callback_function)
-	{
-		int ret_val = callback_function(ih);
-		// don't need to do anything with return value
-		(void)(ret_val);
-	}
+  int keyCode = [event keyCode];
+  if (iupcocoaKeyEvent(ih, event, keyCode, true))
+    return;
+
+  BOOL handled = NO;
+
+  if (keyCode == kVK_Home)
+  {
+    if (ih->data->inverted)
+      [self setDoubleValue:ih->data->vmax];
+    else
+      [self setDoubleValue:ih->data->vmin];
+
+    IupCocoaSliderReceiver* receiver = (IupCocoaSliderReceiver*)objc_getAssociatedObject(self, IUP_COCOA_SLIDER_RECEIVER_OBJ_KEY);
+    if (receiver)
+    {
+      iupAttribSet(ih, "_IUPCOCOA_VAL_KEYPRESS", "1");
+      [receiver sliderAction:self];
+      iupAttribSet(ih, "_IUPCOCOA_VAL_KEYPRESS", NULL);
+    }
+    handled = YES;
+  }
+  else if (keyCode == kVK_End)
+  {
+    if (ih->data->inverted)
+      [self setDoubleValue:ih->data->vmin];
+    else
+      [self setDoubleValue:ih->data->vmax];
+
+    IupCocoaSliderReceiver* receiver = (IupCocoaSliderReceiver*)objc_getAssociatedObject(self, IUP_COCOA_SLIDER_RECEIVER_OBJ_KEY);
+    if (receiver)
+    {
+      iupAttribSet(ih, "_IUPCOCOA_VAL_KEYPRESS", "1");
+      [receiver sliderAction:self];
+      iupAttribSet(ih, "_IUPCOCOA_VAL_KEYPRESS", NULL);
+    }
+    handled = YES;
+  }
+
+  if (!handled)
+  {
+    [super keyDown:event];
+  }
 }
 
 @end
 
 
+@implementation IupCocoaSliderReceiver
 
+- (IBAction)sliderAction:(id)sender
+{
+  Ihandle* ih = (Ihandle*)objc_getAssociatedObject(sender, IHANDLE_ASSOCIATED_OBJ_KEY);
+  if (!ih)
+  {
+    return;
+  }
 
+  NSSlider* slider = (NSSlider*)sender;
+  double slider_val = [slider doubleValue];
+  double old_iup_val = ih->data->val;
+
+  ih->data->val = ih->data->inverted ? (ih->data->vmax - slider_val) + ih->data->vmin : slider_val;
+  iupValCropValue(ih);
+
+  IFn valuechanged_cb = (IFn)IupGetCallback(ih, "VALUECHANGED_CB");
+  if (valuechanged_cb)
+  {
+    if (ih->data->val == old_iup_val)
+    {
+      return;
+    }
+    valuechanged_cb(ih);
+  }
+  else
+  {
+    IFnd cb_old = NULL;
+
+    if (iupAttribGet(ih, "_IUPCOCOA_VAL_BUTTONRELEASE"))
+    {
+      cb_old = (IFnd)IupGetCallback(ih, "BUTTON_RELEASE_CB");
+      iupAttribSet(ih, "_IUPCOCOA_VAL_BUTTONRELEASE", NULL);
+    }
+    else if (iupAttribGet(ih, "_IUPCOCOA_VAL_DRAGGING"))
+    {
+      cb_old = (IFnd)IupGetCallback(ih, "MOUSEMOVE_CB");
+    }
+    else if (iupAttribGet(ih, "_IUPCOCOA_VAL_KEYPRESS"))
+    {
+      cb_old = (IFnd)IupGetCallback(ih, "BUTTON_PRESS_CB");
+    }
+    else
+    {
+      NSEvent* event = [NSApp currentEvent];
+      NSEventType event_type = [event type];
+
+      if (event_type == NSEventTypeKeyDown)
+      {
+        cb_old = (IFnd)IupGetCallback(ih, "BUTTON_PRESS_CB");
+      }
+    }
+
+    if (cb_old)
+    {
+      cb_old(ih, ih->data->val);
+    }
+  }
+}
+
+@end
+
 void iupdrvValGetMinSize(Ihandle* ih, int *w, int *h)
 {
-	if(ih->handle)
-	{
-//		NSLog(@"iupdrvValGetMinSize with handle");
-		NSSlider* the_slider = (NSSlider*)ih->handle;
-		CGFloat knob_thickness = [the_slider knobThickness];
-//		NSLog(@"iupdrvValGetMinSize knob_thickness:%lf", knob_thickness);
-		
-		const int PADDING = 4;
-		
-		*w = knob_thickness + PADDING;
-		*h = knob_thickness + PADDING;
-		return;
-	}
-	else
-	{
-//		NSLog(@"iupdrvValGetMinSize no handle");
-		
-	}
-	// 10.13 knobThickness is 20.0 for pointy, 21.0 for round
-	
-	const int KNOBTHICKNESS = 21;
-	const int PADDING = 4;
-	
-	if(ih->data->orientation == IVAL_HORIZONTAL)
-	{
-		*w = KNOBTHICKNESS + PADDING;
-		*h = KNOBTHICKNESS + PADDING;
-	}
-	else
-	{
-		*w = KNOBTHICKNESS + PADDING;
-		*h = KNOBTHICKNESS + PADDING;
-	}
+  int ticks_size = 0;
+  if (iupAttribGetInt(ih, "SHOWTICKS") > 0)
+  {
+    char* tickspos = iupAttribGetStr(ih, "TICKSPOS");
+    if (iupStrEqualNoCase(tickspos, "BOTH"))
+    {
+      /* NSSlider doesn't support both sides, but account for the user's expectation */
+      ticks_size = 2 * 8;
+    }
+    else
+    {
+      ticks_size = 8;
+    }
+  }
+
+  if (ih->data->orientation == IVAL_HORIZONTAL)
+  {
+    *w = 35;
+    *h = 30 + ticks_size;
+  }
+  else
+  {
+    *w = 30 + ticks_size;
+    *h = 35;
+  }
 }
 
 static int cocoaValSetValueAttrib(Ihandle* ih, const char* value)
 {
-	double new_value = 0;
-	if(iupStrToDouble(value, &new_value))
-	{
-		NSSlider* the_slider = ih->handle;
-		// Not sure if I should bounds check in case the user is trying to reset max, min and this, but out of order.
-		if(new_value < ih->data->vmin)
-		{
-			new_value = ih->data->vmin;
-		}
-		if(new_value > ih->data->vmax)
-		{
-			new_value = ih->data->vmax;
-		}
-		
-		ih->data->val = new_value;
-		
-		[the_slider setDoubleValue:new_value];
-	}
-	return 0; /* do not store value in hash table */
+  double new_iup_val;
+
+  if (!value)
+  {
+    /* If value is NULL, use current value (e.g., when MIN/MAX changed) */
+    new_iup_val = ih->data->val;
+  }
+  else if (!iupStrToDouble(value, &new_iup_val))
+  {
+    return 0;
+  }
+
+  NSSlider* slider = ih->handle;
+
+  if (new_iup_val < ih->data->vmin) new_iup_val = ih->data->vmin;
+  if (new_iup_val > ih->data->vmax) new_iup_val = ih->data->vmax;
+
+  ih->data->val = new_iup_val;
+
+  /* If inverted, transform the IUP value to the native slider's coordinate space. */
+  double native_val = ih->data->inverted ? (ih->data->vmax - new_iup_val) + ih->data->vmin : new_iup_val;
+  [slider setDoubleValue:native_val];
+
+  return 0;
 }
 
-
 static int cocoaValSetMaxAttrib(Ihandle* ih, const char* value)
 {
-	double new_value = 0;
-	if(iupStrToDouble(value, &new_value))
-	{
-		NSSlider* the_slider = ih->handle;
-		
-		// Not going to bounds check in case the user is trying to change both max and min which could cross into an invalid state
-		
-		ih->data->val = new_value;
-		
-		[the_slider setMaxValue:new_value];
-	}
-	return 0; /* do not store value in hash table */
+  double new_value;
+  if (iupStrToDouble(value, &new_value))
+  {
+    NSSlider* slider = ih->handle;
+    ih->data->vmax = new_value;
+    [slider setMaxValue:new_value];
+
+    double inc_size = ih->data->step * (ih->data->vmax - ih->data->vmin);
+    [(IupCocoaValSlider*)slider setIncrementValue:inc_size];
+
+    double page_inc_size = ih->data->pagestep * (ih->data->vmax - ih->data->vmin);
+    [slider setAltIncrementValue:page_inc_size];
+
+    cocoaValSetValueAttrib(ih, NULL);
+  }
+  return 0;
 }
 
 static char* cocoaValGetMaxAttrib(Ihandle* ih)
 {
-	return iupStrReturnDouble(ih->data->vmax);
+  return iupStrReturnDouble(ih->data->vmax);
 }
 
 static int cocoaValSetMinAttrib(Ihandle* ih, const char* value)
 {
-	double new_value = 0;
-	if(iupStrToDouble(value, &new_value))
-	{
-		NSSlider* the_slider = ih->handle;
-		
-		// Not going to bounds check in case the user is trying to change both max and min which could cross into an invalid state
-		
-		ih->data->val = new_value;
-		
-		[the_slider setMinValue:new_value];
-	}
-	return 0; /* do not store value in hash table */
+  double new_value;
+  if (iupStrToDouble(value, &new_value))
+  {
+    NSSlider* slider = ih->handle;
+    ih->data->vmin = new_value;
+    [slider setMinValue:new_value];
+
+    double inc_size = ih->data->step * (ih->data->vmax - ih->data->vmin);
+    [(IupCocoaValSlider*)slider setIncrementValue:inc_size];
+
+    double page_inc_size = ih->data->pagestep * (ih->data->vmax - ih->data->vmin);
+    [slider setAltIncrementValue:page_inc_size];
+
+    cocoaValSetValueAttrib(ih, NULL);
+  }
+  return 0;
 }
 
 static char* cocoaValGetMinAttrib(Ihandle* ih)
 {
-	return iupStrReturnDouble(ih->data->vmin);
+  return iupStrReturnDouble(ih->data->vmin);
 }
 
-
-// STEP: Controls the increment for keyboard control and the mouse wheel.
-// It is not the size of the increment.
-// The increment size is "step*(max-min)", so it must be 0<step<1. Default is "0.01".
 static int cocoaValSetStepAttrib(Ihandle* ih, const char* value)
 {
-	if(iupStrToDoubleDef(value, &(ih->data->step), 0.01))
-	{
-		double inc_size = ih->data->step * (ih->data->vmax - ih->data->vmin);
-		NSSlider* the_slider = ih->handle;
-		[the_slider setAltIncrementValue:inc_size];
-	}
-	return 0; /* do not store value in hash table */
+  if (iupStrToDoubleDef(value, &(ih->data->step), 0.01))
+  {
+    double inc_size = ih->data->step * (ih->data->vmax - ih->data->vmin);
+    IupCocoaValSlider* slider = ih->handle;
+    [slider setIncrementValue:inc_size];
+  }
+  return 0;
 }
 
+static int cocoaValSetPageStepAttrib(Ihandle* ih, const char* value)
+{
+  if (iupStrToDoubleDef(value, &(ih->data->pagestep), 0.1))
+  {
+    /* PAGESTEP is a fraction of the total range. Convert to an absolute value. */
+    double page_inc_size = ih->data->pagestep * (ih->data->vmax - ih->data->vmin);
+    NSSlider* slider = ih->handle;
+    /* altIncrementValue is used when holding Option key, which is the closest available behavior to PAGESTEP on macOS. */
+    [slider setAltIncrementValue:page_inc_size];
+  }
+  return 0;
+}
 
-
 static int cocoaValSetShowTicksAttrib(Ihandle* ih, const char* value)
 {
-	int show_ticks = 0;
-	if(value != NULL)
-	{
-		show_ticks = atoi(value);
-	}
+  int show_ticks = 0;
+  if (value)
+  {
+    show_ticks = atoi(value);
+  }
+  if (show_ticks < 0) show_ticks = 0;
 
-	//  if (show_ticks<2) show_ticks=2;
+  ih->data->show_ticks = show_ticks;
 
-	ih->data->show_ticks = show_ticks;
-	
-	NSSlider* the_slider = ih->handle;
-	[the_slider setNumberOfTickMarks:show_ticks];
-	
-	return 0;
+  NSSlider* slider = ih->handle;
+  [slider setNumberOfTickMarks:show_ticks];
+
+  return 0;
 }
 
 static int cocoaValSetStepOnTicksAttrib(Ihandle* ih, const char* value)
 {
-	BOOL should_step_on_ticks = (BOOL)iupStrBoolean(value);
-	NSSlider* the_slider = ih->handle;
-	[the_slider setAllowsTickMarkValuesOnly:should_step_on_ticks];
-	return 0;
+  NSSlider* slider = ih->handle;
+  [slider setAllowsTickMarkValuesOnly:(BOOL)iupStrBoolean(value)];
+  return 1; /* Store value */
 }
 
 static char* cocoaValGetStepOnTicksAttrib(Ihandle* ih)
 {
-	NSSlider* the_slider = ih->handle;
-	BOOL should_step_on_ticks = [the_slider allowsTickMarkValuesOnly];
-	return iupStrReturnBoolean(should_step_on_ticks);
+  NSSlider* slider = ih->handle;
+  return iupStrReturnBoolean([slider allowsTickMarkValuesOnly]);
 }
 
+static int cocoaValSetTicksPosAttrib(Ihandle* ih, const char* value)
+{
+  NSSlider* slider = ih->handle;
+  BOOL is_vertical = (ih->data->orientation == IVAL_VERTICAL);
 
+  if (iupStrEqualNoCase(value, "BOTH"))
+  {
+    /* NSSlider doesn't support ticks on both sides, default to NORMAL */
+    [slider setTickMarkPosition: is_vertical ? NSTickMarkPositionLeading : NSTickMarkPositionBelow];
+  }
+  else if (iupStrEqualNoCase(value, "REVERSE"))
+  {
+    [slider setTickMarkPosition: is_vertical ? NSTickMarkPositionTrailing : NSTickMarkPositionAbove];
+  }
+  else /* "NORMAL" */
+  {
+    [slider setTickMarkPosition: is_vertical ? NSTickMarkPositionLeading : NSTickMarkPositionBelow];
+  }
+  return 1;
+}
 
+static char* cocoaValGetInvertedAttrib(Ihandle* ih)
+{
+  return iupStrReturnBoolean(ih->data->inverted);
+}
+
+static int cocoaValSetInvertedAttrib(Ihandle* ih, const char* value)
+{
+  ih->data->inverted = iupStrBoolean(value);
+  /* Re-apply the current value to reflect the inversion */
+  cocoaValSetValueAttrib(ih, iupValGetValueAttrib(ih));
+  return 0;
+}
+
 static int cocoaValMapMethod(Ihandle* ih)
 {
-	IupCocoaSlider* the_slider = [[IupCocoaSlider alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)];
+  IupCocoaValSlider* slider = [[IupCocoaValSlider alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)];
+  ih->handle = slider;
 
-	[the_slider setMinValue:0.0];
-	[the_slider setMaxValue:1.0];
-	// PAGESTEP cannot be supported. Only STEP.
-	[the_slider setAltIncrementValue:0.01];
-	[the_slider setNumberOfTickMarks:0];
+  if (ih->data->orientation == IVAL_VERTICAL)
+  {
+    [slider setVertical:YES];
+  }
 
-	if(ih->data->orientation == IVAL_VERTICAL)
-	{
-		[the_slider setVertical:YES];
-	}
-	else
-	{
-		[the_slider setVertical:NO];
-	}
+  [slider setContinuous:YES];
 
+  if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+  {
+    [slider setRefusesFirstResponder:YES];
+    iupcocoaSetCanFocus(ih, 0);
+  }
+  else
+  {
+    iupcocoaSetCanFocus(ih, 1);
+  }
 
-	// I'm using objc_setAssociatedObject/objc_getAssociatedObject because it allows me to avoid making subclasses just to hold ivars.
-	objc_setAssociatedObject(the_slider, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
-	// I also need to track the memory of the buttion action receiver.
-	// I prefer to keep the Ihandle the actual NSView instead of the receiver because it makes the rest of the implementation easier if the handle is always an NSView (or very small set of things, e.g. NSWindow, NSView, CALayer).
-	// So with only one pointer to deal with, this means we need our button to hold a reference to the receiver object.
-	// This is generally not good Cocoa as buttons don't retain their receivers, but this seems like the best option.
-	// Be careful of retain cycles.
-	IupCocoaSliderReceiver* slider_receiver = [[IupCocoaSliderReceiver alloc] init];
-	[the_slider setTarget:slider_receiver];
-	[the_slider setAction:@selector(mySliderDidMove:)];
+  objc_setAssociatedObject(slider, IHANDLE_ASSOCIATED_OBJ_KEY, (id)ih, OBJC_ASSOCIATION_ASSIGN);
 
-	// We're going to use OBJC_ASSOCIATION_RETAIN because I do believe it will do the right thing for us.
-	// Just be very careful to not have anything in the delegate retain main widget, or we get a retain cycle.
-	objc_setAssociatedObject(the_slider, IUP_COCOA_SLIDER_RECEIVER_OBJ_KEY, (id)slider_receiver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
-	[slider_receiver release];
-	
-	
+  IupCocoaSliderReceiver* slider_receiver = [[IupCocoaSliderReceiver alloc] init];
+  [slider setTarget:slider_receiver];
+  [slider setAction:@selector(sliderAction:)];
 
-	
+  objc_setAssociatedObject(slider, IUP_COCOA_SLIDER_RECEIVER_OBJ_KEY, slider_receiver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+  [slider_receiver release];
 
-	ih->handle = the_slider;
+  iupcocoaSetAssociatedViews(ih, slider, slider);
+  iupcocoaAddToParent(ih);
 
-	iupCocoaSetAssociatedViews(ih, the_slider, the_slider);
+  cocoaValSetMinAttrib(ih, iupAttribGetStr(ih, "MIN"));
+  cocoaValSetMaxAttrib(ih, iupAttribGetStr(ih, "MAX"));
+  cocoaValSetStepAttrib(ih, NULL);
+  cocoaValSetPageStepAttrib(ih, NULL);
 
-	
-	// All Cocoa views shoud call this to add the new view to the parent view.
-	iupCocoaAddToParent(ih);
-	
+  const char* inverted_str = iupAttribGetStr(ih, "INVERTED");
+  if (inverted_str)
+  {
+    ih->data->inverted = iupStrBoolean(inverted_str);
+  }
 
-	
-	
-	
-	
-	
-	return IUP_NOERROR;
+  const char* value_str = iupAttribGetStr(ih, "VALUE");
+  if (value_str)
+  {
+    cocoaValSetValueAttrib(ih, value_str);
+  }
+  else
+  {
+    cocoaValSetValueAttrib(ih, "0");
+  }
+
+  return IUP_NOERROR;
 }
 
 static void cocoaValUnMapMethod(Ihandle* ih)
 {
-	id the_slider = ih->handle;
+  if (ih->handle)
+  {
+    NSSlider* slider = ih->handle;
 
-	// Destroy the context menu ih it exists
-	{
-		Ihandle* context_menu_ih = (Ihandle*)iupCocoaCommonBaseGetContextMenuAttrib(ih);
-		if(NULL != context_menu_ih)
-		{
-			IupDestroy(context_menu_ih);
-		}
-		iupCocoaCommonBaseSetContextMenuAttrib(ih, NULL);
-	}
+    iupcocoaTipsDestroy(ih);
 
-	iupCocoaRemoveFromParent(ih);
-	iupCocoaSetAssociatedViews(ih, nil, nil);
-	[the_slider release];
-	ih->handle = NULL;
-	
+    [slider setTarget:nil];
+    objc_setAssociatedObject(slider, IUP_COCOA_SLIDER_RECEIVER_OBJ_KEY, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+    objc_setAssociatedObject(slider, IHANDLE_ASSOCIATED_OBJ_KEY, nil, OBJC_ASSOCIATION_ASSIGN);
+
+    iupcocoaRemoveFromParent(ih);
+    iupcocoaSetAssociatedViews(ih, nil, nil);
+    [slider release];
+    ih->handle = NULL;
+  }
 }
 
-
 void iupdrvValInitClass(Iclass* ic)
 {
-  /* Driver Dependent Class functions */
   ic->Map = cocoaValMapMethod;
   ic->UnMap = cocoaValUnMapMethod;
 
-
-  /* Driver Dependent Attribute functions */
-
   /* Visual */
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT); 
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
 
-  /* Special */
+  /* Common */
+  iupClassRegisterAttribute(ic, "TIP", NULL, iupdrvBaseSetTipAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 
-  /* IupVal only */
-  iupClassRegisterAttribute(ic, "VALUE", iupValGetValueAttrib, cocoaValSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  /* IupVal */
+  iupClassRegisterAttribute(ic, "VALUE", iupValGetValueAttrib, cocoaValSetValueAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MAX", cocoaValGetMaxAttrib, cocoaValSetMaxAttrib, IUPAF_SAMEASSYSTEM, "1", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "MIN", cocoaValGetMinAttrib, cocoaValSetMinAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "STEP", iupValGetStepAttrib, cocoaValSetStepAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "PAGESTEP", iupValGetPageStepAttrib, cocoaValSetPageStepAttrib, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "INVERTED", cocoaValGetInvertedAttrib, cocoaValSetInvertedAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-  iupClassRegisterAttribute(ic, "MAX", cocoaValGetMaxAttrib, cocoaValSetMaxAttrib, IUPAF_SAMEASSYSTEM, "1", IUPAF_NOT_MAPPED);
-  iupClassRegisterAttribute(ic, "MIN", cocoaValGetMinAttrib, cocoaValSetMinAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED);
-
-
-
-  iupClassRegisterAttribute(ic, "STEP", iupValGetStepAttrib, cocoaValSetStepAttrib, IUPAF_SAMEASSYSTEM, "0.01", IUPAF_NO_INHERIT);
+  /* Ticks */
   iupClassRegisterAttribute(ic, "SHOWTICKS", iupValGetShowTicksAttrib, cocoaValSetShowTicksAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_DEFAULT);
-
-
-
-	// Not supported
-	  iupClassRegisterAttribute(ic, "PAGESTEP", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-  iupClassRegisterAttribute(ic, "INVERTED", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-  iupClassRegisterAttribute(ic, "TICKSPOS", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
-
-
-
-	// New API
-	// For setting and retrieving whether values on the slider can be anything
-	//   the slider normally allows, or only values that correspond to a tick mark.
-	//   This has no effect if numberOfTickMarks is 0.
+  iupClassRegisterAttribute(ic, "TICKSPOS", NULL, cocoaValSetTicksPosAttrib, "NORMAL", NULL, IUPAF_DEFAULT);
   iupClassRegisterAttribute(ic, "STEPONTICKS", cocoaValGetStepOnTicksAttrib, cocoaValSetStepOnTicksAttrib, IUPAF_SAMEASSYSTEM, "NO", IUPAF_DEFAULT);
 
-	/* New API for view specific contextual menus (Mac only) */
-	iupClassRegisterAttribute(ic, "CONTEXTMENU", iupCocoaCommonBaseGetContextMenuAttrib, iupCocoaCommonBaseSetContextMenuAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-	iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupCocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
-
+  /* macOS Specific */
+  iupClassRegisterAttribute(ic, "LAYERBACKED", iupCocoaCommonBaseGetLayerBackedAttrib, iupcocoaCommonBaseSetLayerBackedAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE);
 }
Index: src/config.mak
===================================================================
--- src/config.mak	(revision 5971)
+++ src/config.mak	(working copy)
@@ -64,6 +64,7 @@
       iup_flatseparator.c iup_space.c iup_multibox.c iup_flatlist.c iup_globalsdlg.c \
       iup_flatval.c iup_loop.c iup_thread.c iup_classinfo.c iup_elempropdlg.c \
       iup_export.c iup_flattree.c
+SRC += iup_notify.c iup_popover.c iup_tablecontrol.c iup_tray.c
 
 ifdef USE_HAIKU
   # Since Haiku has no GTK and no Motif, we can only use the native implementation
@@ -100,7 +101,7 @@
          gtk/iupgtk_canvas.c gtk/iupgtk_image.c gtk/iupgtk_dialog.c \
          gtk/iupgtk_common.c gtk/iupgtk_str.c gtk/iupgtk_menu.c \
          gtk/iupgtk_calendar.c iup_datepick.c
-           
+  SRC += gtk/iupgtk_popover.c gtk/iupgtk_table.c gtk/iupgtk_tray_sni.c gtk/iupgtk_tray_xembed.c
   ifdef USE_GTK3
     SRC += gtk/iupgtk_draw_cairo.c
   else
@@ -110,7 +111,7 @@
       SRC += gtk/iupgtk_draw_gdk.c
     endif
   endif
-  
+
   ifneq ($(findstring Win, $(TEC_SYSNAME)), )
     DEFINES += _WIN32_WINNT=$(WIN32VER) _WIN32_IE=0x600 WINVER=$(WIN32VER) NOTREEVIEW
     SRC += win/iupwindows_main.c win/iupwindows_help.c win/iupwindows_info.c
@@ -128,7 +129,7 @@
         USE_X11 = Yes
       endif
       SRC += gtk/iupgtk_help.c mot/iupunix_info.c
-      
+
       ifdef USE_GTK3
         SRC += gtk/iupgtk_info.c
       else
@@ -141,7 +142,7 @@
       endif
     endif
   endif
-  
+
   ifdef USE_HILDON
     DEFINES += HILDON
     STDINCS += /usr/include/hildon-1
@@ -158,9 +159,23 @@
          mot/iupmot_text.c mot/iupmot_val.c mot/iupmot_tabs.c mot/iupmot_menu.c \
          mot/iupmot_list.c mot/iupmot_tree.c mot/iupmot_dragdrop.c mot/iupmot_str.c \
          mot/iupmot_calendar.c iup_datepick.c
-         
-  SRC += mot/iupunix_help.c mot/iupunix_info.c mot/iupx11_info.c
+
+SRC +=   mot/iupmot_table.c \
+mot/iupmot_popover.c \
+mot/iupmot_tray_sni.c \
+mot/iupmot_tray_xembed.c \
+mot/iupunix_help.c \
+mot/iupunix_info.c \
+mot/iupx11_info.c \
+mot/iupunix_notify.c
+#		mot/iupunix_sni.c     # conflict /iupmot_tray_sni.c
+
+
+
   USE_X11 = Yes
+  # add from iup-go  
+  STDINCS += /usr/include/dbus-1.0 /usr/lib/dbus-1.0/include
+  LIBS += dbus-1
 
   INCLUDES += mot
 else
@@ -174,7 +189,7 @@
          win/iupwin_progressbar.c win/iupwin_text.c win/iupwin_val.c win/iupwin_touch.c \
          win/iupwin_tabs.c win/iupwin_menu.c win/iupwin_list.c win/iupwin_tree.c \
          win/iupwin_calendar.c win/iupwin_datepick.c
-         
+
   ifdef USE_NEW_DRAW
     INCLUDES += win/wdl
     DEFINES += COBJMACROS _UNICODE USE_NEW_DRAW
Index: src/gtk/iupgtk_button.c
===================================================================
--- src/gtk/iupgtk_button.c	(revision 5971)
+++ src/gtk/iupgtk_button.c	(working copy)
@@ -41,19 +41,291 @@
 
 void iupdrvButtonAddBorders(Ihandle* ih, int *x, int *y)
 {
-  /* LAYOUT_DECORATION_ESTIMATE */
-#ifdef WIN32
-  int border_size = 2*5;
+#if GTK_CHECK_VERSION(3, 0, 0)
+  /* Measure actual borders dynamically since they depend on theme */
+  static int text_border_x = -1, text_border_y = -1;
+  static int image_text_border_x = -1, image_text_border_y = -1;
+  static int image_border_x = -1, image_border_y = -1;
+
+  int has_image = 0;
+  int has_text = 0;
+  int has_bgcolor = 0;
+
+  if (ih)
+  {
+    char* image = iupAttribGet(ih, "IMAGE");
+    char* title = iupAttribGet(ih, "TITLE");
+    char* bgcolor = iupAttribGet(ih, "BGCOLOR");
+    has_image = (image != NULL);
+    has_text = (title != NULL && *title != 0);
+    has_bgcolor = (!has_image && !has_text && bgcolor != NULL);
+  }
+
+  if (has_bgcolor)
+  {
+    GtkWidget* temp_window = gtk_offscreen_window_new();
+    GtkWidget* temp_button = gtk_button_new();
+
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_button);
+    gtk_widget_show_all(temp_window);
+
+    gint button_nat_w, button_nat_h;
+    gtk_widget_get_preferred_width(temp_button, NULL, &button_nat_w);
+    gtk_widget_get_preferred_height(temp_button, NULL, &button_nat_h);
+
+    /* Empty button borders */
+    (*x) += button_nat_w;
+    (*y) += button_nat_h;
+
+    gtk_widget_destroy(temp_window);
+  }
+  else if (has_image && has_text)
+  {
+    if (image_text_border_x == -1)
+    {
+      GtkWidget* temp_window = gtk_offscreen_window_new();
+      GtkWidget* temp_button = gtk_button_new();
+      GtkWidget* temp_image = gtk_image_new_from_icon_name("document-open", GTK_ICON_SIZE_BUTTON);
+
+      gtk_button_set_image(GTK_BUTTON(temp_button), temp_image);
+      gtk_button_set_label(GTK_BUTTON(temp_button), "Test");
+      gtk_button_set_always_show_image(GTK_BUTTON(temp_button), TRUE);
+
+      gtk_container_add(GTK_CONTAINER(temp_window), temp_button);
+      gtk_widget_show_all(temp_window);
+
+      /* Get button's preferred size */
+      gint button_width, button_height;
+      gtk_widget_get_preferred_width(temp_button, NULL, &button_width);
+      gtk_widget_get_preferred_height(temp_button, NULL, &button_height);
+
+      /* Get child allocation */
+      GtkWidget* child = gtk_bin_get_child(GTK_BIN(temp_button));
+      GtkAllocation child_alloc;
+      if (child)
+      {
+        gtk_widget_get_allocation(child, &child_alloc);
+        image_text_border_x = button_width - child_alloc.width;
+        image_text_border_y = button_height - child_alloc.height;
+      }
+      else
+      {
+        image_text_border_x = 11;
+        image_text_border_y = 11;
+      }
+
+      gtk_widget_destroy(temp_window);
+    }
+    (*x) += image_text_border_x;
+    (*y) += image_text_border_y;
+  }
+  else if (has_image)
+  {
+    if (image_border_x == -1)
+    {
+      GtkWidget* temp_window = gtk_offscreen_window_new();
+      GtkWidget* temp_button = gtk_button_new();
+      GtkWidget* temp_image = gtk_image_new_from_icon_name("document-open", GTK_ICON_SIZE_BUTTON);
+
+      gtk_button_set_image(GTK_BUTTON(temp_button), temp_image);
+
+      gtk_container_add(GTK_CONTAINER(temp_window), temp_button);
+      gtk_widget_show_all(temp_window);
+
+      /* Get button's preferred size */
+      gint button_width, button_height;
+      gtk_widget_get_preferred_width(temp_button, NULL, &button_width);
+      gtk_widget_get_preferred_height(temp_button, NULL, &button_height);
+
+      /* Get child allocation */
+      GtkWidget* child = gtk_bin_get_child(GTK_BIN(temp_button));
+      GtkAllocation child_alloc;
+      if (child)
+      {
+        gtk_widget_get_allocation(child, &child_alloc);
+        image_border_x = button_width - child_alloc.width;
+        image_border_y = button_height - child_alloc.height;
+      }
+      else
+      {
+        image_border_x = 11;
+        image_border_y = 11;
+      }
+
+      gtk_widget_destroy(temp_window);
+    }
+    (*x) += image_border_x;
+    (*y) += image_border_y;
+  }
+  else
+  {
+    if (text_border_x == -1)
+    {
+      GtkWidget* temp_window = gtk_offscreen_window_new();
+      GtkWidget* temp_button = gtk_button_new_with_label("Test");
+
+      gtk_container_add(GTK_CONTAINER(temp_window), temp_button);
+      gtk_widget_show_all(temp_window);
+
+      gint button_nat_w, button_nat_h;
+      gtk_widget_get_preferred_width(temp_button, NULL, &button_nat_w);
+      gtk_widget_get_preferred_height(temp_button, NULL, &button_nat_h);
+
+      GtkWidget* child = gtk_bin_get_child(GTK_BIN(temp_button));
+      if (child)
+      {
+        gint child_nat_w, child_nat_h;
+        gtk_widget_get_preferred_width(child, NULL, &child_nat_w);
+        gtk_widget_get_preferred_height(child, NULL, &child_nat_h);
+
+        text_border_x = button_nat_w - child_nat_w;
+        text_border_y = button_nat_h - child_nat_h;
+      }
+      else
+      {
+        text_border_x = 11;
+        text_border_y = 11;
+      }
+
+      gtk_widget_destroy(temp_window);
+    }
+    (*x) += text_border_x;
+    (*y) += text_border_y;
+  }
 #else
-#ifdef HILDON
-  int border_size = 2*7+1; /* borders are not symmetric */
-#else
-  int border_size = 2*5+1; /* borders are not symmetric */
+  /* GTK2: Measure actual borders since they depend on theme AND button type */
+  GtkWidget* temp_button;
+  GtkWidget* child;
+  GtkRequisition button_size, child_size;
+  int border_x, border_y;
+
+  /* Check if we need to measure for image+text button, image-only, or text-only button */
+  int has_image = 0;
+  int has_text = 0;
+  int has_bgcolor = 0;
+
+  if (ih)
+  {
+    char* image = iupAttribGet(ih, "IMAGE");
+    char* title = iupAttribGet(ih, "TITLE");
+    char* bgcolor = iupAttribGet(ih, "BGCOLOR");
+    has_image = (image != NULL);
+    has_text = (title != NULL && *title != 0);
+    has_bgcolor = (!has_image && !has_text && bgcolor != NULL);
+  }
+
+  if (has_bgcolor)
+  {
+    GtkWidget* temp_window;
+    GtkRequisition req;
+
+    temp_window = gtk_offscreen_window_new();
+    temp_button = gtk_button_new();
+    gtk_widget_set_can_focus(temp_button, TRUE);
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_button);
+    gtk_widget_show_all(temp_window);
+    gtk_widget_realize(temp_window);
+    gtk_widget_realize(temp_button);
+
+    gtk_widget_size_request(temp_button, &req);
+
+    (*x) += req.width;
+    (*y) += req.height;
+
+    gtk_widget_destroy(temp_window);
+    return;
+  }
+  else if (has_image && has_text)
+  {
+    /* Create button with both image and text to match actual structure */
+    GdkPixbuf* temp_pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, 32, 32);
+    GtkWidget* temp_image = gtk_image_new_from_pixbuf(temp_pixbuf);
+
+    temp_button = gtk_button_new();
+    gtk_widget_set_can_focus(temp_button, TRUE);
+    gtk_button_set_alignment(GTK_BUTTON(temp_button), 0.5f, 0.5f);
+    gtk_button_set_image(GTK_BUTTON(temp_button), temp_image);
+    gtk_button_set_label(GTK_BUTTON(temp_button), "Test");
+
+    /* Get the alignment child that contains the box */
+    child = gtk_bin_get_child(GTK_BIN(temp_button));
+
+    gtk_widget_size_request(temp_button, &button_size);
+    gtk_widget_size_request(child, &child_size);
+
+    g_object_unref(temp_pixbuf);
+  }
+  else if (has_image)
+  {
+    /* Image-only button */
+    GdkPixbuf* temp_pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, 32, 32);
+    GtkWidget* temp_image = gtk_image_new_from_pixbuf(temp_pixbuf);
+
+    temp_button = gtk_button_new();
+    gtk_widget_set_can_focus(temp_button, TRUE);
+    gtk_button_set_alignment(GTK_BUTTON(temp_button), 0.5f, 0.5f);
+    gtk_button_set_image(GTK_BUTTON(temp_button), temp_image);
+
+    /* For image-only buttons, we need to measure the GtkAlignment, not the image */
+    child = gtk_bin_get_child(GTK_BIN(temp_button));
+
+    gtk_widget_size_request(temp_button, &button_size);
+    gtk_widget_size_request(child, &child_size);
+
+    g_object_unref(temp_pixbuf);
+  }
+  else
+  {
+    /* Text-only button */
+    temp_button = gtk_button_new_with_label("Test");
+    gtk_widget_set_can_focus(temp_button, TRUE);
+    gtk_button_set_alignment(GTK_BUTTON(temp_button), 0.5f, 0.5f);
+    child = gtk_bin_get_child(GTK_BIN(temp_button));
+
+    gtk_widget_size_request(temp_button, &button_size);
+    gtk_widget_size_request(child, &child_size);
+  }
+
+  /* Force allocation to see what GTK2 actually gives to the child */
+  GtkAllocation alloc = {0, 0, button_size.width, button_size.height};
+  gtk_widget_size_allocate(temp_button, &alloc);
+
+  /* Now get the ACTUAL allocated size of the child */
+  GtkWidget* allocated_child = gtk_bin_get_child(GTK_BIN(temp_button));
+  GtkAllocation child_alloc;
+  if (allocated_child)
+  {
+    gtk_widget_get_allocation(allocated_child, &child_alloc);
+
+    /* Calculate border from allocated child size */
+    border_x = button_size.width - child_alloc.width;
+    border_y = button_size.height - child_alloc.height;
+
+    GtkBorder *inner_border = NULL;
+    gtk_widget_style_get(temp_button, "inner-border", &inner_border, NULL);
+
+    if (!inner_border)
+    {
+      border_x += 6;
+      border_y += 6;
+    }
+
+    if (inner_border)
+      gtk_border_free(inner_border);
+
+  }
+  else
+  {
+    /* Fallback to requested size if no child */
+    border_x = button_size.width - child_size.width;
+    border_y = button_size.height - child_size.height;
+  }
+
+  (*x) += border_x;
+  (*y) += border_y;
+
+  gtk_widget_destroy(temp_button);
 #endif
-#endif
-  (void)ih;  
-  (*x) += border_size;
-  (*y) += border_size;
 }
 
 static void gtkButtonChildrenCb(GtkWidget *widget, gpointer client_data)
@@ -77,17 +349,71 @@
   }
   else if (ih->data->type == IUP_BUTTON_BOTH) /* both */
   {
-    /* when both is set, button contains an GtkAlignment, 
-       that contains a GtkBox, that contains a label and an image */
-    GtkContainer *container = (GtkContainer*)gtk_bin_get_child((GtkBin*)gtk_bin_get_child((GtkBin*)ih->handle));
-    GtkLabel* label = NULL;
-    gtk_container_foreach(container, gtkButtonChildrenCb, &label);
-    return label;
+    if (iupAttribGet(ih, "_IUPGTK_EVENTBOX"))
+    {
+      /* Borderless IMAGE+TEXT */
+      GtkWidget* box = gtk_bin_get_child((GtkBin*)ih->handle);
+      if (box && GTK_IS_BOX(box))
+      {
+        GtkLabel* label = NULL;
+        gtk_container_foreach(GTK_CONTAINER(box), gtkButtonChildrenCb, &label);
+        return label;
+      }
+      return NULL;
+    }
+    else
+    {
+      /* when both is set, button contains an GtkAlignment, that contains a GtkBox, that contains a label and an image */
+      GtkContainer *container = (GtkContainer*)gtk_bin_get_child((GtkBin*)gtk_bin_get_child((GtkBin*)ih->handle));
+      GtkLabel* label = NULL;
+      gtk_container_foreach(container, gtkButtonChildrenCb, &label);
+      return label;
+    }
   }
   else
     return NULL;
 }
 
+static void gtkButtonFixVerticalAlignment(Ihandle* ih)
+{
+  /* GTK3 uses BASELINE alignment for image+text buttons, which doesn't vertically
+     center the image and text relative to each other. Fix this by setting CENTER alignment. */
+  if (ih->data->type == IUP_BUTTON_BOTH)
+  {
+    GtkWidget* box = NULL;
+
+    if (iupAttribGet(ih, "_IUPGTK_EVENTBOX"))
+    {
+      /* Borderless IMAGE+TEXT */
+      box = gtk_bin_get_child((GtkBin*)ih->handle);
+    }
+    else
+    {
+      /* Normal button */
+      GtkWidget* align = gtk_bin_get_child((GtkBin*)ih->handle);
+      if (align && GTK_IS_BIN(align))
+        box = gtk_bin_get_child((GtkBin*)align);
+    }
+
+    if (box && GTK_IS_BOX(box))
+    {
+      GList* children = gtk_container_get_children(GTK_CONTAINER(box));
+      GList* l;
+      for (l = children; l != NULL; l = l->next)
+      {
+        GtkWidget* child = GTK_WIDGET(l->data);
+#if GTK_CHECK_VERSION(3, 0, 0)
+        gtk_widget_set_valign(child, GTK_ALIGN_CENTER);
+#else
+        if (GTK_IS_MISC(child))
+          gtk_misc_set_alignment(GTK_MISC(child), 0.5, 0.5);
+#endif
+      }
+      g_list_free(children);
+    }
+  }
+}
+
 static int gtkButtonSetTitleAttrib(Ihandle* ih, const char* value)
 {
   if (ih->data->type & IUP_BUTTON_TEXT)  /* text or both */
@@ -138,8 +464,12 @@
   else  /* ACENTER (default) */
     yalign = 0.5f;
 
+#if GTK_CHECK_VERSION(3, 14, 0)
+  /* gtk_button_set_alignment() deprecated in 3.14 */
+  g_object_set(G_OBJECT(button), "xalign", xalign, "yalign", yalign, NULL);
+#else
   gtk_button_set_alignment(button, xalign, yalign);
-  /* TODO:   g_object_set(widget, "xalign", xalign, "yalign", yalign, NULL); */
+#endif
 
   if (ih->data->type == IUP_BUTTON_TEXT)   /* text only */
   {
@@ -166,18 +496,7 @@
 #if GTK_CHECK_VERSION(3, 4, 0)
     iupgtkSetMargin(ih->handle, ih->data->horiz_padding, ih->data->vert_padding, 0);
 #else
-    if (ih->data->type == IUP_BUTTON_TEXT)   /* text only */
-    {
-      GtkMisc* misc = (GtkMisc*)gtk_bin_get_child((GtkBin*)ih->handle);
-      gtk_misc_set_padding(misc, ih->data->horiz_padding, ih->data->vert_padding);
-    }
-    else
-    {
-      GtkAlignment* alignment = (GtkAlignment*)gtk_bin_get_child((GtkBin*)ih->handle);
-      if (GTK_IS_ALIGNMENT(alignment))
-        gtk_alignment_set_padding(alignment, ih->data->vert_padding, ih->data->vert_padding, 
-                                             ih->data->horiz_padding, ih->data->horiz_padding);
-    }
+    (void)ih; /* Padding already handled in size calculation */
 #endif
     return 0;
   }
@@ -185,12 +504,82 @@
     return 1; /* store until not mapped, when mapped will be set again */
 }
 
+#if GTK_CHECK_VERSION(3, 0, 0)
+static gboolean gtkButtonColorDrawAreaDraw(GtkWidget* widget, cairo_t* cr, Ihandle* ih)
+{
+  GtkStyleContext* context = gtk_widget_get_style_context(widget);
+  int width = gtk_widget_get_allocated_width(widget);
+  int height = gtk_widget_get_allocated_height(widget);
+
+  (void)ih;
+  gtk_render_background(context, cr, 0, 0, width, height);
+
+  return FALSE;
+}
+
+static void gtkButtonColorDrawAreaRealize(GtkWidget* widget, Ihandle* ih)
+{
+  char* value = iupAttribGet(ih, "BGCOLOR");
+  if (value)
+  {
+    unsigned char r, g, b;
+    if (iupStrToRGB(value, &r, &g, &b))
+      iupgtkSetBgColor(widget, r, g, b);
+  }
+}
+#else
+static gboolean gtkButtonColorExposeAfter(GtkWidget* widget, GdkEventExpose* evt, Ihandle* ih)
+{
+  GtkAllocation allocation;
+  cairo_t* cr;
+  GdkWindow* window;
+  char* value;
+  unsigned char r, g, b;
+  int x, y, w, h;
+  gint xthickness, ythickness;
+
+  (void)evt;
+
+  value = iupAttribGet(ih, "BGCOLOR");
+  if (!value || !iupStrToRGB(value, &r, &g, &b))
+    return FALSE;
+
+  window = gtk_widget_get_window(widget);
+  if (!window)
+    return FALSE;
+
+  gtk_widget_get_allocation(widget, &allocation);
+
+  /* Draw inside the button frame (just inside xthickness/ythickness) */
+  xthickness = GTK_WIDGET(widget)->style->xthickness;
+  ythickness = GTK_WIDGET(widget)->style->ythickness;
+
+  /* GTK2 buttons use parent's window, so we need allocation offset */
+  x = allocation.x + xthickness;
+  y = allocation.y + ythickness;
+  w = allocation.width - 2 * xthickness;
+  h = allocation.height - 2 * ythickness;
+
+  if (w > 0 && h > 0)
+  {
+    cr = gdk_cairo_create(window);
+    cairo_set_source_rgb(cr, r / 255.0, g / 255.0, b / 255.0);
+    cairo_rectangle(cr, x, y, w, h);
+    cairo_fill(cr);
+    cairo_destroy(cr);
+  }
+
+  return FALSE;
+}
+#endif
+
 static int gtkButtonSetBgColorAttrib(Ihandle* ih, const char* value)
 {
+#if GTK_CHECK_VERSION(3, 0, 0)
   if (ih->data->type == IUP_BUTTON_TEXT)
   {
-    /* Color button */
-    GtkWidget* frame = gtk_button_get_image(GTK_BUTTON(ih->handle));
+    /* Color button with frame+drawarea */
+    GtkWidget* frame = gtk_bin_get_child(GTK_BIN(ih->handle));
     if (frame && GTK_IS_FRAME(frame))
     {
       unsigned char r, g, b;
@@ -197,10 +586,23 @@
       if (!iupStrToRGB(value, &r, &g, &b))
         return 0;
 
-      iupgtkSetBgColor(gtk_bin_get_child(GTK_BIN(frame)), r, g, b);
+      GtkWidget* drawarea = gtk_bin_get_child(GTK_BIN(frame));
+      if (gtk_widget_get_realized(drawarea))
+        iupgtkSetBgColor(drawarea, r, g, b);
       return 1;
     }
   }
+#else
+  if (ih->data->type == IUP_BUTTON_TEXT)
+  {
+    char* bgcolor = iupAttribGet(ih, "BGCOLOR");
+    if (bgcolor)
+    {
+      gtk_widget_queue_draw(ih->handle);
+      return 1;
+    }
+  }
+#endif
 
   return iupdrvBaseSetBgColorAttrib(ih, value);
 }
@@ -233,13 +635,33 @@
   return 1;
 }
 
+static void gtkButtonImageChildrenCb(GtkWidget *widget, gpointer client_data)
+{
+  if (GTK_IS_IMAGE(widget))
+  {
+    GtkImage **image = (GtkImage**)client_data;
+    *image = (GtkImage*)widget;
+  }
+}
+
 static void gtkButtonSetPixbuf(Ihandle* ih, const char* name, int make_inactive)
 {
-  GtkImage* image;
+  GtkImage* image = NULL;
+
   if (!iupAttribGet(ih, "_IUPGTK_EVENTBOX"))
+  {
     image = (GtkImage*)gtk_button_get_image((GtkButton*)ih->handle);
+  }
   else
-    image = (GtkImage*)gtk_bin_get_child((GtkBin*)ih->handle);
+  {
+    GtkWidget* child = gtk_bin_get_child((GtkBin*)ih->handle);
+    if (GTK_IS_IMAGE(child))
+      image = (GtkImage*)child;
+    else if (GTK_IS_BOX(child))
+    {
+      gtk_container_foreach(GTK_CONTAINER(child), gtkButtonImageChildrenCb, &image);
+    }
+  }
 
   if (name && image)
   {
@@ -250,7 +672,6 @@
     return;
   }
 
-  /* if not defined */
 #if GTK_CHECK_VERSION(2, 8, 0)
   if (image)
     gtk_image_clear(image);
@@ -390,19 +811,6 @@
 static void gtkButtonLayoutUpdateMethod(Ihandle *ih)
 {
   iupdrvBaseLayoutUpdateMethod(ih);
-
-  if (ih->data->type == IUP_BUTTON_TEXT)
-  {
-    /* Color button */
-    GtkWidget* frame = gtk_button_get_image(GTK_BUTTON(ih->handle));
-    if (frame && GTK_IS_FRAME(frame))
-    {
-      int x = 0, y = 0;
-      iupdrvButtonAddBorders(ih, &x, &y);
-      if (ih->currentwidth - x > 0 && ih->currentheight - y > 0)
-        gtk_widget_set_size_request(frame, ih->currentwidth-x, ih->currentheight-y);
-    }
-  }
 }
 
 static int gtkButtonMapMethod(Ihandle* ih)
@@ -421,7 +829,7 @@
   else
     ih->data->type = IUP_BUTTON_TEXT;
 
-  if (ih->data->type == IUP_BUTTON_IMAGE &&
+  if (ih->data->type & IUP_BUTTON_IMAGE &&
       iupAttribGet(ih, "IMPRESS") &&
       !iupAttribGetBoolean(ih, "IMPRESSBORDER"))
     has_border = 0;
@@ -428,11 +836,30 @@
 
   if (!has_border)
   {
-    GtkWidget *img = gtk_image_new();
     ih->handle = gtk_event_box_new();
-    gtk_container_add((GtkContainer*)ih->handle, img);
-    gtk_widget_show(img);
     iupAttribSet(ih, "_IUPGTK_EVENTBOX", "1");
+
+    if (ih->data->type & IUP_BUTTON_TEXT)
+    {
+#if GTK_CHECK_VERSION(3, 0, 0)
+      GtkWidget* box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, ih->data->spacing);
+#else
+      GtkWidget* box = gtk_hbox_new(FALSE, ih->data->spacing);
+#endif
+      GtkWidget* img = gtk_image_new();
+      GtkWidget* label = gtk_label_new("");
+
+      gtk_box_pack_start(GTK_BOX(box), img, FALSE, FALSE, 0);
+      gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 0);
+      gtk_container_add((GtkContainer*)ih->handle, box);
+      gtk_widget_show_all(box);
+    }
+    else
+    {
+      GtkWidget* img = gtk_image_new();
+      gtk_container_add((GtkContainer*)ih->handle, img);
+      gtk_widget_show(img);
+    }
   }
   else
     ih->handle = gtk_button_new();
@@ -466,23 +893,28 @@
   else
   {
     char* title = iupAttribGet(ih, "TITLE");
-    if (!title) 
+    if (!title || *title == 0)
     {
       if (iupAttribGet(ih, "BGCOLOR"))
       {
+#if GTK_CHECK_VERSION(3, 0, 0)
         GtkWidget* frame = gtk_frame_new(NULL);
-#if GTK_CHECK_VERSION(2, 18, 0)
         GtkWidget* drawarea = gtk_drawing_area_new();
         gtk_widget_set_has_window(drawarea, TRUE);
-#else
-        GtkWidget* drawarea = gtk_fixed_new();
-        gtk_fixed_set_has_window(GTK_FIXED(drawarea), TRUE);
-#endif
         gtk_frame_set_shadow_type(GTK_FRAME(frame), GTK_SHADOW_IN);
         gtk_container_add(GTK_CONTAINER(frame), drawarea);
         gtk_widget_show(drawarea);
 
-        gtk_button_set_image((GtkButton*)ih->handle, frame);
+        g_signal_connect(G_OBJECT(drawarea), "realize", G_CALLBACK(gtkButtonColorDrawAreaRealize), ih);
+        g_signal_connect(G_OBJECT(drawarea), "draw", G_CALLBACK(gtkButtonColorDrawAreaDraw), ih);
+
+        /* Add frame directly as button's child so it can expand to fill */
+        gtk_container_add(GTK_CONTAINER(ih->handle), frame);
+        gtk_widget_show(frame);
+#else
+        /* GTK2: Draw directly on button via expose-event */
+        g_signal_connect_after(G_OBJECT(ih->handle), "expose-event", G_CALLBACK(gtkButtonColorExposeAfter), ih);
+#endif
       }
       else
         gtk_button_set_label((GtkButton*)ih->handle, "");
@@ -491,10 +923,8 @@
       gtk_button_set_label((GtkButton*)ih->handle, "");
   }
 
-  if (has_border)
-    iupgtkClearSizeStyleCSS(ih->handle);
+  (void)has_border;
 
-  /* add to the parent, all GTK controls must call this. */
   iupgtkAddToParent(ih);
 
   if (!iupAttribGetBoolean(ih, "CANFOCUS"))
@@ -529,12 +959,24 @@
 
   if (!has_border)
   {
-    GtkWidget* img = gtk_bin_get_child((GtkBin*)ih->handle);
-    gtk_widget_realize(img);
+    GtkWidget* child = gtk_bin_get_child((GtkBin*)ih->handle);
+    if (child)
+      gtk_widget_realize(child);
   }
 
+#if !GTK_CHECK_VERSION(3, 0, 0)
+  /* GTK2: Apply button alignment before realize to actually center content. */
+  if (has_border && !iupAttribGet(ih, "_IUPGTK_EVENTBOX"))
+  {
+    gtk_button_set_alignment((GtkButton*)ih->handle, 0.5f, 0.5f);
+  }
+#endif
+
   gtk_widget_realize(ih->handle);
 
+  /* Fix vertical alignment for image+text buttons */
+  gtkButtonFixVerticalAlignment(ih);
+
   /* update a mnemonic in a label if necessary */
   iupgtkUpdateMnemonic(ih);
 
Index: src/gtk/iupgtk_calendar.c
===================================================================
--- src/gtk/iupgtk_calendar.c	(revision 5971)
+++ src/gtk/iupgtk_calendar.c	(working copy)
@@ -107,8 +107,18 @@
 
 static void gtkCalendarDaySelected(GtkCalendar *calendar, Ihandle* ih)
 {
-  iupBaseCallValueChangedCb(ih);
-  (void)calendar;
+  guint year, month, day;
+  int old_day;
+
+  gtk_calendar_get_date(calendar, &year, &month, &day);
+
+  old_day = iupAttribGetInt(ih, "_IUP_OLD_DAY");
+
+  if ((int)day != old_day)
+  {
+    iupAttribSetInt(ih, "_IUP_OLD_DAY", (int)day);
+    iupBaseCallValueChangedCb(ih);
+  }
 }
 
 static int gtkCalendarMapMethod(Ihandle* ih)
Index: src/gtk/iupgtk_canvas.c
===================================================================
--- src/gtk/iupgtk_canvas.c	(revision 5971)
+++ src/gtk/iupgtk_canvas.c	(working copy)
@@ -6,6 +6,10 @@
 
 #include <gtk/gtk.h>
 
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -142,7 +146,7 @@
   }
   else
   {
-    IFnff cb = (IFnff)IupGetCallback(ih,"ACTION");
+    IFn cb = (IFn)IupGetCallback(ih,"ACTION");
     if (cb)
     {
       /* REDRAW Now (since 3.24) - to allow a full native redraw process */
@@ -198,7 +202,7 @@
   }
   else
   {
-    IFnff cb = (IFnff)IupGetCallback(ih,"ACTION");
+    IFn cb = (IFn)IupGetCallback(ih,"ACTION");
     if (cb)
     {
       /* REDRAW Now (since 3.24) - to allow a full native redraw process */
@@ -303,10 +307,37 @@
 static gboolean gtkCanvasExposeEvent(GtkWidget *widget, GdkEventExpose *evt, Ihandle *ih)
 #endif
 {
-  IFnff cb = (IFnff)IupGetCallback(ih,"ACTION");
+  IFn cb = (IFn)IupGetCallback(ih,"ACTION");
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  /* Check if there's a persistent buffer from SCROLL_CB or other drawing outside ACTION */
+  if (iupAttribGet(ih, "_IUPGTK3_BUFFER_DIRTY"))
+  {
+    cairo_surface_t* buffer = (cairo_surface_t*)iupAttribGet(ih, "_IUPGTK3_CANVAS_BUFFER");
+
+    if (buffer)
+    {
+      GdkRectangle rect;
+      gdk_cairo_get_clip_rectangle(cr, &rect);
+
+      int buf_w = cairo_image_surface_get_width(buffer);
+      int buf_h = cairo_image_surface_get_height(buffer);
+
+      /* If buffer exists and matches size, use it instead of calling ACTION */
+      if (buf_w == rect.width && buf_h == rect.height)
+      {
+        cairo_set_source_surface(cr, buffer, 0, 0);
+        cairo_paint(cr);
+        /* Keep dirty flag set - continue using buffer until ACTION is called */
+        return TRUE;  /* Don't call ACTION callback */
+      }
+    }
+  }
+#endif
+
   if (cb && !(ih->data->inside_resize))
   {
-    /* IMPORTANT: this will not fully work at the first time because the GTK internal double buffer already started. 
+    /* IMPORTANT: this will not fully work at the first time because the GTK internal double buffer already started.
                   On the first time, the canvas will be configured correctly but after calling the application callback,
                   GTK will overwrite its contents with the BGCOLOR. */
     if (!iupAttribGet(ih, "_IUPGTK_NO_BGCOLOR"))
@@ -318,12 +349,14 @@
       gdk_cairo_get_clip_rectangle(cr, &rect);
       iupAttribSetStrf(ih, "CLIPRECT", "%d %d %d %d", rect.x, rect.y, rect.x+rect.width-1, rect.y+rect.height-1);
       iupAttribSet(ih, "CAIRO_CR", (char*)cr);
+      /* Clear dirty flag since ACTION is being called */
+      iupAttribSet(ih, "_IUPGTK3_BUFFER_DIRTY", NULL);
     }
 #else
     iupAttribSetStrf(ih, "CLIPRECT", "%d %d %d %d", evt->area.x, evt->area.y, evt->area.x+evt->area.width-1, evt->area.y+evt->area.height-1);
 #endif
 
-    cb(ih, (float)ih->data->posx, (float)ih->data->posy);
+    cb(ih);
 
     iupAttribSet(ih, "CLIPRECT", NULL);
     iupAttribSet(ih, "CAIRO_CR", NULL);
@@ -498,7 +531,13 @@
       iupAttribSet(ih, "XHIDDEN", "NO");
 
       if (value_changed)
+      {
+#if GTK_CHECK_VERSION(3, 18, 0)
+        g_signal_emit_by_name(sb_horiz_adjust, "value-changed");
+#else
         gtk_adjustment_value_changed(sb_horiz_adjust);
+#endif
+      }
     }
   }
   return 1;
@@ -586,7 +625,13 @@
       iupAttribSet(ih, "YHIDDEN", "NO");
 
       if (value_changed)
+      {
+#if GTK_CHECK_VERSION(3, 18, 0)
+        g_signal_emit_by_name(sb_vert_adjust, "value-changed");
+#else
         gtk_adjustment_value_changed(sb_vert_adjust);
+#endif
+      }
     }
   }
   return 1;
@@ -673,14 +718,17 @@
       if (sb) iupgtkSetBgColor(sb, r, g, b);
     }
 
-    /* enable automatic double buffering */
+#if !GTK_CHECK_VERSION(3, 14, 0)
+    /* enable automatic double buffering (deprecated in GTK 3.14, always enabled) */
     gtk_widget_set_double_buffered(ih->handle, TRUE);
     gtk_widget_set_double_buffered(sb_win, TRUE);
+#endif
 
     return iupdrvBaseSetBgColorAttrib(ih, value);
   }
   else
   {
+#if !GTK_CHECK_VERSION(3, 14, 0)
     /* disable automatic double buffering if not a container or an OpenGL canvas */
     if (ih->iclass->childtype != IUP_CHILDNONE && !iupAttribGet(ih, "_IUP_GLCONTROLDATA"))
     {
@@ -696,6 +744,7 @@
       gdk_window_set_back_pixmap(iupgtkGetWindow(ih->handle), NULL, FALSE);
 #endif
     }
+#endif
 
     iupAttribSet(ih, "_IUPGTK_NO_BGCOLOR", "1");
     return 1;
@@ -711,8 +760,10 @@
 #if GTK_CHECK_VERSION(2, 24, 0)
     w = gdk_window_get_width(window);
     h = gdk_window_get_height(window);
+#elif !defined(GDK_DISABLE_DEPRECATED)
+    gdk_drawable_get_size(window, &w, &h);
 #else
-    gdk_drawable_get_size(window, &w, &h);
+    gdk_window_get_geometry(window, NULL, NULL, &w, &h, NULL);
 #endif
     return iupStrReturnIntInt(w, h, 'x');
   }
@@ -745,8 +796,14 @@
 
   /* canvas is also a container */
   /* use a window to be a full native container */
-  ih->handle = iupgtkNativeContainerNew(1);  
+  /* Check if this is a GL canvas to determine Wayland window handling */
+  if (iupAttribGet(ih, "_IUP_GLCONTROLDATA"))
+    iupgtkNativeContainerSetGLCanvas(1);
 
+  ih->handle = iupgtkNativeContainerNew(1);
+
+  iupgtkNativeContainerSetGLCanvas(0);
+
 #if !GTK_CHECK_VERSION(3, 0, 0)
   if (visual)
     gtk_widget_pop_colormap();
@@ -899,4 +956,5 @@
   /* Not Supported */
   iupClassRegisterAttribute(ic, "BACKINGSTORE", NULL, NULL, "YES", NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TOUCH", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/gtk/iupgtk_common.c
===================================================================
--- src/gtk/iupgtk_common.c	(revision 5971)
+++ src/gtk/iupgtk_common.c	(working copy)
@@ -11,6 +11,10 @@
 
 #include <gtk/gtk.h>
 
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+
 #include "iup.h"
 #include "iupcbs.h"
 #include "iupkey.h"
@@ -29,6 +33,9 @@
 
 #include "iupgtk_drv.h"
 
+/* Global state variables for GTK Fixed container */
+static int iupGtkFixedIsGLCanvas = 0;
+
 #if GTK_CHECK_VERSION(3, 0, 0)
 typedef struct _iupGtkFixed
 {
@@ -58,6 +65,15 @@
 
 static void iup_gtk_fixed_init (iupGtkFixed *fixed)
 {
+#ifdef GDK_WINDOWING_WAYLAND
+  GdkDisplay* display = gdk_display_get_default();
+  if (display && GDK_IS_WAYLAND_DISPLAY(display) && iupGtkFixedWindow && iupGtkFixedIsGLCanvas)
+  {
+    /* For GL canvas on Wayland, use has_window=FALSE and create subsurface manually */
+    return;
+  }
+#endif
+
   if (iupGtkFixedWindow)
     gtk_widget_set_has_window(GTK_WIDGET(fixed), TRUE);
 }
@@ -93,6 +109,17 @@
 #endif
 
 #if GTK_CHECK_VERSION(2, 18, 0)
+  /* On Wayland, GL canvas containers should NOT have their own GdkWindow.
+   * We create a manual subsurface instead. */
+#ifdef GDK_WINDOWING_WAYLAND
+  {
+    GdkDisplay* display = gdk_display_get_default();
+    if (display && GDK_IS_WAYLAND_DISPLAY(display) && has_window && iupGtkFixedIsGLCanvas)
+    {
+      has_window = 0;
+    }
+  }
+#endif
   gtk_widget_set_has_window(widget, has_window);
 #else
   gtk_fixed_set_has_window(GTK_FIXED(widget), has_window);
@@ -101,6 +128,11 @@
   return widget;
 }
 
+void iupgtkNativeContainerSetGLCanvas(int is_gl)
+{
+  iupGtkFixedIsGLCanvas = is_gl;
+}
+
 void iupgtkNativeContainerAdd(GtkWidget* container, GtkWidget* widget)
 {
   gtk_fixed_put(GTK_FIXED(container), widget, 0, 0);
@@ -148,7 +180,14 @@
   old_parent = gtk_widget_get_parent(widget);
   if (old_parent != new_parent)
   {
+#if GTK_CHECK_VERSION(3, 14, 0)
+    g_object_ref(widget);
+    gtk_container_remove(GTK_CONTAINER(old_parent), widget);
+    gtk_container_add(GTK_CONTAINER(new_parent), widget);
+    g_object_unref(widget);
+#else
     gtk_widget_reparent(widget, new_parent);
+#endif
     gtk_widget_realize(widget);
   }
 }
@@ -167,7 +206,53 @@
   iupgtkNativeContainerMove((GtkWidget*)parent, widget, x, y);
 
   if (width > 0 && height > 0)
-    gtk_widget_set_size_request(widget, width, height);
+  {
+    /* Check if VISIBLELINES is set, if so, use IUP's calculated height directly */
+    const char* visiblelines_set = (const char*)g_object_get_data(G_OBJECT(widget), "iup-visiblelines-set");
+    if (visiblelines_set)
+    {
+      /* IUP's calculated height includes proper borders */
+      gtk_widget_set_size_request(widget, width, height);
+
+      /* For editbox lists (VBox container), also find and set size_request on scrolled_window child */
+      if (GTK_IS_BOX(widget))
+      {
+        GList* children = gtk_container_get_children(GTK_CONTAINER(widget));
+        for (GList* l = children; l != NULL; l = l->next)
+        {
+          GtkWidget* child = GTK_WIDGET(l->data);
+          const char* sw_flag = (const char*)g_object_get_data(G_OBJECT(child), "iup-visiblelines-scrolled");
+          if (sw_flag)
+          {
+            /* Calculate scrolled_window height (total - entry height) */
+            int entry_h = 0;
+            for (GList* le = children; le != NULL; le = le->next)
+            {
+              GtkWidget* w = GTK_WIDGET(le->data);
+              if (GTK_IS_ENTRY(w))
+              {
+                GtkRequisition req;
+#if GTK_CHECK_VERSION(3, 0, 0)
+                gtk_widget_get_preferred_size(w, &req, NULL);
+#else
+                gtk_widget_size_request(w, &req);
+#endif
+                entry_h = req.height;
+                break;
+              }
+            }
+            int sw_h = (entry_h > 0) ? (height - entry_h) : height;
+            if (sw_h < 1) sw_h = 1;
+            gtk_widget_set_size_request(child, -1, sw_h);
+            break;
+          }
+        }
+        g_list_free(children);
+      }
+    }
+    else
+      gtk_widget_set_size_request(widget, width, height);
+  }
 }
 
 IUP_SDK_API void iupdrvBaseLayoutUpdateMethod(Ihandle *ih)
@@ -207,9 +292,11 @@
   /* Post a REDRAW */
   gtk_widget_queue_draw(ih->handle);
 
-  /* Force a REDRAW */
+#if !GTK_CHECK_VERSION(3, 22, 0)
+  /* Force a REDRAW (deprecated in GTK 3.22, no replacement needed) */
   if (window)
     gdk_window_process_updates(window, TRUE);
+#endif
 }
 
 static GtkWidget* gtkGetWindowedParent(GtkWidget* widget)
@@ -379,7 +466,7 @@
 }
 
 #if GTK_CHECK_VERSION(3, 0, 0)
-static void iupgdkRGBASet(GdkRGBA* rgba, unsigned char r, unsigned char g, unsigned char b)
+void iupgdkRGBASet(GdkRGBA* rgba, unsigned char r, unsigned char g, unsigned char b)
 {
   rgba->red = iupgtkColorToDouble(r);
   rgba->green = iupgtkColorToDouble(g);
@@ -564,9 +651,12 @@
 
   iupgdkRGBASet(&rgba, r, g, b);
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
   gtk_widget_override_color(handle, GTK_STATE_FLAG_NORMAL, &rgba);
   gtk_widget_override_color(handle, GTK_STATE_FLAG_ACTIVE, &rgba);
   gtk_widget_override_color(handle, GTK_STATE_FLAG_PRELIGHT, &rgba);
+#pragma GCC diagnostic pop
 #else
   GtkRcStyle *rc_style;  
   GdkColor color;
@@ -615,7 +705,7 @@
 {
 #if GTK_CHECK_VERSION(2, 16, 0)
   (void)ih;
-  return gdk_cursor_new(GDK_BLANK_CURSOR);
+  return gdk_cursor_new_for_display(gdk_display_get_default(), GDK_BLANK_CURSOR);
 #else  
   /* creates an empty cursor */
   GdkColor cursor_color = {0L,0,0,0};
@@ -687,7 +777,7 @@
     if (iupStrEqualNoCase(name, table[i].iupname)) 
     {
       if (table[i].sysname)
-        cur = gdk_cursor_new(table[i].sysname);
+        cur = gdk_cursor_new_for_display(gdk_display_get_default(), table[i].sysname);
       else
         cur = gtkEmptyCursor(ih);
 
@@ -735,9 +825,6 @@
 {
   static int size = 0;
 
-  if (iupStrBoolean(IupGetGlobal("OVERLAYSCROLLBAR")))
-    return 1;
-
   if (size == 0)
   {
     gint slider_width, trough_border;
@@ -871,7 +958,7 @@
   if (!keyval)
     return;
 
-  if (!gdk_keymap_get_entries_for_keyval(gdk_keymap_get_default(), keyval, &keys, &nkeys))
+  if (!gdk_keymap_get_entries_for_keyval(gdk_keymap_get_for_display(gdk_display_get_default()), keyval, &keys, &nkeys))
     return;
 
   window = iupgtkGetWindow(focus->handle);
@@ -888,7 +975,11 @@
 IUP_SDK_API void iupdrvWarpPointer(int x, int y)
 {
   /* VirtualBox does not reproduce the mouse move visually, but it is working. */
-#if GTK_CHECK_VERSION(3, 0, 0)
+#if GTK_CHECK_VERSION(3, 20, 0)
+  GdkSeat* seat = gdk_display_get_default_seat(gdk_display_get_default());
+  GdkDevice* device = gdk_seat_get_pointer(seat);
+  gdk_device_warp(device, gdk_screen_get_default(), x, y);
+#elif GTK_CHECK_VERSION(3, 0, 0)
   GdkDeviceManager* device_manager = gdk_display_get_device_manager(gdk_display_get_default());
   GdkDevice* device = gdk_device_manager_get_client_pointer(device_manager);
   gdk_device_warp(device, gdk_screen_get_default(), x, y);
@@ -911,7 +1002,10 @@
 
     /* TODO check gdk_event_set_pointer_emulated */
 
-#if GTK_CHECK_VERSION(3, 0, 0)
+#if GTK_CHECK_VERSION(3, 20, 0)
+    GdkSeat* seat = gdk_display_get_default_seat(gdk_display_get_default());
+    GdkDevice* device = gdk_seat_get_pointer(seat);
+#elif GTK_CHECK_VERSION(3, 0, 0)
     GdkDeviceManager* device_manager = gdk_display_get_device_manager(gdk_display_get_default());
     GdkDevice* device = gdk_device_manager_get_client_pointer(device_manager);
 #endif
@@ -1040,8 +1134,13 @@
 
 void iupgtkWindowGetPointer(GdkWindow *window, int *x, int *y, GdkModifierType *mask)
 {
-#if GTK_CHECK_VERSION(3, 0, 0)
+#if GTK_CHECK_VERSION(3, 20, 0)
   GdkDisplay *display = gdk_window_get_display(window);
+  GdkSeat* seat = gdk_display_get_default_seat(display);
+  GdkDevice* device = gdk_seat_get_pointer(seat);
+  gdk_window_get_device_position(window, device, x, y, mask);
+#elif GTK_CHECK_VERSION(3, 0, 0)
+  GdkDisplay *display = gdk_window_get_display(window);
   GdkDeviceManager* device_manager = gdk_display_get_device_manager(display);
   GdkDevice* device = gdk_device_manager_get_client_pointer(device_manager);
   gdk_window_get_device_position(window, device, x, y, mask);
@@ -1072,19 +1171,42 @@
   (void)mandatory_gtk3;
 }
 
-void iupgtkClearSizeStyleCSS(GtkWidget* widget)
+
+int iupgtkIsSystemDarkMode(void)
 {
 #if GTK_CHECK_VERSION(3, 0, 0)
-  GtkStyleContext *context = gtk_widget_get_style_context(widget);
-  const char* str = "*{ padding-bottom: 0px ; padding-top: 0px; padding-left: 2px;  padding-right: 2px; "
-                        "margin-bottom: 0px;  margin-top: 0px;  margin-left: 0px;   margin-right: 0px; }";
-  GtkCssProvider *provider = gtk_css_provider_new();
-  gtk_css_provider_load_from_data(GTK_CSS_PROVIDER(provider), str, -1, NULL);
-  gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
-  g_object_unref(provider);
+  GtkWidget* temp_window;
+  GtkStyleContext* style;
+  GdkRGBA bg, fg;
+  double bg_lum, fg_lum;
+  int is_dark;
+
+  temp_window = gtk_offscreen_window_new();
+  style = gtk_widget_get_style_context(temp_window);
+
+#if GTK_CHECK_VERSION(3, 16, 0)
+  if (!gtk_style_context_lookup_color(style, "theme_bg_color", &bg))
+  {
+    bg.red = 1.0; bg.green = 1.0; bg.blue = 1.0; bg.alpha = 1.0;
+  }
 #else
-  (void)widget;
+  gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &bg);
 #endif
+  gtk_style_context_get_color(style, GTK_STATE_FLAG_NORMAL, &fg);
+
+  /* Calculate relative luminance using standard formula (ITU-R BT.709) */
+  bg_lum = 0.2126 * bg.red + 0.7152 * bg.green + 0.0722 * bg.blue;
+  fg_lum = 0.2126 * fg.red + 0.7152 * fg.green + 0.0722 * fg.blue;
+
+  /* Dark theme has lower background luminance than foreground */
+  is_dark = (bg_lum < fg_lum) ? 1 : 0;
+
+  gtk_widget_destroy(temp_window);
+
+  return is_dark;
+#else
+  return 0;
+#endif
 }
 
 IUP_SDK_API void iupdrvSetAccessibleTitle(Ihandle *ih, const char* title)
Index: src/gtk/iupgtk_dialog.c
===================================================================
--- src/gtk/iupgtk_dialog.c	(revision 5971)
+++ src/gtk/iupgtk_dialog.c	(working copy)
@@ -4,13 +4,20 @@
  * See Copyright Notice in "iup.h"
  */
 
-#undef GTK_DISABLE_DEPRECATED  /* Since GTK 3.14 gtk_status_icon is deprecated. */
 #include <gtk/gtk.h>
 
+#ifdef GDK_WINDOWING_X11
+#include <gdk/gdkx.h>
+#endif
+
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+
 #ifdef HILDON
 #include <hildon/hildon-program.h>
 #endif
-                                         
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -43,7 +50,6 @@
 static void gtkDialogSetMinMax(Ihandle* ih, int min_w, int min_h, int max_w, int max_h);
 
 
-
 /****************************************************************
                      Utilities
 ****************************************************************/
@@ -50,17 +56,11 @@
 
 static gboolean gtkDialogChildDestroyEvent(GtkWidget *widget, Ihandle *ih)
 {
-  /* It seems that the documentation for this callback is not correct */
-  /* The second parameter must be the user_data or it will fail. */
   (void)widget;
 
-  /* If the IUP dialog was not destroyed, destroy it here. */
   if (iupObjectCheck(ih))
     IupDestroy(ih);
 
-  /* this callback is useful to destroy children dialogs when the parent is destroyed. */
-  /* The application is responsible for destroying the children before this happen. */
-
   return FALSE;
 }
 
@@ -67,8 +67,6 @@
 void iupdrvDialogSetParent(Ihandle* ih, InativeHandle* parent)
 {
   gtk_window_set_transient_for((GtkWindow*)ih->handle, (GtkWindow*)parent);
-
-  /* manually remove child windows when parent is destroyed */
   g_signal_connect(G_OBJECT(parent), "destroy", G_CALLBACK(gtkDialogChildDestroyEvent), ih);
 }
 
@@ -81,16 +79,28 @@
 {
   int width, height;
   int border = 0, caption = 0, menu;
+  int decorheight;
+
   if (!handle)
     handle = ih->handle;
 
-  gtk_window_get_size((GtkWindow*)handle, &width, &height);  /* client size */
+  gtk_window_get_size((GtkWindow*)handle, &width, &height);
 
   if (ih)
     iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
 
+  decorheight = 2*border + caption;
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  {
+    GtkStyleContext* context = gtk_widget_get_style_context(GTK_WIDGET(handle));
+    if (gtk_style_context_has_class(context, "csd"))
+      decorheight = caption;
+  }
+#endif
+
   if (w) *w = width + 2*border;
-  if (h) *h = height + 2*border + caption;  /* menu is inside the dialog_manager */
+  if (h) *h = height + decorheight;
 }
 
 void iupdrvDialogSetVisible(Ihandle* ih, int visible)
@@ -115,7 +125,6 @@
   }
   else if (ih)
   {
-    /* gtk_window_get_position returns an outdated value if window is not visible */
     if (x) *x = iupAttribGetInt(ih, "_IUPGTK_OLD_X");
     if (y) *y = iupAttribGetInt(ih, "_IUPGTK_OLD_Y");
   }
@@ -130,7 +139,7 @@
 {
 #ifdef HILDON
   return 0;
-#else                    
+#else
   if (ih->data->menu && !iupStrBoolean(IupGetGlobal("GLOBALMENU")))
     return iupdrvMenuGetMenuBarSize(ih->data->menu);
   else
@@ -140,20 +149,83 @@
 
 #define iupABS(_x) ((_x)<0? -(_x): (_x))
 
+/* Get CSD shadow margin (the part of window outside visible frame) */
+static int gtkDialogGetCSDShadowMargin(Ihandle* ih)
+{
+#if GTK_CHECK_VERSION(3, 0, 0)
+  GtkStyleContext* context = gtk_widget_get_style_context(ih->handle);
+  if (gtk_style_context_has_class(context, "csd"))
+  {
+    /* GTK3 CSD shadow margin is typically 26 pixels (Adwaita theme) */
+    return 26;
+  }
+#endif
+  return 0;
+}
+
+/* Get window decoration sizes for CSD windows by measuring allocations */
 static void gtkDialogGetWindowDecor(Ihandle* ih, int *win_border, int *win_caption)
 {
-  int x, y, frame_x, frame_y;
-  gdk_window_get_origin(iupgtkGetWindow(ih->handle), &x, &y);
-  gdk_window_get_root_origin(iupgtkGetWindow(ih->handle), &frame_x, &frame_y);
-  *win_border = iupABS(x - frame_x);   /* For unknown reason GTK sometimes give negative results */
-  *win_caption = iupABS(y - frame_y) - *win_border;
+  GdkWindow* window = iupgtkGetWindow(ih->handle);
+
+  *win_border = 0;
+  *win_caption = 0;
+
+  if (!window)
+    return;
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  {
+    GtkStyleContext* context = gtk_widget_get_style_context(ih->handle);
+    if (gtk_style_context_has_class(context, "csd"))
+    {
+      static int cached_border = -1;
+      static int cached_caption = -1;
+
+      if (cached_border >= 0 && cached_caption >= 0)
+      {
+        *win_border = cached_border;
+        *win_caption = cached_caption;
+        return;
+      }
+
+      GtkAllocation window_alloc, child_alloc;
+      GtkWidget* child = gtk_bin_get_child(GTK_BIN(ih->handle));
+
+      gtk_widget_get_allocation(ih->handle, &window_alloc);
+      if (child && gtk_widget_get_allocated_width(child) > 0 && gtk_widget_get_allocated_height(child) > 0)
+        gtk_widget_get_allocation(child, &child_alloc);
+      else
+        return;
+
+      *win_caption = window_alloc.height - child_alloc.height;
+      if (*win_caption < 0) *win_caption = 0;
+
+      *win_border = (window_alloc.width - child_alloc.width) / 2;
+      if (*win_border < 0) *win_border = 0;
+
+      if (*win_caption > 0)
+      {
+        cached_border = *win_border;
+        cached_caption = *win_caption;
+      }
+      return;
+    }
+  }
+#endif
+
+  {
+    int x, y, frame_x, frame_y;
+    gdk_window_get_origin(window, &x, &y);
+    gdk_window_get_root_origin(window, &frame_x, &frame_y);
+    *win_border = iupABS(x - frame_x);
+    *win_caption = iupABS(y - frame_y) - *win_border;
+  }
 }
 
 void iupdrvDialogGetDecoration(Ihandle* ih, int *border, int *caption, int *menu)
 {
 #ifdef HILDON
-  /* In Hildon, borders have fixed dimensions, but are drawn as part
-     of the client area! */
   if (border)
     *border = (iupAttribGetBoolean(ih, "HILDONWINDOW") && !iupAttribGetBoolean(ih, "FULLSCREEN")) ? 12 : 0;
   if (caption)
@@ -163,11 +235,12 @@
 #else
   static int native_border = 0;
   static int native_caption = 0;
+  int has_csd = 0;
 
-  int has_titlebar = iupAttribGetBoolean(ih, "RESIZE")  || /* GTK and Motif only */
+  int has_titlebar = iupAttribGetBoolean(ih, "RESIZE")  ||
                      iupAttribGetBoolean(ih, "MAXBOX")  ||
                      iupAttribGetBoolean(ih, "MINBOX")  ||
-                     iupAttribGetBoolean(ih, "MENUBOX") || 
+                     iupAttribGetBoolean(ih, "MENUBOX") ||
                      iupAttribGet(ih, "TITLE");
 
   int has_border = has_titlebar ||
@@ -176,50 +249,71 @@
 
   *menu = gtkDialogGetMenuSize(ih);
 
-  if (ih->handle && iupdrvIsVisible(ih))
+#if GTK_CHECK_VERSION(3, 0, 0)
+  if (ih->handle)
   {
-    int win_border, win_caption;
+    GtkStyleContext* context = gtk_widget_get_style_context(ih->handle);
+    if (gtk_style_context_has_class(context, "csd"))
+      has_csd = 1;
+  }
+
+  /* CSD: shadows are outside the visible frame, IUP doesn't care about them.
+     Return border=0 so IUP Core doesn't subtract shadows.
+     Caption = titlebar height (inside the visible frame). */
+  if (has_csd && ih->handle && iupdrvIsVisible(ih))
+  {
+    int win_border = 0, win_caption = 0;
     gtkDialogGetWindowDecor(ih, &win_border, &win_caption);
 
-#ifdef WIN32
-    if (*menu)
-      win_caption -= *menu;
+    if (win_caption > 0)
+    {
+      int titlebar_only = win_caption - 2*win_border;
+      if (titlebar_only < 0) titlebar_only = 0;
+
+      *border = 0;  /* Shadows are outside IUP's model */
+      *caption = titlebar_only;
+      return;
+    }
+  }
 #endif
 
-    *border = 0;
-    if (has_border)
-      *border = win_border;
+  /* Non-CSD visible path (SSD windows only) */
+  if (!has_csd && ih->handle && iupdrvIsVisible(ih))
+  {
+    int win_border = 0, win_caption = 0;
+    gtkDialogGetWindowDecor(ih, &win_border, &win_caption);
 
-    *caption = 0;
-    if (has_titlebar)
-      *caption = win_caption;
+    if (win_border >= 0 && win_border < 100 && win_caption >= 0 && win_caption < 200)
+    {
+      *border = has_border ? win_border : 0;
+      *caption = has_titlebar ? win_caption : 0;
 
-    if (!native_border && *border)
-      native_border = win_border;
+      if (win_border > 0) native_border = win_border;
+      if (win_caption > 0) native_caption = win_caption;
 
-    if (!native_caption && *caption)
-      native_caption = win_caption;
+      if (iupAttribGetBoolean(ih, "HIDETITLEBAR"))
+        *caption = 0;
+      return;
+    }
   }
 
-  /* I could not set the size of the window including the decorations when the dialog is hidden */
-  /* So we have to estimate the size of borders and caption when the dialog is hidden           */
-
-  *border = 0;
-  if (has_border)
+  /* Estimate when not visible or measurement failed */
+  if (has_csd)
   {
-    if (native_border)
-      *border = native_border;
-    else
-      *border = 5;
+    /* CSD: shadows are outside IUP's model, so border=0.
+       Caption = headerbar height. CSD styling means there IS a headerbar. */
+    *border = 0;
+    *caption = (native_caption > 0) ? native_caption : 37;
   }
+  else
+  {
+    *border = 0;
+    if (has_border)
+      *border = (native_border > 0) ? native_border : 5;
 
-  *caption = 0;
-  if (has_titlebar)
-  {
-    if (native_caption)
-      *caption = native_caption;
-    else
-      *caption = 20;
+    *caption = 0;
+    if (has_titlebar)
+      *caption = (native_caption > 0) ? native_caption : 20;
   }
 
   if (iupAttribGetBoolean(ih, "HIDETITLEBAR"))
@@ -238,7 +332,7 @@
     gtk_window_fullscreen((GtkWindow*)ih->handle);
     return 1;
   }
-  
+
   placement = iupAttribGet(ih, "PLACEMENT");
   if (!placement)
   {
@@ -291,9 +385,8 @@
     height += menu; /* menu is inside the client area. */
 
     /* set the new size and position */
-    /* The resize evt will update the layout */
     iupdrvDialogSetPosition(ih, x, y);
-    gtk_window_resize((GtkWindow*)ih->handle, width, height); 
+    gtk_window_resize((GtkWindow*)ih->handle, width, height);
 
     if (old_state == IUP_MAXIMIZE || old_state == IUP_MINIMIZE)
       ih->data->show_state = IUP_RESTORE;
@@ -303,12 +396,10 @@
   return 1;
 }
 
-
 /****************************************************************
                      Callbacks and Events
 ****************************************************************/
 
-
 gboolean iupgtkDialogDeleteEvent(GtkWidget *widget, GdkEvent *evt, Ihandle *ih)
 {
   Icallback cb;
@@ -329,6 +420,9 @@
       IupExitLoop();
   }
 
+  /* Detach virtual table models before hiding dialog to prevent expensive GTK operations */
+  iupgtkTableDetachVirtualModels(ih);
+
   IupHide(ih); /* default: close the window */
 
   return TRUE; /* do not propagate */
@@ -341,7 +435,6 @@
   (void)widget;
 
 #ifndef HILDON
-  /* In hildon the menu is not a menubar */
   if (ih->data->menu && ih->data->menu->handle)
   {
     if (evt->width > 0)
@@ -349,34 +442,101 @@
   }
 #endif
 
-  if (ih->data->ignore_resize) 
-    return FALSE; 
+  if (ih->data->ignore_resize)
+    return FALSE;
 
   old_width = iupAttribGetInt(ih, "_IUPGTK_OLD_WIDTH");
   old_height = iupAttribGetInt(ih, "_IUPGTK_OLD_HEIGHT");
 
-  /* Check the size change, because configure is called also for position changes */
   if (evt->width != old_width || evt->height != old_height)
   {
     IFnii cb;
     int border, caption, menu;
+    int client_width, client_height;
+    int has_csd = 0;
+    int is_wayland = 0;
+
     iupAttribSetInt(ih, "_IUPGTK_OLD_WIDTH", evt->width);
     iupAttribSetInt(ih, "_IUPGTK_OLD_HEIGHT", evt->height);
 
     iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
 
-  /* update dialog size */
-#ifdef HILDON
-    /* In Hildon, the configure event contains the window size, not the client area size */
-    ih->currentwidth = evt->width;
-    ih->currentheight = evt->height;
+#if GTK_CHECK_VERSION(3, 0, 0)
+    {
+      GtkStyleContext* context = gtk_widget_get_style_context(ih->handle);
+      if (gtk_style_context_has_class(context, "csd"))
+        has_csd = 1;
+    }
+#endif
+
+#ifdef GDK_WINDOWING_WAYLAND
+    {
+      GdkWindow* window = iupgtkGetWindow(ih->handle);
+      if (window && GDK_IS_WAYLAND_WINDOW(window))
+        is_wayland = 1;
+    }
+#endif
+
+    if (has_csd)
+    {
+      /* CSD: shadows are OUTSIDE the visible frame, IUP doesn't care about them.
+         We normalize evt to always be the visible frame (window geometry).
+
+         On Wayland:
+         - Initial/restore (saved_size=true): evt includes shadows, subtract them
+         - Resize (saved_size=false): evt is already the visible frame
+
+         On X11 CSD: evt includes shadows, subtract them */
+      int visible_width, visible_height;
+      int shadow_margin = gtkDialogGetCSDShadowMargin(ih);
+
+      /* CSD shadow handling:
+         Shadows are part of the window surface but not part of the visible frame.
+         - Maximized/fullscreen/tiled: window fills screen, no shadows
+         - Normal state: evt includes shadows, subtract them */
+      {
+        GdkWindow* window = iupgtkGetWindow(ih->handle);
+        GdkWindowState state = window ? gdk_window_get_state(window) : 0;
+#if GTK_CHECK_VERSION(3, 10, 0)
+        int no_shadows = (state & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_FULLSCREEN | GDK_WINDOW_STATE_TILED)) != 0;
 #else
-    ih->currentwidth = evt->width + 2*border;
-    ih->currentheight = evt->height + 2*border + caption;  /* menu is inside the window client area */
+        int no_shadows = (state & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_FULLSCREEN)) != 0;
 #endif
 
+        if (no_shadows)
+        {
+          visible_width = evt->width;
+          visible_height = evt->height;
+        }
+        else
+        {
+          visible_width = evt->width - 2*shadow_margin;
+          visible_height = evt->height - 2*shadow_margin;
+        }
+      }
+
+      /* For CSD, current = visible frame. */
+      ih->currentwidth = visible_width;
+      ih->currentheight = visible_height;
+
+      /* Client = visible frame - titlebar (caption is inside visible frame for CSD) */
+      client_width = visible_width;
+      client_height = visible_height - caption;
+      if (client_width < 0) client_width = 0;
+      if (client_height < 0) client_height = 0;
+    }
+    else
+    {
+      /* SSD: evt is client area size */
+      client_width = evt->width;
+      client_height = evt->height;
+
+      ih->currentwidth = client_width + 2*border;
+      ih->currentheight = client_height + 2*border + caption;
+    }
+
     cb = (IFnii)IupGetCallback(ih, "RESIZE_CB");
-    if (!cb || cb(ih, evt->width, evt->height - menu)!=IUP_IGNORE)  /* width and height here are for the client area */
+    if (!cb || cb(ih, client_width, client_height - menu) != IUP_IGNORE)
     {
       ih->data->ignore_resize = 1;
       IupRefresh(ih);
@@ -386,9 +546,8 @@
 
   old_x = iupAttribGetInt(ih, "_IUPGTK_OLD_X");
   old_y = iupAttribGetInt(ih, "_IUPGTK_OLD_Y");
-  iupdrvDialogGetPosition(ih, NULL, &x, &y);  /* ignore evt->x and evt->y because they are the clientpos and not X/Y */
+  iupdrvDialogGetPosition(ih, NULL, &x, &y);
 
-  /* Check the position change, because configure is called also for size changes */
   if (x != old_x || y != old_y)
   {
     IFnii cb;
@@ -411,9 +570,9 @@
   iupAttribSet(ih, "MAXIMIZED", NULL);
   iupAttribSet(ih, "MINIMIZED", NULL);
 
-  if ((evt->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) &&        /* if flag changed and  */
-      (evt->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) &&    /* is now set           */
-      !(evt->new_window_state & GDK_WINDOW_STATE_WITHDRAWN))     /* is visible           */
+  if ((evt->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) &&
+      (evt->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) &&
+      !(evt->new_window_state & GDK_WINDOW_STATE_WITHDRAWN))
   {
     state = IUP_MAXIMIZE;
     iupAttribSet(ih, "MAXIMIZED", "Yes");
@@ -429,15 +588,15 @@
            (evt->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) &&
            !(evt->new_window_state & GDK_WINDOW_STATE_WITHDRAWN))
     state = IUP_MAXIMIZE;
-  else if (((evt->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) &&       /* maximized changed */
-            !(evt->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) &&  /* not maximized     */
-            !(evt->new_window_state & GDK_WINDOW_STATE_WITHDRAWN) &&  /* is visible        */
-            !(evt->new_window_state & GDK_WINDOW_STATE_ICONIFIED))    /* not minimized     */
-            ||                                                       /* OR                     */
-           ((evt->changed_mask & GDK_WINDOW_STATE_ICONIFIED) &&       /* minimized changed   */
-            !(evt->new_window_state & GDK_WINDOW_STATE_ICONIFIED) &&  /* not minimized       */
-            !(evt->new_window_state & GDK_WINDOW_STATE_WITHDRAWN) &&  /* is visible          */
-            !(evt->new_window_state & GDK_WINDOW_STATE_MAXIMIZED)))   /* not maximized       */
+  else if (((evt->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) &&
+            !(evt->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) &&
+            !(evt->new_window_state & GDK_WINDOW_STATE_WITHDRAWN) &&
+            !(evt->new_window_state & GDK_WINDOW_STATE_ICONIFIED))
+            ||
+           ((evt->changed_mask & GDK_WINDOW_STATE_ICONIFIED) &&
+            !(evt->new_window_state & GDK_WINDOW_STATE_ICONIFIED) &&
+            !(evt->new_window_state & GDK_WINDOW_STATE_WITHDRAWN) &&
+            !(evt->new_window_state & GDK_WINDOW_STATE_MAXIMIZED)))
     state = IUP_RESTORE;
 
   if (state < 0)
@@ -449,7 +608,7 @@
     ih->data->show_state = state;
 
     cb = (IFni)IupGetCallback(ih, "SHOW_CB");
-    if (cb && cb(ih, state) == IUP_CLOSE) 
+    if (cb && cb(ih, state) == IUP_CLOSE)
       IupExitLoop();
   }
 
@@ -456,31 +615,47 @@
   return FALSE;
 }
 
+static void gtkDialogThemeChanged(GtkSettings* settings, GParamSpec* pspec, Ihandle* ih)
+{
+  int dark_mode;
+  IFni cb;
 
+  (void)settings;
+  (void)pspec;
+
+  if (!iupObjectCheck(ih))
+    return;
+
+  iupgtkSetGlobalColors();
+
+  dark_mode = iupgtkIsSystemDarkMode();
+
+  cb = (IFni)IupGetCallback(ih, "THEMECHANGED_CB");
+  if (cb)
+    cb(ih, dark_mode);
+}
+
+
 /****************************************************************
                      Idialog Methods
 ****************************************************************/
 
-
-/* replace the common dialog SetChildrenPosition method because of 
-   the menu that it is inside the dialog. */
 static void gtkDialogSetChildrenPositionMethod(Ihandle* ih, int x, int y)
 {
   if (ih->firstchild)
   {
     char* offset = iupAttribGet(ih, "CHILDOFFSET");
+    int menu_size;
 
-    /* Native container, position is reset */
     x = 0;
     y = 0;
 
     if (offset) iupStrToIntInt(offset, &x, &y, 'x');
 
-    y += gtkDialogGetMenuSize(ih);
+    menu_size = gtkDialogGetMenuSize(ih);
+    y += menu_size;
 
-    /* Child coordinates are relative to client left-top corner. */
-    if (ih->firstchild)
-      iupBaseSetPosition(ih->firstchild, x, y);
+    iupBaseSetPosition(ih->firstchild, x, y);
   }
 }
 
@@ -487,7 +662,7 @@
 static void* gtkDialogGetInnerNativeContainerHandleMethod(Ihandle* ih, Ihandle* child)
 {
   (void)child;
-  return (void*)gtk_bin_get_child((GtkBin*)ih->handle);
+  return iupAttribGet(ih, "_IUP_GTK_INNER_PARENT");
 }
 
 static int gtkDialogMapMethod(Ihandle* ih)
@@ -499,16 +674,16 @@
   int has_titlebar = 0;
 
 #ifdef HILDON
-  if (iupAttribGetBoolean(ih, "HILDONWINDOW")) 
+  if (iupAttribGetBoolean(ih, "HILDONWINDOW"))
   {
     HildonProgram *program = HILDON_PROGRAM(hildon_program_get_instance());
     ih->handle = hildon_window_new();
     if (ih->handle)
-      hildon_program_add_window(program, HILDON_WINDOW(ih->handle)); 
-  } 
-  else 
+      hildon_program_add_window(program, HILDON_WINDOW(ih->handle));
+  }
+  else
   {
-    iupAttribSet(ih, "DIALOGHINT", "YES");  /* otherwise not displayed correctly */ 
+    iupAttribSet(ih, "DIALOGHINT", "YES"); /* otherwise not displayed correctly */
     ih->handle = gtk_window_new(GTK_WINDOW_TOPLEVEL);
   }
 #else
@@ -521,8 +696,6 @@
   if (parent)
   {
     gtk_window_set_transient_for((GtkWindow*)ih->handle, (GtkWindow*)parent);
-
-    /* manually remove child windows when parent is destroyed */
     g_signal_connect(G_OBJECT(parent), "destroy", G_CALLBACK(gtkDialogChildDestroyEvent), ih);
   }
 
@@ -531,29 +704,25 @@
   g_signal_connect(G_OBJECT(ih->handle), "enter-notify-event", G_CALLBACK(iupgtkEnterLeaveEvent), ih);
   g_signal_connect(G_OBJECT(ih->handle), "leave-notify-event", G_CALLBACK(iupgtkEnterLeaveEvent), ih);
   g_signal_connect(G_OBJECT(ih->handle), "show-help",          G_CALLBACK(iupgtkShowHelp), ih);
-
-  /* The iupgtkKeyPressEvent of the control with the focus will propagate the key up to the dialog. */
-  /* Inside iupgtkKeyPressEvent we test this to avoid duplicate calls. */
   g_signal_connect(G_OBJECT(ih->handle), "key-press-event",    G_CALLBACK(iupgtkKeyPressEvent), ih);
-
   g_signal_connect(G_OBJECT(ih->handle), "configure-event",    G_CALLBACK(gtkDialogConfigureEvent), ih);
   g_signal_connect(G_OBJECT(ih->handle), "window-state-event", G_CALLBACK(gtkDialogWindowStateEvent), ih);
   g_signal_connect(G_OBJECT(ih->handle), "delete-event",       G_CALLBACK(iupgtkDialogDeleteEvent), ih);
-                                    
-  gtk_window_set_default_size((GtkWindow*)ih->handle, 100, 100); /* set this to avoid size calculation problems  */
 
-  if (iupAttribGetBoolean(ih, "DIALOGHINT")) 
+  gtk_window_set_default_size((GtkWindow*)ih->handle, 100, 100);
+
+  if (iupAttribGetBoolean(ih, "DIALOGHINT"))
     gtk_window_set_type_hint(GTK_WINDOW(ih->handle), GDK_WINDOW_TYPE_HINT_DIALOG);
 
   if (iupAttribGetBoolean(ih, "CUSTOMFRAME"))
   {
 #if GTK_CHECK_VERSION(3, 10, 0)
-    iupDialogCustomFrameSimulateCheckCallbacks(ih); /* no need for full simulation */
+    iupDialogCustomFrameSimulateCheckCallbacks(ih);
     iupAttribSet(ih, "HIDETITLEBAR", "Yes");
 #else
     IupSetAttribute(ih, "CUSTOMFRAMESIMULATE", "Yes");
 #endif
-  } 
+  }
 
   if (iupAttribGetBoolean(ih, "CUSTOMFRAMESIMULATE"))
   {
@@ -572,38 +741,68 @@
     gtk_window_set_titlebar(GTK_WINDOW(ih->handle), gtk_fixed_new());
 #endif
 
-  /* the container that will receive the child element. */
-  inner_parent = iupgtkNativeContainerNew(0);
-  gtk_container_add((GtkContainer*)ih->handle, inner_parent);
-  gtk_widget_show(inner_parent);
+  /* Create inner_parent (GtkFixed) for absolute positioning of IUP children.
+     Wrap in GtkViewport to clip content on Wayland CSD. */
+  {
+    GtkWidget* viewport = gtk_viewport_new(NULL, NULL);
+    gtk_viewport_set_shadow_type(GTK_VIEWPORT(viewport), GTK_SHADOW_NONE);
+    gtk_container_add((GtkContainer*)ih->handle, viewport);
+    gtk_widget_show(viewport);
 
-  /* initialize the widget */
+    inner_parent = iupgtkNativeContainerNew(0);
+    gtk_container_add((GtkContainer*)viewport, inner_parent);
+    gtk_widget_show(inner_parent);
+
+    /* Store inner_parent for retrieval (since viewport is now the direct child) */
+    iupAttribSet(ih, "_IUP_GTK_INNER_PARENT", (char*)inner_parent);
+  }
+
+#if !GTK_CHECK_VERSION(3, 22, 0)
+  {
+    const char* appid = IupGetGlobal("_IUP_APPID_INTERNAL");
+    if (appid)
+      gtk_window_set_wmclass(GTK_WINDOW(ih->handle), appid, appid);
+  }
+#endif
+
   gtk_widget_realize(ih->handle);
 
+#if GTK_CHECK_VERSION(3, 0, 0) && defined(GDK_WINDOWING_X11)
+  {
+    /* Set WM_CLASS for X11 windows if APPID is set */
+    const char* appid = IupGetGlobal("_IUP_APPID_INTERNAL");
+    if (appid)
+    {
+      GdkWindow* window = iupgtkGetWindow(ih->handle);
+      if (window && GDK_IS_X11_WINDOW(window))
+        gdk_x11_window_set_utf8_property(GDK_X11_WINDOW(window), "WM_CLASS", appid);
+    }
+  }
+#endif
+
   if (iupAttribGet(ih, "TITLE"))
     has_titlebar = 1;
-  if (iupAttribGetBoolean(ih, "RESIZE")) 
+  if (iupAttribGetBoolean(ih, "RESIZE"))
   {
     functions   |= GDK_FUNC_RESIZE;
     decorations |= GDK_DECOR_RESIZEH;
-
-    decorations |= GDK_DECOR_BORDER;  /* has_border */
+    decorations |= GDK_DECOR_BORDER;
   }
   else
     iupAttribSet(ih, "MAXBOX", "NO");
-  if (iupAttribGetBoolean(ih, "MENUBOX")) 
+  if (iupAttribGetBoolean(ih, "MENUBOX"))
   {
     functions   |= GDK_FUNC_CLOSE;
     decorations |= GDK_DECOR_MENU;
     has_titlebar = 1;
   }
-  if (iupAttribGetBoolean(ih, "MAXBOX")) 
+  if (iupAttribGetBoolean(ih, "MAXBOX"))
   {
     functions   |= GDK_FUNC_MAXIMIZE;
     decorations |= GDK_DECOR_MAXIMIZE;
     has_titlebar = 1;
   }
-  if (iupAttribGetBoolean(ih, "MINBOX")) 
+  if (iupAttribGetBoolean(ih, "MINBOX"))
   {
     functions   |= GDK_FUNC_MINIMIZE;
     decorations |= GDK_DECOR_MINIMIZE;
@@ -616,7 +815,7 @@
     gtk_window_set_title((GtkWindow*)ih->handle, "");
   }
   if (iupAttribGetBoolean(ih, "BORDER") || has_titlebar)
-    decorations |= GDK_DECOR_BORDER;  /* has_border */
+    decorations |= GDK_DECOR_BORDER;
 
   if (decorations == 0)
     gtk_window_set_decorated((GtkWindow*)ih->handle, FALSE);
@@ -625,17 +824,20 @@
     GdkWindow* window = iupgtkGetWindow(ih->handle);
     if (window)
     {
-      gdk_window_set_decorations(window, (GdkWMDecoration)decorations);
-      gdk_window_set_functions(window, (GdkWMFunction)functions);
+#if GTK_CHECK_VERSION(3, 0, 0) && defined(GDK_WINDOWING_WAYLAND)
+      if (!GDK_IS_WAYLAND_WINDOW(window))
+#endif
+      {
+        gdk_window_set_decorations(window, (GdkWMDecoration)decorations);
+        gdk_window_set_functions(window, (GdkWMFunction)functions);
+      }
     }
   }
 
-  /* configure for DRAG&DROP */
   if (IupGetCallback(ih, "DROPFILES_CB"))
     iupAttribSet(ih, "DROPFILESTARGET", "YES");
 
-  /* configure the size range */
-  gtkDialogSetMinMax(ih, 1, 1, 65535, 65535);  /* MINSIZE and MAXSIZE default values */
+  gtkDialogSetMinMax(ih, 1, 1, 65535, 65535); /* MINSIZE and MAXSIZE default values */
 
   /* Ignore VISIBLE before mapping */
   iupAttribSet(ih, "VISIBLE", NULL);
@@ -643,6 +845,18 @@
   if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
     gtk_widget_add_events(ih->handle, GDK_POINTER_MOTION_MASK|GDK_BUTTON_PRESS_MASK|GDK_BUTTON_RELEASE_MASK|GDK_BUTTON_MOTION_MASK);
 
+  /* Monitor theme changes */
+  {
+    GtkSettings* settings = gtk_settings_get_default();
+    gulong handler_id;
+
+    handler_id = g_signal_connect(G_OBJECT(settings), "notify::gtk-theme-name", G_CALLBACK(gtkDialogThemeChanged), ih);
+    iupAttribSet(ih, "_IUPGTK_THEME_HANDLER1", (char*)(uintptr_t)handler_id);
+
+    handler_id = g_signal_connect(G_OBJECT(settings), "notify::gtk-application-prefer-dark-theme", G_CALLBACK(gtkDialogThemeChanged), ih);
+    iupAttribSet(ih, "_IUPGTK_THEME_HANDLER2", (char*)(uintptr_t)handler_id);
+  }
+
   return IUP_NOERROR;
 }
 
@@ -650,28 +864,29 @@
 {
   GtkWidget* inner_parent, *parent;
 
-#if GTK_CHECK_VERSION(2, 10, 0) && !GTK_CHECK_VERSION(3, 14, 0)
-  GtkStatusIcon* status_icon;
-#endif
-
-  if (ih->data->menu) 
+  if (ih->data->menu)
   {
     ih->data->menu->handle = NULL; /* the dialog will destroy the native menu */
-    IupDestroy(ih->data->menu);  
+    IupDestroy(ih->data->menu);
     ih->data->menu = NULL;
   }
 
-#if GTK_CHECK_VERSION(2, 10, 0) && !GTK_CHECK_VERSION(3, 14, 0)
-  status_icon = (GtkStatusIcon*)iupAttribGet(ih, "_IUPDLG_STATUSICON");
-  if (status_icon)
+  /* Disconnect theme change monitoring */
   {
-    g_object_unref(status_icon);
-    iupAttribSet(ih, "_IUPDLG_STATUSICON", NULL);
+    gulong handler_id;
+    GtkSettings* settings = gtk_settings_get_default();
+
+    handler_id = (gulong)(uintptr_t)iupAttribGet(ih, "_IUPGTK_THEME_HANDLER1");
+    if (handler_id != 0)
+      g_signal_handler_disconnect(G_OBJECT(settings), handler_id);
+
+    handler_id = (gulong)(uintptr_t)iupAttribGet(ih, "_IUPGTK_THEME_HANDLER2");
+    if (handler_id != 0)
+      g_signal_handler_disconnect(G_OBJECT(settings), handler_id);
   }
-#endif
 
+#if GLIB_CHECK_VERSION(2, 32, 0)
   /* disconnect signal handlers */
-#if GLIB_CHECK_VERSION(2, 32, 0)
   g_signal_handlers_disconnect_by_data(G_OBJECT(ih->handle), ih);
 #endif
   parent = iupDialogGetNativeParent(ih);
@@ -678,12 +893,18 @@
   if (parent)
     g_signal_handlers_disconnect_by_func(G_OBJECT(parent), gtkDialogChildDestroyEvent, ih);
 
-  inner_parent = gtk_bin_get_child((GtkBin*)ih->handle);
-  gtk_widget_unrealize(inner_parent);
-  gtk_widget_destroy(inner_parent);  
+  /* Destroy viewport (which contains inner_parent) */
+  {
+    GtkWidget* viewport = gtk_bin_get_child((GtkBin*)ih->handle);
+    if (viewport)
+    {
+      gtk_widget_unrealize(viewport);
+      gtk_widget_destroy(viewport);
+    }
+  }
 
-  gtk_widget_unrealize(ih->handle); /* To match the call to gtk_widget_realize */
-  gtk_widget_destroy(ih->handle);   /* To match the call to gtk_window_new     */
+  gtk_widget_unrealize(ih->handle);
+  gtk_widget_destroy(ih->handle);
 }
 
 static void gtkDialogLayoutUpdateMethod(Ihandle *ih)
@@ -690,38 +911,55 @@
 {
   int border, caption, menu;
   int width, height;
+  int decorheight;
+  int has_csd = 0;
 
-  if (ih->data->ignore_resize ||
-      iupAttribGet(ih, "_IUPGTK_FS_STYLE"))
+  if (ih->data->ignore_resize || iupAttribGet(ih, "_IUPGTK_FS_STYLE"))
     return;
 
-  /* for dialogs the position is not updated here */
   ih->data->ignore_resize = 1;
 
   iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
 
-  /* set size excluding the border */
+  decorheight = 2*border + caption;
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  {
+    GtkStyleContext* context = gtk_widget_get_style_context(ih->handle);
+    if (gtk_style_context_has_class(context, "csd"))
+    {
+      has_csd = 1;
+      /* For CSD, current = visible frame (including titlebar).
+         gtk_window_resize expects client area (excluding titlebar). */
+      iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
+      decorheight = caption;
+    }
+  }
+#endif
+
   width = ih->currentwidth - 2*border;
-  height = ih->currentheight - 2*border - caption;   /* menu is inside the client area. */
-  if(width <= 0) width = 1;
-  if(height <= 0) height = 1;
+  height = ih->currentheight - decorheight;
+
+  if (width <= 0) width = 1;
+  if (height <= 0) height = 1;
+
   gtk_window_resize((GtkWindow*)ih->handle, width, height);
 
   if (!iupAttribGetBoolean(ih, "RESIZE"))
   {
     GdkGeometry geometry;
+
     geometry.min_width = width;
     geometry.min_height = height;
     geometry.max_width = width;
     geometry.max_height = height;
-    gtk_window_set_geometry_hints((GtkWindow*)ih->handle, ih->handle,
-                                  &geometry, (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
+
+    gtk_window_set_geometry_hints((GtkWindow*)ih->handle, ih->handle, &geometry, (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
   }
 
   ih->data->ignore_resize = 0;
 }
 
-
 /****************************************************************************
                                    Attributes
 ****************************************************************************/
@@ -728,28 +966,48 @@
 
 static void gtkDialogSetMinMax(Ihandle* ih, int min_w, int min_h, int max_w, int max_h)
 {
-  /* The minmax size restricts the client area */
   GdkGeometry geometry;
+  int border = 0, caption = 0, menu = 0;
   int decorwidth = 0, decorheight = 0;
-  iupDialogGetDecorSize(ih, &decorwidth, &decorheight);
+  int has_csd = 0;
 
+  iupdrvDialogGetDecoration(ih, &border, &caption, &menu);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  {
+    GtkStyleContext* context = gtk_widget_get_style_context(ih->handle);
+    if (gtk_style_context_has_class(context, "csd"))
+      has_csd = 1;
+  }
+#endif
+
+  if (has_csd)
+  {
+    decorwidth = 2*border;
+    decorheight = caption;
+  }
+  else
+  {
+    decorwidth = 2*border;
+    decorheight = 2*border + caption;
+  }
+
   geometry.min_width = 1;
   if (min_w > decorwidth)
-    geometry.min_width = min_w-decorwidth;
+    geometry.min_width = min_w - decorwidth;
 
   geometry.min_height = 1;
   if (min_h > decorheight)
-    geometry.min_height = min_h-decorheight;
+    geometry.min_height = min_h - decorheight;
 
   geometry.max_width = 65535;
   if (max_w > decorwidth && max_w > geometry.min_width)
-    geometry.max_width = max_w-decorwidth;
+    geometry.max_width = max_w - decorwidth;
 
   geometry.max_height = 65535;
   if (max_h > decorheight && max_h > geometry.min_height)
-    geometry.max_height = max_h-decorheight;
+    geometry.max_height = max_h - decorheight;
 
-  /* must set both at the same time, or GTK will assume its default */
   gtk_window_set_geometry_hints((GtkWindow*)ih->handle, ih->handle,
                                 &geometry, (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
 }
@@ -756,8 +1014,8 @@
 
 static int gtkDialogSetMinSizeAttrib(Ihandle* ih, const char* value)
 {
-  int min_w = 1, min_h = 1;          /* MINSIZE default value */
-  int max_w = 65535, max_h = 65535;  /* MAXSIZE default value */
+  int min_w = 1, min_h = 1;
+  int max_w = 65535, max_h = 65535;
   iupStrToIntInt(value, &min_w, &min_h, 'x');
 
   /* if MAXSIZE also set, must be also updated here */
@@ -770,8 +1028,8 @@
 
 static int gtkDialogSetMaxSizeAttrib(Ihandle* ih, const char* value)
 {
-  int min_w = 1, min_h = 1;          /* MINSIZE default value */
-  int max_w = 65535, max_h = 65535;  /* MAXSIZE default value */
+  int min_w = 1, min_h = 1;
+  int max_w = 65535, max_h = 65535;
   iupStrToIntInt(value, &max_w, &max_h, 'x');
 
   /* if MINSIZE also set, must be also updated here */
@@ -796,8 +1054,8 @@
 
 static char* gtkDialogGetActiveWindowAttrib(Ihandle* ih)
 {
-  return iupStrReturnBoolean (gtk_window_is_active((GtkWindow*)ih->handle)); 
-}    
+  return iupStrReturnBoolean(gtk_window_is_active((GtkWindow*)ih->handle));
+}
 
 static char* gtkDialogGetClientSizeAttrib(Ihandle *ih)
 {
@@ -805,10 +1063,7 @@
   {
     int width, height;
     gtk_window_get_size((GtkWindow*)ih->handle, &width, &height);
-
-    /* remove the menu because it is placed inside the client area */
     height -= gtkDialogGetMenuSize(ih);
-
     return iupStrReturnIntInt(width, height, 'x');
   }
   else
@@ -822,7 +1077,7 @@
 }
 
 static int gtkDialogSetFullScreenAttrib(Ihandle* ih, const char* value)
-{                       
+{
   if (iupStrBoolean(value))
   {
     if (!iupAttribGet(ih, "_IUPGTK_FS_STYLE"))
@@ -861,7 +1116,7 @@
       iupAttribSetStr(ih, "MAXBOX", iupAttribGet(ih, "_IUPGTK_FS_MAXBOX"));
       iupAttribSetStr(ih, "MINBOX", iupAttribGet(ih, "_IUPGTK_FS_MINBOX"));
       iupAttribSetStr(ih, "MENUBOX",iupAttribGet(ih, "_IUPGTK_FS_MENUBOX"));
-      IupSetAttribute(ih, "TITLE",  iupAttribGet(ih, "_IUPGTK_FS_TITLE"));   /* must use IupSetAttribute to update the native implementation */
+      IupSetAttribute(ih, "TITLE",  iupAttribGet(ih, "_IUPGTK_FS_TITLE"));  /* must use IupSetAttribute to update the native implementation */
       iupAttribSetStr(ih, "RESIZE", iupAttribGet(ih, "_IUPGTK_FS_RESIZE"));
       iupAttribSetStr(ih, "BORDER", iupAttribGet(ih, "_IUPGTK_FS_BORDER"));
 
@@ -937,7 +1192,7 @@
 #else
     GdkBitmap* mask = NULL;
     gdk_pixbuf_render_pixmap_and_mask(pixbuf, NULL, &mask, 255);
-    if (mask) 
+    if (mask)
     {
       gtk_widget_shape_combine_mask(ih->handle, mask, 0, 0);
       g_object_unref(mask);
@@ -947,7 +1202,6 @@
   }
   return 0;
 }
-
 #endif
 
 static int gtkDialogSetIconAttrib(Ihandle* ih, const char *value)
@@ -967,11 +1221,7 @@
 {
   if (iupdrvBaseSetBgColorAttrib(ih, value))
   {
-#if GTK_CHECK_VERSION(3, 0, 0)
-    GdkWindow* window = iupgtkGetWindow(ih->handle);
-    if (window)
-      gdk_window_set_background_pattern(window, NULL);
-#else
+#if !GTK_CHECK_VERSION(3, 0, 0)
     GtkStyle *style = gtk_widget_get_style(ih->handle);
     if (style->bg_pixmap[GTK_STATE_NORMAL])
     {
@@ -988,29 +1238,11 @@
     if (pixbuf)
     {
 #if GTK_CHECK_VERSION(3, 0, 0)
-    GdkWindow* window = iupgtkGetWindow(ih->handle);
-    if (window)
-    {
-      /* TODO: this is NOT working!!!! */
-      cairo_pattern_t* pattern;
-      int width = gdk_pixbuf_get_width(pixbuf);
-      int height = gdk_pixbuf_get_height(pixbuf);
-
-      cairo_surface_t* surface = gdk_window_create_similar_surface(window, CAIRO_CONTENT_COLOR_ALPHA, width, height);
-      cairo_t* cr = cairo_create(surface);
-      gdk_cairo_set_source_pixbuf(cr, pixbuf, 0, 0);
-      cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
-      cairo_paint(cr);
-      cairo_destroy(cr);
-
-      pattern = cairo_pattern_create_for_surface(surface);
-      cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
-
-      gdk_window_set_background_pattern(window, pattern);
-      cairo_pattern_destroy (pattern);
-
-      cairo_surface_destroy(surface);
-    }
+      /* Background images not supported.
+         GTK3 CSS url() uses g_file_read() which doesn't support data: URIs.
+         Using file:// URLs requires saving to temporary files which is inefficient. */
+      (void)pixbuf;
+      return 0;
 #else
       GdkPixmap* pixmap;
       GtkStyle *style = gtk_style_copy(gtk_widget_get_style(ih->handle));
@@ -1019,9 +1251,9 @@
 
       style->bg_pixmap[GTK_STATE_NORMAL] = pixmap;
       gtk_widget_set_style(ih->handle, style);
-#endif
 
       return 1;
+#endif
     }
   }
 
@@ -1028,121 +1260,6 @@
   return 0;
 }
 
-/* gtk_status_icon - deprecated in 3.14, but still available in 3.22 */
-#if GTK_CHECK_VERSION(2, 10, 0)
-static int gtkDialogTaskDoubleClick(int button)
-{
-  static int last_button = -1;
-  static GTimer* timer = NULL;
-  if (last_button == -1 || last_button != button)
-  {
-    last_button = button;
-    if (timer)
-      g_timer_destroy(timer);
-    timer = g_timer_new();
-    return 0;
-  }
-  else
-  {
-    double seconds;
-
-    if (!timer)  /* just in case */
-      return 0;
-
-    seconds = g_timer_elapsed(timer, NULL);
-    if (seconds < 0.4)
-    {
-      /* reset state */
-      g_timer_destroy(timer);
-      timer = NULL;
-      last_button = -1;  
-      return 1;
-    }
-    else
-    {
-      g_timer_reset(timer);
-      return 0;
-    }
-  }
-}
-
-static void gtkDialogTaskAction(GtkStatusIcon *status_icon, Ihandle *ih)
-{
-  /* from GTK source code it is called only when button==1 and pressed==1 */
-  int button = 1;
-  int pressed = 1;
-  int dclick = gtkDialogTaskDoubleClick(button);
-  IFniii cb = (IFniii)IupGetCallback(ih, "TRAYCLICK_CB");
-  if (cb && cb(ih, button, pressed, dclick) == IUP_CLOSE)
-    IupExitLoop();
-  (void)status_icon;
-}
-
-static void gtkDialogTaskPopupMenu(GtkStatusIcon *status_icon, guint gbutton, guint activate_time, Ihandle *ih)
-{
-  /* from GTK source code it is called only when button==3 and pressed==1 */
-  int button = 3;
-  int pressed = 1;
-  int dclick = gtkDialogTaskDoubleClick(button);
-  IFniii cb = (IFniii)IupGetCallback(ih, "TRAYCLICK_CB");
-  if (cb && cb(ih, button, pressed, dclick) == IUP_CLOSE)
-    IupExitLoop();
-  (void)activate_time;
-  (void)gbutton;
-  (void)status_icon;
-}
-
-static GtkStatusIcon* gtkDialogGetStatusIcon(Ihandle *ih)
-{
-  GtkStatusIcon* status_icon = (GtkStatusIcon*)iupAttribGet(ih, "_IUPDLG_STATUSICON");
-  if (!status_icon)
-  {
-    status_icon = gtk_status_icon_new();
-
-    g_signal_connect(G_OBJECT(status_icon), "activate", G_CALLBACK(gtkDialogTaskAction), ih);
-    g_signal_connect(G_OBJECT(status_icon), "popup-menu", G_CALLBACK(gtkDialogTaskPopupMenu), ih);
-
-    iupAttribSet(ih, "_IUPDLG_STATUSICON", (char*)status_icon);
-  }
-  return status_icon;
-}
-
-static int gtkDialogSetTrayAttrib(Ihandle *ih, const char *value)
-{
-  GtkStatusIcon* status_icon = gtkDialogGetStatusIcon(ih);
-  gtk_status_icon_set_visible(status_icon, iupStrBoolean(value));
-  return 1;
-}
-
-static int gtkDialogSetTrayTipAttrib(Ihandle *ih, const char *value)
-{
-  GtkStatusIcon* status_icon = gtkDialogGetStatusIcon(ih);
-#if GTK_CHECK_VERSION(2, 16, 0)
-  if (value)
-  {
-    gtk_status_icon_set_has_tooltip(status_icon, TRUE);
-    if (iupAttribGetBoolean(ih, "TIPMARKUP"))
-      gtk_status_icon_set_tooltip_markup(status_icon, value);
-    else
-      gtk_status_icon_set_tooltip_text(status_icon, value);
-  }
-  else
-    gtk_status_icon_set_has_tooltip(status_icon, FALSE);
-#else
-  gtk_status_icon_set_tooltip(status_icon, value);
-#endif
-  return 1;
-}
-
-static int gtkDialogSetTrayImageAttrib(Ihandle *ih, const char *value)
-{
-  GtkStatusIcon* status_icon = gtkDialogGetStatusIcon(ih);
-  GdkPixbuf* icon = (GdkPixbuf*)iupImageGetIcon(value);
-  gtk_status_icon_set_from_pixbuf(status_icon, icon);
-  return 1;
-}
-#endif  /* gtk_status_icon */
-
 #if GTK_CHECK_VERSION(3, 4, 0)
 static int gtkDialogSetHideTitleBarAttrib(Ihandle *ih, const char *value)
 {
@@ -1149,11 +1266,10 @@
   gtk_window_set_hide_titlebar_when_maximized(GTK_WINDOW(ih->handle), iupStrBoolean(value));
   return 1;
 }
-#endif  /* GTK_CHECK_VERSION(3, 4, 0) */
+#endif
 
 /****************************************************************************************************************/
 
-
 void iupdrvDialogInitClass(Iclass* ic)
 {
   /* Driver Dependent Class methods */
@@ -1163,14 +1279,14 @@
   ic->GetInnerNativeContainerHandle = gtkDialogGetInnerNativeContainerHandleMethod;
   ic->SetChildrenPosition = gtkDialogSetChildrenPositionMethod;
 
-  /* Callback Windows and GTK Only */
-  iupClassRegisterCallback(ic, "TRAYCLICK_CB", "iii");
+  /* Callback for theme changes */
+  iupClassRegisterCallback(ic, "THEMECHANGED_CB", "i");
 
   /* Driver Dependent Attribute functions */
   iupClassRegisterAttribute(ic, iupgtkGetNativeWindowHandleName(), iupgtkGetNativeWindowHandleAttrib, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_NO_STRING);
 
   /* Visual */
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, "DLGBGCOLOR", NULL, IUPAF_DEFAULT);  /* force new default value */
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, "DLGBGCOLOR", NULL, IUPAF_DEFAULT);
 
   /* Base Container */
   iupClassRegisterAttribute(ic, "CLIENTSIZE", gtkDialogGetClientSizeAttrib, iupDialogSetClientSizeAttrib, NULL, NULL, IUPAF_NOT_MAPPED | IUPAF_NO_SAVE | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);  /* dialog is the only not read-only */
@@ -1188,22 +1304,14 @@
   iupClassRegisterAttribute(ic, "SAVEUNDER", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);  /* saveunder not supported in GTK */
   iupClassRegisterAttribute(ic, "MAXIMIZED", NULL, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
 
-  /* IupDialog Windows and GTK Only */
   iupClassRegisterAttribute(ic, "ACTIVEWINDOW", gtkDialogGetActiveWindowAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TOPMOST", NULL, gtkDialogSetTopMostAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "DIALOGHINT", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-#if GTK_CHECK_VERSION(2, 12, 0)
+
   iupClassRegisterAttribute(ic, "OPACITY", NULL, gtkDialogSetOpacityAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "OPACITYIMAGE", NULL, gtkDialogSetShapeImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "SHAPEIMAGE", NULL, gtkDialogSetShapeImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-#endif
-/* gtk_status_icon - deprecated in 3.14, but still available in 3.22 */
-#if GTK_CHECK_VERSION(2, 10, 0)
-  iupClassRegisterAttribute(ic, "TRAY", NULL, gtkDialogSetTrayAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYIMAGE", NULL, gtkDialogSetTrayImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYTIP", NULL, gtkDialogSetTrayTipAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYTIPMARKUP", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
-#endif
+
   iupClassRegisterAttribute(ic, "CUSTOMFRAME", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_DEFAULT);
 
 #if GTK_CHECK_VERSION(3, 4, 0)
Index: src/gtk/iupgtk_draw_cairo.c
===================================================================
--- src/gtk/iupgtk_draw_cairo.c	(revision 5971)
+++ src/gtk/iupgtk_draw_cairo.c	(working copy)
@@ -8,11 +8,11 @@
 #include <stdio.h>
 #include <string.h>
 #include <memory.h>
+#include <math.h>
 
 #include <gtk/gtk.h>
 
 #include "iup.h"
-
 #include "iup_attrib.h"
 #include "iup_class.h"
 #include "iup_str.h"
@@ -47,31 +47,58 @@
 {
   IdrawCanvas* dc = calloc(1, sizeof(IdrawCanvas));
   cairo_surface_t* surface;
+  cairo_surface_t* buffer;
 
   dc->ih = ih;
 
   dc->widget = (GtkWidget*)IupGetAttribute(ih, "WID");
 
+#if !GTK_CHECK_VERSION(3, 0, 0)
+  dc->wnd = (GdkWindow*)IupGetAttribute(ih, "DRAWABLE");
+  gdk_window_get_geometry(dc->wnd, NULL, NULL, &dc->w, &dc->h, NULL);
+#else
+  dc->w = gtk_widget_get_allocated_width(dc->widget);
+  dc->h = gtk_widget_get_allocated_height(dc->widget);
+#endif
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  /* Check if we have persistent offscreen buffer */
+  buffer = (cairo_surface_t*)iupAttribGet(ih, "_IUPGTK3_CANVAS_BUFFER");
+  if (buffer)
+  {
+    /* Check if size changed - recreate buffer if needed */
+    int buf_w = cairo_image_surface_get_width(buffer);
+    int buf_h = cairo_image_surface_get_height(buffer);
+    if (buf_w != dc->w || buf_h != dc->h)
+    {
+      cairo_surface_destroy(buffer);
+      buffer = NULL;
+    }
+  }
+
+  /* Create new buffer if needed */
+  if (!buffer)
+  {
+    buffer = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, dc->w, dc->h);
+    iupAttribSet(ih, "_IUPGTK3_CANVAS_BUFFER", (char*)buffer);
+  }
+#endif
+
   /* valid only inside the ACTION callback of an IupCanvas */
   dc->cr = (cairo_t*)IupGetAttribute(ih, "CAIRO_CR");
   if (!dc->cr)
   {
-    GdkWindow* wnd = (GdkWindow*)IupGetAttribute(ih, "DRAWABLE");
-    dc->cr = gdk_cairo_create(wnd);
+#if GTK_CHECK_VERSION(3, 0, 0)
+    /* Outside ACTION callback - draw to persistent buffer */
+    dc->cr = cairo_create(buffer);
+#else
+    dc->cr = gdk_cairo_create(dc->wnd);
+#endif
     dc->release_cr = 1;
-#if !GTK_CHECK_VERSION(3, 0, 0)
-    dc->wnd = wnd;
-#endif
   }
 
-#if !GTK_CHECK_VERSION(3, 0, 0)
-  gdk_drawable_get_size(dc->wnd, &dc->w, &dc->h);
-#else
-  dc->w = gtk_widget_get_allocated_width(dc->widget);
-  dc->h = gtk_widget_get_allocated_height(dc->widget);
-#endif
-
-  surface = cairo_surface_create_similar(cairo_get_target(dc->cr), CAIRO_CONTENT_COLOR_ALPHA, dc->w, dc->h);
+  /* Create image surface for double-buffering the current operation */
+  surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, dc->w, dc->h);
   dc->image_cr = cairo_create(surface);
   cairo_surface_destroy(surface);
 
@@ -93,7 +120,7 @@
 {
   int w, h;
 #if !GTK_CHECK_VERSION(3, 0, 0)
-  gdk_drawable_get_size(dc->wnd, &w, &h);
+  gdk_window_get_geometry(dc->wnd, NULL, NULL, &w, &h, NULL);
 #else
   w = gtk_widget_get_allocated_width(dc->widget);
   h = gtk_widget_get_allocated_height(dc->widget);
@@ -108,7 +135,7 @@
 
     cairo_destroy(dc->image_cr);
 
-    surface = cairo_surface_create_similar(cairo_get_target(dc->cr), CAIRO_CONTENT_COLOR_ALPHA, dc->w, dc->h);
+    surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, dc->w, dc->h);
     dc->image_cr = cairo_create(surface);
     cairo_surface_destroy(surface);
   }
@@ -130,19 +157,13 @@
 
 IUP_SDK_API void iupdrvDrawFlush(IdrawCanvas* dc)
 {
-  /* flush the writing in the image */
-  cairo_show_page(dc->image_cr);
-
+  /* Reset clip on image buffer to ensure clean state for next frame */
   iupdrvDrawResetClip(dc);
 
-  cairo_rectangle(dc->cr, 0, 0, dc->w, dc->h);
-  cairo_clip(dc->cr);  /* intersect with the current clipping */
-
-  /* creates a pattern from the image and sets it as source in the canvas. */
+  /* Copy the image buffer to the target surface */
   cairo_set_source_surface(dc->cr, cairo_get_target(dc->image_cr), 0, 0);
-
   cairo_set_operator(dc->cr, CAIRO_OPERATOR_SOURCE);
-  cairo_paint(dc->cr);  /* paints the current source everywhere within the current clip region. */
+  cairo_paint(dc->cr);  /* paints the entire source surface */
 
 #if !GTK_CHECK_VERSION(3, 0, 0)
   if (dc->draw_focus)
@@ -151,6 +172,23 @@
     dc->draw_focus = 0;
   }
 #endif
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  /* If drawing to persistent buffer (outside ACTION), trigger widget repaint */
+  if (dc->release_cr)
+  {
+    cairo_surface_t* buffer = (cairo_surface_t*)iupAttribGet(dc->ih, "_IUPGTK3_CANVAS_BUFFER");
+    if (buffer)
+    {
+      cairo_surface_flush(buffer);
+      /* Mark buffer as updated so gtkCanvasDraw knows to use it */
+      iupAttribSet(dc->ih, "_IUPGTK3_BUFFER_DIRTY", "1");
+    }
+
+    /* Trigger widget repaint to copy buffer to screen (in ACTION callback) */
+    gtk_widget_queue_draw(dc->widget);
+  }
+#endif
 }
 
 IUP_SDK_API void iupdrvDrawGetSize(IdrawCanvas* dc, int *w, int *h)
@@ -354,6 +392,59 @@
   }
 }
 
+IUP_SDK_API void iupdrvDrawEllipse(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  double xc, yc, w, h;
+
+  cairo_set_source_rgba(dc->image_cr, iupgtkColorToDouble(iupDrawRed(color)), iupgtkColorToDouble(iupDrawGreen(color)), iupgtkColorToDouble(iupDrawBlue(color)), iupgtkColorToDouble(iupDrawAlpha(color)));
+
+  if (style != IUP_DRAW_FILL)
+  {
+    iDrawSetLineWidth(dc, line_width);
+    iDrawSetLineStyle(dc, style);
+  }
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  w = x2 - x1;
+  h = y2 - y1;
+  xc = x1 + w/2.0;
+  yc = y1 + h/2.0;
+
+  if (w == h)
+  {
+    /* Circle: simple arc */
+    cairo_new_path(dc->image_cr);
+    cairo_arc(dc->image_cr, xc, yc, 0.5*w, 0, 2*G_PI);
+
+    if (style == IUP_DRAW_FILL)
+      cairo_fill(dc->image_cr);
+    else
+      cairo_stroke(dc->image_cr);
+  }
+  else
+  {
+    /* Ellipse: use scale transform to create from circle */
+    cairo_save(dc->image_cr);
+
+    cairo_new_path(dc->image_cr);
+
+    cairo_translate(dc->image_cr, xc, yc);
+    cairo_scale(dc->image_cr, w/h, 1.0);
+    cairo_translate(dc->image_cr, -xc, -yc);
+
+    cairo_arc(dc->image_cr, xc, yc, 0.5*h, 0, 2*G_PI);
+
+    if (style == IUP_DRAW_FILL)
+      cairo_fill(dc->image_cr);
+    else
+      cairo_stroke(dc->image_cr);
+
+    cairo_restore(dc->image_cr);
+  }
+}
+
 IUP_SDK_API void iupdrvDrawPolygon(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width)
 {
   int i;
@@ -369,9 +460,11 @@
   cairo_new_path(dc->image_cr);
 
   cairo_move_to(dc->image_cr, points[0], points[1]);
-  for (i=0; i<count; i++)
+  for (i=1; i<count; i++)  /* Start at 1 to avoid redundant line to first point */
     cairo_line_to(dc->image_cr, points[2*i], points[2*i+1]);
 
+  cairo_close_path(dc->image_cr);  /* Close polygon by connecting last point to first */
+
   if (style==IUP_DRAW_FILL)
     cairo_fill(dc->image_cr);
   else
@@ -378,6 +471,111 @@
     cairo_stroke(dc->image_cr);
 }
 
+IUP_SDK_API void iupdrvDrawPixel(IdrawCanvas* dc, int x, int y, long color)
+{
+  cairo_set_source_rgba(dc->image_cr,
+                        iupgtkColorToDouble(iupDrawRed(color)),
+                        iupgtkColorToDouble(iupDrawGreen(color)),
+                        iupgtkColorToDouble(iupDrawBlue(color)),
+                        iupgtkColorToDouble(iupDrawAlpha(color)));
+
+  cairo_new_path(dc->image_cr);
+  cairo_rectangle(dc->image_cr, x, y, 1, 1);
+  cairo_fill(dc->image_cr);
+}
+
+IUP_SDK_API void iupdrvDrawRoundedRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width)
+{
+  double radius = (double)corner_radius;
+  double degrees = IUP_DEG2RAD;
+
+  /* Set color */
+  cairo_set_source_rgba(dc->image_cr,
+                        iupgtkColorToDouble(iupDrawRed(color)),
+                        iupgtkColorToDouble(iupDrawGreen(color)),
+                        iupgtkColorToDouble(iupDrawBlue(color)),
+                        iupgtkColorToDouble(iupDrawAlpha(color)));
+
+  /* Set line style for stroked rectangles */
+  if (style != IUP_DRAW_FILL)
+  {
+    iDrawSetLineWidth(dc, line_width);
+    iDrawSetLineStyle(dc, style);
+  }
+
+  /* Clamp radius to prevent oversized corners */
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+  double max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2.0 : (y2 - y1) / 2.0;
+  if (radius > max_radius)
+    radius = max_radius;
+
+  /* Draw path with rounded corners */
+  cairo_new_path(dc->image_cr);
+  cairo_arc(dc->image_cr, x2 - radius, y1 + radius, radius, -90 * degrees, 0 * degrees);
+  cairo_line_to(dc->image_cr, x2, y2 - radius);
+  cairo_arc(dc->image_cr, x2 - radius, y2 - radius, radius, 0 * degrees, 90 * degrees);
+  cairo_line_to(dc->image_cr, x1 + radius, y2);
+  cairo_arc(dc->image_cr, x1 + radius, y2 - radius, radius, 90 * degrees, 180 * degrees);
+  cairo_line_to(dc->image_cr, x1, y1 + radius);
+  cairo_arc(dc->image_cr, x1 + radius, y1 + radius, radius, 180 * degrees, 270 * degrees);
+  cairo_close_path(dc->image_cr);
+
+  if (style == IUP_DRAW_FILL)
+    cairo_fill(dc->image_cr);
+  else
+    cairo_stroke(dc->image_cr);
+}
+
+IUP_SDK_API void iupdrvDrawBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width)
+{
+  /* Set color */
+  cairo_set_source_rgba(dc->image_cr,
+                        iupgtkColorToDouble(iupDrawRed(color)),
+                        iupgtkColorToDouble(iupDrawGreen(color)),
+                        iupgtkColorToDouble(iupDrawBlue(color)),
+                        iupgtkColorToDouble(iupDrawAlpha(color)));
+
+  /* Set line style for stroked curves */
+  if (style != IUP_DRAW_FILL)
+  {
+    iDrawSetLineWidth(dc, line_width);
+    iDrawSetLineStyle(dc, style);
+  }
+
+  /* Draw cubic Bezier curve */
+  cairo_move_to(dc->image_cr, x1, y1);
+  cairo_curve_to(dc->image_cr, x2, y2, x3, y3, x4, y4);
+
+  if (style == IUP_DRAW_FILL)
+    cairo_fill(dc->image_cr);
+  else
+    cairo_stroke(dc->image_cr);
+}
+
+IUP_SDK_API void iupdrvDrawQuadraticBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width)
+{
+  /* Convert quadratic Bezier to cubic Bezier using the 2/3 formula:
+   * Given quadratic: Q(t) with control points q0, q1, q2
+   * Convert to cubic: C(t) with control points c0, c1, c2, c3
+   *
+   * c0 = q0                        (start point)
+   * c1 = q0 + (2/3) * (q1 - q0)   (first control point)
+   * c2 = q2 + (2/3) * (q1 - q2)   (second control point)
+   * c3 = q2                        (end point)
+   */
+  int cx1, cy1, cx2, cy2;
+
+  /* Calculate cubic control points from quadratic */
+  cx1 = x1 + ((2 * (x2 - x1)) / 3);
+  cy1 = y1 + ((2 * (y2 - y1)) / 3);
+  cx2 = x3 + ((2 * (x2 - x3)) / 3);
+  cy2 = y3 + ((2 * (y2 - y3)) / 3);
+
+  /* Draw as cubic Bezier */
+  iupdrvDrawBezier(dc, x1, y1, cx1, cy1, cx2, cy2, x3, y3, color, style, line_width);
+}
+
 IUP_SDK_API void iupdrvDrawGetClipRect(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2)
 {
   if (x1) *x1 = dc->clip_x1;
@@ -400,6 +598,7 @@
 
   iupdrvDrawResetClip(dc);
 
+  cairo_new_path(dc->image_cr);
   cairo_rectangle(dc->image_cr, x1, y1, x2 - x1 + 1, y2 - y1 + 1);
   cairo_clip(dc->image_cr);  /* intersect with the current clipping */
 
@@ -409,6 +608,45 @@
   dc->clip_y2 = y2;
 }
 
+IUP_SDK_API void iupdrvDrawSetClipRoundedRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius)
+{
+  double radius = (double)corner_radius;
+  double degrees = IUP_DEG2RAD;
+  double max_radius;
+
+  if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
+  {
+    iupdrvDrawResetClip(dc);
+    return;
+  }
+
+  /* Clamp radius to prevent oversized corners */
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+  max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2.0 : (y2 - y1) / 2.0;
+  if (radius > max_radius)
+    radius = max_radius;
+
+  iupdrvDrawResetClip(dc);
+
+  /* Draw rounded rectangle path with arcs at corners */
+  cairo_new_path(dc->image_cr);
+  cairo_arc(dc->image_cr, x2 - radius, y1 + radius, radius, -90 * degrees, 0 * degrees);
+  cairo_line_to(dc->image_cr, x2, y2 - radius);
+  cairo_arc(dc->image_cr, x2 - radius, y2 - radius, radius, 0 * degrees, 90 * degrees);
+  cairo_line_to(dc->image_cr, x1 + radius, y2);
+  cairo_arc(dc->image_cr, x1 + radius, y2 - radius, radius, 90 * degrees, 180 * degrees);
+  cairo_line_to(dc->image_cr, x1, y1 + radius);
+  cairo_arc(dc->image_cr, x1 + radius, y1 + radius, radius, 180 * degrees, 270 * degrees);
+  cairo_close_path(dc->image_cr);
+  cairo_clip(dc->image_cr);  /* intersect with the current clipping */
+
+  dc->clip_x1 = x1;
+  dc->clip_y1 = y1;
+  dc->clip_x2 = x2;
+  dc->clip_y2 = y2;
+}
+
 IUP_SDK_API void iupdrvDrawResetClip(IdrawCanvas* dc)
 {
   cairo_reset_clip(dc->image_cr);
@@ -464,6 +702,7 @@
   if (flags & IUP_DRAW_CLIP)
   {
     cairo_save(dc->image_cr);
+    cairo_new_path(dc->image_cr);
     cairo_rectangle(dc->image_cr, x, y, w, h);
     cairo_clip(dc->image_cr); /* intersect with the current clipping */
   }
@@ -578,4 +817,54 @@
 #endif
 }
 
+IUP_SDK_API void iupdrvDrawLinearGradient(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2)
+{
+  cairo_pattern_t *pattern;
+  float rad, x0, y0, x3, y3;
+  float w, h;
 
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  w = (float)(x2 - x1);
+  h = (float)(y2 - y1);
+
+  /* Calculate gradient endpoints based on angle */
+  /* 0 = left to right, 90 = top to bottom, 180 = right to left, 270 = bottom to top */
+  rad = angle * G_PI / 180.0f;
+
+  /* Start point (x0, y0) and end point (x3, y3) */
+  x0 = x1 + w / 2.0f - (w * cos(rad)) / 2.0f;
+  y0 = y1 + h / 2.0f - (h * sin(rad)) / 2.0f;
+  x3 = x1 + w / 2.0f + (w * cos(rad)) / 2.0f;
+  y3 = y1 + h / 2.0f + (h * sin(rad)) / 2.0f;
+
+  pattern = cairo_pattern_create_linear(x0, y0, x3, y3);
+  cairo_pattern_add_color_stop_rgba(pattern, 0.0,
+    iupDrawRed(color1) / 255.0, iupDrawGreen(color1) / 255.0, iupDrawBlue(color1) / 255.0, iupDrawAlpha(color1) / 255.0);
+  cairo_pattern_add_color_stop_rgba(pattern, 1.0,
+    iupDrawRed(color2) / 255.0, iupDrawGreen(color2) / 255.0, iupDrawBlue(color2) / 255.0, iupDrawAlpha(color2) / 255.0);
+
+  cairo_set_source(dc->image_cr, pattern);
+  cairo_rectangle(dc->image_cr, x1, y1, w, h);
+  cairo_fill(dc->image_cr);
+  cairo_pattern_destroy(pattern);
+}
+
+IUP_SDK_API void iupdrvDrawRadialGradient(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge)
+{
+  cairo_pattern_t *pattern;
+
+  pattern = cairo_pattern_create_radial(cx, cy, 0, cx, cy, radius);
+  cairo_pattern_add_color_stop_rgba(pattern, 0.0,
+    iupDrawRed(colorCenter) / 255.0, iupDrawGreen(colorCenter) / 255.0, iupDrawBlue(colorCenter) / 255.0, iupDrawAlpha(colorCenter) / 255.0);
+  cairo_pattern_add_color_stop_rgba(pattern, 1.0,
+    iupDrawRed(colorEdge) / 255.0, iupDrawGreen(colorEdge) / 255.0, iupDrawBlue(colorEdge) / 255.0, iupDrawAlpha(colorEdge) / 255.0);
+
+  cairo_set_source(dc->image_cr, pattern);
+  cairo_arc(dc->image_cr, cx, cy, radius, 0, 2 * G_PI);
+  cairo_fill(dc->image_cr);
+  cairo_pattern_destroy(pattern);
+}
+
+
Index: src/gtk/iupgtk_draw_gdk.c
===================================================================
--- src/gtk/iupgtk_draw_gdk.c	(revision 5971)
+++ src/gtk/iupgtk_draw_gdk.c	(working copy)
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <memory.h>
+#include <math.h>
 
 #include <gtk/gtk.h>
 
@@ -217,6 +218,26 @@
   gdk_draw_arc(dc->pixmap, dc->pixmap_gc, style == IUP_DRAW_FILL, x1, y1, x2 - x1, y2 - y1, iupRound(a1 * 64), iupRound((a2 - a1) * 64));    /* angle = 1/64ths of a degree */
 }
 
+IUP_SDK_API void iupdrvDrawEllipse(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  GdkColor c;
+  iupgdkColorSet(&c, color);
+  gdk_gc_set_rgb_fg_color(dc->pixmap_gc, &c);
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  if (style != IUP_DRAW_FILL)
+  {
+    iDrawSetLineWidth(dc, line_width);
+    iDrawSetLineStyle(dc, style);
+  }
+
+  /* Draw full ellipse using gdk_draw_arc with 360 degree span */
+  /* angle in GDK is 1/64ths of a degree, so 360*64 = 23040 */
+  gdk_draw_arc(dc->pixmap, dc->pixmap_gc, style == IUP_DRAW_FILL, x1, y1, x2 - x1, y2 - y1, 0, 23040);
+}
+
 IUP_SDK_API void iupdrvDrawPolygon(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width)
 {
   GdkColor c;
@@ -230,11 +251,138 @@
   }
 
   if (style == IUP_DRAW_FILL)
+  {
     gdk_draw_polygon(dc->pixmap, dc->pixmap_gc, TRUE, (GdkPoint*)points, count);
+  }
   else
-    gdk_draw_lines(dc->pixmap, dc->pixmap_gc, (GdkPoint*)points, count);
+  {
+    /* For stroked polygons, need to close the path by adding first point at the end */
+    GdkPoint* closed_points;
+    int use_heap = 0;
+    GdkPoint stack_points[256];
+
+    if (count + 1 <= 256)
+      closed_points = stack_points;
+    else
+    {
+      closed_points = (GdkPoint*)malloc((count + 1) * sizeof(GdkPoint));
+      use_heap = 1;
+    }
+
+    /* Copy all points */
+    memcpy(closed_points, points, count * sizeof(GdkPoint));
+    /* Add first point at the end to close the polygon */
+    closed_points[count] = closed_points[0];
+
+    gdk_draw_lines(dc->pixmap, dc->pixmap_gc, closed_points, count + 1);
+
+    if (use_heap)
+      free(closed_points);
+  }
 }
 
+IUP_SDK_API void iupdrvDrawPixel(IdrawCanvas* dc, int x, int y, long color)
+{
+  GdkColor c;
+  iupgdkColorSet(&c, color);
+  gdk_gc_set_rgb_fg_color(dc->pixmap_gc, &c);
+
+  gdk_draw_point(dc->pixmap, dc->pixmap_gc, x, y);
+}
+
+static void iDrawBuildRoundedRectPath(int x1, int y1, int x2, int y2, int corner_radius, GdkPoint* points, int* num_points)
+{
+  int i, n = 0;
+  double angle, step;
+  double pi = 3.14159265359;
+  int points_per_corner = 16;
+
+  step = 90.0 / points_per_corner;
+
+  /* Top-left corner: from 180 to 270 degrees */
+  for (i = 0; i <= points_per_corner; i++)
+  {
+    angle = (180.0 + i * step) * pi / 180.0;
+    points[n].x = x1 + corner_radius + (int)(corner_radius * cos(angle));
+    points[n].y = y1 + corner_radius + (int)(corner_radius * sin(angle));
+    n++;
+  }
+
+  /* Top-right corner: from 270 to 360 degrees */
+  for (i = 1; i <= points_per_corner; i++)
+  {
+    angle = (270.0 + i * step) * pi / 180.0;
+    points[n].x = x2 - corner_radius + (int)(corner_radius * cos(angle));
+    points[n].y = y1 + corner_radius + (int)(corner_radius * sin(angle));
+    n++;
+  }
+
+  /* Bottom-right corner: from 0 to 90 degrees */
+  for (i = 1; i <= points_per_corner; i++)
+  {
+    angle = (i * step) * pi / 180.0;
+    points[n].x = x2 - corner_radius + (int)(corner_radius * cos(angle));
+    points[n].y = y2 - corner_radius + (int)(corner_radius * sin(angle));
+    n++;
+  }
+
+  /* Bottom-left corner: from 90 to 180 degrees */
+  for (i = 1; i <= points_per_corner; i++)
+  {
+    angle = (90.0 + i * step) * pi / 180.0;
+    points[n].x = x1 + corner_radius + (int)(corner_radius * cos(angle));
+    points[n].y = y2 - corner_radius + (int)(corner_radius * sin(angle));
+    n++;
+  }
+
+  *num_points = n;
+}
+
+IUP_SDK_API void iupdrvDrawRoundedRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width)
+{
+  GdkColor c;
+  GdkPoint points[100];
+  int num_points;
+
+  iupgdkColorSet(&c, color);
+  gdk_gc_set_rgb_fg_color(dc->pixmap_gc, &c);
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Clamp radius to prevent oversized corners */
+  int max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2 : (y2 - y1) / 2;
+  if (corner_radius > max_radius)
+    corner_radius = max_radius;
+
+  if (corner_radius <= 0)
+  {
+    if (style == IUP_DRAW_FILL)
+      gdk_draw_rectangle(dc->pixmap, dc->pixmap_gc, TRUE, x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+    else
+    {
+      iDrawSetLineWidth(dc, line_width);
+      iDrawSetLineStyle(dc, style);
+      gdk_draw_rectangle(dc->pixmap, dc->pixmap_gc, FALSE, x1, y1, x2 - x1, y2 - y1);
+    }
+    return;
+  }
+
+  iDrawBuildRoundedRectPath(x1, y1, x2, y2, corner_radius, points, &num_points);
+
+  if (style == IUP_DRAW_FILL)
+  {
+    gdk_draw_polygon(dc->pixmap, dc->pixmap_gc, TRUE, points, num_points);
+  }
+  else
+  {
+    iDrawSetLineWidth(dc, line_width);
+    iDrawSetLineStyle(dc, style);
+    points[num_points] = points[0];
+    gdk_draw_lines(dc->pixmap, dc->pixmap_gc, points, num_points + 1);
+  }
+}
+
 IUP_SDK_API void iupdrvDrawGetClipRect(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2)
 {
   if (x1) *x1 = dc->clip_x1;
@@ -270,6 +418,40 @@
   dc->clip_y2 = y2;
 }
 
+IUP_SDK_API void iupdrvDrawSetClipRoundedRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius)
+{
+  GdkRegion *region;
+  GdkPoint points[100];
+  int num_points;
+  int max_radius;
+
+  if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
+  {
+    iupdrvDrawResetClip(dc);
+    return;
+  }
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Clamp radius to prevent oversized corners */
+  max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2 : (y2 - y1) / 2;
+  if (corner_radius > max_radius)
+    corner_radius = max_radius;
+
+  iDrawBuildRoundedRectPath(x1, y1, x2, y2, corner_radius, points, &num_points);
+
+  /* Create region from polygon */
+  region = gdk_region_polygon(points, num_points, GDK_WINDING_RULE);
+  gdk_gc_set_clip_region(dc->pixmap_gc, region);
+  gdk_region_destroy(region);
+
+  dc->clip_x1 = x1;
+  dc->clip_y1 = y1;
+  dc->clip_x2 = x2;
+  dc->clip_y2 = y2;
+}
+
 IUP_SDK_API void iupdrvDrawResetClip(IdrawCanvas* dc)
 {
   gdk_gc_set_clip_region(dc->pixmap_gc, NULL);
@@ -429,3 +611,143 @@
   dc->focus_y2 = y2;
 }
 
+IUP_SDK_API void iupdrvDrawBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width)
+{
+  /* GTK2 GDK does not have native Bezier support - use line approximation */
+  GdkPoint points[21]; /* 20 segments should give smooth curve */
+  int i, num_segments = 20;
+  GdkColor c;
+
+  iupgdkColorSet(&c, color);
+  gdk_gc_set_rgb_fg_color(dc->pixmap_gc, &c);
+  gdk_gc_set_line_attributes(dc->pixmap_gc, line_width, GDK_LINE_SOLID, GDK_CAP_ROUND, GDK_JOIN_ROUND);
+
+  /* Generate points along Bezier curve using parametric equation */
+  for (i = 0; i <= num_segments; i++)
+  {
+    double t = (double)i / num_segments;
+    double t1 = 1.0 - t;
+    double t1_3 = t1 * t1 * t1;
+    double t1_2_t = 3.0 * t1 * t1 * t;
+    double t1_t_2 = 3.0 * t1 * t * t;
+    double t_3 = t * t * t;
+
+    points[i].x = (gint)(t1_3 * x1 + t1_2_t * x2 + t1_t_2 * x3 + t_3 * x4);
+    points[i].y = (gint)(t1_3 * y1 + t1_2_t * y2 + t1_t_2 * y3 + t_3 * y4);
+  }
+
+  if (style == IUP_DRAW_FILL)
+  {
+    /* Fill as polygon */
+    gdk_draw_polygon(dc->pixmap, dc->pixmap_gc, TRUE, points, num_segments + 1);
+  }
+  else
+  {
+    /* Draw as polyline */
+    gdk_draw_lines(dc->pixmap, dc->pixmap_gc, points, num_segments + 1);
+  }
+}
+
+IUP_SDK_API void iupdrvDrawQuadraticBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width)
+{
+  /* Convert quadratic Bezier to cubic Bezier using the 2/3 formula */
+  int cx1, cy1, cx2, cy2;
+
+  cx1 = x1 + ((2 * (x2 - x1)) / 3);
+  cy1 = y1 + ((2 * (y2 - y1)) / 3);
+  cx2 = x3 + ((2 * (x2 - x3)) / 3);
+  cy2 = y3 + ((2 * (y2 - y3)) / 3);
+
+  iupdrvDrawBezier(dc, x1, y1, cx1, cy1, cx2, cy2, x3, y3, color, style, line_width);
+}
+
+static long gdkInterpolateColor(long color1, long color2, float t)
+{
+  unsigned char r1 = iupDrawRed(color1), g1 = iupDrawGreen(color1), b1 = iupDrawBlue(color1), a1 = iupDrawAlpha(color1);
+  unsigned char r2 = iupDrawRed(color2), g2 = iupDrawGreen(color2), b2 = iupDrawBlue(color2), a2 = iupDrawAlpha(color2);
+  unsigned char r = (unsigned char)(r1 + t * (r2 - r1));
+  unsigned char g = (unsigned char)(g1 + t * (g2 - g1));
+  unsigned char b = (unsigned char)(b1 + t * (b2 - b1));
+  unsigned char a = (unsigned char)(a1 + t * (a2 - a1));
+  return iupDrawColor(r, g, b, a);
+}
+
+IUP_SDK_API void iupdrvDrawLinearGradient(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2)
+{
+  int i, steps;
+  float t, dx, dy, length;
+  int px1, py1, px2, py2;
+  GdkColor gdk_color;
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Calculate gradient direction */
+  float rad = angle * 3.14159265359f / 180.0f;
+  dx = (float)cos(rad);
+  dy = (float)sin(rad);
+
+  /* Number of steps for smooth gradient */
+  length = (float)sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
+  steps = (int)length;
+  if (steps < 2) steps = 2;
+  if (steps > 256) steps = 256;
+
+  /* Draw gradient strips */
+  for (i = 0; i < steps; i++)
+  {
+    t = (float)i / (float)(steps - 1);
+    long color = gdkInterpolateColor(color1, color2, t);
+
+    gdk_color.red = iupDrawRed(color) * 257;
+    gdk_color.green = iupDrawGreen(color) * 257;
+    gdk_color.blue = iupDrawBlue(color) * 257;
+    gdk_gc_set_rgb_fg_color(dc->pixmap_gc, &gdk_color);
+
+    /* Calculate strip position */
+    if (fabs(dx) > fabs(dy))  /* More horizontal */
+    {
+      px1 = x1 + (int)(t * (x2 - x1));
+      px2 = x1 + (int)((t + 1.0f / steps) * (x2 - x1));
+      py1 = y1;
+      py2 = y2;
+    }
+    else  /* More vertical */
+    {
+      px1 = x1;
+      px2 = x2;
+      py1 = y1 + (int)(t * (y2 - y1));
+      py2 = y1 + (int)((t + 1.0f / steps) * (y2 - y1));
+    }
+
+    gdk_draw_rectangle(dc->pixmap, dc->pixmap_gc, TRUE, px1, py1, px2 - px1 + 1, py2 - py1 + 1);
+  }
+}
+
+IUP_SDK_API void iupdrvDrawRadialGradient(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge)
+{
+  int i, steps;
+  float t, r;
+  GdkColor gdk_color;
+
+  /* Number of steps for smooth gradient */
+  steps = radius;
+  if (steps < 2) steps = 2;
+  if (steps > 256) steps = 256;
+
+  /* Draw from outside to inside */
+  for (i = steps - 1; i >= 0; i--)
+  {
+    t = (float)i / (float)(steps - 1);
+    long color = gdkInterpolateColor(colorCenter, colorEdge, t);
+    r = (float)radius * t;
+
+    gdk_color.red = iupDrawRed(color) * 257;
+    gdk_color.green = iupDrawGreen(color) * 257;
+    gdk_color.blue = iupDrawBlue(color) * 257;
+    gdk_gc_set_rgb_fg_color(dc->pixmap_gc, &gdk_color);
+
+    gdk_draw_arc(dc->pixmap, dc->pixmap_gc, TRUE, (int)(cx - r), (int)(cy - r), (int)(2 * r), (int)(2 * r), 0, 23040);
+  }
+}
+
Index: src/gtk/iupgtk_drv.h
===================================================================
--- src/gtk/iupgtk_drv.h	(revision 5971)
+++ src/gtk/iupgtk_drv.h	(working copy)
@@ -25,6 +25,9 @@
 void iupgtkUpdateMnemonic(Ihandle* ih);
 
 void iupgdkColorSetRGB(GdkColor* color, unsigned char r, unsigned char g, unsigned char b);
+#if GTK_CHECK_VERSION(3, 0, 0)
+void iupgdkRGBASet(GdkRGBA* rgba, unsigned char r, unsigned char g, unsigned char b);
+#endif
 void iupgtkSetBgColor(InativeHandle* handle, unsigned char r, unsigned char g, unsigned char b);
 void iupgtkSetFgColor(InativeHandle* handle, unsigned char r, unsigned char g, unsigned char b);
 
@@ -34,10 +37,10 @@
 GdkWindow* iupgtkGetWindow(GtkWidget *widget);
 void iupgtkWindowGetPointer(GdkWindow *window, int *x, int *y, GdkModifierType *mask);
 int iupgtkIsVisible(GtkWidget* widget);
-void iupgtkClearSizeStyleCSS(GtkWidget* widget);
 void iupgtkSetMargin(GtkWidget* widget, int horiz_padding, int vert_padding, int mandatory_gtk3);
 
 GtkWidget* iupgtkNativeContainerNew(int has_window);
+void iupgtkNativeContainerSetGLCanvas(int is_gl);
 void iupgtkNativeContainerAdd(GtkWidget* container, GtkWidget* widget);
 void iupgtkNativeContainerMove(GtkWidget* container, GtkWidget* widget, int x, int y);
 
@@ -93,7 +96,21 @@
 /* dialog */
 gboolean iupgtkDialogDeleteEvent(GtkWidget *widget, GdkEvent *evt, Ihandle *ih);
 
+/* tray */
+#if GTK_CHECK_VERSION(2, 10, 0)
+int iupgtkSetTrayAttrib(Ihandle *ih, const char *value);
+int iupgtkSetTrayTipAttrib(Ihandle *ih, const char *value);
+int iupgtkSetTrayImageAttrib(Ihandle *ih, const char *value);
+int iupgtkSetTrayMenuAttrib(Ihandle *ih, const char *value);
+int iupgtkTrayCleanup(Ihandle *ih);
+#endif
 
+int iupgtkIsSystemDarkMode(void);
+void iupgtkSetGlobalColors(void);
+
+/* table */
+void iupgtkTableDetachVirtualModels(Ihandle* dialog);
+
 #ifdef __cplusplus
 }
 #endif
Index: src/gtk/iupgtk_filedlg.c
===================================================================
--- src/gtk/iupgtk_filedlg.c	(revision 5971)
+++ src/gtk/iupgtk_filedlg.c	(working copy)
@@ -23,6 +23,8 @@
 #include "iup_predialogs.h"
 #include "iup_array.h"
 #include "iup_drvinfo.h"
+#include "iup_dlglist.h"
+#include "iup_drv.h"
 
 #include "iupgtk_drv.h"
 
@@ -29,11 +31,15 @@
 
 static int gtkIsFile(const char* name)
 {
+  if (!name)
+    return 0;
   return g_file_test(name, G_FILE_TEST_IS_REGULAR);
 }
 
 static int gtkIsDirectory(const char* name)
 {
+  if (!name)
+    return 0;
   return g_file_test(name, G_FILE_TEST_IS_DIR);
 }            
 
@@ -210,6 +216,7 @@
 static void gtkFileDlgUpdatePreview(GtkFileChooser *file_chooser, Ihandle* ih)
 {
   char *filename = gtk_file_chooser_get_preview_filename(file_chooser);
+  GtkWidget* preview_canvas = (GtkWidget*)iupAttribGet(ih, "WID");
 
   IFnss cb = (IFnss)IupGetCallback(ih, "FILE_CB");
   if (cb) /* safety check - callback here always exists */
@@ -223,6 +230,9 @@
   g_free (filename);
 
   gtk_file_chooser_set_preview_widget_active(file_chooser, TRUE);
+
+  if (preview_canvas)
+    gtk_widget_queue_draw(preview_canvas);
 }
   
 static char* gtkFileCheckExt(Ihandle* ih, const char* filename)
@@ -246,6 +256,246 @@
   return (char*)filename;
 }
 
+/* Portal mode implementation using GtkFileChooserNative (GTK 3.20+)
+
+   GtkFileChooserNative uses XDG Desktop Portal automatically when:
+   - Running inside a sandbox (Flatpak, Snap), OR
+   - GTK_USE_PORTAL=1 environment variable is set
+
+   If neither condition is met, GtkFileChooserNative falls back to a
+   regular GtkFileChooserDialog internally.
+
+   The regular GtkFileChooserDialog (PORTAL=NO) never uses portals and
+   always shows the native GTK file chooser with full preview support. */
+#if GTK_CHECK_VERSION(3, 20, 0)
+static int gtkFileDlgPopupPortal(Ihandle* ih, int x, int y)
+{
+  InativeHandle* parent = iupDialogGetNativeParent(ih);
+  GtkFileChooserNative* native;
+  GtkFileChooserAction action;
+  const char *save_label, *open_label, *cancel_label;
+  char* value;
+  int response, filter_count = 0;
+
+  (void)x;
+  (void)y;
+
+  value = iupAttribGetStr(ih, "DIALOGTYPE");
+  if (iupStrEqualNoCase(value, "SAVE"))
+    action = GTK_FILE_CHOOSER_ACTION_SAVE;
+  else if (iupStrEqualNoCase(value, "DIR"))
+    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
+  else
+    action = GTK_FILE_CHOOSER_ACTION_OPEN;
+
+  value = iupAttribGet(ih, "TITLE");
+  if (!value)
+  {
+    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
+      value = "Save As";
+    else
+      value = "Open";
+  }
+
+  save_label = "_Save";
+  open_label = "_Open";
+  cancel_label = "_Cancel";
+
+  if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
+    native = gtk_file_chooser_native_new(iupgtkStrConvertToSystem(value), (GtkWindow*)parent, action, save_label, cancel_label);
+  else
+    native = gtk_file_chooser_native_new(iupgtkStrConvertToSystem(value), (GtkWindow*)parent, action, open_label, cancel_label);
+
+  if (!native)
+    return IUP_ERROR;
+
+  if (iupAttribGetBoolean(ih, "MULTIPLEFILES") && action == GTK_FILE_CHOOSER_ACTION_OPEN)
+    gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(native), TRUE);
+
+  value = iupAttribGet(ih, "FILE");
+  if (value && value[0] != 0 && (value[0] == '/' || value[1] == ':'))
+  {
+    char* dir = iupStrFileGetPath(value);
+    int len = (int)strlen(dir);
+    iupAttribSetStr(ih, "DIRECTORY", dir);
+    free(dir);
+    iupAttribSetStr(ih, "FILE", value+len);
+  }
+
+  value = iupAttribGet(ih, "DIRECTORY");
+  if (value)
+    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(native), iupgtkStrConvertToFilename(value));
+
+  value = iupAttribGet(ih, "FILE");
+  if (value)
+  {
+    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
+      gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(native), iupgtkStrConvertToFilename(value));
+    else
+    {
+      if (gtkIsFile(value))
+        gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(native), iupgtkStrConvertToFilename(value));
+    }
+  }
+
+  value = iupAttribGet(ih, "EXTFILTER");
+  if (value)
+  {
+    char *name, *pattern, *filters = iupStrDup(value);
+    char atrib[30];
+    int i, pattern_count, j;
+    int filter_index = iupAttribGetInt(ih, "FILTERUSED");
+    if (!filter_index)
+      filter_index = 1;
+
+    filter_count = iupStrReplace(filters, '|', 0) / 2;
+
+    name = filters;
+    for (i=0; i<filter_count && name[0]; i++)
+    {
+      GtkFileFilter *filter = gtk_file_filter_new();
+
+      pattern = gtkFileDlgGetNextStr(name);
+      pattern_count = iupStrReplace(pattern, ';', 0)+1;
+
+      gtk_file_filter_set_name(filter, iupgtkStrConvertToSystem(name));
+
+      for (j=0; j<pattern_count && pattern[0]; j++)
+      {
+        gtk_file_filter_add_pattern(filter, pattern);
+        if (j<pattern_count-1)
+          pattern = gtkFileDlgGetNextStr(pattern);
+      }
+
+      gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(native), filter);
+
+      sprintf(atrib, "_IUPDLG_FILTER%d", i+1);
+      iupAttribSet(ih, atrib, (char*)filter);
+
+      if (i+1 == filter_index)
+        gtk_file_chooser_set_filter(GTK_FILE_CHOOSER(native), filter);
+
+      name = gtkFileDlgGetNextStr(pattern);
+    }
+
+    free(filters);
+  }
+  else
+  {
+    value = iupAttribGet(ih, "FILTER");
+    if (value)
+    {
+      char* filters = iupStrDup(value), *fstr;
+      int pattern_count, i;
+      GtkFileFilter *filter = gtk_file_filter_new();
+      char* info = iupAttribGet(ih, "FILTERINFO");
+      if (!info)
+        info = value;
+
+      pattern_count = iupStrReplace(filters, ';', 0)+1;
+
+      gtk_file_filter_set_name(filter, iupgtkStrConvertToSystem(info));
+
+      fstr = filters;
+      for (i=0; i<pattern_count && fstr[0]; i++)
+      {
+        gtk_file_filter_add_pattern(filter, fstr);
+        fstr = gtkFileDlgGetNextStr(fstr);
+      }
+      gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(native), filter);
+      free(filters);
+    }
+  }
+
+  gtk_native_dialog_set_modal(GTK_NATIVE_DIALOG(native), TRUE);
+  response = gtk_native_dialog_run(GTK_NATIVE_DIALOG(native));
+
+  if (response == GTK_RESPONSE_ACCEPT)
+  {
+    int file_exist, dir_exist;
+
+    if (filter_count)
+    {
+      int i;
+      char atrib[30];
+      GtkFileFilter* filter = gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(native));
+
+      for (i=0; i<filter_count; i++)
+      {
+        sprintf(atrib, "_IUPDLG_FILTER%d", i+1);
+        if (filter == (GtkFileFilter*)iupAttribGet(ih, atrib))
+          iupAttribSetInt(ih, "FILTERUSED", i+1);
+      }
+    }
+
+    if (iupAttribGetBoolean(ih, "MULTIPLEFILES"))
+    {
+      GSList* file_list = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(native));
+      gtkFileDlgGetMultipleFiles(ih, file_list);
+      g_slist_free(file_list);
+      file_exist = 1;
+      dir_exist = 0;
+    }
+    else
+    {
+      char *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(native));
+      filename = gtkFileCheckExt(ih, filename);
+      iupAttribSetStr(ih, "VALUE", iupgtkStrConvertFromFilename(filename));
+      file_exist = gtkIsFile(filename);
+      dir_exist = gtkIsDirectory(filename);
+
+      {
+        char* dir = iupStrFileGetPath(filename);
+        iupAttribSetStr(ih, "DIRECTORY", dir);
+        free(dir);
+      }
+
+      g_free(filename);
+    }
+
+    if (dir_exist)
+    {
+      iupAttribSet(ih, "FILEEXIST", NULL);
+      iupAttribSet(ih, "STATUS", "0");
+    }
+    else
+    {
+      if (file_exist)
+      {
+        iupAttribSet(ih, "FILEEXIST", "YES");
+        iupAttribSet(ih, "STATUS", "0");
+      }
+      else
+      {
+        iupAttribSet(ih, "FILEEXIST", "NO");
+        iupAttribSet(ih, "STATUS", "1");
+      }
+    }
+
+    if (action != GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER && !iupAttribGetBoolean(ih, "NOCHANGEDIR"))
+    {
+      char* dir = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(native));
+      if (dir)
+      {
+        g_chdir(dir);
+        g_free(dir);
+      }
+    }
+  }
+  else
+  {
+    iupAttribSet(ih, "FILTERUSED", NULL);
+    iupAttribSet(ih, "VALUE", NULL);
+    iupAttribSet(ih, "FILEEXIST", NULL);
+    iupAttribSet(ih, "STATUS", "-1");
+  }
+
+  g_object_unref(native);
+
+  return IUP_NOERROR;
+}
+#endif
+
 static int gtkFileDlgPopup(Ihandle* ih, int x, int y)
 {
   InativeHandle* parent = iupDialogGetNativeParent(ih);
@@ -257,6 +507,35 @@
   char* value;
   int response, filter_count = 0;
 
+  /* If no parent set, find the active window from dialog list */
+  if (!parent)
+  {
+    Ihandle* dlg;
+    for (dlg = iupDlgListFirst(); dlg; dlg = iupDlgListNext())
+    {
+      if (dlg->handle && iupdrvIsVisible(dlg) && gtk_window_is_active((GtkWindow*)dlg->handle))
+      {
+        parent = dlg->handle;
+        IupSetAttributeHandle(ih, "PARENTDIALOG", dlg);
+        break;
+      }
+    }
+  }
+
+#if GTK_CHECK_VERSION(3, 20, 0)
+  {
+    int use_portal = 0;
+    value = iupAttribGet(ih, "PORTAL");
+    if (value)
+      use_portal = iupStrBoolean(value);
+    else if (IupGetGlobal("SANDBOX"))
+      use_portal = 1;
+
+    if (use_portal)
+      return gtkFileDlgPopupPortal(ih, x, y);
+  }
+#endif
+
   iupAttribSetInt(ih, "_IUPDLG_X", x);   /* used in iupDialogUpdatePosition */
   iupAttribSetInt(ih, "_IUPDLG_Y", y);
 
@@ -308,9 +587,7 @@
   help = GTK_STOCK_HELP;
 #endif
 
-  dialog = gtk_file_chooser_dialog_new(iupgtkStrConvertToSystem(value), (GtkWindow*)parent, action, 
-                                       cancel, GTK_RESPONSE_CANCEL, 
-                                       NULL);
+  dialog = gtk_file_chooser_dialog_new(iupgtkStrConvertToSystem(value), (GtkWindow*)parent, action, cancel, GTK_RESPONSE_CANCEL, NULL);
   if (!dialog)
     return IUP_ERROR;
 
@@ -452,7 +729,9 @@
       gtk_widget_set_size_request(frame, preview_width, preview_height);
 
       preview_canvas = gtk_drawing_area_new();
+#if !GTK_CHECK_VERSION(3, 14, 0)
       gtk_widget_set_double_buffered(preview_canvas, FALSE);
+#endif
       gtk_container_add(GTK_CONTAINER(frame), preview_canvas);
       gtk_widget_show(preview_canvas);
 
Index: src/gtk/iupgtk_font.c
===================================================================
--- src/gtk/iupgtk_font.c	(revision 5971)
+++ src/gtk/iupgtk_font.c	(working copy)
@@ -7,6 +7,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <stdint.h>
 
 #include <gtk/gtk.h>
 
@@ -208,7 +209,10 @@
   IgtkFont* gtkfont;
 
 #if GTK_CHECK_VERSION(3, 0, 0)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
   gtk_widget_override_font(widget, fontdesc);
+#pragma GCC diagnostic pop
 #else
   gtk_widget_modify_font(widget, fontdesc);
 #endif
@@ -228,9 +232,17 @@
 
   if (GTK_IS_ENTRY(widget))
   {
-    /* TODO: This is NOT working. */
-    PangoLayout* layout = gtk_entry_get_layout(GTK_ENTRY(widget));
-    gtkFontUpdateLayout(gtkfont, layout);  /* for strikeout and underline */
+#if GTK_CHECK_VERSION(3, 6, 0)
+    PangoAttrList *attrs = pango_attr_list_new();
+    pango_attr_list_insert(attrs, pango_attribute_copy(gtkfont->strikethrough));
+    pango_attr_list_insert(attrs, pango_attribute_copy(gtkfont->underline));
+    gtk_entry_set_attributes(GTK_ENTRY(widget), attrs);
+    pango_attr_list_unref(attrs);
+#else
+    /* gtk_entry_set_attributes() not available in GTK < 3.6.
+       Modifying the internal layout doesn't work as GTK recreates it. */
+    (void)gtkfont;
+#endif
   }
 }
 
@@ -251,18 +263,19 @@
   g_object_set(object, "font-desc", gtkfont->fontdesc, NULL);
 
   g_object_get(object, "attributes", &attrs, NULL);
-  if (!attrs) 
+  if (!attrs)
   {
     attrs = pango_attr_list_new();
     pango_attr_list_insert(attrs, pango_attribute_copy(gtkfont->strikethrough));
     pango_attr_list_insert(attrs, pango_attribute_copy(gtkfont->underline));
-    g_object_set(object, "attributes", attrs, NULL);  /* TODO: does this reference attrs? */
-    /* pango_attr_list_unref(attrs); */
+    g_object_set(object, "attributes", attrs, NULL);
+    pango_attr_list_unref(attrs);  /* g_object_set takes its own reference */
   }
   else
   {
     pango_attr_list_change(attrs, pango_attribute_copy(gtkfont->strikethrough));
     pango_attr_list_change(attrs, pango_attribute_copy(gtkfont->underline));
+    pango_attr_list_unref(attrs);  /* g_object_get returns a reference we must unref */
   }
 }
 
@@ -270,8 +283,8 @@
 {
   static char str[200]; /* must return a static string, because it will be used as the default value for the FONT attribute */
   const PangoFontDescription* font_desc = NULL;
-  GtkWidget* widget = gtk_invisible_new();
-  gtk_widget_realize(widget);
+  GtkWidget* widget = gtk_offscreen_window_new();
+  gtk_widget_show(widget);
 #if GTK_CHECK_VERSION(3, 0, 0)
   {
     GtkStyleContext* context = gtk_widget_get_style_context(widget);
@@ -299,7 +312,6 @@
     strcpy(str, desc);
     g_free(desc);
   }
-  gtk_widget_unrealize(widget);
   gtk_widget_destroy(widget);
   return str;
 }
@@ -348,13 +360,16 @@
     return NULL;
   else
   {
-#if GTK_CHECK_VERSION(3, 0, 0)
-    return NULL;  /* TODO: not available yet. */
+#if GTK_CHECK_VERSION(3, 0, 0) || defined(GDK_DISABLE_DEPRECATED)
+    /* Not available in GTK3+ or when GDK deprecated APIs are disabled:
+       Pango/Cairo fonts do not expose X11 Font IDs needed for glXUseXFont().
+       Display list fonts (glXUseXFont/wglUseFontBitmaps) are deprecated in modern OpenGL. */
+    return NULL;
 #else
     /* both functions are marked as deprecated in GDK (since 2.22) */
     GdkFont* gdk_font = gdk_font_from_description(gtkfont->fontdesc);
-    return (char*)gdk_font_id(gdk_font);  /* In UNIX will return an X Font ID, 
-                                             in Win32 will return an HFONT */
+    return (char*)(intptr_t)gdk_font_id(gdk_font);  /* In UNIX will return an X Font ID,
+                                                       in Win32 will return an HFONT */
 #endif
   }
 }
Index: src/gtk/iupgtk_frame.c
===================================================================
--- src/gtk/iupgtk_frame.c	(revision 5971)
+++ src/gtk/iupgtk_frame.c	(working copy)
@@ -27,12 +27,72 @@
 #include "iupgtk_drv.h"
 
 
+#if GTK_CHECK_VERSION(3, 0, 0)
+static void gtkFrameMeasureDecor(int has_title, int* decor_w, int* decor_h, int* title_h)
+{
+  GtkWidget* temp_window = gtk_offscreen_window_new();
+  GtkWidget* temp_frame = gtk_frame_new(NULL);
+  GtkWidget* temp_child = gtk_fixed_new();
+  GtkRequisition frame_req, child_req;
+
+  if (has_title)
+    gtk_frame_set_label(GTK_FRAME(temp_frame), "Tj");
+
+  gtk_container_add(GTK_CONTAINER(temp_frame), temp_child);
+  gtk_container_set_border_width(GTK_CONTAINER(temp_frame), 2);
+  gtk_widget_set_size_request(temp_child, 100, 100);
+
+  gtk_container_add(GTK_CONTAINER(temp_window), temp_frame);
+  gtk_widget_show_all(temp_window);
+
+  gtk_widget_get_preferred_size(temp_frame, NULL, &frame_req);
+  gtk_widget_get_preferred_size(temp_child, NULL, &child_req);
+
+  *decor_w = frame_req.width - child_req.width;
+  *decor_h = frame_req.height - child_req.height;
+  *title_h = 0;
+
+  if (has_title)
+  {
+    GtkWidget* label = gtk_frame_get_label_widget(GTK_FRAME(temp_frame));
+    if (label)
+    {
+      GtkRequisition label_req;
+      gtk_widget_get_preferred_size(label, NULL, &label_req);
+      *title_h = label_req.height;
+    }
+  }
+
+  if (*decor_w < 0) *decor_w = 4;
+  if (*decor_h < 0) *decor_h = 4;
+
+  gtk_widget_destroy(temp_window);
+}
+#endif
+
 void iupdrvFrameGetDecorOffset(Ihandle* ih, int *x, int *y)
 {
+#if GTK_CHECK_VERSION(3, 0, 0)
+  static int measured = 0;
+  static int offset_x = 0, offset_y = 0;
   (void)ih;
-  /* LAYOUT_DECORATION_ESTIMATE */
+
+  if (!measured)
+  {
+    int decor_w, decor_h, title_h;
+    gtkFrameMeasureDecor(0, &decor_w, &decor_h, &title_h);
+    offset_x = decor_w / 2;
+    offset_y = decor_h / 2;
+    measured = 1;
+  }
+
+  *x = offset_x;
+  *y = offset_y;
+#else
+  (void)ih;
   *x = 2;
   *y = 2;
+#endif
 }
 
 int iupdrvFrameHasClientOffset(Ihandle* ih)
@@ -43,17 +103,82 @@
 
 int iupdrvFrameGetTitleHeight(Ihandle* ih, int *h)
 {
+#if GTK_CHECK_VERSION(3, 0, 0)
+  static int measured = 0;
+  static int cached_title_h = 0;
+
+  if (ih->handle)
+  {
+    GtkWidget* label = gtk_frame_get_label_widget((GtkFrame*)ih->handle);
+    if (label)
+    {
+      GtkRequisition req;
+      gtk_widget_get_preferred_size(label, NULL, &req);
+      *h = req.height;
+      return 1;
+    }
+  }
+
+  if (!measured)
+  {
+    int decor_w, decor_h;
+    gtkFrameMeasureDecor(1, &decor_w, &decor_h, &cached_title_h);
+    measured = 1;
+  }
+
+  if (cached_title_h > 0)
+  {
+    *h = cached_title_h;
+    return 1;
+  }
+
+  return 0;
+#else
   (void)ih;
   (void)h;
   return 0;
+#endif
 }
 
 int iupdrvFrameGetDecorSize(Ihandle* ih, int *w, int *h)
 {
+#if GTK_CHECK_VERSION(3, 0, 0)
+  static int titled_measured = 0, untitled_measured = 0;
+  static int titled_w = 0, titled_h = 0;
+  static int untitled_w = 0, untitled_h = 0;
+  const char* title = iupAttribGet(ih, "TITLE");
+  int has_title = (title && *title) ? 1 : 0;
+
+  if (has_title)
+  {
+    if (!titled_measured)
+    {
+      int title_h;
+      gtkFrameMeasureDecor(1, &titled_w, &titled_h, &title_h);
+      titled_measured = 1;
+    }
+    *w = titled_w;
+    *h = titled_h;
+  }
+  else
+  {
+    if (!untitled_measured)
+    {
+      int title_h;
+      gtkFrameMeasureDecor(0, &untitled_w, &untitled_h, &title_h);
+      untitled_measured = 1;
+    }
+    *w = untitled_w;
+    *h = untitled_h;
+  }
+
+  return 1;
+#else
   (void)ih;
   (void)w;
   (void)h;
   return 0;
+#endif
 }
 
 static int gtkFrameSetTitleAttrib(Ihandle* ih, const char* value)
@@ -170,6 +295,9 @@
   gtk_container_add((GtkContainer*)ih->handle, inner_parent);
   gtk_widget_show(inner_parent);
 
+  /* Set uniform border width for symmetric spacing */
+  gtk_container_set_border_width(GTK_CONTAINER(ih->handle), 2);
+
   /* Add to the parent, all GTK controls must call this. */
   iupgtkAddToParent(ih);
 
Index: src/gtk/iupgtk_globalattrib.c
===================================================================
--- src/gtk/iupgtk_globalattrib.c	(revision 5971)
+++ src/gtk/iupgtk_globalattrib.c	(working copy)
@@ -153,13 +153,42 @@
 {
   if (iupStrEqual(name, "VIRTUALSCREEN"))
   {
+    int x = 0;
+    int y = 0;
+    int w, h;
+
+#if GTK_CHECK_VERSION(3, 22, 0)
+    GdkDisplay *display = gdk_display_get_default();
+    GdkMonitor* monitor = gdk_display_get_primary_monitor(display);
+    if (!monitor)
+       monitor = gdk_display_get_monitor(display, 0);
+    GdkRectangle rect;
+    gdk_monitor_get_geometry(monitor, &rect);
+    x = rect.x;
+    y = rect.y;
+    w = rect.width;
+    h = rect.height;
+#elif GTK_CHECK_VERSION(3, 0, 0)
     GdkScreen *screen = gdk_screen_get_default();
+    w = gdk_screen_get_width(screen);
+    h = gdk_screen_get_height(screen);
+    GdkRectangle rect;
+#if GTK_CHECK_VERSION(2, 20, 0)
+    gint monitor_num = gdk_screen_get_primary_monitor(screen);
+#else
+    gint monitor_num = gdk_screen_get_monitor_at_point(screen, 0, 0);
+#endif
+    gdk_screen_get_monitor_geometry(screen, monitor_num, &rect);
+    x = rect.x;
+    y = rect.y;
+#else
+    GdkScreen *screen = gdk_screen_get_default();
+    w = gdk_screen_get_width(screen);
+    h = gdk_screen_get_height(screen);
     GdkWindow *root = gdk_screen_get_root_window(gdk_screen_get_default());
-    int x = 0;
-    int y = 0;
-    int w = gdk_screen_get_width(screen);
-    int h = gdk_screen_get_height(screen);
     gdk_window_get_root_origin(root, &x, &y);
+#endif
+
     return iupStrReturnStrf("%d %d %d %d", x, y, w, h);
   }
   if (iupStrEqual(name, "MONITORSINFO"))
@@ -202,7 +231,12 @@
   }
   if (iupStrEqual(name, "TRUECOLORCANVAS"))
   {
+#if GTK_CHECK_VERSION(3, 22, 0)
+    GdkVisual* visual = gdk_screen_get_system_visual(gdk_screen_get_default());
+    return iupStrReturnBoolean(gdk_visual_get_depth(visual) > 8);
+#else
     return iupStrReturnBoolean(gdk_visual_get_best_depth() > 8);
+#endif
   }
   if (iupStrEqual(name, "UTF8MODE"))
   {
@@ -234,5 +268,29 @@
     g_object_get (gtk_settings_get_default (), "gtk-menu-images", &menu_images, NULL);
     return iupStrReturnBoolean(menu_images);
   }
+  if (iupStrEqual(name, "DARKMODE"))
+  {
+    return iupStrReturnBoolean(iupgtkIsSystemDarkMode());
+  }
+  if (iupStrEqual(name, "OVERLAYSCROLLBAR"))
+  {
+#if GTK_CHECK_VERSION(3, 16, 0)
+    gboolean overlay_scrolling;
+    g_object_get(gtk_settings_get_default(), "gtk-overlay-scrolling", &overlay_scrolling, NULL);
+    return iupStrReturnBoolean(overlay_scrolling);
+#else
+    return "NO";  /* GTK < 3.16 doesn't have overlay scrollbars */
+#endif
+  }
+  if (iupStrEqual(name, "SANDBOX"))
+  {
+    if (getenv("FLATPAK_ID"))
+      return "FLATPAK";
+    if (getenv("SNAP"))
+      return "SNAP";
+    if (getenv("APPIMAGE"))
+      return "APPIMAGE";
+    return NULL;
+  }
   return NULL;
 }
Index: src/gtk/iupgtk_help.c
===================================================================
--- src/gtk/iupgtk_help.c	(revision 5971)
+++ src/gtk/iupgtk_help.c	(working copy)
@@ -72,9 +72,9 @@
     char* system = IupGetGlobal("SYSTEM");
     if (iupStrEqualNoCase(system, "Linux") ||
         iupStrEqualNoCase(system, "FreeBSD"))
-        browser = "firefox";
+        browser = "xdg-open";
     else if (iupStrEqualNoCase(system, "MacOS"))
-      browser = "safari";
+      browser = "open";
     else if (iupStrEqualPartial(system, "CYGWIN"))
       browser = "iexplore";
     else
Index: src/gtk/iupgtk_image.c
===================================================================
--- src/gtk/iupgtk_image.c	(revision 5971)
+++ src/gtk/iupgtk_image.c	(working copy)
@@ -281,7 +281,7 @@
   int hx=0, hy=0;
   iupStrToIntInt(iupAttribGet(ih, "HOTSPOT"), &hx, &hy, ':');
 
-#if !GTK_CHECK_VERSION(3, 0, 0)  /* not supported in GTK3 */
+#if !GTK_CHECK_VERSION(3, 0, 0) && !defined(GDK_DISABLE_DEPRECATED)  /* not supported in GTK3 or when GDK deprecated APIs are disabled */
   if (iupAttribGetInt(ih, "BPP") == 8 && !iupAttribGet(ih, "3"))
   {
     GdkPixmap *source, *mask;
Index: src/gtk/iupgtk_info.c
===================================================================
--- src/gtk/iupgtk_info.c	(revision 5971)
+++ src/gtk/iupgtk_info.c	(working copy)
@@ -5,8 +5,8 @@
  */
 
 #include <stdio.h>
-#include <stdlib.h> 
-#include <string.h> 
+#include <stdlib.h>
+#include <string.h>
 #include <limits.h>
 #include <sys/stat.h>
 
@@ -26,41 +26,49 @@
   (void)add;
 }
 
-/* From GDK docs: nowadays it is more common to have a single GdkScreen which combines several physical monitors */
-
-#if 0 /* this is the entire screen area */
-GdkScreen* screen = gdk_screen_get_default();
-*width = gdk_screen_get_width(screen);
-*height = gdk_screen_get_height(screen);
-#endif
-
 IUP_SDK_API void iupdrvGetScreenSize(int *width, int *height)
 {
-#if GTK_CHECK_VERSION(3, 4, 0)
+#if GTK_CHECK_VERSION(3, 22, 0)
+  GdkDisplay *display = gdk_display_get_default();
+  GdkMonitor* monitor = gdk_display_get_primary_monitor(display);
+  if (!monitor)
+    monitor = gdk_display_get_monitor(display, 0);
   GdkRectangle rect;
+  gdk_monitor_get_workarea(monitor, &rect);
+  *width = rect.width;
+  *height = rect.height;
+#elif GTK_CHECK_VERSION(3, 4, 0)
   GdkScreen* screen = gdk_screen_get_default();
+  GdkRectangle rect;
+  gint monitor = gdk_screen_get_primary_monitor(screen);
+  gdk_screen_get_monitor_workarea(screen, monitor, &rect);
+  *width = rect.width;
+  *height = rect.height;
+#else
+  GdkScreen* screen = gdk_screen_get_default();
+  GdkRectangle rect;
 #if GTK_CHECK_VERSION(2, 20, 0)
   gint monitor = gdk_screen_get_primary_monitor(screen);
 #else
   gint monitor = gdk_screen_get_monitor_at_point(screen, 0, 0);
 #endif
-  gdk_screen_get_monitor_workarea(screen, monitor, &rect);
+  gdk_screen_get_monitor_geometry(screen, monitor, &rect);
   *width = rect.width;
   *height = rect.height;
-#else  /* TODO: this is NOT working, couldn't find a way */
-  GdkWindow *root = gdk_screen_get_root_window(gdk_screen_get_default());
-#if GTK_CHECK_VERSION(3, 0, 0)
-  gdk_window_get_geometry(root, NULL, NULL, width, height);
-#else
-  gdk_window_get_geometry(root, NULL, NULL, width, height, NULL);
 #endif
-#endif
 }
 
 IUP_SDK_API void iupdrvGetFullSize(int *width, int *height)
 {
+  GdkRectangle rect;
+#if GTK_CHECK_VERSION(3, 22, 0)
+  GdkDisplay* display = gdk_display_get_default();
+  GdkMonitor* monitor = gdk_display_get_primary_monitor(display);
+  if (!monitor)
+    monitor = gdk_display_get_monitor(display, 0);
+  gdk_monitor_get_geometry(monitor, &rect);
+#else
   GdkScreen* screen = gdk_screen_get_default();
-  GdkRectangle rect;
 #if GTK_CHECK_VERSION(2, 20, 0)
   gint monitor = gdk_screen_get_primary_monitor(screen);
 #else
@@ -67,6 +75,7 @@
   gint monitor = gdk_screen_get_monitor_at_point(screen, 0, 0);
 #endif
   gdk_screen_get_monitor_geometry(screen, monitor, &rect);
+#endif
   *width = rect.width;
   *height = rect.height;
 }
@@ -73,7 +82,11 @@
 
 IUP_SDK_API int iupdrvGetScreenDepth(void)
 {
+#if GTK_CHECK_VERSION(3, 22, 0)
+  GdkVisual* visual = gdk_screen_get_system_visual(gdk_screen_get_default());
+#else
   GdkVisual* visual = gdk_visual_get_system();
+#endif
 #if GTK_CHECK_VERSION(2, 22, 0)
   return gdk_visual_get_depth(visual);
 #else
@@ -88,7 +101,11 @@
 
 IUP_SDK_API void iupdrvGetCursorPos(int *x, int *y)
 {
-#if GTK_CHECK_VERSION(3, 0, 0)
+#if GTK_CHECK_VERSION(3, 20, 0)
+  GdkSeat* seat = gdk_display_get_default_seat(gdk_display_get_default());
+  GdkDevice* device = gdk_seat_get_pointer(seat);
+  gdk_device_get_position(device, NULL, x, y);
+#elif GTK_CHECK_VERSION(3, 0, 0)
   GdkDeviceManager* device_manager = gdk_display_get_device_manager(gdk_display_get_default());
   GdkDevice* device = gdk_device_manager_get_client_pointer(device_manager);
   gdk_device_get_position(device, NULL, x, y);
@@ -99,9 +116,18 @@
 
 IUP_SDK_API void iupdrvGetKeyState(char* key)
 {
-  GdkModifierType aModifierType;
-  gdk_display_get_pointer(gdk_display_get_default(), NULL, NULL, NULL, &aModifierType); /* TODO: deprecated in GTK 3, but couldn't find a simpler way */
+  GdkModifierType aModifierType = 0;
 
+#if GTK_CHECK_VERSION(3, 4, 0)
+  GdkKeymap* keymap = gdk_keymap_get_for_display(gdk_display_get_default());
+  if (keymap)
+    aModifierType = gdk_keymap_get_modifier_state(keymap);
+#else
+  /* Fallback for GTK2 and GTK < 3.4 */
+  /* gdk_display_get_pointer is deprecated in GTK3 but is the only option here */
+  gdk_display_get_pointer(gdk_display_get_default(), NULL, NULL, NULL, &aModifierType);
+#endif
+
   if (aModifierType & GDK_SHIFT_MASK)
     key[0] = 'S';
   else
Index: src/gtk/iupgtk_label.c
===================================================================
--- src/gtk/iupgtk_label.c	(revision 5971)
+++ src/gtk/iupgtk_label.c	(working copy)
@@ -39,14 +39,18 @@
   GtkWidget* eventbox = (GtkWidget*)iupAttribGet(ih, "_IUP_EXTRAPARENT");
   unsigned char r, g, b;
 
-  /* ignore given value, must use only from parent */
-  char* parent_value = iupBaseNativeParentGetBgColor(ih);
+  if (!iupStrToRGB(value, &r, &g, &b))
+    return 0;
 
-  if (iupStrToRGB(parent_value, &r, &g, &b))
+  /* Set background on the eventbox wrapper */
+  if (eventbox)
     iupgtkSetBgColor(eventbox, r, g, b);
 
-  (void)value;
-  return iupdrvBaseSetBgColorAttrib(ih, parent_value);
+  /* Also set on the inner label widget */
+  if (ih->handle)
+    iupgtkSetBgColor(ih->handle, r, g, b);
+
+  return 1;
 }
 
 static int gtkLabelSetTitleAttrib(Ihandle* ih, const char* value)
@@ -105,7 +109,6 @@
 {
   if (ih->data->type != IUP_LABEL_SEP_HORIZ && ih->data->type != IUP_LABEL_SEP_VERT)
   {
-    GtkMisc* misc = (GtkMisc*)ih->handle;
     PangoAlignment alignment;
     float xalign, yalign;
     char value1[30], value2[30];
@@ -135,11 +138,41 @@
     else  /* ACENTER (default) */
       yalign = 0.5f;
 
+#if GTK_CHECK_VERSION(3, 16, 0)
+    /* Use gtk_label_set_xalign/yalign */
+    if (ih->data->type == IUP_LABEL_TEXT)
+    {
+      GtkLabel* label = (GtkLabel*)ih->handle;
+      GtkJustification justify;
+
+      gtk_label_set_xalign(label, xalign);
+      gtk_label_set_yalign(label, yalign);
+
+      /* Convert PangoAlignment to GtkJustification */
+      if (alignment == PANGO_ALIGN_RIGHT)
+        justify = GTK_JUSTIFY_RIGHT;
+      else if (alignment == PANGO_ALIGN_CENTER)
+        justify = GTK_JUSTIFY_CENTER;
+      else
+        justify = GTK_JUSTIFY_LEFT;
+
+      /* gtk_label_set_justify() is required for multiline text alignment */
+      gtk_label_set_justify(label, justify);
+      pango_layout_set_alignment(gtk_label_get_layout(label), alignment);
+    }
+    else if (ih->data->type == IUP_LABEL_IMAGE)
+    {
+      gtk_widget_set_halign(ih->handle, xalign == 0 ? GTK_ALIGN_START : (xalign == 1.0f ? GTK_ALIGN_END : GTK_ALIGN_CENTER));
+      gtk_widget_set_valign(ih->handle, yalign == 0 ? GTK_ALIGN_START : (yalign == 1.0f ? GTK_ALIGN_END : GTK_ALIGN_CENTER));
+    }
+#else
+    /* Use deprecated GtkMisc */
+    GtkMisc* misc = (GtkMisc*)ih->handle;
     gtk_misc_set_alignment(misc, xalign, yalign);
-/* TODO:   g_object_set(widget, "xalign", xalign, "yalign", yalign, NULL); */
 
     if (ih->data->type == IUP_LABEL_TEXT)
       pango_layout_set_alignment(gtk_label_get_layout((GtkLabel*)ih->handle), alignment);
+#endif
 
     return 1;
   }
Index: src/gtk/iupgtk_list.c
===================================================================
--- src/gtk/iupgtk_list.c	(revision 5971)
+++ src/gtk/iupgtk_list.c	(working copy)
@@ -34,15 +34,6 @@
 #include "iupgtk_drv.h"
 
 
-/* TODO:
-  Replace:
-    cell-background-gdk
-    foreground-gdk
-  By:
-    cell-background-rgba
-    foreground-rgba
-*/
-
 enum
 {
   IUPGTK_LIST_IMAGE,  /* "pixbuf" */
@@ -53,46 +44,580 @@
 static void gtkListSelectionChanged(GtkTreeSelection* selection, Ihandle* ih);
 static void gtkListComboBoxChanged(GtkComboBox* widget, Ihandle* ih);
 
+/* Custom Virtual List Model for VIRTUALMODE */
+typedef struct _IupGtkVirtualListModel IupGtkVirtualListModel;
+typedef struct _IupGtkVirtualListModelClass IupGtkVirtualListModelClass;
 
+struct _IupGtkVirtualListModel
+{
+  GObject parent;
+  Ihandle* ih;
+  gint stamp;
+  gint count;  /* Model's own count, used during detach/reattach */
+};
+
+struct _IupGtkVirtualListModelClass
+{
+  GObjectClass parent_class;
+};
+
+GType iup_gtk_virtual_list_model_get_type(void);
+#define IUP_TYPE_GTK_VIRTUAL_LIST_MODEL (iup_gtk_virtual_list_model_get_type())
+#define IUP_GTK_VIRTUAL_LIST_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), IUP_TYPE_GTK_VIRTUAL_LIST_MODEL, IupGtkVirtualListModel))
+
+static void iup_gtk_virtual_list_model_tree_model_init(GtkTreeModelIface *iface);
+
+G_DEFINE_TYPE_WITH_CODE(IupGtkVirtualListModel, iup_gtk_virtual_list_model, G_TYPE_OBJECT,
+                        G_IMPLEMENT_INTERFACE(GTK_TYPE_TREE_MODEL, iup_gtk_virtual_list_model_tree_model_init))
+
+static void iup_gtk_virtual_list_model_init(IupGtkVirtualListModel *model)
+{
+  model->stamp = g_random_int();
+}
+
+static void iup_gtk_virtual_list_model_class_init(IupGtkVirtualListModelClass *klass)
+{
+  (void)klass;
+}
+
+static GtkTreeModelFlags iup_gtk_virtual_list_model_get_flags(GtkTreeModel *tree_model)
+{
+  (void)tree_model;
+  return GTK_TREE_MODEL_LIST_ONLY;
+}
+
+static gint iup_gtk_virtual_list_model_get_n_columns(GtkTreeModel *tree_model)
+{
+  (void)tree_model;
+  return IUPGTK_LIST_LAST_DATA;  /* IMAGE + TEXT columns */
+}
+
+static GType iup_gtk_virtual_list_model_get_column_type(GtkTreeModel *tree_model, gint index)
+{
+  (void)tree_model;
+  if (index == IUPGTK_LIST_IMAGE)
+    return GDK_TYPE_PIXBUF;
+  return G_TYPE_STRING;
+}
+
+static gboolean iup_gtk_virtual_list_model_get_iter(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreePath *path)
+{
+  IupGtkVirtualListModel *model = IUP_GTK_VIRTUAL_LIST_MODEL(tree_model);
+  gint *indices;
+  gint depth, row;
+
+  indices = gtk_tree_path_get_indices(path);
+  depth = gtk_tree_path_get_depth(path);
+
+  if (depth != 1)
+    return FALSE;
+
+  row = indices[0];
+  if (row < 0 || row >= model->count)
+    return FALSE;
+
+  iter->stamp = model->stamp;
+  iter->user_data = GINT_TO_POINTER(row);
+  iter->user_data2 = NULL;
+  iter->user_data3 = NULL;
+
+  return TRUE;
+}
+
+static GtkTreePath *iup_gtk_virtual_list_model_get_path(GtkTreeModel *tree_model, GtkTreeIter *iter)
+{
+  IupGtkVirtualListModel *model = IUP_GTK_VIRTUAL_LIST_MODEL(tree_model);
+
+  if (iter->stamp != model->stamp)
+    return NULL;
+
+  gint row = GPOINTER_TO_INT(iter->user_data);
+  return gtk_tree_path_new_from_indices(row, -1);
+}
+
+static void iup_gtk_virtual_list_model_get_value(GtkTreeModel *tree_model, GtkTreeIter *iter, gint column, GValue *value)
+{
+  IupGtkVirtualListModel *model = IUP_GTK_VIRTUAL_LIST_MODEL(tree_model);
+  gint row;
+  char *item_value;
+
+  if (column == IUPGTK_LIST_IMAGE)
+  {
+    g_value_init(value, GDK_TYPE_PIXBUF);
+
+    if (iter->stamp != model->stamp)
+    {
+      g_value_set_object(value, NULL);
+      return;
+    }
+
+    row = GPOINTER_TO_INT(iter->user_data);
+    if (row < 0 || row >= model->count)
+    {
+      g_value_set_object(value, NULL);
+      return;
+    }
+
+    /* Query image via IMAGE_CB (pos is 1-based) */
+    if (model->ih->data->show_image)
+    {
+      char* image_name = iupListGetItemImageCb(model->ih, row + 1);
+      if (image_name)
+      {
+        GdkPixbuf* pixImage = (GdkPixbuf*)iupImageGetImage(image_name, model->ih, 0, NULL);
+        if (pixImage)
+        {
+          /* Scale image down if needed to fit item height */
+          int charheight;
+          iupdrvFontGetCharSize(model->ih, NULL, &charheight);
+          int available_height = charheight + 2 * model->ih->data->spacing;
+          int img_height = gdk_pixbuf_get_height(pixImage);
+          int img_width = gdk_pixbuf_get_width(pixImage);
+
+          if (model->ih->data->fit_image && img_height > available_height)
+          {
+            int scaled_width = (img_width * available_height) / img_height;
+            GdkPixbuf* scaled = gdk_pixbuf_scale_simple(pixImage, scaled_width, available_height, GDK_INTERP_BILINEAR);
+            g_value_set_object(value, scaled);
+            g_object_unref(scaled);
+          }
+          else
+          {
+            g_value_set_object(value, pixImage);
+          }
+          return;
+        }
+      }
+    }
+    g_value_set_object(value, NULL);
+    return;
+  }
+
+  g_value_init(value, G_TYPE_STRING);
+
+  if (iter->stamp != model->stamp)
+  {
+    g_value_set_string(value, "");
+    return;
+  }
+
+  row = GPOINTER_TO_INT(iter->user_data);
+  if (row < 0 || row >= model->count)
+  {
+    g_value_set_string(value, "");
+    return;
+  }
+
+  /* Query data via VALUE_CB (pos is 1-based for IUP) */
+  item_value = iupListGetItemValueCb(model->ih, row + 1);
+  g_value_set_string(value, item_value ? item_value : "");
+}
+
+static gboolean iup_gtk_virtual_list_model_iter_next(GtkTreeModel *tree_model, GtkTreeIter *iter)
+{
+  IupGtkVirtualListModel *model = IUP_GTK_VIRTUAL_LIST_MODEL(tree_model);
+  gint row;
+
+  if (iter->stamp != model->stamp)
+    return FALSE;
+
+  row = GPOINTER_TO_INT(iter->user_data);
+  row++;
+
+  if (row >= model->count)
+    return FALSE;
+
+  iter->user_data = GINT_TO_POINTER(row);
+  return TRUE;
+}
+
+static gboolean iup_gtk_virtual_list_model_iter_children(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent)
+{
+  IupGtkVirtualListModel *model = IUP_GTK_VIRTUAL_LIST_MODEL(tree_model);
+
+  if (parent != NULL)
+    return FALSE;
+
+  if (model->count == 0)
+    return FALSE;
+
+  iter->stamp = model->stamp;
+  iter->user_data = GINT_TO_POINTER(0);
+  iter->user_data2 = NULL;
+  iter->user_data3 = NULL;
+  return TRUE;
+}
+
+static gboolean iup_gtk_virtual_list_model_iter_has_child(GtkTreeModel *tree_model, GtkTreeIter *iter)
+{
+  (void)tree_model;
+  (void)iter;
+  return FALSE;
+}
+
+static gint iup_gtk_virtual_list_model_iter_n_children(GtkTreeModel *tree_model, GtkTreeIter *iter)
+{
+  IupGtkVirtualListModel *model = IUP_GTK_VIRTUAL_LIST_MODEL(tree_model);
+
+  if (iter == NULL)
+    return model->count;
+
+  return 0;
+}
+
+static gboolean iup_gtk_virtual_list_model_iter_nth_child(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, gint n)
+{
+  IupGtkVirtualListModel *model = IUP_GTK_VIRTUAL_LIST_MODEL(tree_model);
+
+  if (parent != NULL)
+    return FALSE;
+
+  if (n < 0 || n >= model->count)
+    return FALSE;
+
+  iter->stamp = model->stamp;
+  iter->user_data = GINT_TO_POINTER(n);
+  iter->user_data2 = NULL;
+  iter->user_data3 = NULL;
+  return TRUE;
+}
+
+static gboolean iup_gtk_virtual_list_model_iter_parent(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *child)
+{
+  (void)tree_model;
+  (void)iter;
+  (void)child;
+  return FALSE;
+}
+
+static void iup_gtk_virtual_list_model_tree_model_init(GtkTreeModelIface *iface)
+{
+  iface->get_flags = iup_gtk_virtual_list_model_get_flags;
+  iface->get_n_columns = iup_gtk_virtual_list_model_get_n_columns;
+  iface->get_column_type = iup_gtk_virtual_list_model_get_column_type;
+  iface->get_iter = iup_gtk_virtual_list_model_get_iter;
+  iface->get_path = iup_gtk_virtual_list_model_get_path;
+  iface->get_value = iup_gtk_virtual_list_model_get_value;
+  iface->iter_next = iup_gtk_virtual_list_model_iter_next;
+  iface->iter_children = iup_gtk_virtual_list_model_iter_children;
+  iface->iter_has_child = iup_gtk_virtual_list_model_iter_has_child;
+  iface->iter_n_children = iup_gtk_virtual_list_model_iter_n_children;
+  iface->iter_nth_child = iup_gtk_virtual_list_model_iter_nth_child;
+  iface->iter_parent = iup_gtk_virtual_list_model_iter_parent;
+}
+
+static IupGtkVirtualListModel *iup_gtk_virtual_list_model_new(Ihandle *ih)
+{
+  IupGtkVirtualListModel *model = g_object_new(IUP_TYPE_GTK_VIRTUAL_LIST_MODEL, NULL);
+  model->ih = ih;
+  model->count = ih->data->item_count;  /* Use count set before mapping */
+  return model;
+}
+
+/* Notify the view that model item count has changed. */
+static void iup_gtk_virtual_list_model_notify_count_changed(IupGtkVirtualListModel *model, Ihandle* ih, int new_count)
+{
+  GtkTreeView* tree_view;
+
+  if (!ih->handle || !GTK_IS_TREE_VIEW(ih->handle))
+  {
+    /* Not mapped yet, just update count and stamp */
+    model->count = new_count;
+    model->stamp = g_random_int();
+    return;
+  }
+
+  tree_view = GTK_TREE_VIEW(ih->handle);
+
+  /* Detach model, model->count still has old value so GTK can unref correctly */
+  gtk_tree_view_set_model(tree_view, NULL);
+
+  /* Now set new count and invalidate iterators */
+  model->count = new_count;
+  model->stamp = g_random_int();
+
+  /* Reattach model, GTK will build tree with new count */
+  gtk_tree_view_set_model(tree_view, GTK_TREE_MODEL(model));
+}
+
+/* Cell data function for virtual mode, called only for visible rows */
+static void gtkListVirtualCellDataFunc(GtkTreeViewColumn* column, GtkCellRenderer* renderer,
+                                       GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer user_data)
+{
+  Ihandle* ih = (Ihandle*)user_data;
+  gint row;
+  char* text;
+
+  (void)column;
+  (void)tree_model;
+
+  row = GPOINTER_TO_INT(iter->user_data);
+  text = iupListGetItemValueCb(ih, row + 1);  /* 1-based for IUP */
+  g_object_set(renderer, "text", text ? text : "", NULL);
+}
+
+/* Cached measurement for list item space */
+static int iupgtk_list_item_space = -1;
+static int iupgtk_list_row_height = -1;
+
+static void iupgtkListMeasureItemMetrics(void)
+{
+  if (iupgtk_list_item_space < 0)
+  {
+    GtkWidget *temp_window = gtk_offscreen_window_new();
+    GtkListStore *temp_store = gtk_list_store_new(1, G_TYPE_STRING);
+    GtkWidget *temp_tree = gtk_tree_view_new_with_model(GTK_TREE_MODEL(temp_store));
+    GtkCellRenderer *renderer = gtk_cell_renderer_text_new();
+    GtkTreeViewColumn *column = gtk_tree_view_column_new_with_attributes("", renderer, "text", 0, NULL);
+    GtkTreeIter iter;
+    int char_height;
+    PangoContext *context;
+    PangoLayout *layout;
+    int row1_y, row2_y;
+
+    g_object_set(G_OBJECT(renderer), "xpad", 0, NULL);
+    g_object_set(G_OBJECT(renderer), "ypad", 0, NULL);
+
+    gtk_tree_view_append_column(GTK_TREE_VIEW(temp_tree), column);
+
+    gtk_list_store_append(temp_store, &iter);
+    gtk_list_store_set(temp_store, &iter, 0, "X", -1);
+    gtk_list_store_append(temp_store, &iter);
+    gtk_list_store_set(temp_store, &iter, 0, "X", -1);
+
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_tree);
+    gtk_widget_show_all(temp_window);
+
+    /* Measure actual row stride by comparing Y positions of row 0 and row 1 */
+    {
+      GtkTreePath *path0 = gtk_tree_path_new_from_string("0");
+      GtkTreePath *path1 = gtk_tree_path_new_from_string("1");
+      GdkRectangle rect0, rect1;
+
+      gtk_tree_view_get_background_area(GTK_TREE_VIEW(temp_tree), path0, column, &rect0);
+      gtk_tree_view_get_background_area(GTK_TREE_VIEW(temp_tree), path1, column, &rect1);
+
+      row1_y = rect0.y;
+      row2_y = rect1.y;
+      iupgtk_list_row_height = rect1.y - rect0.y;
+
+      gtk_tree_path_free(path0);
+      gtk_tree_path_free(path1);
+    }
+
+    context = gtk_widget_get_pango_context(temp_tree);
+    layout = pango_layout_new(context);
+    pango_layout_set_text(layout, "X", -1);
+    pango_layout_get_pixel_size(layout, NULL, &char_height);
+    g_object_unref(layout);
+
+    /* item_space = actual_row_height - char_height */
+    iupgtk_list_item_space = iupgtk_list_row_height - char_height;
+    if (iupgtk_list_item_space < 0) iupgtk_list_item_space = 2;
+
+    g_object_unref(temp_store);
+    gtk_widget_destroy(temp_window);
+  }
+}
+
 void iupdrvListAddItemSpace(Ihandle* ih, int *h)
 {
   (void)ih;
-  /* FROM:
-    gtk_tree_view_column_cell_get_size
-      height = text_height + 2*focus_line_width;
-    gtk_widget_style_get(ih->handle, "focus-line-width", &focus_line_width, NULL);
-      returns always 1
-  */
-  *h += 2;
+  iupgtkListMeasureItemMetrics();
+  *h += iupgtk_list_item_space;
 }
 
 void iupdrvListAddBorders(Ihandle* ih, int *x, int *y)
 {
   /* LAYOUT_DECORATION_ESTIMATE */
-  int border_size = 2 * 5;
-  (*x) += border_size;
-  (*y) += border_size;
+  static int dropdown_button_width = -1;
+  static int dropdown_border_y = -1;
+  static int dropdown_editbox_border_x = -1;
+  static int dropdown_editbox_border_y = -1;
+  static int editbox_border_y = -1;
+  static int scrolled_window_border = -1;
+  int x_before = *x;
+  int y_before = *y;
 
+  /* Measure scrolled_window border for plain lists */
+  if (scrolled_window_border == -1)
+  {
+    GtkWidget *temp_window = gtk_offscreen_window_new();
+    GtkWidget *temp_scrolled = gtk_scrolled_window_new(NULL, NULL);
+    GtkWidget *temp_label = gtk_label_new("X");
+    GtkRequisition label_min, label_nat;
+    GtkRequisition sw_min, sw_nat;
+
+    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(temp_scrolled), GTK_POLICY_NEVER, GTK_POLICY_NEVER);
+    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(temp_scrolled), GTK_SHADOW_IN);
+
+    gtk_container_add(GTK_CONTAINER(temp_scrolled), temp_label);
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_scrolled);
+    gtk_widget_show_all(temp_window);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+    gtk_widget_get_preferred_size(temp_label, &label_min, &label_nat);
+    gtk_widget_get_preferred_size(temp_scrolled, &sw_min, &sw_nat);
+
+    /* Border is the difference between scrolled_window and its child */
+    scrolled_window_border = sw_nat.height - label_nat.height;
+    if (scrolled_window_border < 0) scrolled_window_border = 10; /* fallback to safe default */
+#else
+    /* GTK2: Use size_request instead */
+    gtk_widget_size_request(temp_label, &label_nat);
+    gtk_widget_size_request(temp_scrolled, &sw_nat);
+
+    scrolled_window_border = sw_nat.height - label_nat.height;
+    if (scrolled_window_border < 0) scrolled_window_border = 10;
+#endif
+
+    gtk_widget_destroy(temp_window);
+  }
+
+  /* Use measured border for Y, keep 10px for X (horizontal padding) */
+  (*x) += 10;
+  (*y) += scrolled_window_border;
+
+  /* Measure plain GtkEntry for non-dropdown editbox list */
+  if (editbox_border_y == -1)
+  {
+    GtkWidget *temp_window = gtk_offscreen_window_new();
+    GtkWidget *temp_entry = gtk_entry_new();
+
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_entry);
+    gtk_widget_show_all(temp_window);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+    {
+      int entry_nat_h;
+      gtk_widget_get_preferred_height(temp_entry, NULL, &entry_nat_h);
+      editbox_border_y = entry_nat_h;
+    }
+#else
+    {
+      GtkRequisition requisition;
+      gtk_widget_size_request(temp_entry, &requisition);
+      editbox_border_y = requisition.height;
+    }
+#endif
+
+    gtk_widget_destroy(temp_window);
+  }
+
   if (ih->data->is_dropdown)
   {
-#ifdef HILDON
-    (*x) += 9; /* extra space for the dropdown button */
+    if (dropdown_button_width == -1)
+    {
+      /* Measure dropdown borders dynamically from temporary widgets */
+      GtkWidget *temp_window = gtk_offscreen_window_new();
+      GtkListStore *temp_store = gtk_list_store_new(1, G_TYPE_STRING);
+      GtkTreeIter iter;
+      gtk_list_store_append(temp_store, &iter);
+      gtk_list_store_set(temp_store, &iter, 0, "X", -1);
+
+      /* Measure regular dropdown (no editbox) */
+      GtkWidget* temp_combo = gtk_combo_box_new_with_model(GTK_TREE_MODEL(temp_store));
+      GtkRequisition combo_min, combo_nat;
+      GtkCellRenderer *renderer = gtk_cell_renderer_text_new();
+      gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(temp_combo), renderer, TRUE);
+      gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(temp_combo), renderer, "text", 0, NULL);
+
+      gtk_container_add(GTK_CONTAINER(temp_window), temp_combo);
+      gtk_widget_show_all(temp_window);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+      gtk_widget_get_preferred_size(temp_combo, &combo_min, &combo_nat);
 #else
-    (*x) += 5; /* extra space for the dropdown button */
+      /* GTK2: Use size_request */
+      gtk_widget_size_request(temp_combo, &combo_nat);
 #endif
 
+      /* single char width ~ button width + borders */
+      int char_width = 10;  /* Approximate single char width */
+      dropdown_button_width = (combo_nat.width > char_width) ? combo_nat.width - char_width : 15;
+      if (dropdown_button_width < 15) dropdown_button_width = 15;  /* Minimum arrow size */
+
+      /* Vertical border, measure actual difference */
+      int text_height = 16;
+      dropdown_border_y = combo_nat.height - text_height;
+      if (dropdown_border_y < 0) dropdown_border_y = 6;  /* fallback */
+
+      gtk_widget_destroy(temp_window);
+
+      /* Measure dropdown with editbox */
+      temp_window = gtk_offscreen_window_new();
+#if GTK_CHECK_VERSION(2, 24, 0)
+      GtkWidget* temp_combo_entry = gtk_combo_box_new_with_model_and_entry(GTK_TREE_MODEL(temp_store));
+      gtk_combo_box_set_entry_text_column((GtkComboBox*)temp_combo_entry, 0);
+#else
+      GtkWidget* temp_combo_entry = gtk_combo_box_entry_new_with_model(GTK_TREE_MODEL(temp_store), 0);
+#endif
+      GtkRequisition combo_entry_min, combo_entry_nat;
+
+      gtk_container_add(GTK_CONTAINER(temp_window), temp_combo_entry);
+      gtk_widget_show_all(temp_window);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+      gtk_widget_get_preferred_size(temp_combo_entry, &combo_entry_min, &combo_entry_nat);
+#else
+      /* GTK2: Use size_request */
+      gtk_widget_size_request(temp_combo_entry, &combo_entry_nat);
+#endif
+
+      /* Extra space needed for editbox combo */
+      dropdown_editbox_border_x = (combo_entry_nat.width > char_width + dropdown_button_width) ?
+                                   (combo_entry_nat.width - char_width) - dropdown_button_width : 5;
+      if (dropdown_editbox_border_x < 5) dropdown_editbox_border_x = 5;
+
+      /* Editbox combo vertical border - measure actual difference */
+      dropdown_editbox_border_y = combo_entry_nat.height - text_height;
+      if (dropdown_editbox_border_y < 0) dropdown_editbox_border_y = 6;  /* fallback */
+
+      gtk_widget_destroy(temp_window);
+      g_object_unref(temp_store);
+    }
+
+    /* Dropdown doesn't use scrolled_window, so remove that border and add dropdown-specific border */
+    (*y) -= scrolled_window_border;
+
+    (*x) += dropdown_button_width;
+
     if (ih->data->has_editbox)
-      (*x) += 5; /* another extra space for the dropdown button */
+    {
+      (*x) += dropdown_editbox_border_x; /* measured extra space for editbox combo */
+      (*y) += dropdown_editbox_border_y; /* measured vertical border for editbox combo */
+    }
     else
     {
-      (*y) += 4; /* extra padding space */
-      (*x) += 4; /* extra padding space */
+      (*y) += dropdown_border_y; /* measured vertical border */
+      (*x) += 4; /* extra horizontal padding space */
     }
   }
   else
   {
+    int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+
     if (ih->data->has_editbox)
-      (*y) += 2*3; /* internal border between editbox and list */
+    {
+      /* For EDITBOX: VISIBLELINES includes the entry line */
+      if (visiblelines > 0)
+      {
+        /* Remove one item's height since entry takes one "line" of VISIBLELINES */
+        int char_width, char_height;
+        iupdrvFontGetCharSize(ih, &char_width, &char_height);
+        int item_height = char_height;
+        iupdrvListAddItemSpace(ih, &item_height);
+        (*y) -= item_height;
+      }
+
+      (*y) += editbox_border_y;
+      if (ih->data->sb && !visiblelines)
+        (*y) += iupdrvGetScrollbarSize();
+    }
+    else if (ih->data->sb && !visiblelines)
+    {
+      (*y) += iupdrvGetScrollbarSize();
+    }
   }
 }
 
@@ -326,9 +851,15 @@
     GtkCellRenderer* renderer = (GtkCellRenderer*)iupAttribGet(ih, "_IUPGTK_RENDERER");
     if (renderer)
     {
+#if GTK_CHECK_VERSION(3, 4, 0)
+      GdkRGBA rgba;
+      iupgdkRGBASet(&rgba, r, g, b);
+      g_object_set(G_OBJECT(renderer), "cell-background-rgba", &rgba, NULL);
+#else
       GdkColor color;
       iupgdkColorSetRGB(&color, r, g, b);
       g_object_set(G_OBJECT(renderer), "cell-background-gdk", &color, NULL);
+#endif
     }
   }
 
@@ -355,9 +886,15 @@
     GtkCellRenderer* renderer = (GtkCellRenderer*)iupAttribGet(ih, "_IUPGTK_RENDERER");
     if (renderer)
     {
+#if GTK_CHECK_VERSION(3, 4, 0)
+      GdkRGBA rgba;
+      iupgdkRGBASet(&rgba, r, g, b);
+      g_object_set(G_OBJECT(renderer), "foreground-rgba", &rgba, NULL);
+#else
       GdkColor color;
       iupgdkColorSetRGB(&color, r, g, b);
       g_object_set(G_OBJECT(renderer), "foreground-gdk", &color, NULL);
+#endif
     }
   }
 
@@ -917,7 +1454,33 @@
   if (!ih->data->show_image || !gtk_tree_model_iter_nth_child(model, &iter, NULL, pos))
     return 0;
 
-  gtk_list_store_set(GTK_LIST_STORE(model), &iter, IUPGTK_LIST_IMAGE, pixImage, -1);
+  /* Scale image down if needed to fit font height */
+  if (pixImage)
+  {
+    int charheight;
+    iupdrvFontGetCharSize(ih, NULL, &charheight);
+    int available_height = charheight + 2 * ih->data->spacing;
+    int img_height = gdk_pixbuf_get_height(pixImage);
+    int img_width = gdk_pixbuf_get_width(pixImage);
+
+    if (ih->data->fit_image && img_height > available_height)
+    {
+      /* Scale down proportionally to fit available height */
+      int scaled_width = (img_width * available_height) / img_height;
+      GdkPixbuf* scaled = gdk_pixbuf_scale_simple(pixImage, scaled_width, available_height, GDK_INTERP_BILINEAR);
+      gtk_list_store_set(GTK_LIST_STORE(model), &iter, IUPGTK_LIST_IMAGE, scaled, -1);
+      g_object_unref(scaled);
+    }
+    else
+    {
+      gtk_list_store_set(GTK_LIST_STORE(model), &iter, IUPGTK_LIST_IMAGE, pixImage, -1);
+    }
+  }
+  else
+  {
+    gtk_list_store_set(GTK_LIST_STORE(model), &iter, IUPGTK_LIST_IMAGE, NULL, -1);
+  }
+
   return 0;
 }
 
@@ -960,6 +1523,18 @@
   return 0;
 }
 
+void iupdrvListSetItemCount(Ihandle* ih, int count)
+{
+  IupGtkVirtualListModel* model;
+
+  if (!ih->data->is_virtual)
+    return;
+
+  model = (IupGtkVirtualListModel*)iupAttribGet(ih, "_IUPGTK_VIRTUAL_MODEL");
+  if (model)
+    iup_gtk_virtual_list_model_notify_count_changed(model, ih, count);
+}
+
 /*********************************************************************************/
 
 static void gtkListDragDataReceived(GtkWidget *widget, GdkDragContext *context, gint x, gint y, 
@@ -1416,7 +1991,36 @@
 
 /*********************************************************************************/
 
+/* Callback to track scrolled window size allocation and clamp if needed */
+static void gtkListScrolledWindowSizeAllocate(GtkWidget* widget, GdkRectangle* allocation, gpointer user_data)
+{
+  Ihandle* ih = (Ihandle*)user_data;
+  int sw_req_w, sw_req_h;
 
+  gtk_widget_get_size_request(widget, &sw_req_w, &sw_req_h);
+
+  /* If VISIBLELINES is set and we have a size_request height, clamp allocation to it */
+  int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+  if (visiblelines > 0 && sw_req_h > 0 && allocation->height > sw_req_h)
+  {
+    /* Create a new clamped allocation and apply it */
+    GtkAllocation clamped = *allocation;
+    clamped.height = sw_req_h;
+
+    /* Block this signal handler to prevent recursion */
+    g_signal_handlers_block_by_func(widget, gtkListScrolledWindowSizeAllocate, user_data);
+
+    /* Apply the clamped allocation - this will allocate children correctly */
+    gtk_widget_size_allocate(widget, &clamped);
+
+    /* Unblock the signal handler */
+    g_signal_handlers_unblock_by_func(widget, gtkListScrolledWindowSizeAllocate, user_data);
+
+    /* Update the allocation parameter to reflect what we actually did */
+    *allocation = clamped;
+  }
+}
+
 static int gtkListMapMethod(Ihandle* ih)
 {
   GtkScrolledWindow* scrolled_window = NULL;
@@ -1464,7 +2068,6 @@
 #endif
       entry = gtk_bin_get_child(GTK_BIN(ih->handle));
       iupAttribSet(ih, "_IUPGTK_ENTRY", (char*)entry);
-      iupgtkClearSizeStyleCSS(entry);
 
       g_signal_connect(G_OBJECT(entry), "focus-in-event",     G_CALLBACK(iupgtkFocusInOutEvent), ih);
       g_signal_connect(G_OBJECT(entry), "focus-out-event",    G_CALLBACK(iupgtkFocusInOutEvent), ih);
@@ -1530,11 +2133,19 @@
       if (!iupAttribGetBoolean(ih, "CANFOCUS"))
       {
         iupgtkSetCanFocus(ih->handle, 0);
-        gtk_combo_box_set_focus_on_click((GtkComboBox*)ih->handle, FALSE);
+#if GTK_CHECK_VERSION(3, 20, 0)
+        gtk_widget_set_focus_on_click(ih->handle, FALSE);
+#else
+        gtk_combo_box_set_focus_on_click(GTK_COMBO_BOX(ih->handle), FALSE);
+#endif
       }
       else
       {
-        gtk_combo_box_set_focus_on_click((GtkComboBox*)ih->handle, TRUE);
+#if GTK_CHECK_VERSION(3, 20, 0)
+        gtk_widget_set_focus_on_click(ih->handle, TRUE);
+#else
+        gtk_combo_box_set_focus_on_click(GTK_COMBO_BOX(ih->handle), TRUE);
+#endif
         iupgtkSetCanFocus(ih->handle, 1);
       }
     }
@@ -1558,19 +2169,40 @@
     GtkTreeSelection* selection;
     GtkTreeViewColumn *column;
     GtkPolicyType scrollbar_policy;
+    GtkTreeModel* model;
 
-    ih->handle = gtk_tree_view_new_with_model(GTK_TREE_MODEL(store));
-    g_object_unref(store);
+    /* Virtual mode: use custom virtual model instead of GtkListStore */
+    if (ih->data->is_virtual)
+    {
+      IupGtkVirtualListModel* virtual_model = iup_gtk_virtual_list_model_new(ih);
+      model = GTK_TREE_MODEL(virtual_model);
+      iupAttribSet(ih, "_IUPGTK_VIRTUAL_MODEL", (char*)virtual_model);
+      g_object_unref(store);  /* Don't need the regular store */
+    }
+    else
+    {
+      model = GTK_TREE_MODEL(store);
+    }
 
+    ih->handle = gtk_tree_view_new_with_model(model);
+    if (!ih->data->is_virtual)
+      g_object_unref(store);
+
     if (!ih->handle)
       return IUP_ERROR;
 
     scrolled_window = (GtkScrolledWindow*)gtk_scrolled_window_new(NULL, NULL);
 
+    /* Track scrolled window size allocation for VISIBLELINES clamping */
+    g_signal_connect(G_OBJECT(scrolled_window), "size-allocate", G_CALLBACK(gtkListScrolledWindowSizeAllocate), ih);
+
     if (ih->data->has_editbox)
     {
 #if GTK_CHECK_VERSION(3, 0, 0)
       GtkBox* vbox = (GtkBox*)gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+      gtk_box_set_homogeneous(vbox, FALSE);
+      gtk_widget_set_vexpand((GtkWidget*)vbox, FALSE);
+      gtk_widget_set_hexpand((GtkWidget*)vbox, FALSE);
 #else
       GtkBox* vbox = (GtkBox*)gtk_vbox_new(FALSE, 0);
 #endif
@@ -1577,11 +2209,20 @@
 
       GtkWidget *entry = gtk_entry_new();
       gtk_widget_show(entry);
+#if GTK_CHECK_VERSION(3, 0, 0)
+      gtk_widget_set_vexpand(entry, FALSE);
+      gtk_widget_set_hexpand(entry, FALSE);
+#endif
+
       gtk_box_pack_start(vbox, entry, FALSE, FALSE, 0);
       iupAttribSet(ih, "_IUPGTK_ENTRY", (char*)entry);
-      iupgtkClearSizeStyleCSS(entry);
 
       gtk_widget_show((GtkWidget*)vbox);
+
+      /* Pack scrolled_window into vbox */
+#if GTK_CHECK_VERSION(3, 0, 0)
+      gtk_widget_set_vexpand((GtkWidget*)scrolled_window, TRUE);
+#endif
       gtk_box_pack_end(vbox, (GtkWidget*)scrolled_window, TRUE, TRUE, 0);
       iupAttribSet(ih, "_IUP_EXTRAPARENT", (char*)vbox);
       iupAttribSet(ih, "_IUPGTK_SCROLLED_WINDOW", (char*)scrolled_window);
@@ -1632,7 +2273,22 @@
 
     renderer = gtk_cell_renderer_text_new();
     gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(column), renderer, TRUE);
-    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer, "text", IUPGTK_LIST_TEXT, NULL);
+    if (ih->data->is_virtual)
+    {
+      /* Virtual mode: use cell data func instead of attributes to avoid GTK querying all rows */
+      gtk_tree_view_column_set_cell_data_func(column, renderer, gtkListVirtualCellDataFunc, ih, NULL);
+
+      /* Use FIXED sizing to prevent GTK from measuring all rows for column width */
+      gtk_tree_view_column_set_sizing(column, GTK_TREE_VIEW_COLUMN_FIXED);
+
+      /* Enable fixed height mode, requires all columns to be FIXED type.
+         This prevents GTK from iterating all rows during validation. */
+      gtk_tree_view_set_fixed_height_mode(GTK_TREE_VIEW(ih->handle), TRUE);
+    }
+    else
+    {
+      gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer, "text", IUPGTK_LIST_TEXT, NULL);
+    }
     iupAttribSet(ih, "_IUPGTK_RENDERER", (char*)renderer);
     g_object_set(G_OBJECT(renderer), "xpad", 0, NULL);
     g_object_set(G_OBJECT(renderer), "ypad", 0, NULL);
@@ -1643,10 +2299,18 @@
 
     gtk_container_add((GtkContainer*)scrolled_window, ih->handle);
     gtk_widget_show((GtkWidget*)scrolled_window);
-    gtk_scrolled_window_set_shadow_type(scrolled_window, GTK_SHADOW_IN); 
+    gtk_scrolled_window_set_shadow_type(scrolled_window, GTK_SHADOW_IN);
 
-    if (ih->data->sb)
+    /* VISIBLELINES requires AUTOMATIC policy for min/max_content_height to work */
+    int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+
+    if (visiblelines > 0)
     {
+      /* GTK3 only applies min/max_content_height when policy is AUTOMATIC (not NEVER or ALWAYS) */
+      scrollbar_policy = GTK_POLICY_AUTOMATIC;
+    }
+    else if (ih->data->sb)
+    {
       if (iupAttribGetBoolean(ih, "AUTOHIDE"))
         scrollbar_policy = GTK_POLICY_AUTOMATIC;
       else
@@ -1653,10 +2317,37 @@
         scrollbar_policy = GTK_POLICY_ALWAYS;
     }
     else
+    {
       scrollbar_policy = GTK_POLICY_NEVER;
+    }
 
     gtk_scrolled_window_set_policy(scrolled_window, scrollbar_policy, scrollbar_policy);
 
+    /* Mark container with VISIBLELINES flag so iupgtkSetPosSize can set size correctly */
+    {
+      int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+      if (visiblelines > 0)
+      {
+        GtkWidget* container;
+
+        /* Get the container that IUP's layout will call iupgtkSetPosSize on */
+        container = (GtkWidget*)iupAttribGet(ih, "_IUP_EXTRAPARENT");
+        if (!container)
+          container = (GtkWidget*)scrolled_window;
+
+        /* Mark container so iupgtkSetPosSize will use IUP's calculated height directly */
+        g_object_set_data(G_OBJECT(container), "iup-visiblelines-set", (gpointer)"1");
+
+        /* For editbox lists, also mark the scrolled_window */
+        if (ih->data->has_editbox)
+        {
+          GtkWidget* sw = (GtkWidget*)iupAttribGet(ih, "_IUPGTK_SCROLLED_WINDOW");
+          if (sw)
+            g_object_set_data(G_OBJECT(sw), "iup-visiblelines-scrolled", (gpointer)"1");
+        }
+      }
+    }
+
     selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(ih->handle));
     if (!ih->data->has_editbox && ih->data->is_multiple)
     {
@@ -1675,14 +2366,16 @@
     g_signal_connect(G_OBJECT(ih->handle), "button-release-event", G_CALLBACK(iupgtkButtonEvent), ih);
   }
 
-  iupgtkClearSizeStyleCSS(ih->handle);
-
   /* Enable internal drag and drop support */
   if(ih->data->show_dragdrop && !ih->data->is_dropdown && !ih->data->is_multiple)
     gtkListEnableDragDrop(ih);
 
-  if (iupAttribGetBoolean(ih, "SORT"))
-    gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store), IUPGTK_LIST_TEXT, GTK_SORT_ASCENDING);
+  if (iupAttribGetBoolean(ih, "SORT") && !ih->data->is_virtual)
+  {
+    GtkTreeModel* tree_model = gtkListGetModel(ih);
+    if (GTK_IS_LIST_STORE(tree_model))
+      gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(tree_model), IUPGTK_LIST_TEXT, GTK_SORT_ASCENDING);
+  }
 
   /* add to the parent, all GTK controls must call this. */
   iupgtkAddToParent(ih);
@@ -1697,7 +2390,9 @@
 
   IupSetCallback(ih, "_IUP_XY2POS_CB", (Icallback)gtkListConvertXYToPos);
 
-  iupListSetInitialItems(ih);
+  /* Don't populate items in virtual mode */
+  if (!ih->data->is_virtual)
+    iupListSetInitialItems(ih);
 
   /* update a mnemonic in a label if necessary */
   iupgtkUpdateMnemonic(ih);
@@ -1705,10 +2400,25 @@
   return IUP_NOERROR;
 }
 
+static void gtkListUnMapMethod(Ihandle* ih)
+{
+  /* For virtual mode, detach model before destruction to avoid expensive iteration */
+  if (ih->data->is_virtual && ih->handle && GTK_IS_TREE_VIEW(ih->handle))
+  {
+    IupGtkVirtualListModel* model = (IupGtkVirtualListModel*)iupAttribGet(ih, "_IUPGTK_VIRTUAL_MODEL");
+    if (model)
+      model->count = 0;  /* Set to 0 so GTK sees empty model during detach */
+    gtk_tree_view_set_model(GTK_TREE_VIEW(ih->handle), NULL);
+  }
+
+  iupdrvBaseUnMapMethod(ih);
+}
+
 void iupdrvListInitClass(Iclass* ic)
 {
   /* Driver Dependent Class functions */
   ic->Map = gtkListMapMethod;
+  ic->UnMap = gtkListUnMapMethod;
 
   /* Driver Dependent Attribute functions */
 
@@ -1747,7 +2457,7 @@
 
   /* Not Supported */
   iupClassRegisterAttribute(ic, "VISIBLEITEMS", NULL, NULL, IUPAF_SAMEASSYSTEM, "5", IUPAF_NOT_SUPPORTED);
-  /*OLD*/iupClassRegisterAttribute(ic, "VISIBLE_ITEMS", NULL, NULL, IUPAF_SAMEASSYSTEM, "5", IUPAF_NOT_SUPPORTED);
   iupClassRegisterAttribute(ic, "DROPEXPAND", NULL, NULL, IUPAF_SAMEASSYSTEM, "Yes", IUPAF_NOT_SUPPORTED | IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "AUTOREDRAW", NULL, NULL, IUPAF_SAMEASSYSTEM, "Yes", IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/gtk/iupgtk_loop.c
===================================================================
--- src/gtk/iupgtk_loop.c	(revision 5971)
+++ src/gtk/iupgtk_loop.c	(working copy)
@@ -58,10 +58,15 @@
 IUP_API void IupExitLoop(void)
 {
   char* exit_loop = IupGetGlobal("EXITLOOP");
-  if (gtk_main_level() > 1 || !exit_loop || iupStrBoolean(exit_loop))
+  int level = gtk_main_level();
+  /* Only call gtk_main_quit() if there's actually a main loop running.
+   * Check level > 0 first to avoid warning when no loop is active. */
+  if (level > 0 && (level > 1 || !exit_loop || iupStrBoolean(exit_loop)))
   {
-    if (gtk_main_iteration_do(FALSE) == FALSE)
-      gtk_main_quit();
+    /* Call gtk_main_quit() once - it will quit the current (innermost) level.
+     * The level doesn't change until the event loop actually processes this.
+     * For nested loops, each level will need its own quit call when appropriate. */
+    gtk_main_quit();
   }
 }
 
Index: src/gtk/iupgtk_menu.c
===================================================================
--- src/gtk/iupgtk_menu.c	(revision 5971)
+++ src/gtk/iupgtk_menu.c	(working copy)
@@ -4,7 +4,6 @@
  * See Copyright Notice in "iup.h"
  */
 
-#undef GTK_DISABLE_DEPRECATED  /* Since GTK 3.10 gtk_image_menu is deprecated. */
 #include <gtk/gtk.h>
 #include <gdk/gdkkeysyms.h>
 #if GTK_CHECK_VERSION(3, 0, 0)
@@ -80,6 +79,51 @@
 
 int iupdrvMenuPopup(Ihandle* ih, int x, int y)
 {
+#if GTK_CHECK_VERSION(3, 22, 0)
+  GdkRectangle rect;
+  GdkWindow* window;
+  GdkGravity rect_anchor = GDK_GRAVITY_NORTH_WEST;
+  GdkGravity menu_anchor = GDK_GRAVITY_NORTH_WEST;
+  char* value = iupAttribGet(ih, "POPUPALIGN");
+
+  rect.x = x;
+  rect.y = y;
+  rect.width = 1;
+  rect.height = 1;
+
+  if (value)
+  {
+    char value1[30], value2[30];
+    iupStrToStrStr(value, value1, value2, ':');
+
+    if (iupStrEqualNoCase(value1, "ARIGHT"))
+      menu_anchor = GDK_GRAVITY_NORTH_EAST;
+    else if (iupStrEqualNoCase(value1, "ACENTER"))
+      menu_anchor = GDK_GRAVITY_NORTH;
+
+    if (iupStrEqualNoCase(value2, "ABOTTOM"))
+    {
+      if (menu_anchor == GDK_GRAVITY_NORTH_EAST)
+        menu_anchor = GDK_GRAVITY_SOUTH_EAST;
+      else if (menu_anchor == GDK_GRAVITY_NORTH)
+        menu_anchor = GDK_GRAVITY_SOUTH;
+      else
+        menu_anchor = GDK_GRAVITY_SOUTH_WEST;
+    }
+    else if (iupStrEqualNoCase(value2, "ACENTER"))
+    {
+      if (menu_anchor == GDK_GRAVITY_NORTH_EAST)
+        menu_anchor = GDK_GRAVITY_EAST;
+      else if (menu_anchor == GDK_GRAVITY_NORTH)
+        menu_anchor = GDK_GRAVITY_CENTER;
+      else
+        menu_anchor = GDK_GRAVITY_WEST;
+    }
+  }
+
+  window = gdk_screen_get_root_window(gdk_screen_get_default());
+  gtk_menu_popup_at_rect((GtkMenu*)ih->handle, window, &rect, rect_anchor, menu_anchor, NULL);
+#else
   ImenuPos menupos;
   menupos.x = x;
   menupos.y = y;
@@ -86,6 +130,7 @@
   menupos.ih = ih;
   gtk_menu_popup((GtkMenu*)ih->handle, NULL, NULL, (GtkMenuPositionFunc)gtkMenuPositionFunc,
                  (gpointer)&menupos, 0, gtk_get_current_event_time());
+#endif
   gtk_main();
   return IUP_NOERROR;
 }
@@ -101,39 +146,136 @@
 #endif
 }
 
-/* TODO:
-GtkImageMenuItem has been deprecated since GTK+ 3.10. 
-If you want to display an icon in a menu item, 
-you should use GtkMenuItem and pack a GtkBox with a GtkImage and a GtkLabel instead. 
+/* GTK 3.10+ uses GtkMenuItem + GtkBox instead of deprecated GtkImageMenuItem */
 
-Furthermore, if you would like to display keyboard accelerator, 
-you must pack the accel label into the box using gtk_box_pack_end() 
-and align the label, otherwise the accelerator will not display correctly. 
+#if GTK_CHECK_VERSION(3, 10, 0)
 
-Example:
+/* Check if menu item has our custom image box structure */
+static int gtkItemHasImageBox(Ihandle* ih)
+{
+  GtkWidget* child = gtk_bin_get_child(GTK_BIN(ih->handle));
+  return (child && GTK_IS_BOX(child));
+}
 
-GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
-GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
-GtkWidget *label = gtk_accel_label_new ("Music");
-GtkWidget *menu_item = gtk_menu_item_new ();
-GtkAccelGroup *accel_group = gtk_accel_group_new ();
+/* Get the image widget from our box structure */
+static GtkWidget* gtkItemGetImageWidget(Ihandle* ih)
+{
+  GtkWidget* child = gtk_bin_get_child(GTK_BIN(ih->handle));
+  if (child && GTK_IS_BOX(child))
+  {
+    GList* children = gtk_container_get_children(GTK_CONTAINER(child));
+    GList* l;
+    GtkWidget* image = NULL;
+    for (l = children; l; l = l->next)
+    {
+      if (GTK_IS_IMAGE(l->data))
+      {
+        image = (GtkWidget*)l->data;
+        break;
+      }
+    }
+    g_list_free(children);
+    return image;
+  }
+  return NULL;
+}
 
-gtk_container_add (GTK_CONTAINER (box), icon);
+/* Get the label widget from menu item (handles both box and simple structures) */
+static GtkWidget* gtkItemGetLabelWidget(Ihandle* ih)
+{
+  GtkWidget* child = gtk_bin_get_child(GTK_BIN(ih->handle));
+  if (child && GTK_IS_BOX(child))
+  {
+    GList* children = gtk_container_get_children(GTK_CONTAINER(child));
+    GList* l;
+    GtkWidget* label = NULL;
+    for (l = children; l; l = l->next)
+    {
+      if (GTK_IS_LABEL(l->data))
+      {
+        label = (GtkWidget*)l->data;
+        break;
+      }
+    }
+    g_list_free(children);
+    return label;
+  }
+  else if (child && GTK_IS_LABEL(child))
+    return child;
+  return NULL;
+}
 
-gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
-gtk_label_set_xalign (GTK_LABEL (label), 0.0);
+/* Set/update/remove image in menu item with box structure */
+static void gtkItemSetImageWidget(Ihandle* ih, GdkPixbuf* pixbuf)
+{
+  GtkWidget* child = gtk_bin_get_child(GTK_BIN(ih->handle));
 
-gtk_widget_add_accelerator (menu_item, "activate", accel_group,
-GDK_KEY_m, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
-gtk_accel_label_set_accel_widget (GTK_ACCEL_LABEL (label), menu_item);
+  if (!pixbuf)
+  {
+    /* Remove image if present */
+    if (child && GTK_IS_BOX(child))
+    {
+      GtkWidget* image = gtkItemGetImageWidget(ih);
+      if (image)
+        gtk_widget_destroy(image);
+    }
+    return;
+  }
 
-gtk_box_pack_end (GTK_BOX (box), label, TRUE, TRUE, 0);
+  if (child && GTK_IS_BOX(child))
+  {
+    /* Box exists, update or add image */
+    GtkWidget* image = gtkItemGetImageWidget(ih);
+    if (image)
+    {
+      gtk_image_set_from_pixbuf(GTK_IMAGE(image), pixbuf);
+    }
+    else
+    {
+      image = gtk_image_new_from_pixbuf(pixbuf);
+      gtk_box_pack_start(GTK_BOX(child), image, FALSE, FALSE, 0);
+      gtk_box_reorder_child(GTK_BOX(child), image, 0);
+      gtk_widget_show(image);
+    }
+  }
+  else if (child && GTK_IS_LABEL(child))
+  {
+    /* Convert from simple label to box structure */
+    GtkWidget* box;
+    GtkWidget* image;
 
-gtk_container_add (GTK_CONTAINER (menu_item), box);
+    g_object_ref(child);
+    gtk_container_remove(GTK_CONTAINER(ih->handle), child);
 
-gtk_widget_show_all (menu_item);
-*/
+    box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
+    image = gtk_image_new_from_pixbuf(pixbuf);
 
+    gtk_box_pack_start(GTK_BOX(box), image, FALSE, FALSE, 0);
+    gtk_box_pack_end(GTK_BOX(box), child, TRUE, TRUE, 0);
+    g_object_unref(child);
+
+    gtk_container_add(GTK_CONTAINER(ih->handle), box);
+    gtk_widget_show_all(box);
+  }
+}
+
+/* Create a menu item with box structure for image support */
+static GtkWidget* gtkMenuItemNewWithImageSupport(void)
+{
+  GtkWidget* menu_item = gtk_menu_item_new();
+  GtkWidget* box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
+  GtkWidget* label = gtk_label_new("");
+
+  gtk_label_set_use_underline(GTK_LABEL(label), TRUE);
+  gtk_label_set_xalign(GTK_LABEL(label), 0.0);
+
+  gtk_box_pack_end(GTK_BOX(box), label, TRUE, TRUE, 0);
+  gtk_container_add(GTK_CONTAINER(menu_item), box);
+  gtk_widget_show_all(box);
+
+  return menu_item;
+}
+
 static void gtkItemUpdateImage(Ihandle* ih, const char* value, const char* image, const char* impress)
 {
   GdkPixbuf* pixbuf;
@@ -143,6 +285,20 @@
   else
     pixbuf = iupImageGetImage(impress, ih, 0, NULL);
 
+  gtkItemSetImageWidget(ih, pixbuf);
+}
+
+#else /* GTK < 3.10 - use GtkImageMenuItem */
+
+static void gtkItemUpdateImage(Ihandle* ih, const char* value, const char* image, const char* impress)
+{
+  GdkPixbuf* pixbuf;
+
+  if (!impress || !iupStrBoolean(value))
+    pixbuf = iupImageGetImage(image, ih, 0, NULL);
+  else
+    pixbuf = iupImageGetImage(impress, ih, 0, NULL);
+
   if (pixbuf)
   {
     GtkWidget* image_label = gtk_image_menu_item_get_image((GtkImageMenuItem*)ih->handle);
@@ -159,7 +315,9 @@
     gtk_image_menu_item_set_image((GtkImageMenuItem*)ih->handle, NULL);
 }
 
+#endif /* GTK_CHECK_VERSION(3, 10, 0) */
 
+
 /*******************************************************************************************/
 
 
@@ -214,7 +372,11 @@
     g_signal_handlers_unblock_by_func(G_OBJECT(ih->handle), G_CALLBACK(gtkItemActivate), ih);
   }
 
+#if GTK_CHECK_VERSION(3, 10, 0)
+  if (gtkItemHasImageBox(ih))
+#else
   if (GTK_IS_IMAGE_MENU_ITEM(ih->handle))
+#endif
   {
     if (iupAttribGetBoolean(ih, "AUTOTOGGLE"))
     {
@@ -228,8 +390,12 @@
   }
 
   cb = IupGetCallback(ih, "ACTION");
-  if (cb && cb(ih)==IUP_CLOSE)
-    IupExitLoop();
+  if (cb)
+  {
+    int result = cb(ih);
+    if (result == IUP_CLOSE)
+      IupExitLoop();
+  }
 
   (void)widget;
 }
@@ -333,7 +499,11 @@
 
 static int gtkItemSetTitleImageAttrib(Ihandle* ih, const char* value)
 {
+#if GTK_CHECK_VERSION(3, 10, 0)
+  if (gtkItemHasImageBox(ih))
+#else
   if (GTK_IS_IMAGE_MENU_ITEM(ih->handle))
+#endif
   {
     gtkItemUpdateImage(ih, NULL, value, NULL);
     return 1;
@@ -344,7 +514,11 @@
 
 static int gtkItemSetImageAttrib(Ihandle* ih, const char* value)
 {
+#if GTK_CHECK_VERSION(3, 10, 0)
+  if (gtkItemHasImageBox(ih))
+#else
   if (GTK_IS_IMAGE_MENU_ITEM(ih->handle))
+#endif
   {
     gtkItemUpdateImage(ih, iupAttribGet(ih, "VALUE"), value, iupAttribGet(ih, "IMPRESS"));
     return 1;
@@ -355,7 +529,11 @@
 
 static int gtkItemSetImpressAttrib(Ihandle* ih, const char* value)
 {
+#if GTK_CHECK_VERSION(3, 10, 0)
+  if (gtkItemHasImageBox(ih))
+#else
   if (GTK_IS_IMAGE_MENU_ITEM(ih->handle))
+#endif
   {
     gtkItemUpdateImage(ih, iupAttribGet(ih, "VALUE"), iupAttribGet(ih, "IMAGE"), value);
     return 1;
@@ -377,9 +555,14 @@
   else
     str = iupMenuProcessTitle(ih, value);
 
+#if GTK_CHECK_VERSION(3, 10, 0)
+  label = gtkItemGetLabelWidget(ih);
+#else
   label = gtk_bin_get_child((GtkBin*)ih->handle);
+#endif
 
-  iupgtkSetMnemonicTitle(ih, (GtkLabel*)label, str);
+  if (label)
+    iupgtkSetMnemonicTitle(ih, (GtkLabel*)label, str);
 
   if (str != value) free(str);
   return 1;
@@ -397,7 +580,11 @@
     g_signal_handlers_unblock_by_func(G_OBJECT(ih->handle), G_CALLBACK(gtkItemActivate), ih);
     return 0;
   }
+#if GTK_CHECK_VERSION(3, 10, 0)
+  else if (gtkItemHasImageBox(ih))
+#else
   else if (GTK_IS_IMAGE_MENU_ITEM(ih->handle))
+#endif
   {
     gtkItemUpdateImage(ih, value, iupAttribGet(ih, "IMAGE"), iupAttribGet(ih, "IMPRESS"));
     return 1;
@@ -425,7 +612,13 @@
 #endif
   {
     if (iupAttribGet(ih, "IMAGE")||iupAttribGet(ih, "TITLEIMAGE"))
+    {
+#if GTK_CHECK_VERSION(3, 10, 0)
+      ih->handle = gtkMenuItemNewWithImageSupport();
+#else
       ih->handle = gtk_image_menu_item_new_with_label("");
+#endif
+    }
     else if (iupAttribGetBoolean(ih->parent, "RADIO"))
     {
       GtkRadioMenuItem* last_tg = (GtkRadioMenuItem*)iupAttribGet(ih->parent, "_IUPGTK_LASTRADIOITEM");
@@ -442,7 +635,7 @@
       if (!hidemark)
       {
         /* change HIDEMARK default if VALUE is not defined, after GTK 2.14 */
-        if (!iupAttribGet(ih, "VALUE")) 
+        if (!iupAttribGet(ih, "VALUE"))
           hidemark = "YES";
       }
 #endif
@@ -501,7 +694,11 @@
 
 static int gtkSubmenuSetImageAttrib(Ihandle* ih, const char* value)
 {
+#if GTK_CHECK_VERSION(3, 10, 0)
+  if (gtkItemHasImageBox(ih))
+#else
   if (GTK_IS_IMAGE_MENU_ITEM(ih->handle))
+#endif
   {
     gtkItemUpdateImage(ih, NULL, value, NULL);
     return 1;
@@ -522,12 +719,18 @@
     ih->handle = gtk_menu_item_new_with_label("");
   else
 #endif
+  {
+#if GTK_CHECK_VERSION(3, 10, 0)
+    ih->handle = gtkMenuItemNewWithImageSupport();
+#else
     ih->handle = gtk_image_menu_item_new_with_label("");
+#endif
+  }
 
   if (!ih->handle)
     return IUP_ERROR;
 
-  ih->serial = iupMenuGetChildId(ih); 
+  ih->serial = iupMenuGetChildId(ih);
 
   pos = IupGetChildPos(ih->parent, ih);
   gtk_menu_shell_insert((GtkMenuShell*)ih->parent->handle, ih->handle, pos);
@@ -540,28 +743,8 @@
   return IUP_NOERROR;
 }
 
-void iupdrvSubmenuInitClass(Iclass* ic)
-{
-  /* Driver Dependent Class functions */
-  ic->Map = gtkSubmenuMapMethod;
-  ic->UnMap = iupdrvBaseUnMapMethod;
-
-  /* Common */
-  iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
-
-  /* Visual */
-  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-
-  /* IupSubmenu only */
-  iupClassRegisterAttribute(ic, "TITLE", NULL, gtkItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "IMAGE", NULL, gtkSubmenuSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-}
-
-
 /*******************************************************************************************/
 
-
 static int gtkSeparatorMapMethod(Ihandle* ih)
 {
   int pos;
@@ -573,7 +756,7 @@
   if (!ih->handle)
     return IUP_ERROR;
 
-  ih->serial = iupMenuGetChildId(ih); 
+  ih->serial = iupMenuGetChildId(ih);
 
   pos = IupGetChildPos(ih->parent, ih);
   gtk_menu_shell_insert((GtkMenuShell*)ih->parent->handle, ih->handle, pos);
@@ -588,3 +771,143 @@
   ic->Map = gtkSeparatorMapMethod;
   ic->UnMap = iupdrvBaseUnMapMethod;
 }
+
+/*******************************************************************************************/
+
+static void gtkRecentItemActivate(GtkWidget *widget, Ihandle* menu)
+{
+  int index = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "_IUP_RECENT_INDEX"));
+  Icallback recent_cb = (Icallback)iupAttribGet(menu, "_IUP_RECENT_CB");
+  Ihandle* config = (Ihandle*)iupAttribGet(menu, "_IUP_CONFIG");
+
+  if (recent_cb && config)
+  {
+    char attr_name[32];
+    const char* filename;
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", index);
+    filename = iupAttribGet(menu, attr_name);
+
+    if (filename)
+    {
+      IupSetStrAttribute(config, "RECENTFILENAME", filename);
+      IupSetStrAttribute(config, "TITLE", filename);
+      config->parent = menu;
+
+      recent_cb(config);
+
+      config->parent = NULL;
+      IupSetAttribute(config, "RECENTFILENAME", NULL);
+      IupSetAttribute(config, "TITLE", NULL);
+    }
+  }
+}
+
+int iupdrvRecentMenuInit(Ihandle* menu, int max_recent, Icallback recent_cb)
+{
+  iupAttribSetInt(menu, "_IUP_RECENT_MAX", max_recent);
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", 0);
+  return 0;
+}
+
+int iupdrvRecentMenuUpdate(Ihandle* menu, const char** filenames, int count, Icallback recent_cb)
+{
+  GtkMenuShell* gtk_menu;
+  GtkWidget* empty_item;
+  int max_recent, existing, i;
+
+  if (!menu || !menu->handle)
+    return -1;
+
+  gtk_menu = (GtkMenuShell*)menu->handle;
+  max_recent = iupAttribGetInt(menu, "_IUP_RECENT_MAX");
+  existing = iupAttribGetInt(menu, "_IUP_RECENT_COUNT");
+
+  if (count > max_recent)
+    count = max_recent;
+
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+
+  empty_item = (GtkWidget*)iupAttribGet(menu, "_IUP_RECENT_EMPTY");
+  if (count > 0 && empty_item)
+  {
+    gtk_container_remove(GTK_CONTAINER(gtk_menu), empty_item);
+    iupAttribSet(menu, "_IUP_RECENT_EMPTY", NULL);
+  }
+
+  for (i = 0; i < count; i++)
+  {
+    GtkWidget* item;
+    char attr_name[32];
+
+    sprintf(attr_name, "_IUP_RECENT_ITEM%d", i);
+    item = (GtkWidget*)iupAttribGet(menu, attr_name);
+
+    if (item)
+    {
+      GtkWidget* label = gtk_bin_get_child(GTK_BIN(item));
+      if (label)
+        gtk_label_set_text(GTK_LABEL(label), filenames[i]);
+    }
+    else
+    {
+      item = gtk_menu_item_new_with_label(filenames[i]);
+      g_object_set_data(G_OBJECT(item), "_IUP_RECENT_INDEX", GINT_TO_POINTER(i));
+      g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(gtkRecentItemActivate), menu);
+      gtk_menu_shell_insert(gtk_menu, item, i);
+      gtk_widget_show(item);
+      iupAttribSet(menu, attr_name, (char*)item);
+    }
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
+    iupAttribSetStr(menu, attr_name, filenames[i]);
+  }
+
+  for (; i < existing; i++)
+  {
+    char attr_name[32];
+    GtkWidget* item;
+
+    sprintf(attr_name, "_IUP_RECENT_ITEM%d", i);
+    item = (GtkWidget*)iupAttribGet(menu, attr_name);
+    if (item)
+    {
+      gtk_container_remove(GTK_CONTAINER(gtk_menu), item);
+      iupAttribSet(menu, attr_name, NULL);
+    }
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
+    iupAttribSet(menu, attr_name, NULL);
+  }
+
+  if (count == 0 && !iupAttribGet(menu, "_IUP_RECENT_EMPTY"))
+  {
+    empty_item = gtk_menu_item_new_with_label("");
+    gtk_widget_set_sensitive(empty_item, FALSE);
+    gtk_menu_shell_append(gtk_menu, empty_item);
+    gtk_widget_show(empty_item);
+    iupAttribSet(menu, "_IUP_RECENT_EMPTY", (char*)empty_item);
+  }
+
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", count);
+  return 0;
+}
+
+void iupdrvSubmenuInitClass(Iclass* ic)
+{
+  /* Driver Dependent Class functions */
+  ic->Map = gtkSubmenuMapMethod;
+  ic->UnMap = iupdrvBaseUnMapMethod;
+
+  /* Common */
+  iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
+
+  /* Visual */
+  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+
+  /* IupSubmenu only */
+  iupClassRegisterAttribute(ic, "TITLE", NULL, gtkItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "IMAGE", NULL, gtkSubmenuSetImageAttrib, NULL, NULL, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+}
Index: src/gtk/iupgtk_open.c
===================================================================
--- src/gtk/iupgtk_open.c	(revision 5971)
+++ src/gtk/iupgtk_open.c	(working copy)
@@ -4,13 +4,30 @@
  * See Copyright Notice in "iup.h"
  */
 
-#include <stdio.h>          
+#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>          
+#include <string.h>
 #include <locale.h>
 
 #include <gtk/gtk.h>
+#include <gdk/gdk.h>
 
+#ifdef GDK_WINDOWING_X11
+#include <gdk/gdkx.h>
+#endif
+
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+
+#ifdef GDK_WINDOWING_WIN32
+#include <gdk/gdkwin32.h>
+#endif
+
+#ifdef GDK_WINDOWING_QUARTZ
+#include <gdk/gdkquartz.h>
+#endif
+
 #include "iup.h"
 
 #include "iup_str.h"
@@ -21,185 +38,316 @@
 
 #include "iupgtk_drv.h"
 
+#if defined(GDK_WINDOWING_WIN32)
+#if GTK_CHECK_VERSION(3, 0, 0)
+#define IUPGTK_GDK_WINDOW_HWND(w) gdk_win32_window_get_handle(w)
+#else
+#define IUPGTK_GDK_WINDOW_HWND(w) GDK_WINDOW_HWND(w)
+#endif
+#endif
 
-#if defined(GDK_NULL)   /******************************** Dummy definitions ************************************/
+#if defined(GDK_WINDOWING_X11)
+#if GTK_CHECK_VERSION(3, 0, 0)
+#define IUPGTK_GDK_WINDOW_XID(w) gdk_x11_window_get_xid(w)
+#define IUPGTK_GDK_DISPLAY_XDISPLAY(d) gdk_x11_display_get_xdisplay(d)
+#else
+#define IUPGTK_GDK_WINDOW_XID(w) GDK_WINDOW_XID(w)
+#define IUPGTK_GDK_DISPLAY_XDISPLAY(d) GDK_DISPLAY_XDISPLAY(d)
+#endif
 
-char* iupgtkGetNativeWidgetHandle(GtkWidget *widget)
-{
-  return NULL;
-}
+/* X11 function pointers - loaded dynamically to avoid hard linking */
+typedef struct _XDisplay Display;
+typedef struct _XGC* GC;
+typedef unsigned long XID;
 
-const char* iupgtkGetNativeWindowHandleName(void)
-{
-  return "????";
-}
+#include <dlfcn.h>
 
-const char* iupgtkGetNativeFontIdName(void)
-{
-  return "????";
-}
+static void* x11_lib = NULL;
+static GC (*_XCreateGC)(Display*, XID, unsigned long, void*) = NULL;
+static int (*_XFreeGC)(Display*, GC) = NULL;
+static int (*_XDefaultScreen)(Display*) = NULL;
+static char* (*_XServerVendor)(Display*) = NULL;
+static int (*_XVendorRelease)(Display*) = NULL;
 
-void* iupgtkGetNativeGraphicsContext(GtkWidget* widget)
+static int x11_load_functions(void)
 {
-  return NULL;
-}
+  if (x11_lib)
+    return 1;
 
-void iupgtkReleaseNativeGraphicsContext(GtkWidget* widget, void* gc)
-{
-}
+  x11_lib = dlopen("libX11.so.6", RTLD_LAZY);
+  if (!x11_lib)
+    x11_lib = dlopen("libX11.so", RTLD_LAZY);
 
-IUP_SDK_API void* iupdrvGetDisplay(void)
-{
-  return NULL;
-}
+  if (!x11_lib)
+    return 0;
 
-void iupgtkPushVisualAndColormap(void* visual, void* colormap)
-{
+  _XCreateGC = (GC (*)(Display*, XID, unsigned long, void*))dlsym(x11_lib, "XCreateGC");
+  _XFreeGC = (int (*)(Display*, GC))dlsym(x11_lib, "XFreeGC");
+  _XDefaultScreen = (int (*)(Display*))dlsym(x11_lib, "XDefaultScreen");
+  _XServerVendor = (char* (*)(Display*))dlsym(x11_lib, "XServerVendor");
+  _XVendorRelease = (int (*)(Display*))dlsym(x11_lib, "XVendorRelease");
+
+  if (!_XCreateGC || !_XFreeGC || !_XDefaultScreen || !_XServerVendor || !_XVendorRelease)
+  {
+    dlclose(x11_lib);
+    x11_lib = NULL;
+    return 0;
+  }
+
+  return 1;
 }
 
-static void gtkSetGlobalAttrib(void)
-{
+/* XVisualIDFromVisual is a macro in X11, define it as inline function */
+static inline XID x11_visual_id_from_visual(Visual* v) {
+    return v ? v->visualid : 0;
 }
+#endif
 
-#elif defined(GDK_WINDOWING_QUARTZ)   /******************************** MacOSX ************************************/
-#include <gdk/gdk.h>
-
 char* iupgtkGetNativeWidgetHandle(GtkWidget *widget)
 {
   GdkWindow* window = iupgtkGetWindow(widget);
-  if (window)
-    return (char*)window;
-  else
+  if (!window)
     return NULL;
-}
 
-const char* iupgtkGetNativeWindowHandleName(void)
-{
-  return "????";
-}
+#if GTK_CHECK_VERSION(3, 0, 0)
+  /* GTK3+: Use runtime checks for backend detection */
 
-const char* iupgtkGetNativeFontIdName(void)
-{
-  return "????";
-}
+#ifdef GDK_WINDOWING_X11
+  if (GDK_IS_X11_WINDOW(window))
+  {
+    return (char*)IUPGTK_GDK_WINDOW_XID(window);
+  }
+#endif
 
-void* iupgtkGetNativeGraphicsContext(GtkWidget* widget)
-{
-  return (void*)gdk_gc_new((GdkDrawable*)iupgtkGetWindow(widget));
-}
+#ifdef GDK_WINDOWING_WAYLAND
+  if (GDK_IS_WAYLAND_WINDOW(window))
+  {
+    /* Return wl_surface. */
+    return (char*)gdk_wayland_window_get_wl_surface(window);
+  }
+#endif
 
-void iupgtkReleaseNativeGraphicsContext(GtkWidget* widget, void* gc)
-{
-  g_object_unref(gc);
-  (void)widget;
-}
+#ifdef GDK_WINDOWING_WIN32
+  if (GDK_IS_WIN32_WINDOW(window))
+  {
+    return (char*)IUPGTK_GDK_WINDOW_HWND(window);
+  }
+#endif
 
-IUP_SDK_API void* iupdrvGetDisplay(void)
-{
-  GdkDisplay* display = gdk_display_get_default();
-  return display;
+#ifdef GDK_WINDOWING_QUARTZ
+  if (GDK_IS_QUARTZ_WINDOW(window))
+  {
+    return (char*)window;
+  }
+#endif
+
+#else
+  /* GTK2: Use compile-time detection since runtime checks are not available */
+
+#ifdef GDK_WINDOWING_X11
+  return (char*)IUPGTK_GDK_WINDOW_XID(window);
+#elif defined(GDK_WINDOWING_WIN32)
+  return (char*)IUPGTK_GDK_WINDOW_HWND(window);
+#elif defined(GDK_WINDOWING_QUARTZ)
+  return (char*)window;
+#endif
+
+#endif /* GTK_CHECK_VERSION(3, 0, 0) */
+
+  /* Fallback or unsupported backend */
+  return NULL;
 }
 
-void iupgtkPushVisualAndColormap(void* visual, void* colormap)
+const char* iupgtkGetNativeWindowHandleName(void)
 {
 #if GTK_CHECK_VERSION(3, 0, 0)
-  (void)visual;
-  (void)colormap;
-#else
-  GdkColormap* gdk_colormap;
-  GdkVisual *gdk_visual = gdk_visual_get_best();
+  GdkDisplay* display = gdk_display_get_default();
+  if (!display) return "NULL";
 
-  gdk_colormap = gdk_colormap_new(gdk_visual, FALSE);
+#ifdef GDK_WINDOWING_X11
+  if (GDK_IS_X11_DISPLAY(display))
+  {
+    return "XWINDOW";
+  }
+#endif
 
-  gtk_widget_push_colormap(gdk_colormap);
+#ifdef GDK_WINDOWING_WAYLAND
+  if (GDK_IS_WAYLAND_DISPLAY(display))
+  {
+    return "WL_SURFACE";
+  }
+#endif
 
-  /* gtk_widget_push_visual is now deprecated */
+#ifdef GDK_WINDOWING_WIN32
+  if (GDK_IS_WIN32_DISPLAY(display))
+  {
+    return "HWND";
+  }
 #endif
-}
 
-static void gtkSetGlobalAttrib(void)
-{
-}
+#ifdef GDK_WINDOWING_QUARTZ
+  if (GDK_IS_QUARTZ_DISPLAY(display))
+  {
+    return "GDKWINDOW";
+  }
+#endif
 
-#elif defined(GDK_WINDOWING_WIN32)   /******************************** Windows ************************************/
-#include <gdk/gdkwin32.h>
+#else
+  /* GTK2: Use compile-time detection */
 
-char* iupgtkGetNativeWidgetHandle(GtkWidget *widget)
-{
-  GdkWindow* window = iupgtkGetWindow(widget);
-  if (window)
-    return (char*)GDK_WINDOW_HWND(window);
-  else
-    return NULL;
-}
+#ifdef GDK_WINDOWING_X11
+  return "XWINDOW";
+#elif defined(GDK_WINDOWING_WIN32)
+  return "HWND";
+#elif defined(GDK_WINDOWING_QUARTZ)
+  return "GDKWINDOW";
+#endif
 
-const char* iupgtkGetNativeWindowHandleName(void)
-{
-  return "HWND";
+#endif /* GTK_CHECK_VERSION(3, 0, 0) */
+
+  return "UNKNOWN";
 }
 
 const char* iupgtkGetNativeFontIdName(void)
 {
+#if GTK_CHECK_VERSION(3, 0, 0)
+  GdkDisplay* display = gdk_display_get_default();
+  if (!display) return NULL;
+
+#ifdef GDK_WINDOWING_X11
+  if (GDK_IS_X11_DISPLAY(display))
+  {
+    return "XFONTID";
+  }
+#endif
+
+#ifdef GDK_WINDOWING_WIN32
+  if (GDK_IS_WIN32_DISPLAY(display))
+  {
+    return "HFONT";
+  }
+#endif
+
+#else
+  /* GTK2: Use compile-time detection */
+
+#ifdef GDK_WINDOWING_X11
+  return "XFONTID";
+#elif defined(GDK_WINDOWING_WIN32)
   return "HFONT";
+#endif
+
+#endif /* GTK_CHECK_VERSION(3, 0, 0) */
+
+  /* Wayland, Quartz, and others use Pango/Fontconfig/CoreText. */
+  return NULL;
 }
 
 void* iupgtkGetNativeGraphicsContext(GtkWidget* widget)
 {
-  return GetDC(GDK_WINDOW_HWND(iupgtkGetWindow(widget)));
-}
+  GdkWindow* window = iupgtkGetWindow(widget);
+  if (!window) return NULL;
 
-void iupgtkReleaseNativeGraphicsContext(GtkWidget* widget, void* gc)
-{
-  ReleaseDC(GDK_WINDOW_HWND(iupgtkGetWindow(widget)), (HDC)gc);
-}
+#if GTK_CHECK_VERSION(3, 0, 0)
+  GdkDisplay* display = gdk_window_get_display(window);
 
-IUP_SDK_API void* iupdrvGetDisplay(void)
-{
-  return NULL;
-}
+#ifdef GDK_WINDOWING_X11
+  if (GDK_IS_X11_DISPLAY(display))
+  {
+    if (!x11_load_functions())
+      return NULL;
+    return (void*)_XCreateGC(IUPGTK_GDK_DISPLAY_XDISPLAY(display), IUPGTK_GDK_WINDOW_XID(window), 0, NULL);
+  }
+#endif
 
-void iupgtkPushVisualAndColormap(void* visual, void* colormap)
-{
-  (void)visual;
-  (void)colormap;
-}
+#ifdef GDK_WINDOWING_WIN32
+  if (GDK_IS_WIN32_DISPLAY(display))
+  {
+    return GetDC(IUPGTK_GDK_WINDOW_HWND(window));
+  }
+#endif
 
-static void gtkSetGlobalAttrib(void)
-{
-}
+#ifdef GDK_WINDOWING_QUARTZ
+  if (GDK_IS_QUARTZ_DISPLAY(display))
+  {
+    /* In GTK3/Quartz/Wayland, drawing is done via Cairo. */
+    return NULL;
+  }
+#endif
 
-#elif defined(GDK_WINDOWING_X11)          /******************************** X11 ************************************/
-#include <gdk/gdkx.h>
+#else
+  /* GTK2: Use compile-time backend detection */
 
-char* iupgtkGetNativeWidgetHandle(GtkWidget *widget)
-{
-  GdkWindow* window = iupgtkGetWindow(widget);
+#ifdef GDK_WINDOWING_X11
+  Display* xdisplay = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
+  if (!x11_load_functions())
+    return NULL;
+  return (void*)_XCreateGC(xdisplay, IUPGTK_GDK_WINDOW_XID(window), 0, NULL);
+#elif defined(GDK_WINDOWING_WIN32)
+  return GetDC(IUPGTK_GDK_WINDOW_HWND(window));
+#elif defined(GDK_WINDOWING_QUARTZ)
   if (window)
-    return (char*)GDK_WINDOW_XID(window);
-  else
-    return NULL;
-}
+    return (void*)gdk_gc_new((GdkDrawable*)window);
+#endif
 
-const char* iupgtkGetNativeWindowHandleName(void)
-{
-  return "XWINDOW";
+#endif /* GTK_CHECK_VERSION(3, 0, 0) */
+
+  /* Wayland and GTK3 use Cairo contexts for drawing. */
+  return NULL;
 }
 
-const char* iupgtkGetNativeFontIdName(void)
+void iupgtkReleaseNativeGraphicsContext(GtkWidget* widget, void* gc)
 {
-  return "XFONTID";
-}
+  if (!gc) return;
 
-void* iupgtkGetNativeGraphicsContext(GtkWidget* widget)
-{
+  GdkWindow* window = iupgtkGetWindow(widget);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
   GdkDisplay* display = gdk_display_get_default();
-  return (void*)XCreateGC(GDK_DISPLAY_XDISPLAY(display), GDK_WINDOW_XID(iupgtkGetWindow(widget)), 0, NULL);
-}
+  if (!display) return;
 
-void iupgtkReleaseNativeGraphicsContext(GtkWidget* widget, void* gc)
-{
-  GdkDisplay* display = gdk_display_get_default();
-  XFreeGC(GDK_DISPLAY_XDISPLAY(display), (GC)gc);
+#ifdef GDK_WINDOWING_X11
+  if (GDK_IS_X11_DISPLAY(display))
+  {
+    if (x11_load_functions())
+      _XFreeGC(IUPGTK_GDK_DISPLAY_XDISPLAY(display), (GC)gc);
+    return;
+  }
+#endif
+
+#ifdef GDK_WINDOWING_WIN32
+  if (GDK_IS_WIN32_DISPLAY(display))
+  {
+    if (window)
+      ReleaseDC(IUPGTK_GDK_WINDOW_HWND(window), (HDC)gc);
+    return;
+  }
+#endif
+
+#ifdef GDK_WINDOWING_QUARTZ
+  if (GDK_IS_QUARTZ_DISPLAY(display))
+  {
+    /* Nothing to do for GTK3/Quartz */
+    return;
+  }
+#endif
+
+#else
+  /* GTK2: Use compile-time backend detection */
+
+#ifdef GDK_WINDOWING_X11
+  Display* xdisplay = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
+  if (x11_load_functions())
+    _XFreeGC(xdisplay, (GC)gc);
+#elif defined(GDK_WINDOWING_WIN32)
+  if (window)
+    ReleaseDC(IUPGTK_GDK_WINDOW_HWND(window), (HDC)gc);
+#elif defined(GDK_WINDOWING_QUARTZ)
+  g_object_unref(gc);
+#endif
+
+#endif /* GTK_CHECK_VERSION(3, 0, 0) */
+
   (void)widget;
 }
 
@@ -206,21 +354,66 @@
 IUP_SDK_API void* iupdrvGetDisplay(void)
 {
   GdkDisplay* display = gdk_display_get_default();
-  return GDK_DISPLAY_XDISPLAY(display);
+  if (!display) return NULL;
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+
+#ifdef GDK_WINDOWING_X11
+  if (GDK_IS_X11_DISPLAY(display))
+  {
+    return IUPGTK_GDK_DISPLAY_XDISPLAY(display);
+  }
+#endif
+
+#ifdef GDK_WINDOWING_WAYLAND
+  if (GDK_IS_WAYLAND_DISPLAY(display))
+  {
+    return gdk_wayland_display_get_wl_display(display);
+  }
+#endif
+
+#ifdef GDK_WINDOWING_QUARTZ
+  if (GDK_IS_QUARTZ_DISPLAY(display))
+  {
+    return (void*)display;
+  }
+#endif
+
+#else
+  /* GTK2: Use compile-time detection */
+
+#ifdef GDK_WINDOWING_X11
+  return IUPGTK_GDK_DISPLAY_XDISPLAY(display);
+#elif defined(GDK_WINDOWING_QUARTZ)
+  return (void*)display;
+#endif
+
+#endif /* GTK_CHECK_VERSION(3, 0, 0) */
+
+  return NULL;
 }
 
 void iupgtkPushVisualAndColormap(void* visual, void* colormap)
 {
+  /* This function is for X11 compatibility in GTK2.
+     It is deprecated in GTK3 and irrelevant for Wayland/Win32/Quartz.
+  */
+
 #if GTK_CHECK_VERSION(3, 0, 0)
   (void)visual;
   (void)colormap;
-#else
+
+#else /* GTK2 */
+
+#ifdef GDK_WINDOWING_X11
   GdkColormap* gdk_colormap;
+  GdkVisual* gdk_visual;
+
 #if GTK_CHECK_VERSION(2, 24, 0)
   GdkScreen* screen = gdk_screen_get_default();
-  GdkVisual* gdk_visual = gdk_x11_screen_lookup_visual(screen, XVisualIDFromVisual((Visual*)visual));
+  gdk_visual = gdk_x11_screen_lookup_visual(screen, x11_visual_id_from_visual((Visual*)visual));
 #else
-  GdkVisual* gdk_visual = gdkx_visual_get(XVisualIDFromVisual((Visual*)visual));
+  gdk_visual = gdkx_visual_get(x11_visual_id_from_visual((Visual*)visual));
 #endif
   if (colormap)
     gdk_colormap = gdk_x11_colormap_foreign_new(gdk_visual, (Colormap)colormap);
@@ -228,23 +421,86 @@
     gdk_colormap = gdk_colormap_new(gdk_visual, FALSE);
 
   gtk_widget_push_colormap(gdk_colormap);
+  /* gtk_widget_push_visual is deprecated */
 
-  /* gtk_widget_push_visual is now deprecated */
+#elif defined(GDK_WINDOWING_QUARTZ)
+  GdkColormap* gdk_colormap;
+  GdkVisual *gdk_visual = gdk_visual_get_best();
+
+  gdk_colormap = gdk_colormap_new(gdk_visual, FALSE);
+
+  gtk_widget_push_colormap(gdk_colormap);
+#else
+  (void)visual;
+  (void)colormap;
 #endif
+
+#endif /* GTK version check */
 }
 
 static void gtkSetGlobalAttrib(void)
 {
   GdkDisplay* display = gdk_display_get_default();
-  Display* xdisplay = GDK_DISPLAY_XDISPLAY(display);
+  if (!display) return;
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+
+#ifdef GDK_WINDOWING_X11
+  if (GDK_IS_X11_DISPLAY(display))
+  {
+    Display* xdisplay = IUPGTK_GDK_DISPLAY_XDISPLAY(display);
+    IupSetGlobal("XDISPLAY", (char*)xdisplay);
+    if (x11_load_functions())
+    {
+      IupSetGlobal("XSCREEN", (char*)(long)_XDefaultScreen(xdisplay));
+      IupSetGlobal("XSERVERVENDOR", _XServerVendor(xdisplay));
+      IupSetInt(NULL, "XVENDORRELEASE", _XVendorRelease(xdisplay));
+    }
+    IupSetGlobal("WINDOWING", "X11");
+  }
+#endif
+
+#ifdef GDK_WINDOWING_WAYLAND
+  if (GDK_IS_WAYLAND_DISPLAY(display))
+  {
+    struct wl_display* wl_display = gdk_wayland_display_get_wl_display(display);
+    IupSetGlobal("WL_DISPLAY", (char*)wl_display);
+    IupSetGlobal("WINDOWING", "WAYLAND");
+  }
+#endif
+
+#ifdef GDK_WINDOWING_QUARTZ
+  if (GDK_IS_QUARTZ_DISPLAY(display))
+  {
+    IupSetGlobal("WINDOWING", "COCOA");
+  }
+#endif
+
+#ifdef GDK_WINDOWING_WIN32
+  if (GDK_IS_WIN32_DISPLAY(display))
+  {
+    IupSetGlobal("WINDOWING", "WIN32");
+  }
+#endif
+
+#else
+  /* GTK2: Set X11 attributes if on X11 */
+
+#ifdef GDK_WINDOWING_X11
+  Display* xdisplay = IUPGTK_GDK_DISPLAY_XDISPLAY(display);
   IupSetGlobal("XDISPLAY", (char*)xdisplay);
-  IupSetGlobal("XSCREEN", (char*)XDefaultScreen(xdisplay));
-  IupSetGlobal("XSERVERVENDOR", ServerVendor(xdisplay));
-  IupSetInt(NULL, "XVENDORRELEASE", VendorRelease(xdisplay));
+  if (x11_load_functions())
+  {
+    IupSetGlobal("XSCREEN", (char*)(long)_XDefaultScreen(xdisplay));
+    IupSetGlobal("XSERVERVENDOR", _XServerVendor(xdisplay));
+    IupSetInt(NULL, "XVENDORRELEASE", _XVendorRelease(xdisplay));
+  }
+  IupSetGlobal("WINDOWING", "X11");
+#endif
+
+#endif /* GTK_CHECK_VERSION(3, 0, 0) */
 }
 
-#endif
-
 char* iupgtkGetNativeWindowHandleAttrib(Ihandle* ih)
 {
   /* Used only in Canvas and Dialog */
@@ -254,15 +510,15 @@
 #if GTK_CHECK_VERSION(3, 0, 0)
 static void gtkSetGlobalColorAttrib(const char* name, GdkRGBA *color)
 {
-  iupGlobalSetDefaultColorAttrib(name, (int)iupgtkColorFromDouble(color->red), 
-                                       (int)iupgtkColorFromDouble(color->green), 
+  iupGlobalSetDefaultColorAttrib(name, (int)iupgtkColorFromDouble(color->red),
+                                       (int)iupgtkColorFromDouble(color->green),
                                        (int)iupgtkColorFromDouble(color->blue));
 }
 #else
 static void gtkSetGlobalColorAttrib(const char* name, GdkColor *color)
 {
-  iupGlobalSetDefaultColorAttrib(name, (int)iupCOLOR16TO8(color->red), 
-                                       (int)iupCOLOR16TO8(color->green), 
+  iupGlobalSetDefaultColorAttrib(name, (int)iupCOLOR16TO8(color->red),
+                                       (int)iupCOLOR16TO8(color->green),
                                        (int)iupCOLOR16TO8(color->blue));
 }
 #endif
@@ -270,55 +526,65 @@
 static void gtkUpdateGlobalColors(GtkWidget* dialog, GtkWidget* text)
 {
 #if GTK_CHECK_VERSION(3, 0, 0)
-#ifdef XWIN32  /* TODO: Workaround for GTK3 on Win32, should remove this code in the future */
-#define gtkColorToRGBA(color, color3) {color3.red = color.red/65535.0; color3.green = color.green/65535.0; color3.blue = color.blue/65535.0; color3.alpha = 1.0;}
-
-  GdkRGBA color3;
-  GtkStyle* style = gtk_widget_get_style(dialog);
-
-  GdkColor color = style->bg[GTK_STATE_NORMAL];
-  gtkColorToRGBA(color, color3);
-  gtkSetGlobalColorAttrib("DLGBGCOLOR", &color3);
-
-  color = style->fg[GTK_STATE_NORMAL];
-  gtkColorToRGBA(color, color3);
-  gtkSetGlobalColorAttrib("DLGFGCOLOR", &color3);
-
-  style = gtk_widget_get_style(text);
-
-  color = style->base[GTK_STATE_NORMAL];
-  gtkColorToRGBA(color, color3);
-  gtkSetGlobalColorAttrib("TXTBGCOLOR", &color3);
-
-  color = style->text[GTK_STATE_NORMAL];
-  gtkColorToRGBA(color, color3);
-  gtkSetGlobalColorAttrib("TXTFGCOLOR", &color3);
-
-  color = style->base[GTK_STATE_SELECTED];
-  gtkColorToRGBA(color, color3);
-  gtkSetGlobalColorAttrib("TXTHLCOLOR", &color3);
-#else /* Not Windows */
   GdkRGBA color;
   GtkStyleContext* context = gtk_widget_get_style_context(dialog);
 
-  gtk_style_context_get_background_color(context, GTK_STATE_FLAG_NORMAL, &color);
-  gtkSetGlobalColorAttrib("DLGBGCOLOR", &color);
-
   gtk_style_context_get_color(context, GTK_STATE_FLAG_NORMAL, &color);
   gtkSetGlobalColorAttrib("DLGFGCOLOR", &color);
 
+  if (gtk_style_context_lookup_color(context, "theme_bg_color", &color))
+  {
+    gtkSetGlobalColorAttrib("DLGBGCOLOR", &color);
+  }
+  else
+  {
+    /* Light gray background for dialogs */
+    color.red = 0.94; color.green = 0.94; color.blue = 0.94; color.alpha = 1.0;
+    gtkSetGlobalColorAttrib("DLGBGCOLOR", &color);
+  }
+
   context = gtk_widget_get_style_context(text);
 
   gtk_style_context_get_color(context, GTK_STATE_FLAG_NORMAL, &color);
   gtkSetGlobalColorAttrib("TXTFGCOLOR", &color);
 
-  gtk_style_context_get_background_color(context, GTK_STATE_FLAG_NORMAL, &color);
-  if (color.alpha == 0) { color.red = 1; color.green = 1; color.blue = 1; }  /* TODO: workaround for GTK > 3.14 */
-  gtkSetGlobalColorAttrib("TXTBGCOLOR", &color);
+  if (gtk_style_context_lookup_color(context, "theme_base_color", &color))
+  {
+    gtkSetGlobalColorAttrib("TXTBGCOLOR", &color);
+  }
+  else
+  {
+    /* White background for text entries */
+    color.red = 1.0; color.green = 1.0; color.blue = 1.0; color.alpha = 1.0;
+    gtkSetGlobalColorAttrib("TXTBGCOLOR", &color);
+  }
 
-  gtk_style_context_get_background_color(context, GTK_STATE_FLAG_SELECTED, &color);
-  gtkSetGlobalColorAttrib("TXTHLCOLOR", &color);
-#endif
+  if (gtk_style_context_lookup_color(context, "theme_selected_bg_color", &color))
+  {
+    gtkSetGlobalColorAttrib("TXTHLCOLOR", &color);
+  }
+  else
+  {
+    /* Blue highlight color */
+    color.red = 0.2; color.green = 0.4; color.blue = 0.8; color.alpha = 1.0;
+    gtkSetGlobalColorAttrib("TXTHLCOLOR", &color);
+  }
+
+  context = gtk_widget_get_style_context(dialog);
+
+  gtk_style_context_get_color(context, GTK_STATE_FLAG_NORMAL, &color);
+  gtkSetGlobalColorAttrib("MENUFGCOLOR", &color);
+
+  if (gtk_style_context_lookup_color(context, "theme_bg_color", &color))
+  {
+    gtkSetGlobalColorAttrib("MENUBGCOLOR", &color);
+  }
+  else
+  {
+    /* Light gray background */
+    color.red = 0.94; color.green = 0.94; color.blue = 0.94; color.alpha = 1.0;
+    gtkSetGlobalColorAttrib("MENUBGCOLOR", &color);
+  }
 #else /* GTK 2.xx */
   GtkStyle* style = gtk_widget_get_style(dialog);
 
@@ -338,19 +604,23 @@
 
   color = style->base[GTK_STATE_SELECTED];
   gtkSetGlobalColorAttrib("TXTHLCOLOR", &color);
+
+  color = style->fg[GTK_STATE_NORMAL];
+  gtkSetGlobalColorAttrib("MENUFGCOLOR", &color);
+
+  color = style->bg[GTK_STATE_NORMAL];
+  gtkSetGlobalColorAttrib("MENUBGCOLOR", &color);
 #endif
 
   iupGlobalSetDefaultColorAttrib("LINKFGCOLOR", 0, 0, 238);
 }
 
-static void gtkSetGlobalColors(void)
+void iupgtkSetGlobalColors(void)
 {
-  GtkWidget* dialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+  GtkWidget* dialog = gtk_offscreen_window_new();
   GtkWidget* text = gtk_entry_new();
   gtk_container_add((GtkContainer*)dialog, text);
-  gtk_widget_show(text);
-  gtk_widget_realize(text);
-  gtk_widget_realize(dialog);
+  gtk_widget_show_all(dialog);
   gtkUpdateGlobalColors(dialog, text);
   gtk_widget_unrealize(dialog);
   gtk_widget_destroy(dialog);
@@ -393,6 +663,33 @@
 }
 #endif
 
+#if GTK_CHECK_VERSION(3, 0, 0) && GLIB_CHECK_VERSION(2, 50, 0)
+static GLogWriterOutput gtkLogWriter(GLogLevelFlags log_level, const GLogField *fields,
+                                      gsize n_fields, gpointer user_data)
+{
+  gsize i;
+  (void)user_data;
+
+  for (i = 0; i < n_fields; i++)
+  {
+    if (strcmp(fields[i].key, "MESSAGE") == 0 && fields[i].value)
+    {
+      const char* msg = (const char*)fields[i].value;
+      /* Suppress Ubuntu 24 GTK warning about dbus properties on non-Wayland windows.
+         This happens on Ubuntu's patched GTK when windows are created, but causes no issues. */
+      if (strstr(msg, "gdk_wayland_window_set_dbus_properties_libgtk_only"))
+        return G_LOG_WRITER_HANDLED;
+      /* Suppress GTK3 CSS gadget errors when scrollbars get negative size during resize.
+         This happens on Wayland during window resize when widgets temporarily get invalid sizes. */
+      if (strstr(msg, "gtk_box_gadget_distribute") && strstr(msg, "size >= 0"))
+        return G_LOG_WRITER_HANDLED;
+    }
+  }
+
+  return g_log_writer_default(log_level, fields, n_fields, user_data);
+}
+#endif
+
 int iupdrvOpen(int *argc, char ***argv)
 {
   char* value;
@@ -403,6 +700,11 @@
   /* reset to the C default numeric locale after gtk_init */
   setlocale(LC_NUMERIC, "C");
 
+#if GTK_CHECK_VERSION(3, 0, 0) && GLIB_CHECK_VERSION(2, 50, 0)
+  /* Install log writer to suppress warnings */
+  g_log_set_writer_func(gtkLogWriter, NULL, NULL);
+#endif
+
 #if defined(IUPGTK_DEBUG)
   g_log_set_default_handler(iupgtk_log, NULL);
 #endif
@@ -412,12 +714,8 @@
   IupStoreGlobal("SYSTEMLANGUAGE", pango_language_to_string(gtk_get_default_language()));
 
   /* driver system version */
-  IupSetfAttribute(NULL, "GTKVERSION", "%d.%d.%d", gtk_major_version, 
-                                                   gtk_minor_version, 
-                                                   gtk_micro_version);
-  IupSetfAttribute(NULL, "GTKDEVVERSION", "%d.%d.%d", GTK_MAJOR_VERSION, 
-                                                      GTK_MINOR_VERSION, 
-                                                      GTK_MICRO_VERSION);
+  IupSetfAttribute(NULL, "GTKVERSION", "%d.%d.%d", gtk_major_version, gtk_minor_version, gtk_micro_version);
+  IupSetfAttribute(NULL, "GTKDEVVERSION", "%d.%d.%d", GTK_MAJOR_VERSION, GTK_MINOR_VERSION, GTK_MICRO_VERSION);
 
   if (argv && *argv && (*argv)[0] && (*argv)[0][0] != 0)
     IupStoreGlobal("ARGV0", (*argv)[0]);
@@ -424,27 +722,40 @@
 
   gtkSetGlobalAttrib();
 
-  gtkSetGlobalColors();
+  iupgtkSetGlobalColors();
 
   IupSetGlobal("SHOWMENUIMAGES", "YES");
 
-  value = getenv("UBUNTU_MENUPROXY");  /* for now only in Ubuntu */
+  value = getenv("UBUNTU_MENUPROXY");
   if (value && (iupStrEqualNoCase(value, "libappmenu.so") || iupStrEqualNoCase(value, "1")))
     IupSetGlobal("GLOBALMENU", "Yes");
-  
+
   return IUP_NOERROR;
 }
 
-void iupdrvClose(void)
+int iupdrvSetGlobalAppIDAttrib(const char* value)
 {
-  iupgtkStrRelease();
+  static int appid_set = 0;
+  if (appid_set || !value || !value[0])
+    return 0;
+
+  g_set_prgname(value);
+  IupStoreGlobal("_IUP_APPID_INTERNAL", value);
+  appid_set = 1;
+  return 1;
 }
 
-/* TODO:  (deprecated)
+int iupdrvSetGlobalAppNameAttrib(const char* value)
+{
+  static int appname_set = 0;
+  if (appname_set || !value || !value[0])
+    return 0;
 
-foreground-gdk => -rgba
-background-gdk
+  appname_set = 1;
+  return 1;
+}
 
-gtk_widget_reparent has been deprecated since version 3.14 and should not be used in newly-written code.
-Use gtk_container_remove() and gtk_container_add().
-*/
+void iupdrvClose(void)
+{
+  iupgtkStrRelease();
+}
Index: src/gtk/iupgtk_progressbar.c
===================================================================
--- src/gtk/iupgtk_progressbar.c	(revision 5971)
+++ src/gtk/iupgtk_progressbar.c	(working copy)
@@ -26,6 +26,71 @@
 #include "iupgtk_drv.h"
 
 
+void iupdrvProgressBarGetMinSize(Ihandle* ih, int* w, int* h)
+{
+#if GTK_CHECK_VERSION(3, 0, 0)
+  static int horiz_min_w = -1, horiz_min_h = -1;
+  static int vert_min_w = -1, vert_min_h = -1;
+
+  if (horiz_min_w < 0)
+  {
+    GtkWidget* temp_window = gtk_offscreen_window_new();
+    GtkWidget* temp_horiz = gtk_progress_bar_new();
+    GtkWidget* temp_vert = gtk_progress_bar_new();
+    GtkRequisition horiz_req, vert_req;
+
+    gtk_orientable_set_orientation(GTK_ORIENTABLE(temp_horiz), GTK_ORIENTATION_HORIZONTAL);
+    gtk_orientable_set_orientation(GTK_ORIENTABLE(temp_vert), GTK_ORIENTATION_VERTICAL);
+
+    GtkWidget* box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+    gtk_box_pack_start(GTK_BOX(box), temp_horiz, FALSE, FALSE, 0);
+    gtk_box_pack_start(GTK_BOX(box), temp_vert, FALSE, FALSE, 0);
+    gtk_container_add(GTK_CONTAINER(temp_window), box);
+
+    gtk_widget_show_all(temp_window);
+    gtk_widget_realize(temp_window);
+
+    gtk_widget_get_preferred_size(temp_horiz, NULL, &horiz_req);
+    gtk_widget_get_preferred_size(temp_vert, NULL, &vert_req);
+
+    horiz_min_w = horiz_req.width;
+    horiz_min_h = horiz_req.height;
+    vert_min_w = vert_req.width;
+    vert_min_h = vert_req.height;
+
+    if (horiz_min_w < 1) horiz_min_w = 150;
+    if (horiz_min_h < 1) horiz_min_h = 6;
+    if (vert_min_w < 1) vert_min_w = 7;
+    if (vert_min_h < 1) vert_min_h = 80;
+
+    gtk_widget_destroy(temp_window);
+  }
+
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    *w = vert_min_w;
+    *h = vert_min_h;
+  }
+  else
+  {
+    *w = horiz_min_w;
+    *h = horiz_min_h;
+  }
+#else
+  /* GTK2 fallback */
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    *w = 7;
+    *h = 80;
+  }
+  else
+  {
+    *w = 150;
+    *h = 6;
+  }
+#endif
+}
+
 static int gtkProgressBarTimeCb(Ihandle* timer)
 {
   Ihandle* ih = (Ihandle*)iupAttribGet(timer, "_IUP_PROGRESSBAR");
Index: src/gtk/iupgtk_tabs.c
===================================================================
--- src/gtk/iupgtk_tabs.c	(revision 5971)
+++ src/gtk/iupgtk_tabs.c	(working copy)
@@ -79,9 +79,6 @@
     GtkWidget* tab_container = (GtkWidget*)iupAttribGet(child, "_IUPTAB_CONTAINER");
     if (tab_container)
     {
-      GtkWidget* tab_label = (GtkWidget*)iupAttribGet(child, "_IUPGTK_TABLABEL");
-      if (tab_label)
-        iupgtkSetBgColor(tab_label, r, g, b);
       iupgtkSetBgColor(tab_container, r, g, b);
     }
   }
@@ -273,7 +270,24 @@
   return 1;
 }
 
+static int gtkTabsSetAllowReorderAttrib(Ihandle* ih, const char* value)
+{
+  if (ih->handle)
+  {
+    Ihandle* child;
+    gboolean reorderable = iupStrBoolean(value);
 
+    for (child = ih->firstchild; child; child = child->brother)
+    {
+      GtkWidget* tab_page = (GtkWidget*)iupAttribGet(child, "_IUPTAB_PAGE");
+      if (tab_page)
+        gtk_notebook_set_tab_reorderable((GtkNotebook*)ih->handle, tab_page, reorderable);
+    }
+  }
+  return 1;
+}
+
+
 /* ------------------------------------------------------------------------- */
 /* gtkTabs - Callbacks                                                       */
 /* ------------------------------------------------------------------------- */
@@ -372,7 +386,7 @@
 
     pos = IupGetChildPos(ih, child);
 
-    /* Can not hide the tab_page, 
+    /* Can not hide the tab_page,
        or the tab will be automatically hidden.
        So create a secondary container to hide its child instead. */
 #if GTK_CHECK_VERSION(3, 0, 0)
@@ -384,6 +398,7 @@
 
     tab_container = gtk_fixed_new(); /* can not use iupgtkNativeContainerNew here in GTK3 */
     gtk_widget_show(tab_container);
+
     gtk_container_add((GtkContainer*)tab_page, tab_container);
 
     tabtitle = iupAttribGet(child, "TABTITLE");
@@ -435,7 +450,11 @@
       tab_close = gtk_button_new();
       gtk_button_set_image((GtkButton*)tab_close, image);
       gtk_button_set_relief((GtkButton*)tab_close, GTK_RELIEF_NONE);
-      gtk_button_set_focus_on_click((GtkButton*)tab_close, FALSE);
+#if GTK_CHECK_VERSION(3, 20, 0)
+      gtk_widget_set_focus_on_click(tab_close, FALSE);
+#else
+      gtk_button_set_focus_on_click(GTK_BUTTON(tab_close), FALSE);
+#endif
       iupgtkSetCanFocus(tab_close, FALSE);
 
       g_signal_connect(G_OBJECT(tab_close), "clicked", G_CALLBACK(gtkTabsCloseButtonClicked), child);
@@ -444,7 +463,7 @@
     iupAttribSet(ih, "_IUPGTK_IGNORE_CHANGE", "1");
 
     if ((tabimage && tabtitle) || ih->data->show_close)
-    { 
+    {
 #if GTK_CHECK_VERSION(3, 0, 0)
       if (ih->data->orientation == ITABS_VERTICAL)
         box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
@@ -461,6 +480,9 @@
 
     /* RIGHTCLICK_CB will not work without the eventbox */
     evtBox = gtk_event_box_new();
+#if GTK_CHECK_VERSION(2, 2, 0) && !GTK_CHECK_VERSION(3, 0, 0)
+    gtk_event_box_set_visible_window((GtkEventBox*)evtBox, FALSE);
+#endif
     gtk_widget_add_events(evtBox, GDK_BUTTON_PRESS_MASK);
     g_signal_connect(G_OBJECT(evtBox), "button-press-event", G_CALLBACK(gtkTabsButtonPressEvent), child);
 
@@ -468,7 +490,7 @@
     {
       gtk_container_add((GtkContainer*)box, tab_image);
       gtk_container_add((GtkContainer*)box, tab_label);
-      
+
       if(ih->data->show_close)
         gtk_container_add((GtkContainer*)box, tab_close);
 
@@ -509,6 +531,12 @@
     iupAttribSet(child, "_IUPGTK_TABLABEL", (char*)tab_label);
     iupAttribSet(child, "_IUPTAB_CONTAINER", (char*)tab_container);
     iupAttribSet(child, "_IUPTAB_PAGE", (char*)tab_page);
+
+    /* check if tab reordering is allowed */
+    char* allow_reorder = iupAttribGet(ih, "ALLOWREORDER");
+    if (iupStrBoolean(allow_reorder))
+      gtk_notebook_set_tab_reorderable((GtkNotebook*)ih->handle, tab_page, TRUE);
+
     iupStrToRGB(IupGetAttribute(ih, "BGCOLOR"), &r, &g, &b);
     iupgtkSetBgColor(tab_container, r, g, b);
 
@@ -516,8 +544,6 @@
     {
       iupgtkUpdateWidgetFont(ih, tab_label);
 
-      iupgtkSetBgColor(tab_label, r, g, b);
-
       iupStrToRGB(IupGetAttribute(ih, "FGCOLOR"), &r, &g, &b);
       iupgtkSetFgColor(tab_label, r, g, b);
 
@@ -546,31 +572,234 @@
 
 static void gtkTabsChildRemovedMethod(Ihandle* ih, Ihandle* child, int pos)
 {
-  if (ih->handle)
+  if (ih->handle && GTK_IS_WIDGET(ih->handle))
   {
     GtkWidget* tab_page = (GtkWidget*)iupAttribGet(child, "_IUPTAB_PAGE");
-    if (tab_page)
+
+    if (tab_page && GTK_IS_WIDGET(tab_page))
     {
-      if (iupdrvTabsGetCurrentTab(ih) == pos)
-        iupAttribSet(ih, "_IUPGTK_IGNORE_SWITCHPAGE", "1");
+      int page_num = gtk_notebook_page_num((GtkNotebook*)ih->handle, tab_page);
 
-      iupTabsCheckCurrentTab(ih, pos, 1);
+      if (page_num != -1)
+      {
+        if (iupdrvTabsGetCurrentTab(ih) == page_num)
+          iupAttribSet(ih, "_IUPGTK_IGNORE_SWITCHPAGE", "1");
 
-      iupAttribSet(ih, "_IUPGTK_IGNORE_CHANGE", "1");
-      gtk_notebook_remove_page((GtkNotebook*)ih->handle, pos);
-      iupAttribSet(ih, "_IUPGTK_IGNORE_CHANGE", NULL);
+        iupTabsCheckCurrentTab(ih, pos, 1);
 
-      iupAttribSet(child, "_IUPGTK_TABCLOSE", NULL);
-      iupAttribSet(child, "_IUPGTK_TABIMAGE", NULL);
-      iupAttribSet(child, "_IUPGTK_TABLABEL", NULL);
-      iupAttribSet(child, "_IUPTAB_CONTAINER", NULL);
-      iupAttribSet(child, "_IUPTAB_PAGE", NULL);
+        iupAttribSet(ih, "_IUPGTK_IGNORE_CHANGE", "1");
+        gtk_notebook_remove_page((GtkNotebook*)ih->handle, page_num);
+        iupAttribSet(ih, "_IUPGTK_IGNORE_CHANGE", NULL);
+      }
+    }
+  }
 
-      iupAttribSet(ih, "_IUPGTK_IGNORE_SWITCHPAGE", NULL);
+  child->handle = NULL;
+
+  iupAttribSet(child, "_IUPGTK_TABCLOSE", NULL);
+  iupAttribSet(child, "_IUPGTK_TABIMAGE", NULL);
+  iupAttribSet(child, "_IUPGTK_TABLABEL", NULL);
+  iupAttribSet(child, "_IUPTAB_CONTAINER", NULL);
+  iupAttribSet(child, "_IUPTAB_PAGE", NULL);
+
+  iupAttribSet(ih, "_IUPGTK_IGNORE_SWITCHPAGE", NULL);
+}
+
+static int gtkTabsGetTabOverlap(Ihandle* ih)
+{
+  if (!ih->handle)
+    return 0;
+
+  GtkNotebook* notebook = (GtkNotebook*)ih->handle;
+  gint tab_overlap = 0;
+
+  /* Query GTK style property for tab overlap (negative values mean spacing between tabs) */
+  gtk_widget_style_get(GTK_WIDGET(notebook), "tab-overlap", &tab_overlap, NULL);
+
+  return tab_overlap;
+}
+
+void iupdrvTabsGetTabSize(Ihandle* ih, const char* tab_title, const char* tab_image, int* tab_width, int* tab_height)
+{
+  int width = 0;
+  int height = 0;
+  int text_width = 0;
+  int text_height = 0;
+
+  /* Measure text dimensions */
+  if (tab_title)
+  {
+    text_width = iupdrvFontGetStringWidth(ih, tab_title);
+    iupdrvFontGetCharSize(ih, NULL, &text_height);
+    width = text_width;
+    height = text_height;
+  }
+
+  /* Add image dimensions */
+  if (tab_image)
+  {
+    void* img = iupImageGetImage(tab_image, ih, 0, NULL);
+    if (img)
+    {
+      int img_w, img_h;
+      iupdrvImageGetInfo(img, &img_w, &img_h, NULL);
+
+      /* Width: add image width + spacing */
+      width += img_w;
+      if (tab_title)
+        width += 2;
+
+      /* Height: use MAX of text and image */
+      if (img_h > height)
+        height = img_h;
     }
   }
+
+  /* Add GTK tab padding and margin */
+#if GTK_CHECK_VERSION(3, 0, 0)
+  width += 56;  /* GTK3 CSS: 24px padding + 8px margin + ~24px label padding */
+  height += 14;  /* GTK3 vertical padding for tabs */
+#else
+  /* GTK2 padding includes borders, shadows, and internal spacing */
+  width += 44;  /* Accounts for GTK2's border/shadow overhead and internal spacing */
+  height += 18;  /* GTK2 vertical padding for tabs */
+#endif
+
+  /* Add scroll arrows size if scrollable mode is enabled */
+  if (ih->handle && gtk_notebook_get_scrollable((GtkNotebook*)ih->handle))
+  {
+#if GTK_CHECK_VERSION(3, 0, 0)
+    GtkNotebook* notebook = (GtkNotebook*)ih->handle;
+    gint arrow_length = 16;  /* default */
+    const char* style_prop;
+
+    /* Different property names for horizontal vs vertical tabs */
+    if (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT)
+      style_prop = "scroll-arrow-vlength";
+    else
+      style_prop = "scroll-arrow-hlength";
+
+    gtk_widget_style_get(GTK_WIDGET(notebook), style_prop, &arrow_length, NULL);
+
+    /* GTK has 4 possible arrows (2 on each side), but typically only 2 are active
+       Add size for both arrows (left + right for TOP/BOTTOM, or top + bottom for LEFT/RIGHT) */
+    width += arrow_length * 2;
+#else
+    /* GTK2: Use fixed arrow size */
+    width += 32;
+#endif
+  }
+
+  /* For LEFT/RIGHT tabs, swap width/height because tabs are arranged vertically */
+  if (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT)
+  {
+    if (tab_width) *tab_width = height;   /* Use text height as tab width */
+    if (tab_height) *tab_height = width;  /* Use text width as tab height */
+  }
+  else
+  {
+    if (tab_width) *tab_width = width;
+    if (tab_height) *tab_height = height;
+  }
 }
 
+static void gtkTabsSizeAllocateCallback(GtkWidget* widget, GdkRectangle* allocation, Ihandle* ih)
+{
+  GtkNotebook* notebook = (GtkNotebook*)widget;
+  int n_pages = gtk_notebook_get_n_pages(notebook);
+  gboolean scrollable = gtk_notebook_get_scrollable(notebook);
+  int i;
+
+  /* Calculate total width needed for all tabs */
+  if (n_pages > 0 && (ih->data->type == ITABS_TOP || ih->data->type == ITABS_BOTTOM))
+  {
+    int total_tabs_width = 0;
+    int total_allocated_width = 0;
+    int i;
+    int m, s;
+
+    /* Get decoration margins and spacing */
+    m = 4;
+    s = 2;
+
+    /* Sum up all tab widths and show actual allocations */
+    for (i = 0; i < n_pages; i++)
+    {
+      GtkWidget* page = gtk_notebook_get_nth_page(notebook, i);
+      GtkWidget* tab_label = gtk_notebook_get_tab_label(notebook, page);
+      if (tab_label)
+      {
+        GtkAllocation tab_alloc;
+        gtk_widget_get_allocation(tab_label, &tab_alloc);
+        total_allocated_width += tab_alloc.width;
+#if GTK_CHECK_VERSION(3, 0, 0)
+        GtkRequisition tab_min, tab_nat;
+        gtk_widget_get_preferred_size(tab_label, &tab_min, &tab_nat);
+        total_tabs_width += tab_nat.width;
+#else
+        GtkRequisition tab_req;
+        gtk_widget_size_request(tab_label, &tab_req);
+        total_tabs_width += tab_req.width;
+#endif
+      }
+    }
+
+    total_tabs_width += 2 * m;  /* left and right margins */
+    if (n_pages > 1)
+      total_tabs_width += (n_pages - 1) * s;  /* spacing between tabs */
+
+    gboolean need_scrollable = (total_tabs_width > allocation->width);
+
+    if (need_scrollable != scrollable)
+    {
+      gtk_notebook_set_scrollable(notebook, need_scrollable);
+    }
+  }
+  else if (n_pages > 0 && (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT))
+  {
+    /* Similar logic for LEFT/RIGHT tabs but checking height instead */
+    int total_tabs_height = 0;
+    int total_allocated_height = 0;
+    int total_tabs_width = 0;
+    int total_allocated_width = 0;
+    int i;
+    int m = 4;
+
+    for (i = 0; i < n_pages; i++)
+    {
+      GtkWidget* page = gtk_notebook_get_nth_page(notebook, i);
+      GtkWidget* tab_label = gtk_notebook_get_tab_label(notebook, page);
+      if (tab_label)
+      {
+        GtkAllocation tab_alloc;
+        gtk_widget_get_allocation(tab_label, &tab_alloc);
+        total_allocated_height += tab_alloc.height;
+        total_allocated_width += tab_alloc.width;
+#if GTK_CHECK_VERSION(3, 0, 0)
+        GtkRequisition tab_min, tab_nat;
+        gtk_widget_get_preferred_size(tab_label, &tab_min, &tab_nat);
+        total_tabs_height += tab_nat.height;
+        total_tabs_width += tab_nat.width;
+#else
+        GtkRequisition tab_req;
+        gtk_widget_size_request(tab_label, &tab_req);
+        total_tabs_height += tab_req.height;
+        total_tabs_width += tab_req.width;
+#endif
+      }
+    }
+
+    total_tabs_height += 2 * m;
+
+    gboolean need_scrollable = (total_tabs_height > allocation->height);
+
+    if (need_scrollable != scrollable)
+    {
+      gtk_notebook_set_scrollable(notebook, need_scrollable);
+    }
+  }
+}
+
 static int gtkTabsMapMethod(Ihandle* ih)
 {
   ih->handle = gtk_notebook_new();
@@ -577,7 +806,8 @@
   if (!ih->handle)
     return IUP_ERROR;
 
-  gtk_notebook_set_scrollable((GtkNotebook*)ih->handle, TRUE);
+  /* Start with scrollable=FALSE, will be enabled dynamically if needed in size-allocate */
+  gtk_notebook_set_scrollable((GtkNotebook*)ih->handle, FALSE);
 
   gtkTabsUpdateTabType(ih);
 
@@ -594,6 +824,7 @@
   g_signal_connect(G_OBJECT(ih->handle), "show-help",           G_CALLBACK(iupgtkShowHelp),        ih);
 
   g_signal_connect(G_OBJECT(ih->handle), "switch-page",         G_CALLBACK(gtkTabsSwitchPage), ih);
+  g_signal_connect(G_OBJECT(ih->handle), "size-allocate",       G_CALLBACK(gtkTabsSizeAllocateCallback), ih);
 
   gtk_widget_realize(ih->handle);
 
@@ -613,11 +844,38 @@
       /* current value is now given by the native system */
       iupAttribSet(ih, "_IUPTABS_VALUE_HANDLE", NULL);
     }
+
   }
 
   return IUP_NOERROR;
 }
 
+static int gtkTabsSetTipAttrib(Ihandle* ih, const char* value)
+{
+  Ihandle* child;
+
+  for (child = ih->firstchild; child; child = child->brother)
+  {
+    GtkWidget* tab_label = (GtkWidget*)iupAttribGet(child, "_IUPGTK_TABLABEL");
+    if (tab_label)
+    {
+      if (value)
+      {
+        if (iupAttribGetBoolean(ih, "TIPMARKUP"))
+          gtk_widget_set_tooltip_markup(tab_label, iupgtkStrConvertToSystem(value));
+        else
+          gtk_widget_set_tooltip_text(tab_label, iupgtkStrConvertToSystem(value));
+      }
+      else
+      {
+        gtk_widget_set_tooltip_text(tab_label, NULL);
+      }
+    }
+  }
+
+  return 1;
+}
+
 void iupdrvTabsInitClass(Iclass* ic)
 {
   /* Driver Dependent Class functions */
@@ -635,10 +893,12 @@
   /* Visual */
   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, gtkTabsSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
   iupClassRegisterAttribute(ic, "FGCOLOR", NULL, gtkTabsSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "TIP", NULL, gtkTabsSetTipAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
 
   /* IupTabs only */
   iupClassRegisterAttribute(ic, "TABTYPE", iupTabsGetTabTypeAttrib, gtkTabsSetTabTypeAttrib, IUPAF_SAMEASSYSTEM, "TOP", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TABORIENTATION", iupTabsGetTabOrientationAttrib, gtkTabsSetTabOrientationAttrib, IUPAF_SAMEASSYSTEM, "HORIZONTAL", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ALLOWREORDER", NULL, gtkTabsSetAllowReorderAttrib, IUPAF_SAMEASSYSTEM, "NO", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttributeId(ic, "TABTITLE", iupTabsGetTitleAttrib, gtkTabsSetTabTitleAttrib, IUPAF_NO_INHERIT);
   iupClassRegisterAttributeId(ic, "TABIMAGE", NULL, gtkTabsSetTabImageAttrib, IUPAF_IHANDLENAME|IUPAF_NO_INHERIT);
   iupClassRegisterAttributeId(ic, "TABVISIBLE", iupTabsGetTabVisibleAttrib, gtkTabsSetTabVisibleAttrib, IUPAF_NO_INHERIT);
@@ -647,4 +907,3 @@
   /* NOT supported */
   iupClassRegisterAttribute(ic, "MULTILINE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED);
 }
-
Index: src/gtk/iupgtk_text.c
===================================================================
--- src/gtk/iupgtk_text.c	(revision 5971)
+++ src/gtk/iupgtk_text.c	(working copy)
@@ -34,35 +34,269 @@
 #define PANGO_WEIGHT_SEMIBOLD 600
 #endif
 
-/* TODO:
-  Replace:
-    background-gdk
-    foreground-gdk
-  By:
-    background-rgba
-    foreground-rgba
-*/
 
 void iupdrvTextAddSpin(Ihandle* ih, int *w, int h)
 {
+  static int spin_min_width = -1;
+
+  (void)h;
+  (void)ih;
+
+  /* Measure the minimum width required by GtkSpinButton */
+  if (spin_min_width < 0)
+  {
+    GtkWidget *temp_window = gtk_offscreen_window_new();
+    GtkWidget *temp_spin = gtk_spin_button_new_with_range(0, 100, 1);
+    GtkAllocation allocation;
+
+    /* Add to window, show, and realize to get actual allocated size */
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_spin);
+    gtk_widget_show_all(temp_window);
+
 #if GTK_CHECK_VERSION(3, 0, 0)
-  int spin_size = 2*22;
+    int min_w, nat_w;
+    gtk_widget_get_preferred_width(temp_spin, &min_w, &nat_w);
+
+    /* Get the actual allocated size after realization */
+    gtk_widget_get_allocation(temp_spin, &allocation);
+
+    /* Use allocated width with fallback */
+    spin_min_width = (allocation.width > 0) ? allocation.width : 130;
 #else
-  int spin_size = 16;
+    GtkRequisition requisition;
+    gtk_widget_size_request(temp_spin, &requisition);
+    gtk_widget_get_allocation(temp_spin, &allocation);
+
+    spin_min_width = (allocation.width > 0) ? allocation.width : 130;
 #endif
-  *w += spin_size;
-  (void)h;
-  (void)ih;
+
+    gtk_widget_destroy(temp_window);
+  }
+
+  /* Only enforce minimum width, don't force expansion */
+  if (*w < spin_min_width)
+    *w = spin_min_width;
 }
 
+/* Cached measurements for text widget borders */
+static int iupgtk_multiline_line_height = -1;
+static int iupgtk_multiline_border_height = -1;
+static int iupgtk_entry_border_x = -1;
+static int iupgtk_entry_border_y = -1;
+static int iupgtk_entry_noframe_border_y = -1;
+
+static void iupgtkTextMeasureEntryBorders(void)
+{
+  if (iupgtk_entry_border_x < 0)
+  {
+    GtkWidget *temp_window, *temp_entry, *temp_entry_noframe;
+    int entry_w, entry_h, entry_noframe_h;
+    int char_width, char_height;
+    PangoContext *context;
+    PangoLayout *layout;
+    GtkWidget *vbox;
+
+    temp_window = gtk_offscreen_window_new();
+#if GTK_CHECK_VERSION(3, 0, 0)
+    vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#else
+    vbox = gtk_vbox_new(FALSE, 0);
+#endif
+    gtk_container_add(GTK_CONTAINER(temp_window), vbox);
+
+    /* Create entry with frame */
+    temp_entry = gtk_entry_new();
+    gtk_entry_set_width_chars(GTK_ENTRY(temp_entry), 1);
+    gtk_entry_set_has_frame(GTK_ENTRY(temp_entry), TRUE);
+    gtk_box_pack_start(GTK_BOX(vbox), temp_entry, FALSE, FALSE, 0);
+
+    /* Create separate entry without frame */
+    temp_entry_noframe = gtk_entry_new();
+    gtk_entry_set_width_chars(GTK_ENTRY(temp_entry_noframe), 1);
+    gtk_entry_set_has_frame(GTK_ENTRY(temp_entry_noframe), FALSE);
+    gtk_box_pack_start(GTK_BOX(vbox), temp_entry_noframe, FALSE, FALSE, 0);
+
+    gtk_widget_show_all(temp_window);
+
+    context = gtk_widget_get_pango_context(temp_entry);
+    layout = pango_layout_new(context);
+    pango_layout_set_text(layout, "W", -1);
+    pango_layout_get_pixel_size(layout, &char_width, &char_height);
+
+    /* Measure with frame */
+#if GTK_CHECK_VERSION(3, 0, 0)
+    gtk_widget_get_preferred_width(temp_entry, NULL, &entry_w);
+    gtk_widget_get_preferred_height(temp_entry, NULL, &entry_h);
+    /* Measure without frame, get minimum size */
+    gtk_widget_get_preferred_height(temp_entry_noframe, &entry_noframe_h, NULL);
+#else
+    {
+      GtkRequisition requisition;
+      gtk_widget_size_request(temp_entry, &requisition);
+      entry_w = requisition.width;
+      entry_h = requisition.height;
+      gtk_widget_size_request(temp_entry_noframe, &requisition);
+      entry_noframe_h = requisition.height;
+    }
+#endif
+
+    /* Border = total size - content size */
+    iupgtk_entry_border_x = entry_w - char_width;
+    iupgtk_entry_border_y = entry_h - char_height;
+    iupgtk_entry_noframe_border_y = entry_noframe_h - char_height;
+
+    if (iupgtk_entry_border_x < 0) iupgtk_entry_border_x = 10;
+    if (iupgtk_entry_border_y < 0) iupgtk_entry_border_y = 10;
+    if (iupgtk_entry_noframe_border_y < 0) iupgtk_entry_noframe_border_y = 0;
+
+    g_object_unref(layout);
+    gtk_widget_destroy(temp_window);
+  }
+}
+
+static void iupgtkTextMeasureMultilineMetrics(void)
+{
+  if (iupgtk_multiline_border_height < 0)
+  {
+    GtkWidget *temp_window, *temp_sw, *temp_tv;
+    PangoContext *context;
+    PangoLayout *layout;
+    int layout_1line_h, layout_2line_h;
+    int sw_h, tv_h;
+
+    temp_window = gtk_offscreen_window_new();
+    temp_tv = gtk_text_view_new();
+    temp_sw = gtk_scrolled_window_new(NULL, NULL);
+    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(temp_sw), GTK_SHADOW_IN);
+    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(temp_sw), GTK_POLICY_NEVER, GTK_POLICY_NEVER);
+    gtk_container_add(GTK_CONTAINER(temp_sw), temp_tv);
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_sw);
+
+    gtk_widget_show_all(temp_window);
+
+    context = gtk_widget_get_pango_context(temp_tv);
+    layout = pango_layout_new(context);
+
+    pango_layout_set_text(layout, "X", -1);
+    pango_layout_get_pixel_size(layout, NULL, &layout_1line_h);
+
+    pango_layout_set_text(layout, "X\nX", -1);
+    pango_layout_get_pixel_size(layout, NULL, &layout_2line_h);
+
+    iupgtk_multiline_line_height = layout_2line_h - layout_1line_h;
+    if (iupgtk_multiline_line_height <= 0)
+      iupgtk_multiline_line_height = 16;
+
+    /* Measure scrolled window with empty text view */
+#if GTK_CHECK_VERSION(3, 0, 0)
+    gtk_widget_get_preferred_height(temp_sw, &sw_h, NULL);
+    gtk_widget_get_preferred_height(temp_tv, &tv_h, NULL);
+#else
+    {
+      GtkRequisition sw_req, tv_req;
+      gtk_widget_size_request(temp_sw, &sw_req);
+      gtk_widget_size_request(temp_tv, &tv_req);
+      sw_h = sw_req.height;
+      tv_h = tv_req.height;
+    }
+#endif
+
+    /* Border height is scrolled_window height - text_view height */
+    iupgtk_multiline_border_height = sw_h - tv_h;
+    if (iupgtk_multiline_border_height < 0)
+      iupgtk_multiline_border_height = 2;
+
+    g_object_unref(layout);
+    gtk_widget_destroy(temp_window);
+  }
+}
+
 void iupdrvTextAddBorders(Ihandle* ih, int *x, int *y)
 {
   /* Used also by IupCalendar in GTK */
-  /* LAYOUT_DECORATION_ESTIMATE */
-  int border_size = 2 * 5;
-  (*x) += border_size;
-  (*y) += border_size;
+
+  iupgtkTextMeasureEntryBorders();
+  int border_size_x = iupgtk_entry_border_x;
+  int border_size_y = iupgtk_entry_border_y;
+
+  static int spin_natural_height = -1;
+  if (iupAttribGetBoolean(ih, "SPIN") && spin_natural_height == -1)
+  {
+    GtkWidget *temp_window = gtk_offscreen_window_new();
+    GtkWidget *temp_spin = gtk_spin_button_new_with_range(0, 100, 1);
+
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_spin);
+    gtk_widget_show_all(temp_window);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+    gtk_widget_get_preferred_height(temp_spin, NULL, &spin_natural_height);
+#else
+    {
+      GtkRequisition requisition;
+      gtk_widget_size_request(temp_spin, &requisition);
+      spin_natural_height = requisition.height;
+    }
+#endif
+
+    if (spin_natural_height < 16) spin_natural_height = 34;
+
+    gtk_widget_destroy(temp_window);
+  }
+
+  /* For multiline text in scrolled window */
+  if (ih->data && ih->data->is_multiline)
+  {
+    int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+    iupgtkTextMeasureMultilineMetrics();
+
+    /* Multiline uses scrolled window, use measured horizontal border */
+    (*x) += border_size_x;
+
+    if (visiblelines > 0)
+    {
+      /* IUP calculates: char_height * visiblelines
+         GTK actually renders: pango_line_height * visiblelines + scrolled_window_border */
+      int char_height;
+      iupdrvFontGetCharSize(ih, NULL, &char_height);
+
+      int iup_content_h = char_height * visiblelines;
+      int gtk_content_h = iupgtk_multiline_line_height * visiblelines;
+      int line_diff = iup_content_h - gtk_content_h;
+
+      /* Add border height, subtract line height difference */
+      (*y) += iupgtk_multiline_border_height;
+      (*y) -= line_diff;
+    }
+    else
+    {
+      /* No VISIBLELINES set, just add minimal border */
+      (*y) += iupgtk_multiline_border_height;
+    }
+  }
+  else
+  {
+    /* Single-line entry */
+    (*x) += border_size_x;
+
+    if (iupAttribGetBoolean(ih, "SPIN"))
+    {
+      int add = spin_natural_height - (*y);
+      if (add < 0) add = 0;
+      (*y) += add;
+    }
+    else
+    {
+      (*y) += border_size_y;
+    }
+  }
+}
+
+void iupdrvTextAddExtraPadding(Ihandle* ih, int *w, int *h)
+{
   (void)ih;
+  iupgtkTextMeasureEntryBorders();
+  if (w) *w += iupgtk_entry_noframe_border_y;  /* use same value for width */
+  if (h) *h += iupgtk_entry_noframe_border_y;
 }
 
 static void gtkTextParseParagraphFormat(Ihandle* formattag, GtkTextTag* tag)
@@ -280,9 +514,15 @@
     unsigned char r, g, b;
     if (iupStrToRGB(format, &r, &g, &b))
     {
+#if GTK_CHECK_VERSION(3, 4, 0)
+      GdkRGBA rgba;
+      iupgdkRGBASet(&rgba, r, g, b);
+      g_object_set(G_OBJECT(tag), "foreground-rgba", &rgba, NULL);
+#else
       GdkColor color;
       iupgdkColorSetRGB(&color, r, g, b);
       g_object_set(G_OBJECT(tag), "foreground-gdk", &color, NULL);
+#endif
     }
   }
 
@@ -292,9 +532,15 @@
     unsigned char r, g, b;
     if (iupStrToRGB(format, &r, &g, &b))
     {
+#if GTK_CHECK_VERSION(3, 4, 0)
+      GdkRGBA rgba;
+      iupgdkRGBASet(&rgba, r, g, b);
+      g_object_set(G_OBJECT(tag), "background-rgba", &rgba, NULL);
+#else
       GdkColor color;
       iupgdkColorSetRGB(&color, r, g, b);
       g_object_set(G_OBJECT(tag), "background-gdk", &color, NULL);
+#endif
     }
   }
 
@@ -965,6 +1211,11 @@
     if (ih->data->append_newline && pos!=0)
       gtk_text_buffer_insert(buffer, &iter, "\n", 1);
     gtk_text_buffer_insert(buffer, &iter, iupgtkStrConvertToSystem(value), -1);
+
+    /* Move cursor to end and scroll to show it */
+    gtk_text_buffer_get_end_iter(buffer, &iter);
+    gtk_text_buffer_place_cursor(buffer, &iter);
+    gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(ih->handle), gtk_text_buffer_get_insert(buffer));
   }
   else
   {
@@ -1123,13 +1374,6 @@
 }
 
 #if GTK_CHECK_VERSION(3, 20, 0)
-static void iupgdkRGBASet(GdkRGBA* rgba, unsigned char r, unsigned char g, unsigned char b)
-{
-  rgba->red = iupgtkColorToDouble(r);
-  rgba->green = iupgtkColorToDouble(g);
-  rgba->blue = iupgtkColorToDouble(b);
-  rgba->alpha = 1.0;
-}
 #endif
 
 static int gtkTextSetFgColorAttrib(Ihandle* ih, const char* value)
@@ -1611,7 +1855,35 @@
 
 /**********************************************************************************************************/
 
+/* Callback to track scrolled window size allocation and clamp if needed */
+static void gtkTextScrolledWindowSizeAllocate(GtkWidget* widget, GdkRectangle* allocation, gpointer user_data)
+{
+  Ihandle* ih = (Ihandle*)user_data;
+  int sw_req_w, sw_req_h;
 
+  gtk_widget_get_size_request(widget, &sw_req_w, &sw_req_h);
+
+  int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+  if (visiblelines > 0 && sw_req_h > 0 && allocation->height > sw_req_h)
+  {
+    /* Create a new clamped allocation and apply it */
+    GtkAllocation clamped = *allocation;
+    clamped.height = sw_req_h;
+
+    /* Block this signal handler to prevent recursion */
+    g_signal_handlers_block_by_func(widget, gtkTextScrolledWindowSizeAllocate, user_data);
+
+    /* Apply the clamped allocation - this will allocate children correctly */
+    gtk_widget_size_allocate(widget, &clamped);
+
+    /* Unblock the signal handler */
+    g_signal_handlers_unblock_by_func(widget, gtkTextScrolledWindowSizeAllocate, user_data);
+
+    /* Update the allocation parameter to reflect what we actually did */
+    *allocation = clamped;
+  }
+}
+
 static int gtkTextMapMethod(Ihandle* ih)
 {
   GtkScrolledWindow* scrolled_window = NULL;
@@ -1670,6 +1942,19 @@
 
     gtk_scrolled_window_set_policy(scrolled_window, hscrollbar_policy, vscrollbar_policy);
 
+    /* Track scrolled window size allocation for VISIBLELINES clamping */
+    g_signal_connect(G_OBJECT(scrolled_window), "size-allocate", G_CALLBACK(gtkTextScrolledWindowSizeAllocate), ih);
+
+    /* Mark scrolled_window with VISIBLELINES flag so iupgtkSetPosSize can set size correctly */
+    {
+      int visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
+      if (visiblelines > 0)
+      {
+        /* Mark scrolled_window so iupgtkSetPosSize will use IUP's calculated height directly */
+        g_object_set_data(G_OBJECT(scrolled_window), "iup-visiblelines-set", (gpointer)"1");
+      }
+    }
+
     if (wordwrap)
       gtk_text_view_set_wrap_mode((GtkTextView*)ih->handle, GTK_WRAP_WORD);
 
@@ -1688,6 +1973,14 @@
     /* formatting is never supported when MULTILINE=NO */
     ih->data->has_formatting = 0;
 
+#if GTK_CHECK_VERSION(3, 0, 0)
+    /* Set natural alignment */
+    gtk_widget_set_hexpand(ih->handle, FALSE);
+    gtk_widget_set_vexpand(ih->handle, FALSE);
+    gtk_widget_set_halign(ih->handle, GTK_ALIGN_FILL);
+    gtk_widget_set_valign(ih->handle, GTK_ALIGN_CENTER);
+#endif
+
     gtk_entry_set_has_frame((GtkEntry*)ih->handle, iupAttribGetBoolean(ih, "BORDER"));
     gtk_entry_set_width_chars((GtkEntry*)ih->handle, 1);  /* minimum size */
 #if GTK_CHECK_VERSION(3, 14, 0)
@@ -1721,7 +2014,6 @@
       }
     }
 
-    iupgtkClearSizeStyleCSS(ih->handle);
   }
 
   /* add to the parent, all GTK controls must call this. */
@@ -1825,4 +2117,5 @@
 
   /* Not Supported */
   iupClassRegisterAttribute(ic, "FILTER", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/gtk/iupgtk_toggle.c
===================================================================
--- src/gtk/iupgtk_toggle.c	(revision 5971)
+++ src/gtk/iupgtk_toggle.c	(working copy)
@@ -53,28 +53,330 @@
 #endif
 #endif
 
+#if !GTK_CHECK_VERSION(3, 0, 0)
+/* GTK2 Switch dimensions (GTK3-style flat rectangle) */
+#define SWITCH_TRACK_WIDTH  48
+#define SWITCH_TRACK_HEIGHT 22
+#define SWITCH_THUMB_WIDTH  22
+#define SWITCH_THUMB_HEIGHT 18
+#define SWITCH_THUMB_MARGIN 2
+
+typedef struct _IupGtkSwitchData
+{
+  Ihandle* ih;
+  int checked_state;
+  GtkWidget* drawing_area;
+} IupGtkSwitchData;
+
+static void gtkSwitchDrawCairo(Ihandle* ih, IupGtkSwitchData* switch_data, cairo_t* cr)
+{
+  int is_checked = switch_data->checked_state;
+  int is_active = iupdrvIsActive(ih);
+  int thumb_x, thumb_y;
+  GtkStyle* style;
+  GdkColor track_color, thumb_color, border_color;
+
+  style = gtk_widget_get_style(ih->handle);
+
+  if (!is_active)
+  {
+    track_color = style->bg[GTK_STATE_INSENSITIVE];
+    thumb_color = style->light[GTK_STATE_INSENSITIVE];
+    border_color = style->dark[GTK_STATE_INSENSITIVE];
+  }
+  else if (is_checked)
+  {
+    track_color = style->bg[GTK_STATE_SELECTED];
+    thumb_color = style->light[GTK_STATE_NORMAL];
+    border_color = style->dark[GTK_STATE_SELECTED];
+  }
+  else
+  {
+    track_color = style->dark[GTK_STATE_NORMAL];
+    thumb_color = style->light[GTK_STATE_NORMAL];
+    border_color = style->dark[GTK_STATE_ACTIVE];
+  }
+
+  /* Draw track (filled rectangle) */
+  gdk_cairo_set_source_color(cr, &track_color);
+  cairo_rectangle(cr, 0, 0, SWITCH_TRACK_WIDTH, SWITCH_TRACK_HEIGHT);
+  cairo_fill(cr);
+
+  /* Draw track border */
+  gdk_cairo_set_source_color(cr, &border_color);
+  cairo_rectangle(cr, 0.5, 0.5, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1);
+  cairo_set_line_width(cr, 1.0);
+  cairo_stroke(cr);
+
+  /* Calculate thumb position */
+  if (is_checked)
+    thumb_x = SWITCH_TRACK_WIDTH - SWITCH_THUMB_WIDTH - SWITCH_THUMB_MARGIN;
+  else
+    thumb_x = SWITCH_THUMB_MARGIN;
+
+  thumb_y = (SWITCH_TRACK_HEIGHT - SWITCH_THUMB_HEIGHT) / 2;
+
+  /* Draw thumb (filled rectangle) */
+  gdk_cairo_set_source_color(cr, &thumb_color);
+  cairo_rectangle(cr, thumb_x, thumb_y, SWITCH_THUMB_WIDTH, SWITCH_THUMB_HEIGHT);
+  cairo_fill(cr);
+
+  /* Draw thumb border */
+  gdk_cairo_set_source_color(cr, &border_color);
+  cairo_rectangle(cr, thumb_x + 0.5, thumb_y + 0.5, SWITCH_THUMB_WIDTH - 1, SWITCH_THUMB_HEIGHT - 1);
+  cairo_stroke(cr);
+}
+
+#ifndef GDK_DISABLE_DEPRECATED
+static void gtkSwitchDrawGdk(Ihandle* ih, IupGtkSwitchData* switch_data, GdkWindow* window, GdkGC* gc)
+{
+  int is_checked = switch_data->checked_state;
+  int is_active = iupdrvIsActive(ih);
+  int thumb_x, thumb_y;
+  GtkStyle* style;
+  GdkColor track_color, thumb_color, border_color;
+  GdkColormap* colormap;
+
+  style = gtk_widget_get_style(ih->handle);
+  colormap = gtk_widget_get_colormap(ih->handle);
+
+  if (!is_active)
+  {
+    track_color = style->bg[GTK_STATE_INSENSITIVE];
+    thumb_color = style->light[GTK_STATE_INSENSITIVE];
+    border_color = style->dark[GTK_STATE_INSENSITIVE];
+  }
+  else if (is_checked)
+  {
+    track_color = style->bg[GTK_STATE_SELECTED];
+    thumb_color = style->light[GTK_STATE_NORMAL];
+    border_color = style->dark[GTK_STATE_SELECTED];
+  }
+  else
+  {
+    track_color = style->dark[GTK_STATE_NORMAL];
+    thumb_color = style->light[GTK_STATE_NORMAL];
+    border_color = style->dark[GTK_STATE_ACTIVE];
+  }
+
+  gdk_colormap_alloc_color(colormap, &track_color, FALSE, TRUE);
+  gdk_colormap_alloc_color(colormap, &thumb_color, FALSE, TRUE);
+  gdk_colormap_alloc_color(colormap, &border_color, FALSE, TRUE);
+
+  /* Draw track (filled rectangle) */
+  gdk_gc_set_foreground(gc, &track_color);
+  gdk_draw_rectangle(window, gc, TRUE, 0, 0, SWITCH_TRACK_WIDTH, SWITCH_TRACK_HEIGHT);
+
+  /* Draw track border */
+  gdk_gc_set_foreground(gc, &border_color);
+  gdk_draw_rectangle(window, gc, FALSE, 0, 0, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1);
+
+  /* Calculate thumb position */
+  if (is_checked)
+    thumb_x = SWITCH_TRACK_WIDTH - SWITCH_THUMB_WIDTH - SWITCH_THUMB_MARGIN;
+  else
+    thumb_x = SWITCH_THUMB_MARGIN;
+
+  thumb_y = (SWITCH_TRACK_HEIGHT - SWITCH_THUMB_HEIGHT) / 2;
+
+  /* Draw thumb (filled rectangle) */
+  gdk_gc_set_foreground(gc, &thumb_color);
+  gdk_draw_rectangle(window, gc, TRUE, thumb_x, thumb_y, SWITCH_THUMB_WIDTH, SWITCH_THUMB_HEIGHT);
+
+  /* Draw thumb border */
+  gdk_gc_set_foreground(gc, &border_color);
+  gdk_draw_rectangle(window, gc, FALSE, thumb_x, thumb_y, SWITCH_THUMB_WIDTH - 1, SWITCH_THUMB_HEIGHT - 1);
+}
+#endif /* GDK_DISABLE_DEPRECATED */
+
+static gboolean gtkSwitchExposeEvent(GtkWidget* widget, GdkEventExpose* event, IupGtkSwitchData* switch_data)
+{
+  Ihandle* ih = switch_data->ih;
+
+  (void)event;
+
+#ifndef GDK_DISABLE_DEPRECATED
+  {
+    GdkGC* gc = gdk_gc_new(widget->window);
+    if (!gc)
+      return FALSE;
+
+    gtkSwitchDrawGdk(ih, switch_data, widget->window, gc);
+
+    g_object_unref(gc);
+  }
+#else
+  {
+    cairo_t* cr = gdk_cairo_create(widget->window);
+    if (!cr)
+      return FALSE;
+
+    gtkSwitchDrawCairo(ih, switch_data, cr);
+
+    cairo_destroy(cr);
+  }
+#endif
+
+  return FALSE;
+}
+
+static gboolean gtkSwitchButtonPressEvent(GtkWidget* widget, GdkEventButton* event, Ihandle* ih)
+{
+  IupGtkSwitchData* switch_data;
+  IFni cb;
+  int new_check;
+
+  (void)widget;
+  (void)event;
+
+  switch_data = (IupGtkSwitchData*)iupAttribGet(ih, "_IUPGTK_SWITCHDATA");
+  if (!switch_data)
+    return FALSE;
+
+  new_check = switch_data->checked_state ? 0 : 1;
+  switch_data->checked_state = new_check;
+
+  gtk_widget_queue_draw(switch_data->drawing_area);
+
+  cb = (IFni)IupGetCallback(ih, "ACTION");
+  if (cb && cb(ih, new_check) == IUP_CLOSE)
+    IupExitLoop();
+
+  if (iupObjectCheck(ih))
+    iupBaseCallValueChangedCb(ih);
+
+  return TRUE;
+}
+
+static void gtkSwitchDestroyCallback(GtkWidget* widget, Ihandle* ih)
+{
+  IupGtkSwitchData* switch_data = (IupGtkSwitchData*)iupAttribGet(ih, "_IUPGTK_SWITCHDATA");
+  (void)widget;
+
+  if (switch_data)
+  {
+    free(switch_data);
+    iupAttribSet(ih, "_IUPGTK_SWITCHDATA", NULL);
+  }
+}
+#endif
+
 void iupdrvToggleAddBorders(Ihandle* ih, int *x, int *y)
 {
   iupdrvButtonAddBorders(ih, x, y);
 }
 
+void iupdrvToggleAddSwitch(Ihandle* ih, int *x, int *y, const char* str)
+{
+#if GTK_CHECK_VERSION(3, 0, 0)
+  static int switch_w = -1;
+  static int switch_h = -1;
+  (void)ih;
+
+  if (switch_w < 0)
+  {
+    GtkWidget* temp_window = gtk_offscreen_window_new();
+    GtkWidget* temp_switch = gtk_switch_new();
+    GtkAllocation allocation;
+    int min_w, nat_w, min_h, nat_h;
+
+    /* Add to window, show, and realize to get actual allocated size */
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_switch);
+    gtk_widget_show_all(temp_window);
+    gtk_widget_realize(temp_window);
+    gtk_widget_realize(temp_switch);
+
+    /* Force size allocation */
+    gtk_widget_get_preferred_width(temp_switch, &min_w, &nat_w);
+    gtk_widget_get_preferred_height(temp_switch, &min_h, &nat_h);
+
+    /* Get the actual allocated size after realization */
+    gtk_widget_get_allocation(temp_switch, &allocation);
+
+    /* Use allocated size with fallback */
+    switch_w = (allocation.width > 0) ? allocation.width : 48;
+    switch_h = (allocation.height > 0) ? allocation.height : 24;
+
+    gtk_widget_destroy(temp_window);
+  }
+
+  (*x) += 2 + switch_w + 2;
+  if ((*y) < 2 + switch_h + 2) (*y) = 2 + switch_h + 2;
+  else (*y) += 2+2;
+
+  if (str && str[0])
+    (*x) += 8;
+#else
+  /* GTK2: Use fixed dimensions matching our custom drawing */
+  (void)ih;
+
+  (*x) += 2 + SWITCH_TRACK_WIDTH + 2;
+  if ((*y) < 2 + SWITCH_TRACK_HEIGHT + 2) (*y) = 2 + SWITCH_TRACK_HEIGHT + 2;
+  else (*y) += 2+2;
+
+  if (str && str[0])
+    (*x) += 8;
+#endif
+}
+
 void iupdrvToggleAddCheckBox(Ihandle* ih, int *x, int *y, const char* str)
 {
-  /* LAYOUT_DECORATION_ESTIMATE */
-  int check_box = IUP_TOGGLE_BOX;
+  static int check_w = -1;
+  static int check_h = -1;
   (void)ih;
 
-  /* has margins too */
-  (*x) += 2 + check_box + 2;
-  if ((*y) < 2 + check_box + 2) (*y) = 2 + check_box + 2; /* minimum height */
+  if (check_w < 0)
+  {
+#if GTK_CHECK_VERSION(3, 0, 0)
+    GtkWidget* temp_window = gtk_offscreen_window_new();
+    GtkWidget* temp_check = gtk_check_button_new();
+    GtkAllocation allocation;
+    int min_w, nat_w, min_h, nat_h;
+
+    gtk_container_add(GTK_CONTAINER(temp_window), temp_check);
+    gtk_widget_show_all(temp_window);
+    gtk_widget_realize(temp_window);
+    gtk_widget_realize(temp_check);
+
+    gtk_widget_get_preferred_width(temp_check, &min_w, &nat_w);
+    gtk_widget_get_preferred_height(temp_check, &min_h, &nat_h);
+
+    gtk_widget_get_allocation(temp_check, &allocation);
+
+    check_w = (allocation.width > 0) ? allocation.width : IUP_TOGGLE_BOX;
+    check_h = (allocation.height > 0) ? allocation.height : IUP_TOGGLE_BOX;
+
+    gtk_widget_destroy(temp_window);
+#else
+    GtkWidget* temp_check = gtk_check_button_new();
+    GtkRequisition requisition;
+
+    gtk_widget_size_request(temp_check, &requisition);
+
+    check_w = (requisition.width > 0) ? requisition.width : IUP_TOGGLE_BOX;
+    check_h = (requisition.height > 0) ? requisition.height : IUP_TOGGLE_BOX;
+
+    gtk_widget_destroy(temp_check);
+#endif
+  }
+
+  (*x) += 2 + check_w + 2;
+  if ((*y) < 2 + check_h + 2) (*y) = 2 + check_h + 2;
   else (*y) += 2+2;
 
-  if (str && str[0]) /* add spacing between check box and text */
+  if (str && str[0])
     (*x) += 8;
 }
 
 static int gtkToggleGetCheck(Ihandle* ih)
 {
+#if GTK_CHECK_VERSION(3, 0, 0)
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    if (GTK_IS_SWITCH(ih->handle))
+        return gtk_switch_get_active(GTK_SWITCH(ih->handle))? 1: 0;
+  }
+#endif
   if (gtk_toggle_button_get_inconsistent((GtkToggleButton*)ih->handle))
     return -1;
   if (gtk_toggle_button_get_active((GtkToggleButton*)ih->handle))
@@ -149,9 +451,46 @@
 
 static int gtkToggleSetValueAttrib(Ihandle* ih, const char* value)
 {
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+#if GTK_CHECK_VERSION(3, 0, 0)
+    if (GTK_IS_SWITCH(ih->handle))
+    {
+      int check;
+      iupAttribSet(ih, "_IUPGTK_IGNORE_TOGGLE", "1");
+
+      if (iupStrEqualNoCase(value,"TOGGLE"))
+        check = !gtk_switch_get_active(GTK_SWITCH(ih->handle));
+      else
+        check = iupStrBoolean(value);
+
+      gtk_switch_set_active(GTK_SWITCH(ih->handle), check);
+
+      iupAttribSet(ih, "_IUPGTK_IGNORE_TOGGLE", NULL);
+    }
+#else
+    IupGtkSwitchData* switch_data = (IupGtkSwitchData*)iupAttribGet(ih, "_IUPGTK_SWITCHDATA");
+    if (switch_data)
+    {
+      int new_check;
+
+      if (iupStrEqualNoCase(value, "TOGGLE"))
+        new_check = !switch_data->checked_state;
+      else
+        new_check = iupStrBoolean(value);
+
+      switch_data->checked_state = new_check;
+
+      if (ih->handle && switch_data->drawing_area)
+        gtk_widget_queue_draw(switch_data->drawing_area);
+    }
+#endif
+    return 0;
+  }
+
   if (iupStrEqualNoCase(value,"NOTDEF"))
     gtk_toggle_button_set_inconsistent((GtkToggleButton*)ih->handle, TRUE);
-  else 
+  else
   {
     int check;
     Ihandle* last_ih = NULL;
@@ -200,11 +539,23 @@
 
 static char* gtkToggleGetValueAttrib(Ihandle* ih)
 {
+#if !GTK_CHECK_VERSION(3, 0, 0)
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupGtkSwitchData* switch_data = (IupGtkSwitchData*)iupAttribGet(ih, "_IUPGTK_SWITCHDATA");
+    if (switch_data)
+      return iupStrReturnChecked(switch_data->checked_state);
+    return iupStrReturnChecked(0);
+  }
+#endif
   return iupStrReturnChecked(gtkToggleGetCheck(ih));
 }
 
 static int gtkToggleSetTitleAttrib(Ihandle* ih, const char* value)
 {
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+    return 0; /* Switch does not have a title */
+
   if (ih->data->type == IUP_TOGGLE_TEXT)
   {
     GtkButton* button = (GtkButton*)ih->handle;
@@ -241,8 +592,12 @@
   else  /* ACENTER (default) */
     yalign = 0.5f;
 
+#if GTK_CHECK_VERSION(3, 14, 0)
+  /* gtk_button_set_alignment() deprecated in 3.14 */
+  g_object_set(G_OBJECT(button), "xalign", xalign, "yalign", yalign, NULL);
+#else
   gtk_button_set_alignment(button, xalign, yalign);
-  /* TODO:   g_object_set(widget, "xalign", xalign, "yalign", yalign, NULL); */
+#endif
 
   return 1;
 }
@@ -271,7 +626,12 @@
 static int gtkToggleSetFgColorAttrib(Ihandle* ih, const char* value)
 {
   unsigned char r, g, b;
-  GtkWidget* label = (GtkWidget*)gtk_button_get_image((GtkButton*)ih->handle);
+  GtkWidget* label;
+
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+    return 0; /* Switch does not have an internal label */
+
+  label = (GtkWidget*)gtk_button_get_image((GtkButton*)ih->handle);
   if (!label) return 0;
 
   if (!iupStrToRGB(value, &r, &g, &b))
@@ -289,7 +649,12 @@
 
   if (ih->handle)
   {
-    GtkWidget* label = gtk_button_get_image((GtkButton*)ih->handle);
+    GtkWidget* label = NULL;
+
+    if (iupAttribGetBoolean(ih, "SWITCH"))
+      return 1; /* Switch does not have an internal label, but font attribute must be stored */
+
+    label = gtk_button_get_image((GtkButton*)ih->handle);
     if (label)
       iupgtkUpdateWidgetFont(ih, label);
   }
@@ -346,6 +711,28 @@
 
 /****************************************************************************************************/
 
+#if GTK_CHECK_VERSION(3, 0, 0)
+static void gtkSwitchToggled(GtkSwitch *widget, GParamSpec *pspec, Ihandle* ih)
+{
+  IFni cb;
+  int check;
+  (void)widget;
+  (void)pspec;
+
+  if (iupAttribGet(ih, "_IUPGTK_IGNORE_TOGGLE"))
+    return;
+
+  check = gtk_switch_get_active(GTK_SWITCH(ih->handle))? 1: 0;
+
+  cb = (IFni)IupGetCallback(ih, "ACTION");
+  if (cb && cb(ih, check) == IUP_CLOSE)
+    IupExitLoop();
+
+  if (iupObjectCheck(ih))
+    iupBaseCallValueChangedCb(ih);
+}
+#endif
+
 static void gtkToggleToggled(GtkToggleButton *widget, Ihandle* ih)
 {
   IFni cb;
@@ -424,7 +811,7 @@
         return TRUE; /* ignore message to avoid change toggle state */
     }
   }
-    
+
   (void)widget;
   return FALSE;
 }
@@ -462,7 +849,7 @@
   {
     if (evt->type == GDK_ENTER_NOTIFY)
       gtk_button_set_relief((GtkButton*)ih->handle, GTK_RELIEF_NORMAL);
-    else  if (evt->type == GDK_LEAVE_NOTIFY)               
+    else  if (evt->type == GDK_LEAVE_NOTIFY)
       gtk_button_set_relief((GtkButton*)ih->handle, GTK_RELIEF_NONE);
   }
 
@@ -487,6 +874,11 @@
   if (radio)
   {
     GtkRadioButton* last_tg = (GtkRadioButton*)iupAttribGet(radio, "_IUPGTK_LASTRADIOBUTTON");
+
+    /* Disable SWITCH for radio toggles */
+    if (iupAttribGetBoolean(ih, "SWITCH"))
+      iupAttribSet(ih, "SWITCH", "NO");
+
     if (last_tg)
       ih->handle = gtk_radio_button_new_from_widget(last_tg);
     else
@@ -503,10 +895,67 @@
   {
     if (ih->data->type == IUP_TOGGLE_TEXT)
     {
-      ih->handle = gtk_check_button_new();
+      if (iupAttribGetBoolean(ih, "SWITCH"))
+      {
+#if GTK_CHECK_VERSION(3, 0, 0)
+        ih->handle = gtk_switch_new();
+#else
+        /* GTK2: Create custom switch using GtkDrawingArea */
+        IupGtkSwitchData* switch_data;
 
-      if (iupAttribGetBoolean(ih, "3STATE"))
-        is3state = 1;
+        switch_data = (IupGtkSwitchData*)calloc(1, sizeof(IupGtkSwitchData));
+        switch_data->ih = ih;
+        iupAttribSet(ih, "_IUPGTK_SWITCHDATA", (char*)switch_data);
+
+        switch_data->drawing_area = gtk_drawing_area_new();
+        gtk_widget_set_size_request(switch_data->drawing_area, SWITCH_TRACK_WIDTH, SWITCH_TRACK_HEIGHT);
+
+        ih->handle = switch_data->drawing_area;
+
+        if (!ih->handle)
+        {
+          free(switch_data);
+          return IUP_ERROR;
+        }
+
+        /* Set up events */
+        gtk_widget_add_events(ih->handle, GDK_BUTTON_PRESS_MASK | GDK_EXPOSURE_MASK);
+
+        /* Add to parent */
+        iupgtkAddToParent(ih);
+
+        if (!iupAttribGetBoolean(ih, "CANFOCUS"))
+          iupgtkSetCanFocus(ih->handle, 0);
+
+        /* Connect signals */
+        g_signal_connect(G_OBJECT(ih->handle), "expose-event", G_CALLBACK(gtkSwitchExposeEvent), switch_data);
+        g_signal_connect(G_OBJECT(ih->handle), "button-press-event", G_CALLBACK(gtkSwitchButtonPressEvent), ih);
+        g_signal_connect(G_OBJECT(ih->handle), "enter-notify-event", G_CALLBACK(iupgtkEnterLeaveEvent), ih);
+        g_signal_connect(G_OBJECT(ih->handle), "leave-notify-event", G_CALLBACK(iupgtkEnterLeaveEvent), ih);
+        g_signal_connect(G_OBJECT(ih->handle), "focus-in-event", G_CALLBACK(iupgtkFocusInOutEvent), ih);
+        g_signal_connect(G_OBJECT(ih->handle), "focus-out-event", G_CALLBACK(iupgtkFocusInOutEvent), ih);
+        g_signal_connect(G_OBJECT(ih->handle), "key-press-event", G_CALLBACK(iupgtkKeyPressEvent), ih);
+        g_signal_connect(G_OBJECT(ih->handle), "show-help", G_CALLBACK(iupgtkShowHelp), ih);
+        g_signal_connect(G_OBJECT(ih->handle), "destroy", G_CALLBACK(gtkSwitchDestroyCallback), ih);
+
+        /* Set initial value */
+        value = iupAttribGet(ih, "VALUE");
+        if (value && iupStrBoolean(value))
+          switch_data->checked_state = 1;
+        else
+          switch_data->checked_state = 0;
+
+        gtk_widget_realize(ih->handle);
+
+        return IUP_NOERROR;
+#endif
+      }
+      else
+      {
+        ih->handle = gtk_check_button_new();
+        if (iupAttribGetBoolean(ih, "3STATE"))
+          is3state = 1;
+      }
     }
     else
       ih->handle = gtk_toggle_button_new();
@@ -517,8 +966,17 @@
 
   if (ih->data->type == IUP_TOGGLE_TEXT)
   {
-    gtk_button_set_image((GtkButton*)ih->handle, gtk_label_new(NULL));
-    gtk_toggle_button_set_mode((GtkToggleButton*)ih->handle, TRUE);
+#if GTK_CHECK_VERSION(3, 0, 0)
+    if (iupAttribGetBoolean(ih, "SWITCH"))
+    {
+      /* GtkSwitch does not have an internal label */
+    }
+    else
+#endif
+    {
+      gtk_button_set_image((GtkButton*)ih->handle, gtk_label_new(NULL));
+      gtk_toggle_button_set_mode((GtkToggleButton*)ih->handle, TRUE);
+    }
   }
   else
   {
@@ -526,8 +984,6 @@
     gtk_toggle_button_set_mode((GtkToggleButton*)ih->handle, FALSE);
   }
 
-  iupgtkClearSizeStyleCSS(ih->handle);
-
   /* add to the parent, all GTK controls must call this. */
   iupgtkAddToParent(ih);
 
@@ -552,7 +1008,16 @@
   g_signal_connect(G_OBJECT(ih->handle), "key-press-event",    G_CALLBACK(iupgtkKeyPressEvent), ih);
   g_signal_connect(G_OBJECT(ih->handle), "show-help",          G_CALLBACK(iupgtkShowHelp), ih);
 
-  g_signal_connect(G_OBJECT(ih->handle), "toggled",            G_CALLBACK(gtkToggleToggled), ih);
+#if GTK_CHECK_VERSION(3, 0, 0)
+  if (iupAttribGetBoolean(ih, "SWITCH") && ih->data->type == IUP_TOGGLE_TEXT)
+  {
+    g_signal_connect(G_OBJECT(ih->handle), "notify::active", G_CALLBACK(gtkSwitchToggled), ih);
+  }
+  else
+#endif
+  {
+    g_signal_connect(G_OBJECT(ih->handle), "toggled",            G_CALLBACK(gtkToggleToggled), ih);
+  }
 
   if (ih->data->type == IUP_TOGGLE_IMAGE || is3state)
   {
Index: src/gtk/iupgtk_tree.c
===================================================================
--- src/gtk/iupgtk_tree.c	(revision 5971)
+++ src/gtk/iupgtk_tree.c	(working copy)
@@ -35,17 +35,8 @@
 #include "iupgtk_drv.h"
 
 
-/* TODO:
-  Replace:
-    cell-background-gdk
-    foreground-gdk
-  By:
-    cell-background-rgba
-    foreground-rgba
-*/
+/* IMPORTANT:
 
-/* IMPORTANT: 
-
   GtkTreeStore uses the "user_data" field of the GtkTreeIter 
   to store the node pointer that is position independent.
   So we use it as a reference to the node in the cache, just like in Motif and Windows.
@@ -66,7 +57,7 @@
   IUPGTK_NODE_HAS_IMAGE_EXPANDED,
   IUPGTK_NODE_TITLE,   /* "text" */
   IUPGTK_NODE_KIND,    /* "is-expander" */
-  IUPGTK_NODE_COLOR,   /* "foreground-gdk" */
+  IUPGTK_NODE_COLOR,   /* "foreground-rgba" (GTK 3.4+) or "foreground-gdk" (GTK < 3.4) */
   IUPGTK_NODE_FONT,    /* "font-desc" */
   IUPGTK_NODE_SELECTED,
   IUPGTK_NODE_CHECK,   /* "active" */
@@ -121,7 +112,11 @@
   char* title;
   gboolean has_image, has_image_expanded;
   PangoFontDescription* font;
+#if GTK_CHECK_VERSION(3, 4, 0)
+  GdkRGBA *rgba;
+#else
   GdkColor *color;
+#endif
   GdkPixbuf* image, *image_expanded;
 
   gtk_tree_model_get(GTK_TREE_MODEL(store), iterItem, IUPGTK_NODE_IMAGE,      &image,
@@ -130,8 +125,12 @@
                                                       IUPGTK_NODE_HAS_IMAGE_EXPANDED,  &has_image_expanded,
                                                       IUPGTK_NODE_TITLE,  &title,
                                                       IUPGTK_NODE_KIND,  &kind,
-                                                      IUPGTK_NODE_COLOR, &color, 
-                                                      IUPGTK_NODE_FONT, &font, 
+#if GTK_CHECK_VERSION(3, 4, 0)
+                                                      IUPGTK_NODE_COLOR, &rgba,
+#else
+                                                      IUPGTK_NODE_COLOR, &color,
+#endif
+                                                      IUPGTK_NODE_FONT, &font,
                                                       -1);
 
   /* Add the new node */
@@ -149,7 +148,11 @@
                                           IUPGTK_NODE_HAS_IMAGE_EXPANDED, has_image_expanded,
                                           IUPGTK_NODE_TITLE,  title,
                                           IUPGTK_NODE_KIND,  kind,
-                                          IUPGTK_NODE_COLOR, color, 
+#if GTK_CHECK_VERSION(3, 4, 0)
+                                          IUPGTK_NODE_COLOR, rgba,
+#else
+                                          IUPGTK_NODE_COLOR, color,
+#endif
                                           IUPGTK_NODE_FONT, font,
                                           IUPGTK_NODE_SELECTED, 0,
                                           IUPGTK_NODE_CHECK, 0,
@@ -518,6 +521,7 @@
 {
   int old_select = 0;
   GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(ih->handle));
+  GtkTreeViewColumn* column = NULL;
 
   /* in a multiselection set_cursor will unselect all other nodes
      so must save and restore selection */
@@ -528,8 +532,12 @@
   if (gtkTreeIsNodeSelected(model, iterItemFocus))
     old_select = 1;
 
+  /* Need to pass the column when starting edit mode */
+  if (edit)
+    column = (GtkTreeViewColumn*)iupAttribGet(ih, "_IUPGTK_COLUMN");
+
   iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
-  gtk_tree_view_set_cursor(GTK_TREE_VIEW(ih->handle), pathFocus, NULL, edit);
+  gtk_tree_view_set_cursor(GTK_TREE_VIEW(ih->handle), pathFocus, column, edit);
   iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
 
   if (!old_select)
@@ -619,6 +627,18 @@
     gtk_tree_view_collapse_row(GTK_TREE_VIEW(ih->handle), path);
 }
 
+#if GTK_CHECK_VERSION(3, 4, 0)
+int iupgtkGetColor(const char* value, GdkRGBA *rgba)
+{
+  unsigned char r, g, b;
+  if (iupStrToRGB(value, &r, &g, &b))
+  {
+    iupgdkRGBASet(rgba, r, g, b);
+    return 1;
+  }
+  return 0;
+}
+#else
 int iupgtkGetColor(const char* value, GdkColor *color)
 {
   unsigned char r, g, b;
@@ -629,6 +649,7 @@
   }
   return 0;
 }
+#endif
 
 /*****************************************************************************/
 /* ADDING ITEMS                                                              */
@@ -638,7 +659,11 @@
   GtkTreeStore* store = GTK_TREE_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(ih->handle)));
   GtkTreeIter iterPrev, iterNewItem, iterParent;
   GtkTreePath* path;
+#if GTK_CHECK_VERSION(3, 4, 0)
+  GdkRGBA rgba = {0.0, 0.0, 0.0, 1.0};
+#else
   GdkColor color = {0L,0,0,0};
+#endif
   int kindPrev = -1;
 
   /* the previous node is not necessary only
@@ -670,7 +695,11 @@
     ih->data->stamp = iterNewItem.stamp;
   }
 
+#if GTK_CHECK_VERSION(3, 4, 0)
+  iupgtkGetColor(iupAttribGetStr(ih, "FGCOLOR"), &rgba);
+#else
   iupgtkGetColor(iupAttribGetStr(ih, "FGCOLOR"), &color);
+#endif
 
   if (!title)
     title = "";
@@ -680,7 +709,11 @@
                                           IUPGTK_NODE_HAS_IMAGE_EXPANDED, FALSE,
                                           IUPGTK_NODE_TITLE, iupgtkStrConvertToSystem(title),
                                           IUPGTK_NODE_KIND, kind,
-                                          IUPGTK_NODE_COLOR, &color, 
+#if GTK_CHECK_VERSION(3, 4, 0)
+                                          IUPGTK_NODE_COLOR, &rgba,
+#else
+                                          IUPGTK_NODE_COLOR, &color,
+#endif
                                           IUPGTK_NODE_SELECTED, 0,
                                           IUPGTK_NODE_CHECK, 0,
                                           IUPGTK_NODE_3STATE, 0,
@@ -1087,7 +1120,6 @@
 {
   GtkTreeStore* store = GTK_TREE_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(ih->handle)));
   GtkTreeIter iterItem;
-  GdkColor color;
   unsigned char r, g, b;
 
   if (!gtkTreeFindNode(ih, id, &iterItem))
@@ -1096,12 +1128,56 @@
   if (!iupStrToRGB(value, &r, &g, &b))
     return 0;
 
+#if GTK_CHECK_VERSION(3, 4, 0)
+  GdkRGBA rgba;
+  iupgdkRGBASet(&rgba, r, g, b);
+  gtk_tree_store_set(store, &iterItem, IUPGTK_NODE_COLOR, &rgba, -1);
+#else
+  GdkColor color;
   iupgdkColorSetRGB(&color, r, g, b);
   gtk_tree_store_set(store, &iterItem, IUPGTK_NODE_COLOR, &color, -1);
+#endif
 
   return 0;
 }
 
+static GdkPixbuf* gtkTreeGetThemeIcon(Ihandle* ih, const char* icon_name, int size)
+{
+  GdkPixbuf* pixbuf = NULL;
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+  /* GTK 3: Use icon theme */
+  GtkIconTheme* icon_theme = gtk_icon_theme_get_default();
+  GError* error = NULL;
+
+  pixbuf = gtk_icon_theme_load_icon(icon_theme, icon_name, size,
+                                    GTK_ICON_LOOKUP_USE_BUILTIN, &error);
+  if (error)
+  {
+    g_error_free(error);
+    pixbuf = NULL;
+  }
+  (void)ih;
+#else
+  /* GTK 2: Use stock icons - convert icon name to stock id */
+  const char* stock_id = NULL;
+
+  if (strcmp(icon_name, "text-x-generic") == 0)
+    stock_id = GTK_STOCK_FILE;
+  else if (strcmp(icon_name, "folder") == 0 || strcmp(icon_name, "folder-open") == 0)
+    stock_id = GTK_STOCK_DIRECTORY;
+
+  if (stock_id && ih->handle)
+  {
+    pixbuf = gtk_widget_render_icon(ih->handle, stock_id,
+                                   GTK_ICON_SIZE_MENU, NULL);
+  }
+  (void)size;
+#endif
+
+  return pixbuf;
+}
+
 static char* gtkTreeGetParentAttrib(Ihandle* ih, int id)
 {
   GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(ih->handle));
@@ -1743,7 +1819,8 @@
 
     iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", "1");
 
-    for(i = 0; i < ih->data->node_count; /* increment only if not removed */)
+    /* Iterate backwards to avoid index shifting issues when deleting */
+    for (i = ih->data->node_count - 1; i >= 0; i--)
     {
       gtkTreeIterInit(ih, &iterItem, ih->data->node_cache[i].node_handle);
       if (gtkTreeIsNodeSelected(model, &iterItem))
@@ -1751,8 +1828,6 @@
         gtkTreeCallNodeRemoved(ih, model, &iterItem);
         gtk_tree_store_remove(GTK_TREE_STORE(model), &iterItem);
       }
-      else
-        i++;
     }
 
     iupAttribSet(ih, "_IUPTREE_IGNORE_SELECTION_CB", NULL);
@@ -1762,16 +1837,19 @@
 }
 
 static int gtkTreeSetRenameAttrib(Ihandle* ih, const char* value)
-{  
+{
   if (ih->data->show_rename)
   {
-    GtkTreePath* path;
+    GtkTreePath* path = NULL;
     GtkTreeViewColumn *focus_column;
     GtkTreeIter iterItem;
     gtk_tree_view_get_cursor(GTK_TREE_VIEW(ih->handle), &path, &focus_column);
-    gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(ih->handle)), &iterItem, path);
-    gtkTreeSetFocus(ih, path, &iterItem, TRUE); /* start editing */
-    gtk_tree_path_free(path);
+    if (path)
+    {
+      gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(ih->handle)), &iterItem, path);
+      gtkTreeSetFocus(ih, path, &iterItem, TRUE); /* start editing */
+      gtk_tree_path_free(path);
+    }
   }
 
   (void)value;
@@ -1896,11 +1974,19 @@
     GtkCellRenderer *renderer_chk = (GtkCellRenderer*)iupAttribGet(ih, "_IUPGTK_RENDERER_CHECK");
     GtkCellRenderer* renderer_txt = (GtkCellRenderer*)iupAttribGet(ih, "_IUPGTK_RENDERER_TEXT");
     GtkCellRenderer* renderer_img = (GtkCellRenderer*)iupAttribGet(ih, "_IUPGTK_RENDERER_IMG");
+#if GTK_CHECK_VERSION(3, 4, 0)
+    GdkRGBA rgba;
+    iupgdkRGBASet(&rgba, r, g, b);
+    if (renderer_chk) g_object_set(G_OBJECT(renderer_chk), "cell-background-rgba", &rgba, NULL);
+    g_object_set(G_OBJECT(renderer_txt), "cell-background-rgba", &rgba, NULL);
+    g_object_set(G_OBJECT(renderer_img), "cell-background-rgba", &rgba, NULL);
+#else
     GdkColor color;
     iupgdkColorSetRGB(&color, r, g, b);
     if (renderer_chk) g_object_set(G_OBJECT(renderer_chk), "cell-background-gdk", &color, NULL);
     g_object_set(G_OBJECT(renderer_txt), "cell-background-gdk", &color, NULL);
     g_object_set(G_OBJECT(renderer_img), "cell-background-gdk", &color, NULL);
+#endif
   }
 
   iupdrvBaseSetBgColorAttrib(ih, value);   /* use given value for contents */
@@ -1920,11 +2006,17 @@
 
   {
     GtkCellRenderer* renderer_txt = (GtkCellRenderer*)iupAttribGet(ih, "_IUPGTK_RENDERER_TEXT");
+#if GTK_CHECK_VERSION(3, 4, 0)
+    GdkRGBA rgba;
+    iupgdkRGBASet(&rgba, r, g, b);
+    g_object_set(G_OBJECT(renderer_txt), "foreground-rgba", &rgba, NULL);
+#else
     GdkColor color;
     iupgdkColorSetRGB(&color, r, g, b);
     g_object_set(G_OBJECT(renderer_txt), "foreground-gdk", &color, NULL);
     g_object_get(G_OBJECT(renderer_txt), "foreground-gdk", &color, NULL);
     color.blue = 0;
+#endif
   }
 
   return 1;
@@ -2030,7 +2122,10 @@
   if (fontdesc)
   {
 #if GTK_CHECK_VERSION(3, 0, 0)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
     gtk_widget_override_font(GTK_WIDGET(editable), fontdesc);
+#pragma GCC diagnostic pop
 #else
     gtk_widget_modify_font(GTK_WIDGET(editable), fontdesc);
 #endif
@@ -2843,7 +2938,7 @@
   GtkTreeSelection* selection;
   GtkTreeViewColumn *column;
 
-  store = gtk_tree_store_new(IUPGTK_NODE_LAST_DATA, 
+  store = gtk_tree_store_new(IUPGTK_NODE_LAST_DATA,
     GDK_TYPE_PIXBUF,                 /* IUPGTK_NODE_IMAGE */
     G_TYPE_BOOLEAN,                  /* IUPGTK_NODE_HAS_IMAGE */
     GDK_TYPE_PIXBUF,                 /* IUPGTK_NODE_IMAGE_EXPANDED */
@@ -2850,7 +2945,11 @@
     G_TYPE_BOOLEAN,                  /* IUPGTK_NODE_HAS_IMAGE_EXPANDED */
     G_TYPE_STRING,                   /* IUPGTK_NODE_TITLE */
     G_TYPE_INT,                      /* IUPGTK_NODE_KIND */
+#if GTK_CHECK_VERSION(3, 4, 0)
+    GDK_TYPE_RGBA,                   /* IUPGTK_NODE_COLOR */
+#else
     GDK_TYPE_COLOR,                  /* IUPGTK_NODE_COLOR */
+#endif
     PANGO_TYPE_FONT_DESCRIPTION,     /* IUPGTK_NODE_FONT */
     G_TYPE_BOOLEAN,                  /* IUPGTK_NODE_SELECTED */
     G_TYPE_BOOLEAN,                  /* IUPGTK_NODE_CHECK */
@@ -2878,9 +2977,9 @@
 
     if(ih->data->show_toggle==2)
     {
-      gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer_chk, "active", IUPGTK_NODE_CHECK, 
-                                                                            "inconsistent", IUPGTK_NODE_3STATE, 
-                                                                            "visible", IUPGTK_NODE_TOGGLEVISIBLE, 
+      gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer_chk, "active", IUPGTK_NODE_CHECK,
+                                                                            "inconsistent", IUPGTK_NODE_3STATE,
+                                                                            "visible", IUPGTK_NODE_TOGGLEVISIBLE,
                                                                             NULL);
       g_signal_connect(G_OBJECT(ih->handle), "button-press-event",  G_CALLBACK(gtkTreeToggle3StateButtonEvent), ih);
       g_signal_connect(G_OBJECT(ih->handle), "button-release-event",G_CALLBACK(gtkTreeToggle3StateButtonEvent), ih);
@@ -2889,8 +2988,8 @@
     }
     else
     {
-      gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer_chk, "active", IUPGTK_NODE_CHECK, 
-                                                                            "visible", IUPGTK_NODE_TOGGLEVISIBLE, 
+      gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer_chk, "active", IUPGTK_NODE_CHECK,
+                                                                            "visible", IUPGTK_NODE_TOGGLEVISIBLE,
                                                                             NULL);
       g_signal_connect(G_OBJECT(renderer_chk), "toggled", G_CALLBACK(gtkTreeToggled), ih);
    }
@@ -2902,17 +3001,25 @@
   gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(column), renderer_img, FALSE);
   gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer_img, "pixbuf", IUPGTK_NODE_IMAGE,
                                                           "pixbuf-expander-open", IUPGTK_NODE_IMAGE_EXPANDED,
-                                                        "pixbuf-expander-closed", IUPGTK_NODE_IMAGE, 
+                                                        "pixbuf-expander-closed", IUPGTK_NODE_IMAGE,
                                                             NULL);
   iupAttribSet(ih, "_IUPGTK_RENDERER_IMG", (char*)renderer_img);
 
   renderer_txt = gtk_cell_renderer_text_new();
   gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(column), renderer_txt, TRUE);
+#if GTK_CHECK_VERSION(3, 4, 0)
   gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer_txt, "text", IUPGTK_NODE_TITLE,
                                                                  "is-expander", IUPGTK_NODE_KIND,
                                                                    "font-desc", IUPGTK_NODE_FONT,
-                                                              "foreground-gdk", IUPGTK_NODE_COLOR, 
+                                                              "foreground-rgba", IUPGTK_NODE_COLOR,
                                                                   NULL);
+#else
+  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(column), renderer_txt, "text", IUPGTK_NODE_TITLE,
+                                                                 "is-expander", IUPGTK_NODE_KIND,
+                                                                   "font-desc", IUPGTK_NODE_FONT,
+                                                              "foreground-gdk", IUPGTK_NODE_COLOR,
+                                                                  NULL);
+#endif
   iupAttribSet(ih, "_IUPGTK_RENDERER_TEXT", (char*)renderer_txt);
 
   if (ih->data->show_rename)
@@ -2941,7 +3048,7 @@
 
   gtk_container_add((GtkContainer*)scrolled_window, ih->handle);
   gtk_widget_show((GtkWidget*)scrolled_window);
-  gtk_scrolled_window_set_shadow_type(scrolled_window, GTK_SHADOW_IN); 
+  gtk_scrolled_window_set_shadow_type(scrolled_window, GTK_SHADOW_IN);
 
   gtk_scrolled_window_set_policy(scrolled_window, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
 
@@ -2956,7 +3063,7 @@
 
   /* callbacks */
   g_signal_connect(selection,            "changed", G_CALLBACK(gtkTreeSelectionChanged), ih);
-  
+
   g_signal_connect(renderer_txt, "editing-started", G_CALLBACK(gtkTreeCellTextEditingStarted), ih);
   g_signal_connect(renderer_txt,          "edited", G_CALLBACK(gtkTreeCellTextEdited), ih);
 
@@ -2986,14 +3093,48 @@
   gtk_widget_realize(ih->handle);
 
   /* Initialize the default images */
-  ih->data->def_image_leaf = iupImageGetImage(iupAttribGetStr(ih, "IMAGELEAF"), ih, 0, NULL);
-  ih->data->def_image_collapsed = iupImageGetImage(iupAttribGetStr(ih, "IMAGEBRANCHCOLLAPSED"), ih, 0, NULL);
-  ih->data->def_image_expanded = iupImageGetImage(iupAttribGetStr(ih, "IMAGEBRANCHEXPANDED"), ih, 0, NULL);
+  {
+    char* img_name = iupAttribGetStr(ih, "IMAGELEAF");
+    if (img_name && !iupStrEqualNoCase(img_name, "IMGLEAF"))
+      ih->data->def_image_leaf = iupImageGetImage(img_name, ih, 0, NULL);
+    else
+    {
+      ih->data->def_image_leaf = gtkTreeGetThemeIcon(ih, "text-x-generic", 16);
+      if (ih->data->def_image_leaf)
+        iupAttribSet(ih, "_IUPGTK_THEMED_LEAF", (char*)ih->data->def_image_leaf);
+    }
+  }
 
+  {
+    char* img_name = iupAttribGetStr(ih, "IMAGEBRANCHCOLLAPSED");
+    if (img_name && !iupStrEqualNoCase(img_name, "IMGCOLLAPSED"))
+      ih->data->def_image_collapsed = iupImageGetImage(img_name, ih, 0, NULL);
+    else
+    {
+      ih->data->def_image_collapsed = gtkTreeGetThemeIcon(ih, "folder", 16);
+      if (ih->data->def_image_collapsed)
+        iupAttribSet(ih, "_IUPGTK_THEMED_COLLAPSED", (char*)ih->data->def_image_collapsed);
+    }
+  }
+
+  {
+    char* img_name = iupAttribGetStr(ih, "IMAGEBRANCHEXPANDED");
+    if (img_name && !iupStrEqualNoCase(img_name, "IMGEXPANDED"))
+      ih->data->def_image_expanded = iupImageGetImage(img_name, ih, 0, NULL);
+    else
+    {
+      ih->data->def_image_expanded = gtkTreeGetThemeIcon(ih, "folder-open", 16);
+      if (!ih->data->def_image_expanded)
+        ih->data->def_image_expanded = gtkTreeGetThemeIcon(ih, "folder", 16);
+      if (ih->data->def_image_expanded)
+        iupAttribSet(ih, "_IUPGTK_THEMED_EXPANDED", (char*)ih->data->def_image_expanded);
+    }
+  }
+
   if (iupAttribGetInt(ih, "ADDROOT"))
     iupdrvTreeAddNode(ih, -1, ITREE_BRANCH, "", 0);
 
-  /* configure for DRAG&DROP of files */
+  /* configure for DROP of files */
   if (IupGetCallback(ih, "DROPFILES_CB"))
     iupAttribSet(ih, "DROPFILESTARGET", "YES");
 
@@ -3009,8 +3150,23 @@
 
 static void gtkTreeUnMapMethod(Ihandle* ih)
 {
+  GdkPixbuf* pixbuf;
+
   ih->data->node_count = 0;
 
+  /* Free themed icons if they were created */
+  pixbuf = (GdkPixbuf*)iupAttribGet(ih, "_IUPGTK_THEMED_LEAF");
+  if (pixbuf)
+    g_object_unref(pixbuf);
+
+  pixbuf = (GdkPixbuf*)iupAttribGet(ih, "_IUPGTK_THEMED_COLLAPSED");
+  if (pixbuf)
+    g_object_unref(pixbuf);
+
+  pixbuf = (GdkPixbuf*)iupAttribGet(ih, "_IUPGTK_THEMED_EXPANDED");
+  if (pixbuf)
+    g_object_unref(pixbuf);
+
   iupdrvBaseUnMapMethod(ih);
 }
 
@@ -3078,4 +3234,7 @@
 
   /* IupTree Attributes - GTK Only */
   iupClassRegisterAttribute  (ic, "RUBBERBAND", NULL, NULL, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
+
+  /* Not Supported */
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/gtk/iupgtk_val.c
===================================================================
--- src/gtk/iupgtk_val.c	(revision 5971)
+++ src/gtk/iupgtk_val.c	(working copy)
@@ -33,9 +33,59 @@
 
 void iupdrvValGetMinSize(Ihandle* ih, int *w, int *h)
 {
-  /* LAYOUT_DECORATION_ESTIMATE */
+#if GTK_CHECK_VERSION(3, 0, 0)
+  static int horiz_min_w = -1, horiz_min_h = -1;
+  static int vert_min_w = -1, vert_min_h = -1;
+
+  if (horiz_min_w < 0)
+  {
+    GtkWidget* temp_window = gtk_offscreen_window_new();
+    GtkAdjustment* adj = GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 1.0, 0.01, 0.1, 0));
+    GtkWidget* temp_horiz = gtk_scale_new(GTK_ORIENTATION_HORIZONTAL, adj);
+    GtkWidget* temp_vert = gtk_scale_new(GTK_ORIENTATION_VERTICAL, adj);
+    GtkRequisition horiz_req, vert_req;
+
+    gtk_scale_set_draw_value(GTK_SCALE(temp_horiz), FALSE);
+    gtk_scale_set_draw_value(GTK_SCALE(temp_vert), FALSE);
+
+    GtkWidget* box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+    gtk_box_pack_start(GTK_BOX(box), temp_horiz, FALSE, FALSE, 0);
+    gtk_box_pack_start(GTK_BOX(box), temp_vert, FALSE, FALSE, 0);
+    gtk_container_add(GTK_CONTAINER(temp_window), box);
+
+    gtk_widget_show_all(temp_window);
+    gtk_widget_realize(temp_window);
+
+    gtk_widget_get_preferred_size(temp_horiz, NULL, &horiz_req);
+    gtk_widget_get_preferred_size(temp_vert, NULL, &vert_req);
+
+    horiz_min_w = horiz_req.width;
+    horiz_min_h = horiz_req.height;
+    vert_min_w = vert_req.width;
+    vert_min_h = vert_req.height;
+
+    if (horiz_min_w < 20) horiz_min_w = 20;
+    if (horiz_min_h < 20) horiz_min_h = 20;
+    if (vert_min_w < 20) vert_min_w = 20;
+    if (vert_min_h < 20) vert_min_h = 20;
+
+    gtk_widget_destroy(temp_window);
+  }
+
   if (ih->data->orientation == IVAL_HORIZONTAL)
   {
+    *w = horiz_min_w;
+    *h = horiz_min_h;
+  }
+  else
+  {
+    *w = vert_min_w;
+    *h = vert_min_h;
+  }
+#else
+  /* GTK2 fallback */
+  if (ih->data->orientation == IVAL_HORIZONTAL)
+  {
     *w = 20;
     *h = 35;
   }
@@ -44,6 +94,7 @@
     *w = 35;
     *h = 20;
   }
+#endif
 }
 
 static int gtkValSetStepAttrib(Ihandle* ih, const char* value)
Index: src/iup.def
===================================================================
--- src/iup.def	(revision 5971)
+++ src/iup.def	(working copy)
@@ -733,4 +733,38 @@
 iupwinStrToSystemFilename
 iupwinStrToSystemLen
 iupwinStrWide2Char
-iupwinPostMessageFilter
\ No newline at end of file
+iupwinPostMessageFilter
+
+
+iupdrvTraySetMenu
+iupdrvTableSetFocusCell
+iupdrvTableSetShowGrid
+iupdrvTraySetImage
+iupdrvPopoverInitClass
+iupdrvTableAddBorders
+iupdrvTableAddLin
+iupdrvTableInitClass
+iupdrvTableRedraw
+iupdrvNotifyClose
+iupdrvTableSetNumCol
+iupdrvNotifyShow
+iupdrvNotifyInitClass
+iupdrvTableSetColWidth
+iupdrvTableAddCol
+iupdrvTraySetTip
+iupdrvTableGetCellValue
+iupdrvTraySetVisible
+iupdrvTableGetRowHeight
+iupdrvTrayDestroy
+iupdrvTableSetCellValue
+iupdrvTableSetColTitle
+iupdrvNotifyDestroy
+iupdrvTrayInitClass
+iupdrvTableGetHeaderHeight
+iupdrvTableScrollToCell
+iupdrvTableGetFocusCell
+iupdrvTableGetColTitle
+iupdrvTableGetColWidth
+iupdrvTableDelCol
+iupdrvTableDelLin
+iupdrvTableSetNumLin
Index: src/iup_attrib.c
===================================================================
--- src/iup_attrib.c	(revision 5971)
+++ src/iup_attrib.c	(working copy)
@@ -1440,7 +1440,7 @@
     if (!ih)
       return NULL;
 
-    value = iupAttribGet(ih, name);
+    value = iupAttribGetStr(ih, name);
   }
 
   return value;
Index: src/iup_classinfo.c
===================================================================
--- src/iup_classinfo.c	(revision 5971)
+++ src/iup_classinfo.c	(working copy)
@@ -437,9 +437,6 @@
 	IupSetAttributes(box,"MARGIN=8x8, GAP=4");
 
   dialog = IupDialog(box);
-  IupSetAttribute(dialog, "RESIZE", "NO");
-  IupSetAttribute(dialog, "MAXBOX", "NO");
-  IupSetAttribute(dialog, "MINBOX", "NO");
   IupSetAttributeHandle(dialog, "DEFAULTENTER", ok_bt);
   IupSetAttributeHandle(dialog, "DEFAULTESC", ok_bt);
   if (parent) IupSetAttributeHandle(dialog, "PARENTDIALOG", parent);
Index: src/iup_config.c
===================================================================
--- src/iup_config.c	(revision 5971)
+++ src/iup_config.c	(working copy)
@@ -15,19 +15,16 @@
 #include "iup_config.h"
 #include "iup_linefile.h"
 #include "iup_str.h"
+#include "iup_drv.h"
 #include "iup_attrib.h"
 #include "iup_assert.h"
-
 #include "iup_drvinfo.h"
 
-#if defined(__APPLE__)
-#import <TargetConditionals.h>
-#endif
 
 #define GROUPKEYSIZE 100
 #define MAX_LINES 500
+#define MAX_RECENT 100
 
-
 static char* strGetGroupKeyName(const char* group, const char* key)
 {
   static char str[GROUPKEYSIZE];
@@ -57,47 +54,49 @@
 {
   char* app_name;
   char* app_path;
-  int app_config, app_system;
-  
+  int app_config;
+  int use_system;
   char filename[10240] = "";
+
   char* app_filename = IupGetAttribute(ih, "APP_FILENAME");
   if (app_filename)
     return app_filename;
 
   app_name = IupGetAttribute(ih, "APP_NAME");
-  app_path = IupGetAttribute(ih, "APP_PATH");
-  app_config = IupGetInt(ih, "APP_CONFIG");
-  app_system = IupGetInt(ih, "APP_SYSTEMPATH");
+  if (!app_name)
+    app_name = IupGetGlobal("APPNAME");
+  if (!app_name)
+    app_name = IupGetGlobal("APPID");
 
   if (!app_name)
     return NULL;
 
-  if (!app_config && iupdrvGetPreferencePath(filename, app_system))
+  app_path = IupGetAttribute(ih, "APP_PATH");
+  app_config = IupGetInt(ih, "APP_CONFIG");
+
+  /* Use system/XDG paths by default, APP_SYSTEMPATH=NO for legacy paths */
+  use_system = 1;
+  if (IupGetAttribute(ih, "APP_SYSTEMPATH"))
+    use_system = IupGetInt(ih, "APP_SYSTEMPATH");
+
+  if (!app_config && iupdrvGetPreferencePath(filename, app_name, use_system))
   {
-#if defined(__ANDROID__) || defined(__APPLE__) || defined(WIN32) || defined(__EMSCRIPTEN__)
-    strcat(filename, app_name);
-    strcat(filename, ".cfg");
-#else
-    /* UNIX format */
-    strcat(filename, ".");
-    strcat(filename, app_name);
-#endif
+    /* Driver returns full path including filename */
   }
   else
   {
+    /* APP_CONFIG mode: use APP_PATH as base directory */
     if (!app_path)
       return NULL;
 
-    strcat(filename, app_path);
+    strcpy(filename, app_path);
 #if defined(__ANDROID__) || defined(__APPLE__) || defined(WIN32) || defined(__EMSCRIPTEN__)
-    /* these platforms shouldn't use a .dot file */
+    strcat(filename, app_name);
+    strcat(filename, ".cfg");
 #else
     /* Unix generic hidden dot prefix */
     strcat(filename, ".");
-#endif
     strcat(filename, app_name);
-#if defined(__ANDROID__) || defined(__APPLE__) || defined(WIN32) || defined(__EMSCRIPTEN__)
-    strcat(filename, ".cfg");
 #endif
   }
 
@@ -416,12 +415,8 @@
   }
 }
 
-
 /******************************************************************/
 
-/* macOS/Cocoa needs a completely different implementation, so exclude Mac/Cocoa from compiling this. */
-#if !defined(__APPLE__) || !defined(TARGET_OS_OSX)
-
 static const char* iConfigGetRecentAttribName(const char* recent_name, const char* base_name)
 {
   if (recent_name)
@@ -434,23 +429,6 @@
     return base_name;
 }
 
-static int iConfigItemRecent_CB(Ihandle* ih_item)
-{
-  Icallback recent_cb = IupGetCallback(ih_item, "RECENT_CB");
-  if (recent_cb)
-  {
-    Ihandle* ih = (Ihandle*)IupGetAttribute(ih_item, "_IUP_CONFIG");
-    IupSetStrAttribute(ih, "TITLE", IupGetAttribute(ih_item, "RECENTFILENAME"));  /* backward compatibility */
-    ih->parent = ih_item;
-
-    recent_cb(ih);
-
-    ih->parent = NULL;
-    IupSetAttribute(ih, "TITLE", NULL);
-  }
-  return IUP_DEFAULT;
-}
-
 static int iConfigListRecent_CB(Ihandle* list, char *text, int item, int state)
 {
   (void)item;
@@ -478,68 +456,71 @@
   return IUP_DEFAULT;
 }
 
-static void iConfigBuildRecentMenu(Ihandle* ih, Ihandle* menu, int max_recent, const char* group_name, Icallback recent_cb)
+static void iConfigBuildRecentList(Ihandle* ih, Ihandle* list, int max_recent, const char* group_name, Icallback recent_cb)
 {
-  /* add the new items, reusing old ones */
-  int i;
-  int mapped = IupGetAttribute(menu, "WID") != NULL ? 1 : 0;
+  int i, count;
   const char* value;
 
-  i = 1;
-  do
+  IupSetAttribute(list, "REMOVEITEM", "ALL");
+
+  count = 0;
+  for (i = 1; i <= max_recent; i++)
   {
     value = IupConfigGetVariableStrId(ih, group_name, "File", i);
-    if (value)
-    {
-      Ihandle* item = IupGetChild(menu, i - 1);
-      if (item)
-        IupSetStrAttribute(item, "TITLE", value);
-      else
-      {
-        item = IupItem(value, NULL);
-        IupSetAttribute(item, "_IUP_CONFIG", (char*)ih);
-        IupSetCallback(item, "ACTION", iConfigItemRecent_CB);
-        IupSetCallback(item, "RECENT_CB", recent_cb);
-        IupAppend(menu, item);
-        if (mapped) IupMap(item);
-      }
+    if (!value || value[0] == '\0')
+      break;
+    count++;
+    IupSetStrAttributeId(list, "", count, value);
+  }
 
-      IupSetStrAttribute(item, "RECENTFILENAME", value); /* TITLE will convert the string to a native representation, so RECENTFILENAME will keep the original value */
-    }
-    i++;
-  } while (value && i <= max_recent);
+  IupSetCallback(list, "RECENT_CB", recent_cb);
+  IupSetAttribute(list, "_IUP_CONFIG", (char*)ih);
+
+  if (iupStrEqual(IupGetClassName(list), "flatlist"))
+    IupSetCallback(list, "FLAT_ACTION", (Icallback)iConfigListRecent_CB);
+  else
+    IupSetCallback(list, "ACTION", (Icallback)iConfigListRecent_CB);
 }
 
-static void iConfigBuildRecentList(Ihandle* ih, Ihandle* list, int max_recent, const char* group_name, Icallback recent_cb)
+static void iConfigUpdateRecentMenu(Ihandle* ih, Ihandle* menu, int max_recent, const char* group_name, Icallback recent_cb)
 {
-  /* add the new items, reusing old ones */
+  const char* filenames[MAX_RECENT];
+  int count = 0;
   int i;
-  const char* value;
 
-  IupSetAttribute(list, "1", NULL);
+  for (i = 1; i <= max_recent && count < MAX_RECENT; i++)
+  {
+    const char* value = IupConfigGetVariableStrId(ih, group_name, "File", i);
+    if (!value || value[0] == '\0')
+      break;
+    filenames[count++] = value;
+  }
 
-  i = 1;
-  do
+  iupdrvRecentMenuUpdate(menu, filenames, count, recent_cb);
+}
+
+static int iConfigRecentMenuMapCB(Ihandle* menu)
+{
+  Ihandle* ih = (Ihandle*)IupGetAttribute(menu, "_IUP_CONFIG");
+  if (ih)
   {
-    value = IupConfigGetVariableStrId(ih, group_name, "File", i);
-    if (value)
-      IupSetStrAttributeId(list, "", i, value);
-    i++;
-  } while (value && i <= max_recent);
+    char* recent_name = IupGetAttribute(ih, "RECENTNAME");
+    const char* group_name = recent_name;
+    int max_recent;
+    Icallback recent_cb;
 
+    if (!group_name) group_name = "Recent";
 
-  IupSetCallback(list, "RECENT_CB", recent_cb);
-  IupSetAttribute(list, "_IUP_CONFIG", (char*)ih);
+    max_recent = IupGetInt(ih, iConfigGetRecentAttribName(recent_name, "RECENTMAX"));
+    recent_cb = IupGetCallback(ih, iConfigGetRecentAttribName(recent_name, "RECENT_CB"));
 
-  if (iupStrEqual(IupGetClassName(list), "flatlist"))
-    IupSetCallback(list, "FLAT_ACTION", (Icallback)iConfigListRecent_CB);
-  else
-    IupSetCallback(list, "ACTION", (Icallback)iConfigListRecent_CB);
+    iConfigUpdateRecentMenu(ih, menu, max_recent, group_name, recent_cb);
+  }
+  return IUP_DEFAULT;
 }
 
 IUP_API void IupConfigRecentInit(Ihandle* ih, Ihandle* menu_list, Icallback recent_cb, int max_recent)
 {
-
   char* recent_name = IupGetAttribute(ih, "RECENTNAME");
   const char* group_name = recent_name;
   if (!group_name) group_name = "Recent";
@@ -549,8 +530,19 @@
 
   if (iupStrEqual(IupGetClassName(menu_list), "menu"))
   {
+    int already_init = (IupGetAttribute(menu_list, "_IUP_CONFIG") != NULL);
+    int is_mapped = (menu_list->handle != NULL) || (IupGetAttribute(menu_list, "_IUP_RECENT_GMENU") != NULL);
+
     IupSetAttribute(ih, iConfigGetRecentAttribName(recent_name, "RECENTMENU"), (char*)menu_list);
-    iConfigBuildRecentMenu(ih, menu_list, max_recent, group_name, recent_cb);
+    IupSetAttribute(menu_list, "_IUP_CONFIG", (char*)ih);
+
+    if (!already_init)
+      iupdrvRecentMenuInit(menu_list, max_recent, recent_cb);
+
+    if (is_mapped)
+      iConfigUpdateRecentMenu(ih, menu_list, max_recent, group_name, recent_cb);
+    else if (!already_init)
+      IupSetCallback(menu_list, "MAP_CB", (Icallback)iConfigRecentMenuMapCB);
   }
   else
   {
@@ -573,11 +565,9 @@
   value = IupConfigGetVariableStr(ih, group_name, "File1");
   if (value && !iupStrEqual(value, filename))
   {
-    /* must update the stack */
     int found = 0;
+    int i = 1;
 
-    /* First search for the new filename to avoid duplicates */
-    int i = 1;
     do
     {
       value = IupConfigGetVariableStrId(ih, group_name, "File", i);
@@ -596,7 +586,6 @@
     else
       i = max_recent;
 
-    /* simply open space for the new filename */
     do
     {
       value = IupConfigGetVariableStrId(ih, group_name, "File", i - 1);
@@ -606,32 +595,16 @@
     } while (i > 1);
   }
 
-  /* push new at start always */
   IupConfigSetVariableStr(ih, group_name, "File1", filename);
 
   if (menu)
-    iConfigBuildRecentMenu(ih, menu, max_recent, group_name, recent_cb);
-  else
+    iConfigUpdateRecentMenu(ih, menu, max_recent, group_name, recent_cb);
+  if (list)
     iConfigBuildRecentList(ih, list, max_recent, group_name, recent_cb);
 }
-#else
 
-/* NOT supported in MacOS for now */
-
-IUP_API void IupConfigRecentInit(Ihandle* ih, Ihandle* menu_list, Icallback recent_cb, int max_recent)
-{
-}
-
-IUP_API void IupConfigRecentUpdate(Ihandle* ih, const char* filename)
-{
-}
-
-#endif /* macOS/Cocoa */
-
-
 /*******************************************************************/
 
-
 IUP_API void IupConfigDialogShow(Ihandle* ih, Ihandle* dialog, const char* name)
 {
   int shown = 0;
Index: src/iup_datepick.c
===================================================================
--- src/iup_datepick.c	(revision 5971)
+++ src/iup_datepick.c	(working copy)
@@ -23,6 +23,9 @@
 #include "iup_drvfont.h"
 #include "iup_register.h"
 #include "iup_childtree.h"
+#include "iup_mask.h"
+#include "iup_array.h"
+#include "iup_text.h"
 
 
 static int is_leap_year(int year)
@@ -73,31 +76,28 @@
 static int iDatePickCalendarValueChanged_CB(Ihandle* ih_calendar)
 {
   Ihandle* ih = (Ihandle*)iupAttribGet(ih_calendar, "_IUP_DATEPICK");
+  Ihandle* ih_toggle = (Ihandle*)iupAttribGet(ih_calendar, "_IUP_DATEPICK_TOGGLE");
+  Ihandle* popover = (Ihandle*)iupAttribGet(ih, "_IUP_POPOVER");
 
   IupSetStrAttribute(ih, "VALUE", IupGetAttribute(ih_calendar, "VALUE"));
 
   iupBaseCallValueChangedCb(ih);
-  return IUP_DEFAULT;
-}
 
-static int iDatePickCalendarKillFocus_CB(Ihandle* ih_calendar)
-{
-  Ihandle* ih_toggle = (Ihandle*)iupAttribGet(ih_calendar, "_IUP_DATEPICK_TOGGLE");
-  if (!iupAttribGet(ih_toggle, "_IUP_DATEPICK_INSIDETOGGLE"))
-    IupSetAttribute(ih_toggle, "VALUE", "OFF");
-  IupHide(IupGetDialog(ih_calendar));
-  return IUP_DEFAULT;
-}
+  IupSetAttribute(ih_toggle, "VALUE", "OFF");
+  if (popover)
+    IupSetAttribute(popover, "VISIBLE", "NO");
 
-static int iDatePickToggleEnterWindow_CB(Ihandle* ih_toggle)
-{
-  iupAttribSet(ih_toggle, "_IUP_DATEPICK_INSIDETOGGLE", "1");
   return IUP_DEFAULT;
 }
 
-static int iDatePickToggleLeaveWindow_CB(Ihandle* ih_toggle)
+static int iDatePickPopoverShow_CB(Ihandle* popover, int state)
 {
-  iupAttribSet(ih_toggle, "_IUP_DATEPICK_INSIDETOGGLE", NULL);
+  if (state == IUP_HIDE)
+  {
+    Ihandle* ih_toggle = (Ihandle*)iupAttribGet(popover, "_IUP_DATEPICK_TOGGLE");
+    if (ih_toggle)
+      IupSetAttribute(ih_toggle, "VALUE", "OFF");
+  }
   return IUP_DEFAULT;
 }
 
@@ -104,15 +104,13 @@
 static int iDatePickToggleAction_CB(Ihandle* ih_toggle, int state)
 {
   Ihandle* ih = IupGetParent(IupGetParent(ih_toggle));
+  Ihandle* popover = (Ihandle*)iupAttribGet(ih, "_IUP_POPOVER");
   Ihandle* calendar = (Ihandle*)iupAttribGet(ih, "_IUP_CALENDAR");
 
   if (state == 1)
   {
-    int x, y;
-
-    if (!calendar)
+    if (!popover)
     {
-      Ihandle* dlg;
       char* weeknumbers;
 
       calendar = IupCalendar();
@@ -119,32 +117,27 @@
       weeknumbers = iupAttribGet(ih, "CALENDARWEEKNUMBERS");
       if (weeknumbers) IupSetStrAttribute(calendar, "WEEKNUMBERS", weeknumbers);
       IupSetCallback(calendar, "VALUECHANGED_CB", iDatePickCalendarValueChanged_CB);
-      IupSetCallback(calendar, "KILLFOCUS_CB", iDatePickCalendarKillFocus_CB);
       iupAttribSet(calendar, "_IUP_DATEPICK", (char*)ih);
       iupAttribSet(calendar, "_IUP_DATEPICK_TOGGLE", (char*)ih_toggle);
       iupAttribSet(ih, "_IUP_CALENDAR", (char*)calendar);
 
-      dlg = IupDialog(calendar);
-      IupSetAttribute(dlg, "BORDER", "NO");
-      IupSetAttribute(dlg, "MENUBOX", "NO");
-      IupSetAttribute(dlg, "MAXBOX", "NO");
-      IupSetAttribute(dlg, "MINBOX", "NO");
-      IupSetAttribute(dlg, "RESIZE", "NO");
+      popover = IupPopover(calendar);
+      IupSetAttributeHandle(popover, "ANCHOR", ih);
+      IupSetAttribute(popover, "POSITION", "BOTTOM");
+      IupSetAttribute(popover, "ARROW", "NO");
+      IupSetAttribute(popover, "AUTOHIDE", "NO");
+      IupSetCallback(popover, "SHOW_CB", (Icallback)iDatePickPopoverShow_CB);
+      iupAttribSet(popover, "_IUP_DATEPICK_TOGGLE", (char*)ih_toggle);
+      iupAttribSet(ih, "_IUP_POPOVER", (char*)popover);
     }
 
     IupSetStrAttribute(calendar, "VALUE", IupGetAttribute(ih, "VALUE"));
-
-    x = IupGetInt(ih, "X");
-    y = IupGetInt(ih, "Y");
-    y += IupGetInt2(ih, "RASTERSIZE");
-
-    IupShowXY(IupGetDialog(calendar), x, y);
-    IupSetFocus(calendar);
+    IupSetAttribute(popover, "VISIBLE", "YES");
   }
   else
   {
-    if (calendar)
-      IupHide(IupGetDialog(calendar));
+    if (popover)
+      IupSetAttribute(popover, "VISIBLE", "NO");
   }
 
   return IUP_DEFAULT;
@@ -163,11 +156,13 @@
 
 static int iDatePickTextKAny_CB(Ihandle* ih_text, int key)
 {
+  Ihandle* ih = IupGetParent(IupGetParent(ih_text));
+
   if (key == K_UP || key == K_plus || key == K_sPlus)
   {
     int value = IupGetInt(ih_text, "VALUE");
     value++;
-    if (iupAttribGetBoolean(ih_text, "ZEROPRECED"))
+    if (iupAttribGetBoolean(ih, "ZEROPRECED"))
       IupSetStrf(ih_text, "VALUEMASKED", "%02d", value);
     else
       IupSetInt(ih_text, "VALUEMASKED", value);
@@ -180,7 +175,7 @@
   {
     int value = IupGetInt(ih_text, "VALUE");
     value--;
-    if (iupAttribGetBoolean(ih_text, "ZEROPRECED"))
+    if (iupAttribGetBoolean(ih, "ZEROPRECED"))
       IupSetStrf(ih_text, "VALUEMASKED", "%02d", value);
     else
       IupSetInt(ih_text, "VALUEMASKED", value);
@@ -330,7 +325,7 @@
   IupSetAttribute(txt, "MASKINT", "1:31");
   IupSetAttribute(txt, "MASKNOEMPTY", "Yes");
   IupSetAttribute(txt, "NC", "2");
-  IupSetAttribute(txt, "SIZE", "14x");
+  IupSetAttribute(txt, "VISIBLECOLUMNS", "2");
 
   iupAttribSet(ih, "_IUP_DATE_DAY", (char*)txt);
 }
@@ -342,7 +337,7 @@
   IupSetAttribute(txt, "MASKINT", "1:12");
   IupSetAttribute(txt, "MASKNOEMPTY", "Yes");
   IupSetAttribute(txt, "NC", "2");
-  IupSetAttribute(txt, "SIZE", "14x");
+  IupSetAttribute(txt, "VISIBLECOLUMNS", "2");
 
   iupAttribSet(ih, "_IUP_DATE_MONTH", (char*)txt);
 }
@@ -353,7 +348,7 @@
   IupSetAttribute(txt, "MASK", IUP_MASK_UINT);
   IupSetAttribute(txt, "MASKNOEMPTY", "Yes");
   IupSetAttribute(txt, "NC", "4");
-  IupSetAttribute(txt, "SIZE", "26x");
+  IupSetAttribute(txt, "VISIBLECOLUMNS", "4");
 
   iupAttribSet(ih, "_IUP_DATE_YEAR", (char*)txt);
 }
@@ -361,10 +356,18 @@
 static int iDatePickSetOrderAttrib(Ihandle* ih, const char* value)
 {
   int i;
+  int year = 0, month = 0, day = 0;
+  Ihandle* txt_year = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_YEAR");
+  Ihandle* txt_month = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_MONTH");
+  Ihandle* txt_day = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_DAY");
 
   if (!value || strlen(value) != 3)
     return 0;
 
+  if (txt_year) year = IupGetInt(txt_year, "VALUE");
+  if (txt_month) month = IupGetInt(txt_month, "VALUE");
+  if (txt_day) day = IupGetInt(txt_day, "VALUE");
+
   for (i = 0; i < 3; i++)
   {
     if (value[i] == 'D' || value[i] == 'd')
@@ -376,6 +379,27 @@
     else
       return 0;
   }
+
+  txt_year = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_YEAR");
+  txt_month = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_MONTH");
+  txt_day = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_DAY");
+
+  if (year && txt_year) IupSetInt(txt_year, "VALUE", year);
+  if (month && txt_month)
+  {
+    if (iupAttribGetBoolean(ih, "ZEROPRECED"))
+      IupSetStrf(txt_month, "VALUE", "%02d", month);
+    else
+      IupSetInt(txt_month, "VALUE", month);
+  }
+  if (day && txt_day)
+  {
+    if (iupAttribGetBoolean(ih, "ZEROPRECED"))
+      IupSetStrf(txt_day, "VALUE", "%02d", day);
+    else
+      IupSetInt(txt_day, "VALUE", day);
+  }
+
   return 1;
 }
 
@@ -389,7 +413,32 @@
   return iupStrReturnStrf("%d/%d/%d", timeinfo->tm_year + 1900, timeinfo->tm_mon + 1, timeinfo->tm_mday);
 }
 
+static int iDatePickSetZeroprecedAttrib(Ihandle* ih, const char* value)
+{
+  Ihandle* txt_day = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_DAY");
+  Ihandle* txt_month = (Ihandle*)iupAttribGet(ih, "_IUP_DATE_MONTH");
 
+  if (txt_day && txt_month)
+  {
+    int day = IupGetInt(txt_day, "VALUE");
+    int month = IupGetInt(txt_month, "VALUE");
+
+    if (iupStrBoolean(value))
+    {
+      IupSetStrf(txt_day, "VALUE", "%02d", day);
+      IupSetStrf(txt_month, "VALUE", "%02d", month);
+    }
+    else
+    {
+      IupSetInt(txt_day, "VALUE", day);
+      IupSetInt(txt_month, "VALUE", month);
+    }
+  }
+
+  return 1;
+}
+
+
 /*********************************************************************************************/
 
 
@@ -415,12 +464,24 @@
   IupSetAttribute(tgl, "FLAT", "YES");
   IupSetAttribute(tgl, "IGNOREDOUBLECLICK", "YES");
   IupSetCallback(tgl, "ACTION", (Icallback)iDatePickToggleAction_CB);
-  IupSetCallback(tgl, "ENTERWINDOW_CB", (Icallback)iDatePickToggleEnterWindow_CB);
-  IupSetCallback(tgl, "LEAVEWINDOW_CB", (Icallback)iDatePickToggleLeaveWindow_CB);
 
-  box = IupHbox(iDatePickCreateText(), IupLabel("/"), iDatePickCreateText(), IupLabel("/"), iDatePickCreateText(), tgl, NULL);
-  IupSetAttribute(box, "MARGIN", "0x0");
-  IupSetAttribute(box, "GAP", "0");
+  {
+    Ihandle* lbl1 = IupLabel("/");
+    Ihandle* lbl2 = IupLabel("/");
+    int extra_w = 0, extra_h = 0;
+    iupdrvTextAddExtraPadding(NULL, &extra_w, &extra_h);
+    if (extra_h > 0 || extra_w > 0)
+    {
+      int horiz_padding = extra_w / 2;
+      int vert_padding = extra_h / 2;
+      IupSetfAttribute(lbl1, "PADDING", "%dx%d", horiz_padding, vert_padding);
+      IupSetfAttribute(lbl2, "PADDING", "%dx%d", horiz_padding, vert_padding);
+    }
+    box = IupHbox(iDatePickCreateText(), lbl1, iDatePickCreateText(), lbl2, iDatePickCreateText(), tgl, NULL);
+    IupSetAttribute(box, "MARGIN", "0x0");
+    IupSetAttribute(box, "GAP", "0");
+    IupSetAttribute(box, "ALIGNMENT", "ACENTER");
+  }
 
   iupChildTreeAppend(ih, box);
   box->flags |= IUP_INTERNAL;
@@ -439,10 +500,11 @@
 
 static void iDatePickUnMapMethod(Ihandle* ih)
 {
-  Ihandle* calendar = (Ihandle*)iupAttribGet(ih, "_IUP_CALENDAR");
-  if (iupObjectCheck(calendar))
+  Ihandle* popover = (Ihandle*)iupAttribGet(ih, "_IUP_POPOVER");
+  if (iupObjectCheck(popover))
   {
-    IupDestroy(IupGetDialog(calendar));
+    IupDestroy(popover);
+    iupAttribSet(ih, "_IUP_POPOVER", NULL);
     iupAttribSet(ih, "_IUP_CALENDAR", NULL);
   }
 }
@@ -471,7 +533,7 @@
 
   iupClassRegisterAttribute(ic, "SEPARATOR", NULL, iDatePickSetSeparatorAttrib, IUPAF_SAMEASSYSTEM, "/", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "ORDER", NULL, iDatePickSetOrderAttrib, IUPAF_SAMEASSYSTEM, "DMY", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "ZEROPRECED", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ZEROPRECED", NULL, iDatePickSetZeroprecedAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
   iupClassRegisterAttribute(ic, "CALENDARWEEKNUMBERS", NULL, NULL, NULL, NULL, IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "SHOWDROPDOWN", NULL, iDatePickSetShowDropdownAttrib, NULL, NULL, IUPAF_WRITEONLY | IUPAF_NO_INHERIT);
Index: src/iup_dialog.c
===================================================================
--- src/iup_dialog.c	(revision 5971)
+++ src/iup_dialog.c	(working copy)
@@ -408,17 +408,9 @@
   int old_show_state;
 
   /* process all pending messages, make sure the dialog is visible */
-  if (!iupAttribGetBoolean(ih, "NOFLUSH")) {
+  if (!iupAttribGetBoolean(ih, "NOFLUSH"))
     IupFlush();
 
-    /**
-     * check if any callback called by IupFlush() has destroyed the dialog.
-     * if so, there is no point in doing anything else here.
-     */
-    if (!iupObjectCheck(ih))
-      return;
-  }
-
   old_focus = IupGetFocus();
   old_show_state = ih->data->show_state;
 
@@ -463,6 +455,12 @@
 {
   /* Used only in Motif */
   Ihandle* dialog = IupGetDialog(ih);
+  if (!dialog)
+  {
+    /* Element is not inside a dialog (e.g., inside a Popover).
+       Use the element's own address to generate a unique ID. */
+    return iupStrReturnStrf("iup-%s-%p", ih->iclass->name, (void*)ih);
+  }
   return iupStrReturnStrf("iup-%s-%d", ih->iclass->name, dialog->data->child_id);
 }
 
Index: src/iup_draw.c
===================================================================
--- src/iup_draw.c	(revision 5971)
+++ src/iup_draw.c	(working copy)
@@ -175,6 +175,28 @@
   iupdrvDrawArc(dc, x1, y1, x2, y2, a1, a2, color, style, line_width);
 }
 
+IUP_API void IupDrawEllipse(Ihandle* ih, int x1, int y1, int x2, int y2)
+{
+  IdrawCanvas* dc;
+  long color = 0;
+  int style, line_width;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  color = iupDrawStrToColor(iupAttribGetStr(ih, "DRAWCOLOR"), 0);
+
+  line_width = iDrawGetLineWidth(ih);
+  style = iDrawGetStyle(ih);
+
+  iupdrvDrawEllipse(dc, x1, y1, x2, y2, color, style, line_width);
+}
+
 IUP_API void IupDrawPolygon(Ihandle* ih, int* points, int count)
 {
   IdrawCanvas* dc;
@@ -197,6 +219,128 @@
   iupdrvDrawPolygon(dc, points, count, color, style, line_width);
 }
 
+IUP_API void IupDrawPixel(Ihandle* ih, int x, int y)
+{
+  IdrawCanvas* dc;
+  long color = 0;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  color = iupDrawStrToColor(iupAttribGetStr(ih, "DRAWCOLOR"), 0);
+
+  iupdrvDrawPixel(dc, x, y, color);
+}
+
+IUP_API void IupDrawRoundedRectangle(Ihandle* ih, int x1, int y1, int x2, int y2, int corner_radius)
+{
+  IdrawCanvas* dc;
+  long color = 0;
+  int style, line_width;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  color = iupDrawStrToColor(iupAttribGetStr(ih, "DRAWCOLOR"), 0);
+
+  line_width = iDrawGetLineWidth(ih);
+  style = iDrawGetStyle(ih);
+
+  iupdrvDrawRoundedRectangle(dc, x1, y1, x2, y2, corner_radius, color, style, line_width);
+}
+
+IUP_API void IupDrawBezier(Ihandle* ih, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
+{
+  IdrawCanvas* dc;
+  long color = 0;
+  int style, line_width;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  color = iupDrawStrToColor(iupAttribGetStr(ih, "DRAWCOLOR"), 0);
+
+  line_width = iDrawGetLineWidth(ih);
+  style = iDrawGetStyle(ih);
+
+  iupdrvDrawBezier(dc, x1, y1, x2, y2, x3, y3, x4, y4, color, style, line_width);
+}
+
+IUP_API void IupDrawQuadraticBezier(Ihandle* ih, int x1, int y1, int x2, int y2, int x3, int y3)
+{
+  IdrawCanvas* dc;
+  long color = 0;
+  int style, line_width;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  color = iupDrawStrToColor(iupAttribGetStr(ih, "DRAWCOLOR"), 0);
+
+  line_width = iDrawGetLineWidth(ih);
+  style = iDrawGetStyle(ih);
+
+  iupdrvDrawQuadraticBezier(dc, x1, y1, x2, y2, x3, y3, color, style, line_width);
+}
+
+IUP_API void IupDrawLinearGradient(Ihandle* ih, int x1, int y1, int x2, int y2, float angle, const char* color1, const char* color2)
+{
+  IdrawCanvas* dc;
+  long c1, c2;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  c1 = iupDrawStrToColor(color1, 0);
+  c2 = iupDrawStrToColor(color2, 0);
+
+  iupdrvDrawLinearGradient(dc, x1, y1, x2, y2, angle, c1, c2);
+}
+
+IUP_API void IupDrawRadialGradient(Ihandle* ih, int cx, int cy, int radius, const char* colorCenter, const char* colorEdge)
+{
+  IdrawCanvas* dc;
+  long c1, c2;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  c1 = iupDrawStrToColor(colorCenter, 0);
+  c2 = iupDrawStrToColor(colorEdge, 0);
+
+  iupdrvDrawRadialGradient(dc, cx, cy, radius, c1, c2);
+}
+
 static void iDrawRotatePoint(int x, int y, int *rx, int *ry, double sin_theta, double cos_theta)
 {
   double t;
@@ -376,6 +520,21 @@
   iupdrvDrawSetClipRect(dc, x1, y1, x2, y2);
 }
 
+IUP_API void IupDrawSetClipRoundedRect(Ihandle* ih, int x1, int y1, int x2, int y2, int corner_radius)
+{
+  IdrawCanvas* dc;
+
+  iupASSERT(iupObjectCheck(ih));
+  if (!iupObjectCheck(ih))
+    return;
+
+  dc = (IdrawCanvas*)iupAttribGet(ih, "_IUP_DRAW_DC");
+  if (!dc)
+    return;
+
+  iupdrvDrawSetClipRoundedRect(dc, x1, y1, x2, y2, corner_radius);
+}
+
 IUP_API void IupDrawGetClipRect(Ihandle* ih, int *x1, int *y1, int *x2, int *y2)
 {
   IdrawCanvas* dc;
@@ -628,6 +787,76 @@
   iupdrvDrawRectangle(dc, xmin, ymin, xmax, ymax, color, IUP_DRAW_FILL, 1);
 }
 
+IUP_SDK_API void iupFlatDrawRoundedBorder(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int border_width, int corner_radius, const char* fgcolor, const char* bgcolor, int active)
+{
+  long color = 0;
+
+  if (!fgcolor || border_width == 0 || xmin == xmax || ymin == ymax)
+    return;
+
+  iupDrawCheckSwapCoord(xmin, xmax);
+  iupDrawCheckSwapCoord(ymin, ymax);
+
+  color = iupDrawStrToColor(fgcolor, 0);
+  if (!active)
+    color = iFlatDrawColorMakeInactive(color, bgcolor);
+
+  iupdrvDrawRoundedRectangle(dc, xmin, ymin, xmax, ymax, corner_radius, color, IUP_DRAW_STROKE, 1);
+  while (border_width > 1)
+  {
+    border_width--;
+    iupdrvDrawRoundedRectangle(dc, xmin + border_width,
+                                ymin + border_width,
+                                xmax - border_width,
+                                ymax - border_width, corner_radius, color, IUP_DRAW_STROKE, 1);
+  }
+}
+
+IUP_SDK_API void iupFlatDrawRoundedBox(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int corner_radius, const char* fgcolor, const char* bgcolor, int active)
+{
+  long color;
+
+  if (!fgcolor || xmin == xmax || ymin == ymax)
+    return;
+
+  iupDrawCheckSwapCoord(xmin, xmax);
+  iupDrawCheckSwapCoord(ymin, ymax);
+
+  color = iupDrawStrToColor(fgcolor, 0);
+  if (!active)
+    color = iFlatDrawColorMakeInactive(color, bgcolor);
+
+  iupdrvDrawRoundedRectangle(dc, xmin, ymin, xmax, ymax, corner_radius, color, IUP_DRAW_FILL, 1);
+}
+
+IUP_SDK_API void iupFlatDrawGradientBox(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int corner_radius, float angle, const char* color1, const char* color2, const char* bgcolor, int active)
+{
+  long c1, c2;
+
+  if (!color1 || !color2 || xmin == xmax || ymin == ymax)
+    return;
+
+  iupDrawCheckSwapCoord(xmin, xmax);
+  iupDrawCheckSwapCoord(ymin, ymax);
+
+  c1 = iupDrawStrToColor(color1, 0);
+  c2 = iupDrawStrToColor(color2, 0);
+  if (!active)
+  {
+    c1 = iFlatDrawColorMakeInactive(c1, bgcolor);
+    c2 = iFlatDrawColorMakeInactive(c2, bgcolor);
+  }
+
+  if (corner_radius > 0)
+  {
+    iupdrvDrawSetClipRoundedRect(dc, xmin, ymin, xmax, ymax, corner_radius);
+    iupdrvDrawLinearGradient(dc, xmin, ymin, xmax, ymax, angle, c1, c2);
+    iupdrvDrawResetClip(dc);
+  }
+  else
+    iupdrvDrawLinearGradient(dc, xmin, ymin, xmax, ymax, angle, c1, c2);
+}
+
 static void iFlatDrawText(IdrawCanvas* dc, int x, int y, int w, int h, const char* str, const char* font, int text_flags, double text_orientation, const char* fgcolor, const char* bgcolor, int active)
 {
   long color;
Index: src/iup_draw.h
===================================================================
--- src/iup_draw.h	(revision 5971)
+++ src/iup_draw.h	(working copy)
@@ -68,8 +68,11 @@
 IUP_SDK_API const char* iupFlatGetImageNameId(Ihandle* ih, const char* baseattrib, int id, const char* basevalue, int press, int highlight, int active, int *make_inactive);
 
 IUP_SDK_API void iupFlatDrawBorder(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int border_width, const char* color, const char* bgcolor, int active);
+IUP_SDK_API void iupFlatDrawRoundedBorder(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int border_width, int corner_radius, const char* color, const char* bgcolor, int active);
 
 IUP_SDK_API void iupFlatDrawBox(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, const char* color, const char* bgcolor, int active);
+IUP_SDK_API void iupFlatDrawRoundedBox(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int corner_radius, const char* color, const char* bgcolor, int active);
+IUP_SDK_API void iupFlatDrawGradientBox(IdrawCanvas* dc, int xmin, int xmax, int ymin, int ymax, int corner_radius, float angle, const char* color1, const char* color2, const char* bgcolor, int active);
 
 IUP_SDK_API void iupFlatDrawGetIconSize(Ihandle* ih, int img_position, int spacing, int horiz_padding, int vert_padding,
                             const char* imagename, const char* title, int *w, int *h, double text_orientation);
Index: src/iup_drv.h
===================================================================
--- src/iup_drv.h	(revision 5971)
+++ src/iup_drv.h	(working copy)
@@ -111,7 +111,23 @@
  * \ingroup drv */
 IUP_SDK_API void iupdrvSetAccessibleTitle(Ihandle *ih, const char* title);
 
+/** Sets the application identifier (for Wayland/XDG desktop file name).
+ * \ingroup drv */
+IUP_SDK_API int iupdrvSetGlobalAppIDAttrib(const char* value);
 
+/** Sets the application name (for taskbar, dock, window manager).
+ * \ingroup drv */
+IUP_SDK_API int iupdrvSetGlobalAppNameAttrib(const char* value);
+
+/** Initializes recent menu structure. Called once during IupConfigRecentInit.
+ * \ingroup drv */
+IUP_SDK_API int iupdrvRecentMenuInit(Ihandle* menu, int max_recent, Icallback recent_cb);
+
+/** Updates recent menu with new file list. Called during IupConfigRecentUpdate.
+ * \ingroup drv */
+IUP_SDK_API int iupdrvRecentMenuUpdate(Ihandle* menu, const char** filenames, int count, Icallback recent_cb);
+
+
 /* Called only from IupOpen/IupClose. */
 int iupdrvOpen(int *argc, char ***argv);
 void iupdrvClose(void);
Index: src/iup_drvdraw.h
===================================================================
--- src/iup_drvdraw.h	(revision 5971)
+++ src/iup_drvdraw.h	(working copy)
@@ -58,11 +58,42 @@
  * \ingroup drvdraw */
 IUP_SDK_API void iupdrvDrawArc(IdrawCanvas* dc, int x1, int y1, int x2, int y2, double a1, double a2, long color, int style, int line_width);
 
+/** Draws a filled/hollow ellipse inscribed in rectangle (x1,y1)-(x2,y2).
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawEllipse(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width);
+
 /** Draws a filled/hollow polygon.
  * points are arranged xyxyxy...
  * \ingroup drvdraw */
 IUP_SDK_API void iupdrvDrawPolygon(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width);
 
+/** Draws a single pixel.
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawPixel(IdrawCanvas* dc, int x, int y, long color);
+
+/** Draws a filled/hollow rounded rectangle.
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawRoundedRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width);
+
+/** Draws a cubic Bezier curve.
+ * (x1,y1) = start point, (x2,y2) = first control point, (x3,y3) = second control point, (x4,y4) = end point
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width);
+
+/** Draws a quadratic Bezier curve.
+ * (x1,y1) = start point, (x2,y2) = control point, (x3,y3) = end point
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawQuadraticBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width);
+
+/** Draws a linear gradient between two colors.
+ * angle: 0=horizontal right, 90=vertical down, 180=horizontal left, 270=vertical up
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawLinearGradient(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2);
+
+/** Draws a radial gradient from center to edge.
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawRadialGradient(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge);
+
 #define IUP_DRAW_LEFT     0x0000
 #define IUP_DRAW_CENTER   0x0001
 #define IUP_DRAW_RIGHT    0x0002
@@ -85,6 +116,10 @@
  * \ingroup drvdraw */
 IUP_SDK_API void iupdrvDrawSetClipRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2);
 
+/** Sets a rounded rectangle clipping area.
+ * \ingroup drvdraw */
+IUP_SDK_API void iupdrvDrawSetClipRoundedRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius);
+
 /** Removes clipping.
  * \ingroup drvdraw */
 IUP_SDK_API void iupdrvDrawResetClip(IdrawCanvas* dc);
Index: src/iup_drvinfo.h
===================================================================
--- src/iup_drvinfo.h	(revision 5971)
+++ src/iup_drvinfo.h	(working copy)
@@ -83,11 +83,10 @@
  * \ingroup drvinfo */
 IUP_SDK_API char* iupdrvLocaleInfo(void);
 
-/** Returns the path to the preference directory.
- * Path will always have a trailing slash.
- * Return 1 on success, 0 on failure.
+/** Returns the full path to a configuration file for the given app name.
+ * Creates necessary directories if they don't exist.
  * \ingroup drvinfo */
-IUP_SDK_API int iupdrvGetPreferencePath(char *filename, int use_system);
+IUP_SDK_API int iupdrvGetPreferencePath(char *filename, const char *app_name, int use_system);
 
 /** Changes the current directory.
 * \ingroup drvinfo */
Index: src/iup_elempropdlg.c
===================================================================
--- src/iup_elempropdlg.c	(revision 5971)
+++ src/iup_elempropdlg.c	(working copy)
@@ -539,38 +539,6 @@
     break;
   }
 
-  /* In GTK the TIP appears for all children */
-  /* TODO: move this code to iupgtk_tabs.c */
-  if (iupStrEqualNoCase(IupGetGlobal("DRIVER"), "GTK"))
-  {
-    char* tabtype = IupGetAttribute(ih, "TABTYPE");
-    int x = 0;
-    int y = 0;
-    int w = ih->currentwidth;
-    int h = ih->currentheight;
-    int cw = 0, ch = 0;
-
-    IupGetIntInt(ih, "CLIENTSIZE", &cw, &ch);
-
-    /* TABORIENTATION is ignored */
-    if (iupStrEqualNoCase(tabtype, "BOTTOM"))
-    {
-      y += ch;  /* position after the client area */
-      h -= ch;
-    }
-    else if (iupStrEqualNoCase(tabtype, "RIGHT"))
-    {
-      x += cw;  /* position after the client area */
-      w -= cw;
-    }
-    else if (iupStrEqualNoCase(tabtype, "LEFT"))
-      w -= cw;
-    else  /* TOP */
-      h -= ch;
-
-    IupSetfAttribute(ih, "TIPRECT", "%d %d %d %d", x, y, x + w, y + h);
-  }
-
   IupSetAttribute(ih, "TIPVISIBLE", "YES");
   return IUP_DEFAULT;
 }
Index: src/iup_filedlg.c
===================================================================
--- src/iup_filedlg.c	(revision 5971)
+++ src/iup_filedlg.c	(working copy)
@@ -64,6 +64,7 @@
   iupClassRegisterAttribute(ic, "MULTIVALUEPATH", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "EXTDEFAULT", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "MULTIPLEFILES", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "PORTAL", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 
   iupClassRegisterAttribute(ic, "FILEEXIST", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);
   iupClassRegisterAttribute(ic, "STATUS", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT|IUPAF_READONLY);
Index: src/iup_flatbutton.c
===================================================================
--- src/iup_flatbutton.c	(revision 5971)
+++ src/iup_flatbutton.c	(working copy)
@@ -111,6 +111,7 @@
   if (draw_border)
   {
     char* bordercolor = iupAttribGetStr(ih, "BORDERCOLOR");
+    int corner_radius = iupAttribGetInt(ih, "CORNERRADIUS");
 
     if ((ih->data->pressed && ih->data->highlighted) || (selected && !ih->data->highlighted))
     {
@@ -125,9 +126,14 @@
         bordercolor = hlcolor;
     }
 
-    iupFlatDrawBorder(dc, 0, ih->currentwidth - 1, 
-                          0, ih->currentheight - 1, 
-                          border_width, bordercolor, bgcolor, active);
+    if (corner_radius > 0)
+      iupFlatDrawRoundedBorder(dc, 0, ih->currentwidth - 1,
+                                0, ih->currentheight - 1,
+                                border_width, corner_radius, bordercolor, bgcolor, active);
+    else
+      iupFlatDrawBorder(dc, 0, ih->currentwidth - 1,
+                            0, ih->currentheight - 1,
+                            border_width, bordercolor, bgcolor, active);
   }
 
   /* simulate pressed when selected and has images (but colors and borders are not included) */
@@ -146,10 +152,47 @@
       iupdrvDrawImage(dc, draw_image, make_inactive, bgcolor, border_width, border_width, -1, -1);
   }
   else
-    iupFlatDrawBox(dc, border_width, ih->currentwidth - 1 - border_width,
-                       border_width, ih->currentheight - 1 - border_width,
-                       bgcolor, NULL, 1);  /* background is always active */
+  {
+    char* gradient = iupAttribGet(ih, "GRADIENT");
+    int corner_radius = iupAttribGetInt(ih, "CORNERRADIUS");
 
+    if ((ih->data->pressed && ih->data->highlighted) || (selected && !ih->data->highlighted))
+    {
+      char* pressgrad = iupAttribGet(ih, "GRADIENTPS");
+      if (pressgrad)
+        gradient = pressgrad;
+    }
+    else if (ih->data->highlighted)
+    {
+      char* hlgrad = iupAttribGet(ih, "GRADIENTHL");
+      if (hlgrad)
+        gradient = hlgrad;
+    }
+
+    if (gradient)
+    {
+      char color1[30], color2[30];
+      float angle = iupAttribGetFloat(ih, "GRADIENTANGLE");
+      if (angle == 0) angle = 90;  /* default is top to bottom */
+      if (iupStrToStrStr(gradient, color1, color2, ':'))
+        iupFlatDrawGradientBox(dc, border_width, ih->currentwidth - 1 - border_width,
+                                border_width, ih->currentheight - 1 - border_width,
+                                corner_radius, angle, color1, color2, bgcolor, 1);  /* background is always active */
+      else
+        iupFlatDrawGradientBox(dc, border_width, ih->currentwidth - 1 - border_width,
+                                border_width, ih->currentheight - 1 - border_width,
+                                corner_radius, angle, gradient, bgcolor, bgcolor, 1);
+    }
+    else if (corner_radius > 0)
+      iupFlatDrawRoundedBox(dc, border_width, ih->currentwidth - 1 - border_width,
+                             border_width, ih->currentheight - 1 - border_width,
+                             corner_radius, bgcolor, NULL, 1);  /* background is always active */
+    else
+      iupFlatDrawBox(dc, border_width, ih->currentwidth - 1 - border_width,
+                         border_width, ih->currentheight - 1 - border_width,
+                         bgcolor, NULL, 1);  /* background is always active */
+  }
+
   /* reserve space for focus feedback (after background draw) */
   if (iupAttribGetBoolean(ih, "CANFOCUS") && focus_feedback)
     border_width++;
@@ -777,6 +820,12 @@
   iupClassRegisterAttribute(ic, "BACKIMAGEZOOM", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FITTOBACKIMAGE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 
+  iupClassRegisterAttribute(ic, "CORNERRADIUS", NULL, iFlatButtonSetAttribPostRedraw, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "GRADIENT", NULL, iFlatButtonSetAttribPostRedraw, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "GRADIENTHL", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "GRADIENTPS", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "GRADIENTANGLE", NULL, iFlatButtonSetAttribPostRedraw, IUPAF_SAMEASSYSTEM, "90", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);
+
   iupClassRegisterAttribute(ic, "FRONTIMAGE", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FRONTIMAGEPRESS", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FRONTIMAGEHIGHLIGHT", NULL, NULL, NULL, NULL, IUPAF_IHANDLENAME | IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
Index: src/iup_flatlabel.c
===================================================================
--- src/iup_flatlabel.c	(revision 5971)
+++ src/iup_flatlabel.c	(working copy)
@@ -51,9 +51,13 @@
   int text_flags = iupDrawGetTextFlags(ih, "TEXTALIGNMENT", "TEXTWRAP", "TEXTELLIPSIS");
   double text_orientation = iupAttribGetDouble(ih, "TEXTORIENTATION");
   const char* draw_image;
-  IdrawCanvas* dc = iupdrvDrawCreateCanvas(ih);
+  IdrawCanvas* dc;
   int make_inactive = 0;
 
+  dc = iupdrvDrawCreateCanvas(ih);
+  if (!dc)
+    return IUP_DEFAULT;
+
   iupDrawParentBackground(dc, ih);
 
   if (!bgcolor)
@@ -69,9 +73,11 @@
       iupdrvDrawImage(dc, draw_image, make_inactive, bgcolor, 0, 0, -1, -1);
   }
   else
+  {
     iupFlatDrawBox(dc, 0, ih->currentwidth - 1,
                            0, ih->currentheight - 1,
                            bgcolor, NULL, 1);  /* background is always active */
+  }
 
   draw_image = iupFlatGetImageName(ih, "IMAGE", image, 0, 0, active, &make_inactive);
   iupFlatDrawIcon(ih, dc, 0, 0,
Index: src/iup_font.c
===================================================================
--- src/iup_font.c	(revision 5971)
+++ src/iup_font.c	(working copy)
@@ -445,8 +445,9 @@
   int i;
   for (i = 0; i < STYLE_NUM_NAMES; i++)
   {
-    /* iupStrEqualPartial(style_names[i].name, name) */
-    if (strncmp(style_names[i].name, name, len)==0)
+    /* Case-insensitive comparison to handle formats like "COURIER_NORMAL_14" */
+    if (strlen(style_names[i].name) == (size_t)len &&
+        strncasecmp(style_names[i].name, name, len) == 0)
     {
       *style = style_names[i].style;
       return 1;
@@ -456,7 +457,7 @@
   return 0;
 }
 
-#define is_style_sep(_x) (_x == ' ' || _x == ',')
+#define is_style_sep(_x) (_x == ' ' || _x == ',' || _x == '_')
 
 /* this code is shared between CD and IUP, must be updated on both libraries */
 static const char * iFontGetStyleWord(const char *str, const char *last, int *wordlen)
Index: src/iup_globalattrib.c
===================================================================
--- src/iup_globalattrib.c	(revision 5971)
+++ src/iup_globalattrib.c	(working copy)
@@ -136,13 +136,25 @@
   if (iupStrEqual(name, "MOUSEBUTTON"))
   {
     int x, y, status;
-    char bt; 
+    char bt;
     if (value && sscanf(value, "%dx%d %c %d", &x, &y, &bt, &status) == 4)
       iupdrvSendMouse(x, y, bt, status);
     return;
   }
+  if (iupStrEqual(name, "APPID"))
+  {
+    if (iupdrvSetGlobalAppIDAttrib(value))
+      iGlobalTableSet(name, value, store);
+    return;
+  }
+  if (iupStrEqual(name, "APPNAME"))
+  {
+    if (iupdrvSetGlobalAppNameAttrib(value))
+      iGlobalTableSet(name, value, store);
+    return;
+  }
 
-  if (iGlobalChangingDefaultColor(name) || 
+  if (iGlobalChangingDefaultColor(name) ||
       iupdrvSetGlobal(name, value))
     iGlobalTableSet(name, value, store);
 }
@@ -240,16 +252,12 @@
   static struct {
     const char *name;
   } ptr_table[] = {
-#ifndef GTK_MAC
-  #ifdef WIN32
     {"HINSTANCE"},
     {"DLL_HINSTANCE"},
-  #else
     {"XDISPLAY"},
     {"XSCREEN"},
     {"APPSHELL"},
-  #endif
-#endif
+    {"WL_DISPLAY"},
   };
 #define PTR_TABLE_SIZE ((sizeof ptr_table)/(sizeof ptr_table[0]))
 
Index: src/iup_globalsdlg.c
===================================================================
--- src/iup_globalsdlg.c	(revision 5971)
+++ src/iup_globalsdlg.c	(working copy)
@@ -23,104 +23,121 @@
   int windows;
   int motif;
   int gtk;
+  int cocoa;
+  int qt;
+  int gtk4;
+  int efl;
   int readonly;
 } iRegisteredGlobal;
 
 /* sorted alphabetically */
-static iRegisteredGlobal global_attribs[] = { 
-  { "APPSHELL", 0, 0, 1, 1 }, 
-  { "ARGV0", 0, 0, 1, 0 },
-  { "AUTOREPEAT", 0, 1, 0, 0 }, 
-  { "COMCTL32VER6", 1, 0, 0, 1 }, 
-  { "COMPUTERNAME", 1, 1, 1, 1 }, 
-  { "CONTROLKEY", 1, 1, 1, 1 }, 
-  { "COPYRIGHT", 1, 1, 1, 1 }, 
-  { "CURSORPOS", 1, 1, 1, 0 }, 
-  { "DEFAULTBUTTONPADDING", 1, 1, 1, 0 },
-  { "DEFAULTDECIMALSYMBOL", 1, 1, 1, 0 }, 
-  { "DEFAULTFONT", 1, 1, 1, 0 }, 
-  { "DEFAULTFONTFACE", 1, 1, 1, 0 }, 
-  { "DEFAULTFONTSIZE", 1, 1, 1, 0 }, 
-  { "DEFAULTFONTSTYLE", 1, 1, 1, 0 }, 
-  { "DEFAULTPRECISION", 1, 1, 1, 0 },
-  { "DEFAULTTHEME", 1, 1, 1, 0 }, 
-  { "DLGBGCOLOR", 1, 1, 1, 0 }, 
-  { "DLGFGCOLOR", 1, 1, 1, 0 },
-  { "DLL_HINSTANCE", 1, 0, 0, 1 }, 
-  { "DRAWUSEDIRECT2D", 1, 0, 0, 0 },
-  { "DRIVER", 1, 1, 1, 1 }, 
-  { "DWM_COMPOSITION", 1, 0, 0, 1 }, 
-  { "EXEFILENAME", 1, 1, 1, 1 },
-  { "EXITLOOP", 1, 1, 1, 0 }, 
-  { "FREETYPEFONTS_DIR", 1, 1, 1, 0 },
-  { "FULLSIZE", 1, 1, 1, 1 }, 
-  { "GLOBALLAYOUTDLGKEY", 1, 1, 1, 0 }, 
-  { "GLOBALLAYOUTRESIZEKEY", 1, 1, 1, 0 }, 
-  { "GLOBALMENU", 0, 0, 1, 0 },
-  { "GL_RENDERER", 1, 1, 1, 1 }, 
-  { "GL_VENDOR", 1, 1, 1, 1 }, 
-  { "GL_VERSION", 1, 1, 1, 1 }, 
-  { "GTKDEVVERSION", 0, 0, 1, 1 },
-  { "GTKVERSION", 0, 0, 1, 1 }, 
-  { "HELPAPP", 0, 1, 1, 0 },
-  { "HINSTANCE", 1, 0, 0, 1 },
-  { "ICON", 1, 1, 1, 0 },
-  { "IMAGEAUTOSCALE", 1, 1, 1, 0 }, 
-  { "IMAGEEXPORT_STATIC", 1, 1, 1, 0 },
-  { "IMAGESDPI", 1, 1, 1, 0 }, 
-  { "IMAGESTOCKAUTOSCALE", 1, 1, 1, 0 },
-  { "IMAGESTOCKSIZE", 1, 1, 1, 0 }, 
-  { "INPUTCALLBACKS", 1, 1, 1, 0 }, 
-  { "IUPIM_LASTERROR", 1, 1, 1, 1 },
-  { "IUPLUA_THREADED", 1, 1, 1, 0 }, 
-  { "KEY", 1, 1, 1, 1 }, 
-  { "KEYPRESS", 1, 1, 1, 1 }, 
-  { "KEYRELEASE", 1, 1, 1, 1 }, 
-  { "LANGUAGE", 1, 1, 1, 0 },
-  { "LASTERROR", 1, 0, 0, 0 }, 
-  { "LEXERLUA", 1, 1, 1, 0 },
-  { "LINKFGCOLOR", 1, 1, 1, 0 },
-  { "LOCKLOOP", 1, 1, 1, 0 },
-  { "LUA_ERROR_LABEL", 1, 1, 1, 0 },
-  { "MENUBGCOLOR", 1, 0, 0, 0 }, 
-  { "MENUFGCOLOR", 1, 0, 0, 1 }, 
-  { "MGLFONTS", 1, 1, 1, 0 },
-  { "MODKEYSTATE", 1, 1, 1, 1 }, 
-  { "MONITORSCOUNT", 1, 0, 1, 1 }, 
-  { "MONITORSINFO", 1, 0, 1, 1 }, 
-  { "MOTIFNUMBER", 0, 1, 0, 1 }, 
-  { "MOTIFVERSION", 0, 1, 0, 1 }, 
-  { "MOUSEBUTTON", 1, 1, 1, 1 },
-  { "OVERLAYSCROLLBAR", 0, 0, 1, 0 }, 
-  { "PARENTDIALOG", 1, 1, 1, 0 },
-  { "SB_BGCOLOR", 0, 1, 1, 0 }, 
-  { "SCINTILLA_VERSION", 1, 1, 1, 1 },
-  { "SCREENDEPTH", 1, 1, 1, 1 }, 
-  { "SCREENDPI", 1, 1, 1, 1 }, 
-  { "SCREENSIZE", 1, 1, 1, 1 }, 
-  { "SCROLLBARSIZE", 1, 1, 1, 1 }, 
-  { "SHIFTKEY", 1, 1, 1, 1 }, 
-  { "SHOWMENUIMAGES", 0, 0, 1, 0 }, 
-  { "SINGLEINSTANCE", 1, 0, 0, 0 }, 
-  { "SYSTEM", 1, 1, 1, 1 }, 
-  { "SYSTEMLANGUAGE", 1, 1, 1, 1 },
-  { "SYSTEMLOCALE", 1, 1, 1, 1 }, 
-  { "SYSTEMVERSION", 1, 1, 1, 1 }, 
-  { "TREEIMAGE24", 1, 1, 1, 0 },
-  { "TRUECOLORCANVAS", 1, 1, 1, 1 },
-  { "TXTBGCOLOR", 1, 1, 1, 0 }, 
-  { "TXTFGCOLOR", 1, 1, 1, 0 }, 
-  { "TXTHLCOLOR", 1, 1, 1, 0 }, 
-  { "USERNAME", 1, 1, 1, 1 }, 
-  { "UTF8MODE", 1, 0, 1, 0 }, 
-  { "UTF8MODE_FILE", 1, 0, 0, 0 }, 
-  { "VERSION", 1, 1, 1, 1 }, 
-  { "VIRTUALSCREEN", 1, 0, 1, 1 }, 
-  { "XDISPLAY", 0, 1, 1, 1 }, 
-  { "XSCREEN", 0, 1, 1, 1 }, 
-  { "XSERVERVENDOR", 0, 1, 1, 1 }, 
-  { "XVENDORRELEASE", 0, 1, 1, 1 },
-  { NULL, 0, 0, 0, 0 }
+static iRegisteredGlobal global_attribs[] = {
+  { "APPID", 0, 0, 1, 0, 1, 1, 1, 0 },
+  { "APPNAME", 1, 0, 0, 1, 1, 0, 1, 0 },
+  { "APPSHELL", 0, 1, 1, 0, 0, 1, 0, 1 },
+  { "ARGV0", 0, 0, 1, 0, 1, 1, 1, 0 },
+  { "AUTOREPEAT", 0, 1, 0, 0, 0, 0, 1, 0 },
+  { "COMCTL32VER6", 1, 0, 0, 0, 0, 0, 0, 1 },
+  { "COMPUTERNAME", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "CONTROLKEY", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "COPYRIGHT", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "CURSORPOS", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DARKMODE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "DEFAULTBUTTONPADDING", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DEFAULTDECIMALSYMBOL", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DEFAULTFONT", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DEFAULTFONTFACE", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DEFAULTFONTSIZE", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DEFAULTFONTSTYLE", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DEFAULTPRECISION", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DEFAULTTHEME", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DLGBGCOLOR", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DLGFGCOLOR", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "DLL_HINSTANCE", 1, 0, 0, 0, 0, 0, 0, 1 },
+  { "DRIVER", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "DWM_COMPOSITION", 1, 0, 0, 0, 0, 0, 1, 1 },
+  { "EFLTHEME", 0, 0, 0, 0, 0, 0, 1, 0 },
+  { "EFLTHEMEDATA", 0, 0, 0, 0, 0, 0, 1, 0 },
+  { "EFLTHEMEDATALEN", 0, 0, 0, 0, 0, 0, 1, 0 },
+  { "EFLVERSION", 0, 0, 0, 0, 0, 0, 1, 1 },
+  { "EXEFILENAME", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "EXITLOOP", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "FREETYPEFONTS_DIR", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "FULLSIZE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "GLOBALLAYOUTDLGKEY", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "GLOBALLAYOUTRESIZEKEY", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "GLOBALMENU", 0, 0, 1, 0, 0, 0, 1, 0 },
+  { "GL_RENDERER", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "GL_VENDOR", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "GL_VERSION", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "GTKDEVVERSION", 0, 0, 1, 0, 0, 1, 0, 1 },
+  { "GTKVERSION", 0, 0, 1, 0, 0, 1, 0, 1 },
+  { "HELPAPP", 0, 1, 1, 0, 0, 1, 1, 0 },
+  { "HINSTANCE", 1, 0, 0, 0, 0, 0, 0, 1 },
+  { "ICON", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "IMAGEAUTOSCALE", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "IMAGEEXPORT_STATIC", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "IMAGESDPI", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "IMAGESTOCKAUTOSCALE", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "IMAGESTOCKSIZE", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "INPUTCALLBACKS", 1, 1, 1, 1, 1, 0, 0, 0 },
+  { "IUPIM_LASTERROR", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "IUPLUA_THREADED", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "KEY", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "KEYPRESS", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "KEYRELEASE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "LANGUAGE", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "LASTERROR", 1, 0, 0, 0, 0, 0, 0, 0 },
+  { "LEXERLUA", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "LINKFGCOLOR", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "LOCKLOOP", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "LUA_ERROR_LABEL", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "MENUBGCOLOR", 1, 0, 0, 1, 1, 0, 1, 0 },
+  { "MENUFGCOLOR", 1, 0, 0, 1, 1, 0, 1, 1 },
+  { "MGLFONTS", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "MODKEYSTATE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "MONITORSCOUNT", 1, 0, 1, 1, 1, 1, 1, 1 },
+  { "MONITORSINFO", 1, 0, 1, 1, 1, 1, 1, 1 },
+  { "MOTIFNUMBER", 0, 1, 0, 0, 0, 0, 0, 1 },
+  { "MOTIFVERSION", 0, 1, 0, 0, 0, 0, 0, 1 },
+  { "MOUSEBUTTON", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "OVERLAYSCROLLBAR", 0, 0, 1, 0, 0, 1, 0, 0 },
+  { "PARENTDIALOG", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "QTBUILDTYPE", 0, 0, 0, 0, 1, 0, 0, 1 },
+  { "QTDEVVERSION", 0, 0, 0, 0, 1, 0, 0, 1 },
+  { "QTSTYLE", 0, 0, 0, 0, 1, 0, 0, 1 },
+  { "QTVERSION", 0, 0, 0, 0, 1, 0, 0, 1 },
+  { "SB_BGCOLOR", 0, 1, 1, 0, 0, 1, 0, 0 },
+  { "SANDBOX", 0, 0, 1, 0, 1, 1, 0, 1 },
+  { "SCINTILLA_VERSION", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SCREENDEPTH", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SCREENDPI", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SCREENSIZE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SCROLLBARSIZE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SHIFTKEY", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SHOWMENUIMAGES", 0, 0, 1, 0, 1, 1, 1, 0 },
+  { "SINGLEINSTANCE", 1, 0, 0, 0, 0, 0, 0, 0 },
+  { "SYSTEM", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SYSTEMLANGUAGE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SYSTEMLOCALE", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "SYSTEMVERSION", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "TREEIMAGE24", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "TRUECOLORCANVAS", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "TXTBGCOLOR", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "TXTFGCOLOR", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "TXTHLCOLOR", 1, 1, 1, 1, 1, 1, 1, 0 },
+  { "USERNAME", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "UTF8MODE", 1, 0, 1, 1, 1, 1, 1, 0 },
+  { "UTF8MODE_FILE", 1, 0, 0, 0, 0, 0, 0, 0 },
+  { "VERSION", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "VIRTUALSCREEN", 1, 0, 1, 1, 1, 1, 1, 1 },
+  { "WINDOWING", 1, 1, 1, 1, 1, 1, 1, 1 },
+  { "WL_DISPLAY", 0, 0, 1, 0, 0, 1, 1, 1 },
+  { "XDISPLAY", 0, 1, 1, 0, 0, 1, 1, 1 },
+  { "XSCREEN", 0, 1, 1, 0, 0, 1, 1, 1 },
+  { "XSERVERVENDOR", 0, 1, 1, 0, 0, 1, 0, 1 },
+  { "XVENDORRELEASE", 0, 1, 1, 0, 0, 1, 0, 1 },
+  { NULL, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 static int iGlobalGetRegisteredAttributesCount(void)
@@ -229,14 +246,20 @@
   }
 
   total_count = iGlobalGetRegisteredAttributesCount();
-  
+
   j = 0;
   for (i = 0; i < total_count; i++)
   {
     if (!(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "GTK") && global_attribs[i].gtk) &&
         !(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "Motif") && global_attribs[i].motif) &&
-        !(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "Win32") && global_attribs[i].windows))
+        !(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "Win32") && global_attribs[i].windows) &&
+        !(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "Cocoa") && global_attribs[i].cocoa) &&
+        !(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "Qt") && global_attribs[i].qt) &&
+        !(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "GTK4") && global_attribs[i].gtk4) &&
+        !(iupStrEqualNoCase(IupGetGlobal("DRIVER"), "EFL") && global_attribs[i].efl))
+    {
         continue;
+    }
 
     IupSetAttributeId(list1, "", j + 1, global_attribs[i].name);
     IupSetIntId(list1, "_IUP_READONLY", j + 1, global_attribs[i].readonly);
@@ -582,38 +605,6 @@
       break;
   }
 
-  /* In GTK the TIP appears for all children */
-  /* TODO: move this code to iupgtk_tabs.c */
-  if (iupStrEqualNoCase(IupGetGlobal("DRIVER"), "GTK"))
-  {
-    char* tabtype = IupGetAttribute(ih, "TABTYPE");
-    int x = 0;
-    int y = 0;
-    int w = ih->currentwidth;
-    int h = ih->currentheight;
-    int cw = 0, ch = 0;
-
-    IupGetIntInt(ih, "CLIENTSIZE", &cw, &ch);
-
-    /* TABORIENTATION is ignored */
-    if (iupStrEqualNoCase(tabtype, "BOTTOM"))
-    {
-      y += ch;  /* position after the client area */
-      h -= ch;
-    }
-    else if (iupStrEqualNoCase(tabtype, "RIGHT"))
-    {
-      x += cw;  /* position after the client area */
-      w -= cw;
-    }
-    else if (iupStrEqualNoCase(tabtype, "LEFT"))
-      w -= cw;
-    else  /* TOP */
-      h -= ch;
-
-    IupSetfAttribute(ih, "TIPRECT", "%d %d %d %d", x, y, x + w, y + h);
-  }
-
   IupSetAttribute(ih, "TIPVISIBLE", "YES");
   return IUP_DEFAULT;
 }
@@ -806,9 +797,6 @@
   iupAttribSet(dlg, "_IUP_PROPLIST2", (char*)list2);
   iupAttribSet(dlg, "_IUP_FUNCLIST", (char*)list3);
   iupAttribSet(dlg, "_IUP_NAMESLIST", (char*)list4);
-  IupSetAttribute(dlg, "SIZE", "250x");
-  IupSetAttribute(dlg, "MINBOX", "NO");
-  IupSetAttribute(dlg, "MAXBOX", "NO");
 
   return dlg;
 }
Index: src/iup_image.c
===================================================================
--- src/iup_image.c	(revision 5971)
+++ src/iup_image.c	(working copy)
@@ -8,6 +8,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <memory.h>
+#include <stdint.h>
 
 #include "iup.h"
 
@@ -21,7 +22,7 @@
 #include "iup_array.h"
 
 
-static void iDataResizeRGBA(int src_width, int src_height, unsigned char *src_map, int dst_width, int dst_height, unsigned char *dst_map, int depth)
+void iupImageResizeRGBA(int src_width, int src_height, unsigned char *src_map, int dst_width, int dst_height, unsigned char *dst_map, int depth)
 {
   /* Do bilinear interpolation */
 
@@ -121,7 +122,7 @@
   if (bpp == 8)
     iDataStretchMap(ih->currentwidth, ih->currentheight, imgdata, new_width, new_height, new_imgdata);
   else
-    iDataResizeRGBA(ih->currentwidth, ih->currentheight, imgdata, new_width, new_height, new_imgdata, channels);
+    iupImageResizeRGBA(ih->currentwidth, ih->currentheight, imgdata, new_width, new_height, new_imgdata, channels);
 
   ih->currentwidth = new_width;
   ih->currentheight = new_height;
@@ -1074,8 +1075,8 @@
   if (!params)
     return IUP_ERROR;
 
-  width = (int)(params[0]);
-  height = (int)(params[1]);
+  width = (int)(intptr_t)(params[0]);
+  height = (int)(intptr_t)(params[1]);
 
   iupASSERT(width > 0);
   iupASSERT(height > 0);
@@ -1095,9 +1096,9 @@
   count = width*height*channels;
   imgdata = (unsigned char *)malloc(count);
 
-  if (((int)(params[2]) == -1) || ((int)(params[3]) == -1)) /* NULL or compacted in one pointer */
+  if (((intptr_t)(params[2]) == -1) || ((intptr_t)(params[3]) == -1)) /* NULL or compacted in one pointer */
   {
-    if ((int)(params[2]) != -1)
+    if ((intptr_t)(params[2]) != -1)
       memcpy(imgdata, params[2], count);
     else
       memset(imgdata, 0, count);
@@ -1107,7 +1108,7 @@
     int i;
     for (i = 0; i < count; i++)
     {
-      imgdata[i] = (unsigned char)((int)(params[i + 2]));
+      imgdata[i] = (unsigned char)((intptr_t)(params[i + 2]));
     }
   }
 
@@ -1161,10 +1162,10 @@
 IUP_API Ihandle* IupImage(int width, int height, const unsigned char *imgdata)
 {
   void *params[4];
-  params[0] = (void*)width;
-  params[1] = (void*)height;
-  params[2] = imgdata ? (void*)imgdata : (void*)-1;
-  params[3] = (void*)-1;
+  params[0] = (void*)(intptr_t)width;
+  params[1] = (void*)(intptr_t)height;
+  params[2] = imgdata ? (void*)imgdata : (void*)(intptr_t)-1;
+  params[3] = (void*)(intptr_t)-1;
   return IupCreatev("image", params);
 }
 
@@ -1171,10 +1172,10 @@
 IUP_API Ihandle* IupImageRGB(int width, int height, const unsigned char *imgdata)
 {
   void *params[4];
-  params[0] = (void*)width;
-  params[1] = (void*)height;
-  params[2] = imgdata ? (void*)imgdata : (void*)-1;
-  params[3] = (void*)-1;
+  params[0] = (void*)(intptr_t)width;
+  params[1] = (void*)(intptr_t)height;
+  params[2] = imgdata ? (void*)imgdata : (void*)(intptr_t)-1;
+  params[3] = (void*)(intptr_t)-1;
   return IupCreatev("imagergb", params);
 }
 
@@ -1181,10 +1182,10 @@
 IUP_API Ihandle* IupImageRGBA(int width, int height, const unsigned char *imgdata)
 {
   void *params[4];
-  params[0] = (void*)width;
-  params[1] = (void*)height;
-  params[2] = imgdata ? (void*)imgdata : (void*)-1;
-  params[3] = (void*)-1;
+  params[0] = (void*)(intptr_t)width;
+  params[1] = (void*)(intptr_t)height;
+  params[2] = imgdata ? (void*)imgdata : (void*)(intptr_t)-1;
+  params[3] = (void*)(intptr_t)-1;
   return IupCreatev("imagergba", params);
 }
 
Index: src/iup_image.h
===================================================================
--- src/iup_image.h	(revision 5971)
+++ src/iup_image.h	(working copy)
@@ -38,6 +38,9 @@
                                unsigned char bg_r, unsigned char bg_g, unsigned char bg_b);
 int iupImageNormBpp(int bpp);
 
+void iupImageResizeRGBA(int src_width, int src_height, unsigned char *src_map,
+                        int dst_width, int dst_height, unsigned char *dst_map, int depth);
+
 #define iupALPHABLEND(_src,_dst,_alpha) (unsigned char)(((_src) * (_alpha) + (_dst) * (255 - (_alpha))) / 255)
 
 /* In Windows, RAW data is a DIB handle. 
Index: src/iup_ledlex.c
===================================================================
--- src/iup_ledlex.c	(revision 5971)
+++ src/iup_ledlex.c	(working copy)
@@ -371,7 +371,7 @@
   va_end(va);
 
   if (ilex.file || ilex.filename)
-    sprintf(ilex_erromsg, "led(%s):\n  -bad input at line %d\n  -%s\n", ilex.filename, ilex.line, msg);
+    snprintf(ilex_erromsg, sizeof(ilex_erromsg), "led(%s):\n  -bad input at line %d\n  -%s\n", ilex.filename, ilex.line, msg);
   else
   {
     const char* f = ilex.buffer;
@@ -378,11 +378,11 @@
     char* firstline = iupStrDupUntil(&f, '\n');
     if (firstline)
     {
-      sprintf(ilex_erromsg, "led(%s):\n  -bad input at line %d\n  -%s\n", firstline, ilex.line, msg);
+      snprintf(ilex_erromsg, sizeof(ilex_erromsg), "led(%s):\n  -bad input at line %d\n  -%s\n", firstline, ilex.line, msg);
       free(firstline);
     }
     else
-      sprintf(ilex_erromsg, "led(%s):\n  -bad input at line %d\n  -%s\n", ilex.buffer, ilex.line, msg);
+      snprintf(ilex_erromsg, sizeof(ilex_erromsg), "led(%s):\n  -bad input at line %d\n  -%s\n", ilex.buffer, ilex.line, msg);
   }
   return n;
 }
Index: src/iup_ledparse.c
===================================================================
--- src/iup_ledparse.c	(revision 5971)
+++ src/iup_ledparse.c	(working copy)
@@ -8,7 +8,8 @@
 #include <stdio.h>
 #include <ctype.h>
 #include <memory.h>
-#include <string.h>         
+#include <string.h>
+#include <stdint.h>
 
 #include "iup.h"
 
@@ -165,18 +166,18 @@
   case 'b':
   case 'c':
     IPARSE_RETURN_IF_ERROR(iupLexMatch(IUPLEX_TK_NAME));
-    return (void*)(unsigned long)iupLexByte();
+    return (void*)(intptr_t)iupLexByte();
 
   case 'i':
   case 'j':
     IPARSE_RETURN_IF_ERROR(iupLexMatch(IUPLEX_TK_NAME));
-    return (void*)(unsigned long)iupLexInt();
+    return (void*)(intptr_t)iupLexInt();
 
   case 'f':
     IPARSE_RETURN_IF_ERROR(iupLexMatch(IUPLEX_TK_NAME));
     {
       float f = iupLexFloat();
-      unsigned long* l = (unsigned long*)&f;
+      intptr_t* l = (intptr_t*)&f;
       return (void*)*l;
     }
 
Index: src/iup_list.c
===================================================================
--- src/iup_list.c	(revision 5971)
+++ src/iup_list.c	(working copy)
@@ -314,6 +314,11 @@
 static int iListGetCount(Ihandle* ih)
 {
   int count;
+
+  /* Virtual mode: return item_count */
+  if (ih->data->is_virtual)
+    return ih->data->item_count;
+
   if (ih->handle)
     count = iupdrvListGetCount(ih);
   else
@@ -325,6 +330,36 @@
   return count;
 }
 
+/* Virtual mode helper functions */
+
+int iupListIsVirtual(Ihandle* ih)
+{
+  return ih->data->is_virtual;
+}
+
+int iupListGetItemCount(Ihandle* ih)
+{
+  if (ih->data->is_virtual)
+    return ih->data->item_count;
+  return iListGetCount(ih);
+}
+
+char* iupListGetItemValueCb(Ihandle* ih, int pos)
+{
+  sIFni value_cb = (sIFni)IupGetCallback(ih, "VALUE_CB");
+  if (value_cb)
+    return value_cb(ih, pos);
+  return NULL;
+}
+
+char* iupListGetItemImageCb(Ihandle* ih, int pos)
+{
+  sIFni image_cb = (sIFni)IupGetCallback(ih, "IMAGE_CB");
+  if (image_cb)
+    return image_cb(ih, pos);
+  return NULL;
+}
+
 static char* iListGetCountAttrib(Ihandle* ih)
 {
   return iupStrReturnInt(iListGetCount(ih));
@@ -413,9 +448,62 @@
 
 static char* iListGetScrollbarAttrib(Ihandle* ih)
 {
-  return iupStrReturnBoolean (ih->data->sb); 
+  return iupStrReturnBoolean (ih->data->sb);
 }
 
+static int iListSetVirtualModeAttrib(Ihandle* ih, const char* value)
+{
+  /* valid only before map */
+  if (ih->handle)
+    return 0;
+
+  /* virtual mode only valid for plain list (not dropdown, not editbox) */
+  if (iupStrBoolean(value))
+  {
+    if (!ih->data->is_dropdown && !ih->data->has_editbox)
+      ih->data->is_virtual = 1;
+  }
+  else
+    ih->data->is_virtual = 0;
+
+  return 0;
+}
+
+static char* iListGetVirtualModeAttrib(Ihandle* ih)
+{
+  return iupStrReturnBoolean(ih->data->is_virtual);
+}
+
+static int iListSetItemCountAttrib(Ihandle* ih, const char* value)
+{
+  int count;
+
+  /* Only valid in virtual mode */
+  if (!ih->data->is_virtual)
+    return 0;
+
+  if (iupStrToInt(value, &count))
+  {
+    if (count < 0)
+      count = 0;
+
+    ih->data->item_count = count;
+
+    /* Update driver if mapped */
+    if (ih->handle)
+      iupdrvListSetItemCount(ih, count);
+  }
+
+  return 0;
+}
+
+static char* iListGetItemCountAttrib(Ihandle* ih)
+{
+  if (ih->data->is_virtual)
+    return iupStrReturnInt(ih->data->item_count);
+  return iupStrReturnInt(iListGetCount(ih));
+}
+
 static char* iListGetMaskAttrib(Ihandle* ih)
 {
   if (!ih->data->has_editbox)
@@ -527,7 +615,6 @@
         iupMaskDestroy(ih->data->mask);
 
       ih->data->mask = mask;
-      return 1; /* store only a valid mask */
     }
   }
 
@@ -568,7 +655,6 @@
         iupMaskDestroy(ih->data->mask);
 
       ih->data->mask = mask;
-      return 1; /* store only a valid mask */
     }
   }
 
@@ -607,7 +693,6 @@
         iupMaskDestroy(ih->data->mask);
 
       ih->data->mask = mask;
-      return 1; /* store only a valid mask */
     }
   }
 
@@ -630,9 +715,20 @@
 
 static char* iListGetShowImageAttrib(Ihandle* ih)
 {
-  return iupStrReturnBoolean (ih->data->show_image); 
+  return iupStrReturnBoolean (ih->data->show_image);
 }
 
+static int iListSetFitImageAttrib(Ihandle* ih, const char* value)
+{
+  ih->data->fit_image = iupStrBoolean(value);
+  return 0;
+}
+
+static char* iListGetFitImageAttrib(Ihandle* ih)
+{
+  return iupStrReturnBoolean(ih->data->fit_image);
+}
+
 int iupListCallDragDropCb(Ihandle* ih, int drag_id, int drop_id, int *is_ctrl)
 {
   IFniiii cbDragDrop = (IFniiii)IupGetCallback(ih, "DRAGDROP_CB");
@@ -700,6 +796,12 @@
   if (!IupClassMatch(ih_source, "list") && !IupClassMatch(ih_source, "flatlist"))
     return IUP_DEFAULT;
 
+  if (pos < 1)
+    return IUP_DEFAULT;
+
+  /* Convert from 1-based IUP index to 0-based driver index */
+  pos--;
+
   /* A copy operation is enabled with the CTRL key pressed, or else a move operation will occur.
      A move operation will be possible only if the attribute DRAGSOURCEMOVE is Yes.
      When no key is pressed the default operation is copy when DRAGSOURCEMOVE=No and move when DRAGSOURCEMOVE=Yes. */
@@ -786,7 +888,7 @@
 
   /* Copy source handle */
   memcpy(data, (void*)&ih, len);
- 
+
   (void)type;
   return IUP_DEFAULT;
 }
@@ -808,6 +910,10 @@
 static int iListDragBegin_CB(Ihandle* ih, int x, int y)
 {
   int pos = IupConvertXYToPos(ih, x, y);
+
+  if (pos < 1)
+    return IUP_IGNORE;
+
   iupAttribSetInt(ih, "_IUP_LIST_SOURCEPOS", pos);
   return IUP_DEFAULT;
 }
@@ -877,6 +983,7 @@
 
   ih->data = iupALLOCCTRLDATA();
   ih->data->sb = 1;
+  ih->data->fit_image = 1;  /* default YES */
 
   return IUP_NOERROR;
 }
@@ -905,7 +1012,7 @@
 
 static void iListGetNaturalItemsSize(Ihandle *ih, int *w, int *h)
 {
-  int visiblecolumns, i, 
+  int visiblecolumns, i,
       max_h = 0,
       count = iListGetCount(ih);
 
@@ -920,6 +1027,11 @@
     *w = iupdrvFontGetStringWidth(ih, "WWWWWWWWWW");
     *w = (visiblecolumns*(*w))/10;
   }
+  else if (ih->data->is_virtual)
+  {
+    /* Virtual mode: don't iterate items, use default width */
+    *w = iupdrvFontGetStringWidth(ih, "WWWWWWWWWWWWWWWWWWWW");  /* 20 chars default */
+  }
   else
   {
     char *value;
@@ -944,16 +1056,63 @@
   if (ih->data->show_image)
   {
     int max_w = 0;
-    for (i=1; i<=count; i++)
+    int available_height = *h + 2 * ih->data->spacing;  /* max height for scaled images */
+
+    if (ih->data->is_virtual)
     {
-      int img_w, img_h;
-      iListGetItemImageInfo(ih, i, &img_w, &img_h);
-      if (img_w > max_w)
-        max_w = img_w;
-      if (img_h > max_h)
-        max_h = img_h;
+      /* For virtual mode, query IMAGE_CB for first item to get image size */
+      char* image_name = iupListGetItemImageCb(ih, 1);
+      if (image_name)
+      {
+        int img_w = 0, img_h = 0;
+        iupImageGetInfo(image_name, &img_w, &img_h, NULL);
+
+        /* Scale image dimensions if needed */
+        if (ih->data->fit_image && img_h > available_height)
+        {
+          max_w = (img_w * available_height) / img_h;
+          max_h = available_height;
+        }
+        else
+        {
+          max_w = img_w;
+          max_h = img_h;
+        }
+      }
+      else
+      {
+        /* Default image size for virtual mode when no image returned */
+        max_w = 16;
+        max_h = 16;
+      }
     }
+    else
+    {
+      for (i=1; i<=count; i++)
+      {
+        int img_w, img_h;
+        int scaled_w, scaled_h;
+        iListGetItemImageInfo(ih, i, &img_w, &img_h);
 
+        /* Scale image dimensions if needed */
+        if (ih->data->fit_image && img_h > available_height)
+        {
+          scaled_w = (img_w * available_height) / img_h;
+          scaled_h = available_height;
+        }
+        else
+        {
+          scaled_w = img_w;
+          scaled_h = img_h;
+        }
+
+        if (scaled_w > max_w)
+          max_w = scaled_w;
+        if (scaled_h > max_h)
+          max_h = scaled_h;
+      }
+    }
+
     /* Used only in Windows */
     ih->data->maximg_w = max_w;
     ih->data->maximg_h = max_h;
@@ -980,11 +1139,13 @@
 
     visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
     if (visiblelines)
-      num_lines = visiblelines;   
+      num_lines = visiblelines;
 
     *h = *h * num_lines;
 
-    if (ih->data->has_editbox) 
+    /* For dropdown editbox: entry is embedded in native control, add a line for it.
+       For plain editbox: entry is separate widget (GTK VBox, etc), driver manages it. */
+    if (ih->data->has_editbox && ih->data->is_dropdown)
       *h += edit_line_size;
   }
   else
@@ -1020,10 +1181,7 @@
   {
     /* add room for scrollbar */
     if (ih->data->sb)
-    {
-      natural_h += sb_size;
-      natural_w += sb_size;
-    }
+      natural_w += sb_size;  /* vertical scrollbar affects horizontal size only */
   }
 
   if (ih->data->has_editbox)
@@ -1086,6 +1244,8 @@
 
   iupClassRegisterCallback(ic, "EDIT_CB", "is");
   iupClassRegisterCallback(ic, "CARET_CB", "iii");
+  iupClassRegisterCallback(ic, "VALUE_CB", "i=s");  /* Virtual mode callback: (int pos) -> string */
+  iupClassRegisterCallback(ic, "IMAGE_CB", "i=s");  /* Virtual mode image callback: (int pos) -> string (image name) */
 
   /* Common Callbacks */
   iupBaseRegisterCommonCallbacks(ic);
@@ -1128,9 +1288,14 @@
   iupClassRegisterAttribute(ic, "VISIBLELINES", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 
   iupClassRegisterAttribute(ic, "SHOWIMAGE", iListGetShowImageAttrib, iListSetShowImageAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "FITIMAGE", iListGetFitImageAttrib, iListSetFitImageAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "SHOWDRAGDROP", iListGetShowDragDropAttrib, iListSetShowDragDropAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "DRAGDROPLIST", NULL, iListSetDragDropListAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
+  /* Virtual mode attributes */
+  iupClassRegisterAttribute(ic, "VIRTUALMODE", iListGetVirtualModeAttrib, iListSetVirtualModeAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ITEMCOUNT", iListGetItemCountAttrib, iListSetItemCountAttrib, NULL, NULL, IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+
   iupdrvListInitClass(ic);
 
   return ic;
Index: src/iup_list.h
===================================================================
--- src/iup_list.h	(revision 5971)
+++ src/iup_list.h	(working copy)
@@ -40,12 +40,12 @@
 void* iupdrvListGetImageHandle(Ihandle* ih, int id);
 int iupdrvListSetImageHandle(Ihandle* ih, int id, void* hImage);
 
-struct _IcontrolData 
+struct _IcontrolData
 {
   int sb,  /* scrollbar configuration, can be changed only before map */
       nc,
       spacing,
-      horiz_padding, 
+      horiz_padding,
       vert_padding,
       last_caret_pos,
       is_multiple,
@@ -53,11 +53,21 @@
       has_editbox,
       maximg_w, maximg_h, /* used only in Windows */
       show_image,
-      show_dragdrop;
+      fit_image,   /* scale images to fit row height, default 1 (YES) */
+      show_dragdrop,
+      is_virtual,  /* virtual mode flag, can be changed only before map */
+      item_count;  /* number of items in virtual mode */
   Imask* mask;
 };
 
+/* Virtual mode support */
+int iupListIsVirtual(Ihandle* ih);
+int iupListGetItemCount(Ihandle* ih);
+char* iupListGetItemValueCb(Ihandle* ih, int pos);
+char* iupListGetItemImageCb(Ihandle* ih, int pos);
+void iupdrvListSetItemCount(Ihandle* ih, int count);
 
+
 #ifdef __cplusplus
 }
 #endif
Index: src/iup_lng_portuguese.h
===================================================================
--- src/iup_lng_portuguese.h	(revision 5971)
+++ src/iup_lng_portuguese.h	(working copy)
@@ -3,31 +3,31 @@
 {
   return IupSetAtt( "PORTUGUESE", IupUser(), 
     "IUP_APPLY", "Aplicar", 
-    "IUP_ATTENTION", "Ateno!", 
+    "IUP_ATTENTION", "Ateno!", 
     "IUP_BLUE", "&Azul:", 
     "IUP_CANCEL", "Cancelar", 
     "IUP_CONTINUE", "Continuar", 
     "IUP_COPY", "Copiar", 
-    "IUP_COPYTOCLIPBOARD", "Copiar texto para a rea de transferncia.", 
-    "IUP_CREATEFOLDER", "Criar Diretrio", 
+    "IUP_COPYTOCLIPBOARD", "Copiar texto para a rea de transferncia.", 
+    "IUP_CREATEFOLDER", "Criar Diretrio", 
     "IUP_ERROR", "Erro!", 
     "IUP_ERRORFILEOPEN", "Falha ao abrir o arquivo.", 
     "IUP_ERRORFILESAVE", "Falha ao salvar o arquivo.", 
     "IUP_EXIT", "Sair", 
     "IUP_FALSE", "Falso", 
-    "IUP_FAMILY", "Famlia:", 
-    "IUP_FILEISDIR", "O nome selecionado  um diretrio.", 
+    "IUP_FAMILY", "Famlia:", 
+    "IUP_FILEISDIR", "O nome selecionado  um diretrio.", 
     "IUP_FILENOTEXIST", "Arquivo inexistente.", 
     "IUP_FILEOVERWRITE", "Sobrescrever arquivo?", 
-    "IUP_GETCOLOR", "Seleo de Cor", 
+    "IUP_GETCOLOR", "Seleo de Cor", 
     "IUP_GREEN", "V&erde:", 
     "IUP_HELP", "Ajuda", 
     "IUP_HUE", "&Matiz:", 
     "IUP_INTENSITY", "&Intensidade:", 
-    "IUP_INVALIDDIR", "Diretrio invlido.", 
+    "IUP_INVALIDDIR", "Diretrio invlido.", 
     "IUP_LUAERROR", "Erro de Lua", 
-    "IUP_NAMENEWFOLDER", "Nome do novo diretrio:", 
-    "IUP_NO", "No", 
+    "IUP_NAMENEWFOLDER", "Nome do novo diretrio:", 
+    "IUP_NO", "No", 
     "IUP_OK", "OK", 
     "IUP_OPACITY", "&Opacidade:", 
     "IUP_OPEN", "Abrir", 
@@ -36,9 +36,9 @@
     "IUP_RESET", "Reinicializar", 
     "IUP_RETRY", "Tentar Novamente", 
     "IUP_SAMPLE", "Exemplo:", 
-    "IUP_SATURATION", "&Saturao:", 
+    "IUP_SATURATION", "&Saturao:", 
     "IUP_SAVEAS", "Salvar Como", 
-    "IUP_SELECTDIR", "Selecionar Diretrio", 
+    "IUP_SELECTDIR", "Selecionar Diretrio", 
     "IUP_SIZE", "Tamanho:", 
     "IUP_STYLE", "Estilo:", 
     "IUP_TRUE", "Verdadeiro", 
Index: src/iup_lng_spanish.h
===================================================================
--- src/iup_lng_spanish.h	(revision 5971)
+++ src/iup_lng_spanish.h	(working copy)
@@ -3,12 +3,12 @@
 {
   return IupSetAtt( "SPANISH", IupUser(), 
     "IUP_APPLY", "Aplicar", 
-    "IUP_ATTENTION", "Advertencia!", 
+    "IUP_ATTENTION", "Advertencia!", 
     "IUP_BLUE", "&Azul:", 
     "IUP_CANCEL", "Cancelar", 
-    "IUP_CONTINUE", "Contine", 
+    "IUP_CONTINUE", "Contine", 
     "IUP_COPY", "Copiar", 
-    "IUP_COPYTOCLIPBOARD", "Copiar texto para un rea de transferencia.", 
+    "IUP_COPYTOCLIPBOARD", "Copiar texto para un rea de transferencia.", 
     "IUP_CREATEFOLDER", "Crear Directorio", 
     "IUP_ERROR", "Error!", 
     "IUP_ERRORFILEOPEN", "Error al abrir el archivo.", 
@@ -18,13 +18,13 @@
     "IUP_FAMILY", "Familia:", 
     "IUP_FILEISDIR", "El nombre seleccionado es un directorio.", 
     "IUP_FILENOTEXIST", "Archivo inexistente.", 
-    "IUP_FILEOVERWRITE", "Sobrescribir archivo?", 
-    "IUP_GETCOLOR", "Seleccin de Color", 
+    "IUP_FILEOVERWRITE", "Sobrescribir archivo?", 
+    "IUP_GETCOLOR", "Seleccin de Color", 
     "IUP_GREEN", "&Verde:", 
     "IUP_HELP", "Ayuda", 
     "IUP_HUE", "&Matiz:", 
     "IUP_INTENSITY", "&Intensidad:", 
-    "IUP_INVALIDDIR", "Directorio invlido.", 
+    "IUP_INVALIDDIR", "Directorio invlido.", 
     "IUP_LUAERROR", "Error de Lua", 
     "IUP_NAMENEWFOLDER", "Nombre del nuevo directorio:", 
     "IUP_NO", "No", 
@@ -36,10 +36,10 @@
     "IUP_RESET", "Reiniciar", 
     "IUP_RETRY", "Reintentar", 
     "IUP_SAMPLE", "Ejemplo:", 
-    "IUP_SATURATION", "&Saturacin:", 
+    "IUP_SATURATION", "&Saturacin:", 
     "IUP_SAVEAS", "Guardar Como", 
     "IUP_SELECTDIR", "Seleccionar Directorio", 
-    "IUP_SIZE", "Tamao:", 
+    "IUP_SIZE", "Tamao:", 
     "IUP_STYLE", "Estilo:", 
     "IUP_TRUE", "Verdadero", 
     "IUP_YES", "Si", NULL );
Index: src/iup_progressbar.c
===================================================================
--- src/iup_progressbar.c	(revision 5971)
+++ src/iup_progressbar.c	(working copy)
@@ -64,6 +64,30 @@
   return iupStrReturnDouble(ih->data->vmax);
 }
 
+static int iProgressBarSetOrientationAttrib(Ihandle* ih, const char* value)
+{
+  int min_w, min_h;
+
+  /* valid only before map */
+  if (ih->handle)
+    return 0;
+
+  iupdrvProgressBarGetMinSize(ih, &min_w, &min_h);
+
+  if (iupStrEqualNoCase(value, "VERTICAL"))
+  {
+    /* progress bar natural vertical size is MinWx200 */
+    IupSetfAttribute(ih, "RASTERSIZE", "%dx%d", min_w, 200);
+  }
+  else /* "HORIZONTAL" */
+  {
+    /* progress bar natural horizontal size is 200xMinH */
+    IupSetfAttribute(ih, "RASTERSIZE", "%dx%d", 200, min_h);
+  }
+
+  return 0; /* do not store value in hash table */
+}
+
 static int iProgressBarCreateMethod(Ihandle* ih, void **params)
 {
   (void)params;
@@ -74,8 +98,8 @@
   ih->data->vmax      = 1;
   ih->data->dashed    = 0;
 
-  /* progress bar default size is 200x30 */
-  IupSetAttribute(ih, "RASTERSIZE", "200x30");
+  /* set default size based on orientation (defaults to HORIZONTAL) */
+  iProgressBarSetOrientationAttrib(ih, "HORIZONTAL");
 
   return IUP_NOERROR;
 }
@@ -119,7 +143,7 @@
   iupClassRegisterAttribute(ic, "MIN", iProgressBarGetMinAttrib, iProgressBarSetMinAttrib, IUPAF_SAMEASSYSTEM, "0", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "MAX", iProgressBarGetMaxAttrib, iProgressBarSetMaxAttrib, IUPAF_SAMEASSYSTEM, "1", IUPAF_NOT_MAPPED | IUPAF_NO_INHERIT);
 
-  iupClassRegisterAttribute(ic, "ORIENTATION", NULL, NULL, IUPAF_SAMEASSYSTEM, "HORIZONTAL", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "ORIENTATION", NULL, iProgressBarSetOrientationAttrib, IUPAF_SAMEASSYSTEM, "HORIZONTAL", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
   iupdrvProgressBarInitClass(ic);
 
Index: src/iup_progressbar.h
===================================================================
--- src/iup_progressbar.h	(revision 5971)
+++ src/iup_progressbar.h	(working copy)
@@ -29,6 +29,7 @@
 char* iProgressBarGetDashedAttrib(Ihandle* ih);
 
 void iupdrvProgressBarInitClass(Iclass* ic);
+void iupdrvProgressBarGetMinSize(Ihandle* ih, int* w, int* h);
 
 #ifdef __cplusplus
 }
Index: src/iup_recplay.c
===================================================================
--- src/iup_recplay.c	(revision 5971)
+++ src/iup_recplay.c	(working copy)
@@ -183,17 +183,29 @@
 static void iPlayReadInt(FILE* file, int *value, int mode)
 {
   if (mode == IUP_RECTEXT)
-    fscanf(file, "%d ", value);
+  {
+    if (fscanf(file, "%d ", value) != 1)
+      *value = 0;
+  }
   else
-    fread(value, sizeof(int), 1, file);
+  {
+    if (fread(value, sizeof(int), 1, file) != 1)
+      *value = 0;
+  }
 }
 
 static void iPlayReadFloat(FILE* file, float *value, int mode)
 {
   if (mode == IUP_RECTEXT)
-    fscanf(file, "%f ", value);
+  {
+    if (fscanf(file, "%f ", value) != 1)
+      *value = 0;
+  }
   else
-    fread(value, sizeof(float), 1, file);
+  {
+    if (fread(value, sizeof(float), 1, file) != 1)
+      *value = 0;
+  }
 }
 
 static void iPlayReadByte(FILE* file, char *value, int mode)
@@ -200,31 +212,42 @@
 {
   if (mode == IUP_RECTEXT)
   {
-    int ivalue;
-    fscanf(file, "%d ", &ivalue);
+    int ivalue = 0;
+    if (fscanf(file, "%d ", &ivalue) != 1)
+      ivalue = 0;
     *value = (char)ivalue;
   }
   else
-    fread(value, 1, 1, file);
+  {
+    if (fread(value, 1, 1, file) != 1)
+      *value = 0;
+  }
 }
 
 static void iPlayReadChar(FILE* file, char *value, int mode)
 {
   if (mode == IUP_RECTEXT)
-    fscanf(file, "%c ", value);
+  {
+    if (fscanf(file, "%c ", value) != 1)
+      *value = 0;
+  }
   else
-    fread(value, 1, 1, file);
+  {
+    if (fread(value, 1, 1, file) != 1)
+      *value = 0;
+  }
 }
 
 static void iPlayReadStr(FILE* file, char* value, int len, int mode)
 {
-  fread(value, 1, len, file);
-  value[len] = 0;
+  size_t n = fread(value, 1, len, file);
+  value[n] = 0;
 
   if (mode == IUP_RECTEXT)
   {
     char spc;
-    fread(&spc, 1, 1, file); /* skip space */
+    if (fread(&spc, 1, 1, file) != 1)
+      return;
   }
 }
 
Index: src/iup_register.c
===================================================================
--- src/iup_register.c	(revision 5971)
+++ src/iup_register.c	(working copy)
@@ -111,6 +111,8 @@
   iupRegisterClassInternal(iupParamNewClass());
 
   iupRegisterClassInternal(iupTimerNewClass());
+  iupRegisterClassInternal(iupTrayNewClass());
+  iupRegisterClassInternal(iupNotifyNewClass());
   iupRegisterClassInternal(iupImageNewClass());
   iupRegisterClassInternal(iupImageRGBNewClass());
   iupRegisterClassInternal(iupImageRGBANewClass());
@@ -149,6 +151,7 @@
   iupRegisterClassInternal(iupFlatSeparatorNewClass());
   iupRegisterClassInternal(iupDropButtonNewClass());
   iupRegisterClassInternal(iupCalendarNewClass());
+  iupRegisterClassInternal(iupPopoverNewClass());
   iupRegisterClassInternal(iupDatePickNewClass());
   iupRegisterClassInternal(iupSpaceNewClass());
 
@@ -158,6 +161,7 @@
   iupRegisterClassInternal(iupSpinNewClass());
   iupRegisterClassInternal(iupSpinboxNewClass());
   iupRegisterClassInternal(iupTreeNewClass());
+  iupRegisterClassInternal(iupTableNewClass());
   iupRegisterClassInternal(iupScrollBoxNewClass());
   iupRegisterClassInternal(iupBackgroundBoxNewClass());
   iupRegisterClassInternal(iupLinkNewClass());
Index: src/iup_stdcontrols.h
===================================================================
--- src/iup_stdcontrols.h	(revision 5971)
+++ src/iup_stdcontrols.h	(working copy)
@@ -77,8 +77,12 @@
 Iclass* iupFlatListNewClass(void);
 Iclass* iupFlatValNewClass(void);
 Iclass* iupFlatTreeNewClass(void);
+Iclass* iupTableNewClass(void);
+Iclass* iupPopoverNewClass(void);
 
 Iclass* iupTimerNewClass(void);
+Iclass* iupTrayNewClass(void);
+Iclass* iupNotifyNewClass(void);
 Iclass* iupImageNewClass(void);
 Iclass* iupImageRGBNewClass(void);
 Iclass* iupImageRGBANewClass(void);
Index: src/iup_str.c
===================================================================
--- src/iup_str.c	(revision 5971)
+++ src/iup_str.c	(working copy)
@@ -595,10 +595,10 @@
   {
     if (sscanf(str, "%u %u %u", &ri, &gi, &bi) != 3) return 0;
   }
-  if (ri > 255 || gi > 255 || bi > 255) return 0;
-  *r = (unsigned char)ri;
-  *g = (unsigned char)gi;
-  *b = (unsigned char)bi;
+  /* Wrap values >255 */
+  *r = (unsigned char)(ri % 256);
+  *g = (unsigned char)(gi % 256);
+  *b = (unsigned char)(bi % 256);
   return 1;
 }
 
@@ -615,11 +615,11 @@
   {
     if (sscanf(str, "%u %u %u %u", &ri, &gi, &bi, &ai) < 3) return 0;
   }
-  if (ri > 255 || gi > 255 || bi > 255 || ai > 255) return 0;
-  *r = (unsigned char)ri;
-  *g = (unsigned char)gi;
-  *b = (unsigned char)bi;
-  *a = (unsigned char)ai;
+  /* Wrap values >255 */
+  *r = (unsigned char)(ri % 256);
+  *g = (unsigned char)(gi % 256);
+  *b = (unsigned char)(bi % 256);
+  *a = (unsigned char)(ai % 256);
   return 1;
 }
 
Index: src/iup_table.c
===================================================================
--- src/iup_table.c	(revision 5971)
+++ src/iup_table.c	(working copy)
@@ -9,6 +9,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <memory.h>
+#include <stdint.h>
 
 #include "iup_export.h"
 #include "iup_table.h"
@@ -610,7 +611,7 @@
   else
   {
     /* Pointer indexed */
-    *keyIndex = (unsigned long)key;   /* this could NOT be dependent from table size */
+    *keyIndex = (uintptr_t)key;   /* this could NOT be dependent from table size */
   }
 
   return (unsigned int)((*keyIndex) % it->entriesSize);
Index: src/iup_tabs.c
===================================================================
--- src/iup_tabs.c	(revision 5971)
+++ src/iup_tabs.c	(working copy)
@@ -30,11 +30,13 @@
   return iupStrReturnIntInt(ih->data->horiz_padding, ih->data->vert_padding, 'x');
 }
 
-static int iTabsGetMaxWidth(Ihandle* ih)
+static void iTabsGetMaxTabSize(Ihandle* ih, int* max_width, int* max_height)
 {
-  int max_width = 0, width, pos;
+  int width, height, pos;
   char *tabtitle, *tabimage;
   Ihandle* child;
+  int max_w = 0;
+  int max_h = 0;
 
   for (pos = 0, child = ih->firstchild; child; child = child->brother, pos++)
   {
@@ -45,55 +47,16 @@
     if (!tabtitle && !tabimage)
       tabtitle = "     ";
 
-    width = 0;
-    if (tabtitle)
-      width += iupdrvFontGetStringWidth(ih, tabtitle);
+    iupdrvTabsGetTabSize(ih, tabtitle, tabimage, &width, &height);
 
-    if (tabimage)
-    {
-      void* img = iupImageGetImage(tabimage, ih, 0, NULL);
-      if (img)
-      {
-        int w;
-        iupdrvImageGetInfo(img, &w, NULL, NULL);
-        width += w;
-      }
-    }
-
-    if (width > max_width) max_width = width;
+    if (width > max_w) max_w = width;
+    if (height > max_h) max_h = height;
   }
 
-  return max_width;
+  if (max_width) *max_width = max_w;
+  if (max_height) *max_height = max_h;
 }
 
-static int iTabsGetMaxHeight(Ihandle* ih)
-{
-  int max_height = 0, h, pos;
-  char *tabimage;
-  Ihandle* child;
-
-  for (pos = 0, child = ih->firstchild; child; child = child->brother, pos++)
-  {
-    tabimage = iupAttribGetId(ih, "TABIMAGE", pos);
-    if (!tabimage) tabimage = iupAttribGet(child, "TABIMAGE");
-
-    if (tabimage)
-    {
-      void* img = iupImageGetImage(tabimage, ih, 0, NULL);
-      if (img)
-      {
-        iupdrvImageGetInfo(img, NULL, &h, NULL);
-        if (h > max_height) max_height = h;
-      }
-    }
-  }
-
-  iupdrvFontGetCharSize(ih, NULL, &h);
-  if (h > max_height) max_height = h;
-
-  return max_height;
-}
-
 static void iTabsGetDecorMargin(int *m, int *s)
 {
   int e = iupdrvTabsExtraMargin();
@@ -104,15 +67,57 @@
 static void iTabsGetDecorSize(Ihandle* ih, int *width, int *height)
 {
   int m, s;
+  int num_tabs = 0;
+  Ihandle* child;
+
   iTabsGetDecorMargin(&m, &s);
 
+  for (child = ih->firstchild; child; child = child->brother)
+    num_tabs++;
+
   if (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT)
   {
     if (ih->data->orientation == ITABS_HORIZONTAL)
     {
-      int max_width = iTabsGetMaxWidth(ih);
-      *width  = m + (3 + max_width + 3) + s + m;
+      int max_width;
+      int total_height = 0;
+      int pos;
+      char *tabtitle, *tabimage;
+      Ihandle* child;
+      int max_w = 0;
+
+      /* Sum individual tab heights for total (handles non-uniform sizing like GTK) */
+      for (pos = 0, child = ih->firstchild; child; child = child->brother, pos++)
+      {
+        int width, height;
+
+        tabtitle = iupAttribGetId(ih, "TABTITLE", pos);
+        if (!tabtitle) tabtitle = iupAttribGet(child, "TABTITLE");
+        tabimage = iupAttribGetId(ih, "TABIMAGE", pos);
+        if (!tabimage) tabimage = iupAttribGet(child, "TABIMAGE");
+        if (!tabtitle && !tabimage)
+          tabtitle = "     ";
+
+        iupdrvTabsGetTabSize(ih, tabtitle, tabimage, &width, &height);
+
+        /* For unmapped tabs, add extra padding */
+        if (!ih->handle)
+        {
+          width = 3 + width + 3;
+          height = 3 + height + 3;
+        }
+
+        total_height += height;
+        if (width > max_w) max_w = width;
+      }
+      max_width = max_w;
+
+      *width  = m + max_width + s + m;
+
+      /* Calculate height for all tabs stacked vertically */
       *height = m + m;
+      if (num_tabs > 0)
+        *height += total_height;
 
       if (iupdrvTabsExtraDecor(ih))
       {
@@ -123,14 +128,50 @@
     }
     else
     {
-      int max_height = iTabsGetMaxHeight(ih);
-      *width  = m + (3 + max_height + 3) + s + m;
+      int max_width;
+      int total_height = 0;
+      int pos;
+      char *tabtitle, *tabimage;
+      Ihandle* child;
+      int max_w = 0;
+
+      /* Sum individual tab heights total (handles non-uniform sizing like GTK) */
+      for (pos = 0, child = ih->firstchild; child; child = child->brother, pos++)
+      {
+        int width, height;
+
+        tabtitle = iupAttribGetId(ih, "TABTITLE", pos);
+        if (!tabtitle) tabtitle = iupAttribGet(child, "TABTITLE");
+        tabimage = iupAttribGetId(ih, "TABIMAGE", pos);
+        if (!tabimage) tabimage = iupAttribGet(child, "TABIMAGE");
+        if (!tabtitle && !tabimage)
+          tabtitle = "     ";
+
+        iupdrvTabsGetTabSize(ih, tabtitle, tabimage, &width, &height);
+
+        /* For unmapped tabs, add extra padding */
+        if (!ih->handle)
+        {
+          width = 3 + width + 3;
+          height = 3 + height + 3;
+        }
+
+        total_height += height;
+        if (width > max_w) max_w = width;
+      }
+      max_width = max_w;
+
+      *width  = m + max_width + s + m;
+
+      /* Calculate height for all tabs stacked vertically */
       *height = m + m;
+      if (num_tabs > 0)
+        *height += total_height;
 
       if (ih->handle && ih->data->is_multiline)
       {
         int num_lin = iupdrvTabsGetLineCountAttrib(ih);
-        *width += (num_lin-1)*(3 + max_height + 3 + 1);
+        *width += (num_lin-1)*(max_width + 1);
       }
     }
   }
@@ -138,8 +179,46 @@
   {
     if (ih->data->orientation == ITABS_HORIZONTAL)
     {
-      int max_height = iTabsGetMaxHeight(ih);
+      int max_height;
+      int total_width = 0;
+      int pos;
+      char *tabtitle, *tabimage;
+      Ihandle* child;
+      int max_h = 0;
+
+      /* Sum individual tab widths for total (handles non-uniform sizing like GTK) */
+      for (pos = 0, child = ih->firstchild; child; child = child->brother, pos++)
+      {
+        int width, height;
+
+        tabtitle = iupAttribGetId(ih, "TABTITLE", pos);
+        if (!tabtitle) tabtitle = iupAttribGet(child, "TABTITLE");
+        tabimage = iupAttribGetId(ih, "TABIMAGE", pos);
+        if (!tabimage) tabimage = iupAttribGet(child, "TABIMAGE");
+        if (!tabtitle && !tabimage)
+          tabtitle = "     ";
+
+        iupdrvTabsGetTabSize(ih, tabtitle, tabimage, &width, &height);
+
+        /* For unmapped tabs, add extra padding */
+        if (!ih->handle)
+          width = 3 + width + 3;
+
+        total_width += width;
+        if (height > max_h) max_h = height;
+      }
+      max_height = max_h;
+
+      /* Calculate width for all tabs side-by-side */
       *width  = m + m;
+      if (num_tabs > 0)
+      {
+        *width += total_width;
+        /* Add spacing between tabs */
+        if (num_tabs > 1)
+          *width += (num_tabs - 1) * s;
+      }
+
       *height = m + (3 + max_height + 3) + s + m;
 
       if (ih->handle && ih->data->is_multiline)
@@ -157,7 +236,8 @@
     }
     else
     {
-      int max_width = iTabsGetMaxWidth(ih);
+      int max_width, max_height;
+      iTabsGetMaxTabSize(ih, &max_width, &max_height);
       *width  = m + m;
       *height = m + (3 + max_width + 3) + s + m;
     }
@@ -178,12 +258,14 @@
     {
       if (ih->data->orientation == ITABS_HORIZONTAL)
       {
-        int max_width = iTabsGetMaxWidth(ih);
+        int max_width, max_height;
+        iTabsGetMaxTabSize(ih, &max_width, &max_height);
         *dx = m + (3 + max_width + 3) + s;
       }
       else
       {
-        int max_height = iTabsGetMaxHeight(ih);
+        int max_width, max_height;
+        iTabsGetMaxTabSize(ih, &max_width, &max_height);
         *dx = m + (3 + max_height + 3) + s;
 
         if (ih->handle && ih->data->is_multiline)
@@ -204,7 +286,8 @@
     {
       if (ih->data->orientation == ITABS_HORIZONTAL)
       {
-        int max_height = iTabsGetMaxHeight(ih);
+        int max_width, max_height;
+        iTabsGetMaxTabSize(ih, &max_width, &max_height);
         *dy = m + (3 + max_height + 3) + s;
 
         if (ih->handle && ih->data->is_multiline)
@@ -215,7 +298,8 @@
       }
       else
       {
-        int max_width = iTabsGetMaxWidth(ih);
+        int max_width, max_height;
+        iTabsGetMaxTabSize(ih, &max_width, &max_height);
         *dy = m + (3 + max_width + 3) + s;
       }
     }
@@ -487,8 +571,18 @@
 
   iTabsGetDecorSize(ih, &decorwidth, &decorheight);
 
-  *w = children_naturalwidth + decorwidth;
-  *h = children_naturalheight + decorheight;
+  /* For TOP/BOTTOM tabs: decoration is height
+     For LEFT/RIGHT tabs: decoration is width */
+  if (ih->data->type == ITABS_TOP || ih->data->type == ITABS_BOTTOM)
+  {
+    *w = iupMAX(children_naturalwidth, decorwidth);
+    *h = children_naturalheight + decorheight;
+  }
+  else /* LEFT or RIGHT */
+  {
+    *w = children_naturalwidth + decorwidth;
+    *h = iupMAX(children_naturalheight, decorheight);
+  }
 }
 
 static void iTabsSetChildrenCurrentSizeMethod(Ihandle* ih, int shrink)
Index: src/iup_tabs.h
===================================================================
--- src/iup_tabs.h	(revision 5971)
+++ src/iup_tabs.h	(working copy)
@@ -27,6 +27,7 @@
 void iupdrvTabsSetCurrentTab(Ihandle* ih, int pos);
 int iupdrvTabsGetCurrentTab(Ihandle* ih);
 void iupdrvTabsInitClass(Iclass* ic);
+void iupdrvTabsGetTabSize(Ihandle* ih, const char* tab_title, const char* tab_image, int* tab_width, int* tab_height);
 
 typedef enum
 {
Index: src/iup_text.c
===================================================================
--- src/iup_text.c	(revision 5971)
+++ src/iup_text.c	(working copy)
@@ -159,9 +159,15 @@
 void iupTextUpdateFormatTags(Ihandle* ih)
 {
   /* called when the element is mapped */
-  int i, count = iupArrayCount(ih->data->formattags);
-  Ihandle** tag_array = (Ihandle**)iupArrayGetData(ih->data->formattags);
+  int i, count;
+  Ihandle** tag_array;
 
+  if (!ih->data->formattags)
+    return;
+
+  count = iupArrayCount(ih->data->formattags);
+  tag_array = (Ihandle**)iupArrayGetData(ih->data->formattags);
+
   /* must update VALUE before updating the format */
   iTextUpdateValueAttrib(ih);
 
@@ -305,7 +311,6 @@
         iupMaskDestroy(ih->data->mask);
 
       ih->data->mask = mask;
-      return 1; /* store only a valid mask */
     }
   }
 
@@ -343,7 +348,6 @@
         iupMaskDestroy(ih->data->mask);
 
       ih->data->mask = mask;
-      return 1; /* store only a valid mask */
     }
   }
 
@@ -379,7 +383,6 @@
         iupMaskDestroy(ih->data->mask);
 
       ih->data->mask = mask;
-      return 1; /* store only a valid mask */
     }
   }
 
@@ -515,7 +518,7 @@
 
 static void iTextComputeNaturalSizeMethod(Ihandle* ih, int *w, int *h, int *children_expand)
 {
-  int natural_w = 0, 
+  int natural_w = 0,
       natural_h = 0,
       visiblecolumns = iupAttribGetInt(ih, "VISIBLECOLUMNS"),
       visiblelines = iupAttribGetInt(ih, "VISIBLELINES");
@@ -531,6 +534,8 @@
   /* compute the borders space */
   if (iupAttribGetBoolean(ih, "BORDER"))
     iupdrvTextAddBorders(ih, &natural_w, &natural_h);
+  else
+    iupdrvTextAddExtraPadding(ih, &natural_w, &natural_h);
 
   if (iupAttribGetBoolean(ih, "SPIN"))
     iupdrvTextAddSpin(ih, &natural_w, natural_h);
Index: src/iup_text.h
===================================================================
--- src/iup_text.h	(revision 5971)
+++ src/iup_text.h	(working copy)
@@ -14,6 +14,7 @@
 
 void iupdrvTextInitClass(Iclass* ic);
 void iupdrvTextAddBorders(Ihandle* ih, int *w, int *h);
+void iupdrvTextAddExtraPadding(Ihandle* ih, int *w, int *h);
 void iupdrvTextAddSpin(Ihandle* ih, int *w, int h);
 void* iupdrvTextAddFormatTagStartBulk(Ihandle* ih);
 void iupdrvTextAddFormatTagStopBulk(Ihandle* ih, void* state);
Index: src/iup_thread.c
===================================================================
--- src/iup_thread.c	(revision 5971)
+++ src/iup_thread.c	(working copy)
@@ -4,25 +4,29 @@
  * See Copyright Notice in "iup.h"
  */
 
-#ifdef GTK_DISABLE_DEPRECATED
+/* Define IUP_USE_GTK for any GTK version (GTK2, GTK3, or GTK4) */
+#if defined(IUP_USE_GTK2) || defined(IUP_USE_GTK3) || defined(IUP_USE_GTK4)
 #define IUP_USE_GTK
-#ifndef GLIB_CHECK_VERSION
-#define OLD_GLIB
 #endif
-#endif
 
 #ifdef IUP_USE_GTK
 #include <glib.h>
-/* #include <gthread.h> */
+#include <stdint.h>
+/* Check for old GLib (< 2.32) which requires deprecated thread APIs */
+#if !GLIB_CHECK_VERSION(2, 32, 0)
+#define OLD_GLIB
+#endif
 #elif defined(WIN32)
 #include <windows.h>
-#else
-#warning "FIXME: IupThread platform not identified/supported"
+#elif defined(__APPLE__) || defined(__unix__)
+#include <pthread.h>
+#include <sched.h>
+#include <stdint.h>
 #endif
 
-#include <stdio.h>              
+#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>             
+#include <string.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -42,6 +46,12 @@
 #elif defined(WIN32)
   HANDLE thread = (HANDLE)iupAttribGet(ih, "THREAD");
   WaitForSingleObject(thread, INFINITE);
+#elif defined(__APPLE__) || defined(__unix__)
+  pthread_t* thread = (pthread_t*)iupAttribGet(ih, "THREAD");
+  if (thread)
+  {
+    pthread_join(*thread, NULL);
+  }
 #endif
 
   (void)value;
@@ -57,6 +67,8 @@
   g_thread_yield();
 #elif defined(WIN32)
   SwitchToThread();
+#elif defined(__APPLE__) || defined(__unix__)
+  sched_yield();
 #endif
   return 0;
 }
@@ -69,8 +81,15 @@
 #elif defined(WIN32)
   HANDLE thread = (HANDLE)iupAttribGet(ih, "THREAD");
   return iupStrReturnBoolean(thread == GetCurrentThread());
+#elif defined(__APPLE__) || defined(__unix__)
+  pthread_t* thread = (pthread_t*)iupAttribGet(ih, "THREAD");
+  if (thread)
+  {
+    return iupStrReturnBoolean(pthread_equal(*thread, pthread_self()));
+  }
+  return iupStrReturnBoolean(0);
 #else
-	return NULL;
+  return NULL;
 #endif
 }
 
@@ -80,10 +99,12 @@
   iupStrToInt(value, &exit_code);
 
 #ifdef IUP_USE_GTK
-  g_thread_exit((gpointer)exit_code);
+  g_thread_exit((gpointer)(intptr_t)exit_code);
 #elif defined(WIN32)
   ExitThread(exit_code);
-#endif	
+#elif defined(__APPLE__) || defined(__unix__)
+  pthread_exit((void*)(intptr_t)exit_code);
+#endif
 
   (void)ih;
   return 0;
@@ -99,7 +120,13 @@
 #elif defined(WIN32)
     HANDLE mutex = (HANDLE)iupAttribGet(ih, "MUTEX");
     WaitForSingleObject(mutex, INFINITE);
-#endif	
+#elif defined(__APPLE__) || defined(__unix__)
+    pthread_mutex_t* mutex = (pthread_mutex_t*)iupAttribGet(ih, "MUTEX");
+    if (mutex)
+    {
+      pthread_mutex_lock(mutex);
+    }
+#endif
   }
   else
   {
@@ -109,6 +136,12 @@
 #elif defined(WIN32)
     HANDLE mutex = (HANDLE)iupAttribGet(ih, "MUTEX");
     ReleaseMutex(mutex);
+#elif defined(__APPLE__) || defined(__unix__)
+    pthread_mutex_t* mutex = (pthread_mutex_t*)iupAttribGet(ih, "MUTEX");
+    if (mutex)
+    {
+      pthread_mutex_unlock(mutex);
+    }
 #endif
   }
 
@@ -128,7 +161,7 @@
   if (cb)
     cb(ih);
   return 0;
-};
+}
 
 static int iThreadSetStartAttrib(Ihandle* ih, const char* value)
 {
@@ -154,6 +187,25 @@
     HANDLE old_thread = (HANDLE)iupAttribGet(ih, "THREAD");
     if (old_thread) CloseHandle(old_thread);
     iupAttribSet(ih, "THREAD", (char*)thread);
+#elif defined(__APPLE__) || defined(__unix__)
+    pthread_t* thread = (pthread_t*)malloc(sizeof(pthread_t));
+    pthread_t* old_thread = (pthread_t*)iupAttribGet(ih, "THREAD");
+    if (thread)
+    {
+      if (pthread_create(thread, NULL, ClientThreadFunc, ih) == 0)
+      {
+        pthread_detach(*thread);
+        if (old_thread)
+        {
+          free(old_thread);
+        }
+        iupAttribSet(ih, "THREAD", (char*)thread);
+      }
+      else
+      {
+        free(thread);
+      }
+    }
 #endif
   }
 
@@ -170,6 +222,8 @@
 #endif
 #elif defined(WIN32)
   HANDLE mutex;
+#elif defined(__APPLE__) || defined(__unix__)
+  pthread_mutex_t* mutex;
 #else
   void* mutex = NULL;
 #endif
@@ -181,6 +235,12 @@
 #endif
 #elif defined(WIN32)
   mutex = CreateMutexA(NULL, FALSE, "mutex");
+#elif defined(__APPLE__) || defined(__unix__)
+  mutex = (pthread_mutex_t*)malloc(sizeof(pthread_mutex_t));
+  if (mutex)
+  {
+    pthread_mutex_init(mutex, NULL);
+  }
 #endif
 
   iupAttribSet(ih, "MUTEX", (char*)mutex);
@@ -197,8 +257,8 @@
   g_mutex_free(mutex);
 #else
   g_mutex_clear(mutex);
+  free(mutex);
 #endif
-  free(mutex);
 #ifndef OLD_GLIB
   if (thread) g_thread_unref(thread);
 #endif
@@ -207,6 +267,18 @@
   HANDLE thread = (HANDLE)iupAttribGet(ih, "THREAD");
   CloseHandle(mutex);
   if (thread) CloseHandle(thread);
+#elif defined(__APPLE__) || defined(__unix__)
+  pthread_mutex_t* mutex = (pthread_mutex_t*)iupAttribGet(ih, "MUTEX");
+  pthread_t* thread = (pthread_t*)iupAttribGet(ih, "THREAD");
+  if (mutex)
+  {
+    pthread_mutex_destroy(mutex);
+    free(mutex);
+  }
+  if (thread)
+  {
+    free(thread);
+  }
 #endif
 }
 
@@ -242,4 +314,4 @@
 IUP_API Ihandle* IupThread(void)
 {
   return IupCreate("thread");
-}
+}
\ No newline at end of file
Index: src/iup_toggle.c
===================================================================
--- src/iup_toggle.c	(revision 5971)
+++ src/iup_toggle.c	(working copy)
@@ -88,7 +88,10 @@
     char* str = iupStrProcessMnemonic(title, NULL, 0);   /* remove & */
     iupdrvFontGetMultiLineStringSize(ih, str, &natural_w, &natural_h);
 
-    iupdrvToggleAddCheckBox(ih, &natural_w, &natural_h, str);
+    if (iupAttribGetBoolean(ih, "SWITCH"))
+      iupdrvToggleAddSwitch(ih, &natural_w, &natural_h, str);
+    else
+      iupdrvToggleAddCheckBox(ih, &natural_w, &natural_h, str);
 
     if (str && str != title) free(str);
   }
@@ -144,6 +147,7 @@
   iupClassRegisterAttribute(ic, "RADIO", iToggleGetRadioAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "3STATE", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "FLAT", iToggleGetFlatAttrib, iToggleSetFlatAttrib, IUPAF_SAMEASSYSTEM, "No", IUPAF_NOT_MAPPED);
+  iupClassRegisterAttribute(ic, "SWITCH", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "IGNORERADIO", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
 
   iupdrvToggleInitClass(ic);
Index: src/iup_toggle.h
===================================================================
--- src/iup_toggle.h	(revision 5971)
+++ src/iup_toggle.h	(working copy)
@@ -19,6 +19,7 @@
 
 void iupdrvToggleInitClass(Iclass* ic);
 void iupdrvToggleAddCheckBox(Ihandle* ih, int *x, int *y, const char* str);
+void iupdrvToggleAddSwitch(Ihandle* ih, int *x, int *y, const char* str);
 
 IUP_SDK_API Ihandle* iupRadioFindToggleParent(Ihandle* ih_toggle);
 char* iupToggleGetPaddingAttrib(Ihandle* ih);
Index: src/mot/iupmot_button.c
===================================================================
--- src/mot/iupmot_button.c	(revision 5971)
+++ src/mot/iupmot_button.c	(working copy)
@@ -39,7 +39,7 @@
 
 static int motButtonSetTitleAttrib(Ihandle* ih, const char* value)
 {
-  if (ih->data->type == IUP_BUTTON_TEXT)
+  if (ih->data->type & IUP_BUTTON_TEXT)
   {
     iupmotSetMnemonicTitle(ih, NULL, 0, value);
     return 1;
@@ -68,13 +68,13 @@
 
 static int motButtonSetImageAttrib(Ihandle* ih, const char* value)
 {
-  if (ih->data->type == IUP_BUTTON_IMAGE)
+  if (ih->data->type & IUP_BUTTON_IMAGE)
   {
     iupmotSetPixmap(ih, value, XmNlabelPixmap, 0);
 
     if (!iupAttribGet(ih, "IMINACTIVE"))
     {
-      /* if not active and IMINACTIVE is not defined 
+      /* if not active and IMINACTIVE is not defined
          then automatically create one based on IMAGE */
       iupmotSetPixmap(ih, value, XmNlabelInsensitivePixmap, 1); /* make_inactive */
     }
@@ -86,7 +86,7 @@
 
 static int motButtonSetImInactiveAttrib(Ihandle* ih, const char* value)
 {
-  if (ih->data->type == IUP_BUTTON_IMAGE)
+  if (ih->data->type & IUP_BUTTON_IMAGE)
   {
     iupmotSetPixmap(ih, value, XmNlabelInsensitivePixmap, 0);
     return 1;
@@ -97,7 +97,7 @@
 
 static int motButtonSetImPressAttrib(Ihandle* ih, const char* value)
 {
-  if (ih->data->type == IUP_BUTTON_IMAGE)
+  if (ih->data->type & IUP_BUTTON_IMAGE)
   {
     iupmotSetPixmap(ih, value, XmNarmPixmap, 0);
     return 1;
@@ -191,14 +191,27 @@
 {
   int has_border = 1;
   char* value;
+  char* title;
   int num_args = 0;
   Arg args[30];
 
   value = iupAttribGet(ih, "IMAGE");
+  title = iupAttribGet(ih, "TITLE");
+
   if (value)
   {
     ih->data->type = IUP_BUTTON_IMAGE;
-    iupMOT_SETARG(args, num_args, XmNlabelType, XmPIXMAP);
+
+    /* Check if we have both image and text */
+    if (title && *title != 0)
+    {
+      ih->data->type |= IUP_BUTTON_TEXT;  /* IUP_BUTTON_BOTH */
+      iupMOT_SETARG(args, num_args, XmNlabelType, XmPIXMAP_AND_STRING);
+    }
+    else
+    {
+      iupMOT_SETARG(args, num_args, XmNlabelType, XmPIXMAP);
+    }
   }
   else
   {
@@ -286,7 +299,7 @@
   /* initialize the widget */
   XtRealizeWidget(ih->handle);
 
-  if (ih->data->type == IUP_BUTTON_TEXT)
+  if (ih->data->type & IUP_BUTTON_TEXT)
     iupmotSetXmString(ih->handle, XmNlabelString, "");
 
   return IUP_NOERROR;
Index: src/mot/iupmot_canvas.c
===================================================================
--- src/mot/iupmot_canvas.c	(revision 5971)
+++ src/mot/iupmot_canvas.c	(working copy)
@@ -15,6 +15,7 @@
 #include <memory.h>
 #include <stdarg.h>
 #include <limits.h>
+#include <stdint.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -35,7 +36,7 @@
 
 static void motCanvasScrollbarCallback(Widget w, XtPointer client_data, XtPointer call_data)
 {
-  int op = (int)client_data, ipage, ipos;
+  int op = (int)(intptr_t)client_data, ipage, ipos;
   Ihandle *ih;
   IFniff cb;
   double posx, posy;
@@ -70,7 +71,7 @@
     cb(ih, op, (float)posx, (float)posy);
   else
   {
-    IFnff action_cb = (IFnff)IupGetCallback(ih,"ACTION");
+    IFn action_cb = (IFn)IupGetCallback(ih,"ACTION");
     if (action_cb)
     {
       /* REDRAW Now (since 3.24) - to allow a full native redraw process */
@@ -169,19 +170,20 @@
 
 static void motCanvasExposeCallback(Widget w, Ihandle *ih, XtPointer call_data)
 {
-  IFnff cb;
+  IFn cb;
   (void)call_data;
 
-  if (!XtWindow(w) || !ih) 
+  if (!XtWindow(w) || !ih)
     return;
 
-  cb = (IFnff)IupGetCallback(ih,"ACTION");
+  cb = (IFn)IupGetCallback(ih,"ACTION");
   if (cb && !(ih->data->inside_resize))
   {
     if (!iupAttribGet(ih, "_IUPMOT_NO_BGCOLOR"))
       motCanvasSetBgColorAttrib(ih, iupAttribGetStr(ih, "BGCOLOR"));  /* reset to update window attributes */
 
-    cb(ih, (float)ih->data->posx, (float)ih->data->posy);
+    iupAttribSet(ih, "DRAWABLE", (char*)XtWindow(w));
+    cb(ih);
   }
 }
 
@@ -489,7 +491,7 @@
 static char* motCanvasGetXScreenAttrib(Ihandle *ih)
 {
   (void)ih;
-  return (char*)iupmot_screen;
+  return (char*)(intptr_t)iupmot_screen;
 }
 
 static char* motCanvasGetXWindowAttrib(Ihandle *ih)
@@ -748,4 +750,5 @@
 
   /* Not Supported */
   iupClassRegisterAttribute(ic, "TOUCH", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/mot/iupmot_common.c
===================================================================
--- src/mot/iupmot_common.c	(revision 5971)
+++ src/mot/iupmot_common.c	(working copy)
@@ -52,7 +52,7 @@
 
 IUP_SDK_API void iupdrvReparent(Ihandle* ih)
 {
-  /* Intrinsics and Motif do NOT support reparent. 
+  /* Intrinsics and Motif do NOT support reparent.
      XReparentWindow can NOT be used because will reparent only the X-Windows windows.
      So must unmap and map again to obtain the same effect. */
   Widget new_parent = iupChildTreeGetNativeParentHandle(ih);
@@ -64,9 +64,11 @@
     int old_visible = IupGetInt(ih, "VISIBLE");
     if (old_visible)
       IupSetAttribute(ih, "VISIBLE", "NO");
+
     motSaveAttributesRec(ih); /* this does not save everything... */
     IupUnmap(ih);
     IupMap(ih);
+
     if (old_visible)
       IupSetAttribute(ih, "VISIBLE", "Yes");
   }
@@ -691,3 +693,55 @@
   (void)title;
   (void)ih;
 }
+
+int iupmotIsSystemDarkMode(void)
+{
+  unsigned char bg_r, bg_g, bg_b;
+  unsigned char fg_r, fg_g, fg_b;
+  double bg_lum, fg_lum;
+  XColor xcolor;
+  Colormap colormap;
+  XrmDatabase db;
+  XrmValue value;
+  char* type = NULL;
+  char* bg_str = NULL;
+  char* fg_str = NULL;
+
+  db = XrmGetDatabase(iupmot_display);
+  if (!db)
+    return 0;
+
+  /* Try to read background/foreground from X resource database */
+  if (XrmGetResource(db, "*background", "*Background", &type, &value))
+    bg_str = value.addr;
+  if (XrmGetResource(db, "*foreground", "*Foreground", &type, &value))
+    fg_str = value.addr;
+
+  if (!bg_str || !fg_str)
+    return 0;  /* Can't determine, assume light mode */
+
+  colormap = DefaultColormap(iupmot_display, iupmot_screen);
+
+  /* Parse background color */
+  if (!XParseColor(iupmot_display, colormap, bg_str, &xcolor))
+    return 0;
+
+  bg_r = xcolor.red >> 8;
+  bg_g = xcolor.green >> 8;
+  bg_b = xcolor.blue >> 8;
+
+  /* Parse foreground color */
+  if (!XParseColor(iupmot_display, colormap, fg_str, &xcolor))
+    return 0;
+
+  fg_r = xcolor.red >> 8;
+  fg_g = xcolor.green >> 8;
+  fg_b = xcolor.blue >> 8;
+
+  /* Calculate relative luminance using standard formula (ITU-R BT.709) */
+  bg_lum = 0.2126 * bg_r + 0.7152 * bg_g + 0.0722 * bg_b;
+  fg_lum = 0.2126 * fg_r + 0.7152 * fg_g + 0.0722 * fg_b;
+
+  /* Dark theme has lower background luminance than foreground */
+  return (bg_lum < fg_lum) ? 1 : 0;
+}
Index: src/mot/iupmot_dialog.c
===================================================================
--- src/mot/iupmot_dialog.c	(revision 5971)
+++ src/mot/iupmot_dialog.c	(working copy)
@@ -743,7 +743,7 @@
     if (icon)
       XtVaSetValues(ih->handle, XmNiconPixmap, icon, NULL);
     if (icon_mask)
-      XtVaSetValues(ih->handle, XmNiconMask, icon, NULL);
+      XtVaSetValues(ih->handle, XmNiconMask, icon_mask, NULL);
   }
   return 1;
 }
@@ -1004,6 +1004,29 @@
   /* initialize the widget */
   XtRealizeWidget(ih->handle);
 
+  /* Apply APPID and APPNAME if set */
+  {
+    const char* appid = IupGetGlobal("_IUP_APPID_INTERNAL");
+    const char* appname = IupGetGlobal("_IUP_APPNAME_INTERNAL");
+    Window window = XtWindow(ih->handle);
+
+    if (appid || appname)
+    {
+      XClassHint class_hint;
+      class_hint.res_name = (char*)(appid ? appid : "iup");
+      class_hint.res_class = (char*)(appname ? appname : "Iup");
+      XSetClassHint(iupmot_display, window, &class_hint);
+    }
+
+    if (appname)
+    {
+      XStoreName(iupmot_display, window, appname);
+      XChangeProperty(iupmot_display, window, XInternAtom(iupmot_display, "_NET_WM_NAME", False),
+                      XInternAtom(iupmot_display, "UTF8_STRING", False), 8, PropModeReplace,
+                      (unsigned char*)appname, strlen(appname));
+    }
+  }
+
   /* child dialogs must be always on top of the parent */
   if (parent)
     XSetTransientForHint(iupmot_display, XtWindow(ih->handle), XtWindow(parent));
@@ -1014,13 +1037,6 @@
   /* Ignore VISIBLE before mapping */
   iupAttribSet(ih, "VISIBLE", NULL);
 
-  if (IupGetGlobal("_IUP_RESET_DLGBGCOLOR"))
-  {
-    iupmotSetGlobalColorAttrib(dialog_manager, XmNbackground, "DLGBGCOLOR");
-    iupmotSetGlobalColorAttrib(dialog_manager, XmNforeground, "DLGFGCOLOR");
-    IupSetGlobal("_IUP_RESET_DLGBGCOLOR", NULL);
-  }
-
   if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
     XtAddEventHandler(dialog_manager, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
 
@@ -1030,10 +1046,11 @@
 static void motDialogUnMapMethod(Ihandle* ih)
 {
   Widget dialog_manager;
-  if (ih->data->menu) 
+
+  if (ih->data->menu)
   {
     ih->data->menu->handle = NULL; /* the dialog will destroy the native menu */
-    IupDestroy(ih->data->menu);  
+    IupDestroy(ih->data->menu);
     ih->data->menu = NULL;
   }
 
@@ -1047,7 +1064,7 @@
 
   XtRemoveEventHandler(dialog_manager, KeyPressMask, False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
   XtRemoveCallback(dialog_manager, XmNhelpCallback, (XtCallbackProc)iupmotHelpCallback, (XtPointer)ih);
-  
+
   iupdrvBaseUnMapMethod(ih);
 }
 
@@ -1068,21 +1085,29 @@
   {
     int width = ih->currentwidth - 2*border;
     int height = ih->currentheight - 2*border - caption;
-    XtVaSetValues(ih->handle,
-      XmNwidth, width,  /* client size */
-      XmNheight, height,
-      XmNminWidth, width, 
-      XmNminHeight, height, 
-      XmNmaxWidth, width, 
-      XmNmaxHeight, height, 
-      NULL);
+    if (width > 0 && height > 0)
+    {
+      XtVaSetValues(ih->handle,
+        XmNwidth, width,  /* client size */
+        XmNheight, height,
+        XmNminWidth, width,
+        XmNminHeight, height,
+        XmNmaxWidth, width,
+        XmNmaxHeight, height,
+        NULL);
+    }
   }
   else
   {
-    XtVaSetValues(ih->handle,
-      XmNwidth, (XtArgVal)(ih->currentwidth - 2*border),     /* excluding the border */
-      XmNheight, (XtArgVal)(ih->currentheight - 2*border - caption),
-      NULL);
+    int width = ih->currentwidth - 2*border;
+    int height = ih->currentheight - 2*border - caption;
+    if (width > 0 && height > 0)
+    {
+      XtVaSetValues(ih->handle,
+        XmNwidth, (XtArgVal)width,     /* excluding the border */
+        XmNheight, (XtArgVal)height,
+        NULL);
+    }
   }
 
   ih->data->ignore_resize = 0;
@@ -1136,9 +1161,6 @@
   /* Not Supported */
   iupClassRegisterAttribute(ic, "OPACITY", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TOPMOST", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAY", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYIMAGE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYTIP", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "DIALOGHINT", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "BRINGFRONT", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "COMPOSITED", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
Index: src/mot/iupmot_draw_x11.c
===================================================================
--- src/mot/iupmot_draw_x11.c	(revision 5971)
+++ src/mot/iupmot_draw_x11.c	(working copy)
@@ -8,10 +8,15 @@
 #include <stdio.h>
 #include <string.h>
 #include <memory.h>
+#include <math.h>
 
 #include <Xm/Xm.h>
 #include <X11/Xlib.h>
 
+#ifdef IUP_USE_XFT
+#include <X11/Xft/Xft.h>
+#endif
+
 #include "iup.h"
 
 #include "iup_attrib.h"
@@ -37,32 +42,75 @@
   int clip_x1, clip_y1, clip_x2, clip_y2;
 };
 
-static void motDrawGetGeometry(Display *dpy, Drawable wnd, int *_w, int *_h, int *_d)
+static int motDrawGetGeometry(Display *dpy, Drawable wnd, int *_w, int *_h, int *_d)
 {
   Window root;
   int x, y;
-  unsigned int w, h, b, d;
-  XGetGeometry(dpy, wnd, &root, &x, &y, &w, &h, &b, &d);
-  *_w = w;
-  *_h = h;
-  *_d = d;
+  unsigned int w = 0, h = 0, b = 0, d = 0;
+  Status status = XGetGeometry(dpy, wnd, &root, &x, &y, &w, &h, &b, &d);
+  if (status == 0)
+  {
+    *_w = 0;
+    *_h = 0;
+    *_d = 0;
+    return 0;
+  }
+  *_w = (int)w;
+  *_h = (int)h;
+  *_d = (int)d;
+  return 1;
 }
 
 IUP_SDK_API IdrawCanvas* iupdrvDrawCreateCanvas(Ihandle* ih)
 {
-  IdrawCanvas* dc = calloc(1, sizeof(IdrawCanvas));
+  IdrawCanvas* dc;
   int depth;
 
+  dc = calloc(1, sizeof(IdrawCanvas));
+  if (!dc)
+    return NULL;
+
   dc->ih = ih;
   dc->wnd = (Window)IupGetAttribute(ih, "DRAWABLE");
+  if (!dc->wnd)
+  {
+    free(dc);
+    return NULL;
+  }
 
-  dc->gc = XCreateGC(iupmot_display, dc->wnd, 0, NULL);
+  if (!motDrawGetGeometry(iupmot_display, dc->wnd, &dc->w, &dc->h, &depth))
+  {
+    free(dc);
+    return NULL;
+  }
 
-  motDrawGetGeometry(iupmot_display, dc->wnd, &dc->w, &dc->h, &depth);
+  if (dc->w <= 0) dc->w = 1;
+  if (dc->h <= 0) dc->h = 1;
 
   dc->pixmap = XCreatePixmap(iupmot_display, dc->wnd, dc->w, dc->h, depth);
+  if (!dc->pixmap)
+  {
+    free(dc);
+    return NULL;
+  }
+
   dc->pixmap_gc = XCreateGC(iupmot_display, dc->pixmap, 0, NULL);
+  if (!dc->pixmap_gc)
+  {
+    XFreePixmap(iupmot_display, dc->pixmap);
+    free(dc);
+    return NULL;
+  }
 
+  dc->gc = XCreateGC(iupmot_display, dc->wnd, 0, NULL);
+  if (!dc->gc)
+  {
+    XFreeGC(iupmot_display, dc->pixmap_gc);
+    XFreePixmap(iupmot_display, dc->pixmap);
+    free(dc);
+    return NULL;
+  }
+
   iupAttribSet(ih, "DRAWDRIVER", "X11");
 
   return dc;
@@ -70,39 +118,80 @@
 
 IUP_SDK_API void iupdrvDrawKillCanvas(IdrawCanvas* dc)
 {
-  XFreeGC(iupmot_display, dc->pixmap_gc);
-  XFreePixmap(iupmot_display, dc->pixmap);
-  XFreeGC(iupmot_display, dc->gc);
+  if (!dc)
+    return;
 
+  if (dc->pixmap_gc)
+    XFreeGC(iupmot_display, dc->pixmap_gc);
+  if (dc->pixmap)
+    XFreePixmap(iupmot_display, dc->pixmap);
+  if (dc->gc)
+    XFreeGC(iupmot_display, dc->gc);
+
   free(dc);
 }
 
 IUP_SDK_API void iupdrvDrawUpdateSize(IdrawCanvas* dc)
 {
-  int w, h, depth;
+  int w = 0, h = 0, depth = 0;
 
-  motDrawGetGeometry(iupmot_display, dc->wnd, &w, &h, &depth);
+  if (!dc || !dc->wnd)
+    return;
 
+  if (!motDrawGetGeometry(iupmot_display, dc->wnd, &w, &h, &depth))
+    return;
+
+  if (w <= 0 || h <= 0)
+    return;
+
   if (w != dc->w || h != dc->h)
   {
     dc->w = w;
     dc->h = h;
 
-    XFreeGC(iupmot_display, dc->pixmap_gc);
-    XFreePixmap(iupmot_display, dc->pixmap);
+    if (dc->pixmap_gc)
+      XFreeGC(iupmot_display, dc->pixmap_gc);
+    if (dc->pixmap)
+      XFreePixmap(iupmot_display, dc->pixmap);
 
     dc->pixmap = XCreatePixmap(iupmot_display, dc->wnd, dc->w, dc->h, depth);
+    if (!dc->pixmap)
+    {
+      dc->pixmap_gc = NULL;
+      dc->w = 0;
+      dc->h = 0;
+      return;
+    }
+
     dc->pixmap_gc = XCreateGC(iupmot_display, dc->pixmap, 0, NULL);
+    if (!dc->pixmap_gc)
+    {
+      XFreePixmap(iupmot_display, dc->pixmap);
+      dc->pixmap = None;
+      dc->w = 0;
+      dc->h = 0;
+      return;
+    }
   }
 }
 
 IUP_SDK_API void iupdrvDrawFlush(IdrawCanvas* dc)
 {
+  if (!dc || !dc->wnd || !dc->pixmap || !dc->gc)
+    return;
+
   XCopyArea(iupmot_display, dc->pixmap, dc->wnd, dc->gc, 0, 0, dc->w, dc->h, 0, 0);
 }
 
 IUP_SDK_API void iupdrvDrawGetSize(IdrawCanvas* dc, int *w, int *h)
 {
+  if (!dc)
+  {
+    if (w) *w = 0;
+    if (h) *h = 0;
+    return;
+  }
+
   if (w) *w = dc->w;
   if (h) *h = dc->h;
 }
@@ -153,6 +242,50 @@
   XChangeGC(iupmot_display, dc->pixmap_gc, GCLineWidth, &gcval);
 }
 
+/* Combined function to set both line style and width in one XChangeGC call */
+static void iDrawSetLineStyleAndWidth(IdrawCanvas* dc, int style, int line_width)
+{
+  XGCValues gcval;
+
+  /* Set line width */
+  if (line_width == 1)
+    gcval.line_width = 0;
+  else
+    gcval.line_width = line_width;
+
+  /* Set line style */
+  if (style == IUP_DRAW_STROKE || style == IUP_DRAW_FILL)
+    gcval.line_style = LineSolid;
+  else
+  {
+    if (style == IUP_DRAW_STROKE_DASH)
+    {
+      char dashes[2] = { 9, 3 };
+      XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 2);
+    }
+    else if (style == IUP_DRAW_STROKE_DOT)
+    {
+      char dashes[2] = { 1, 2 };
+      XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 2);
+    }
+    else if (style == IUP_DRAW_STROKE_DASH_DOT)
+    {
+      char dashes[4] = { 7, 3, 1, 3 };
+      XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 4);
+    }
+    else if (style == IUP_DRAW_STROKE_DASH_DOT_DOT)
+    {
+      char dashes[6] = { 7, 3, 1, 3, 1, 3 };
+      XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 6);
+    }
+
+    gcval.line_style = LineOnOffDash;
+  }
+
+  /* Batch update both line width and style in one call */
+  XChangeGC(iupmot_display, dc->pixmap_gc, GCLineWidth | GCLineStyle, &gcval);
+}
+
 IUP_SDK_API void iupdrvDrawRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
 {
   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
@@ -164,8 +297,7 @@
     XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1);
   else
   {
-    iDrawSetLineWidth(dc, line_width);
-    iDrawSetLineStyle(dc, style);
+    iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
 
     XDrawRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1, y2 - y1);
   }
@@ -175,8 +307,7 @@
 {
   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
 
-  iDrawSetLineWidth(dc, line_width);
-  iDrawSetLineStyle(dc, style);
+  iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
 
   XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2, y2);
 }
@@ -195,18 +326,53 @@
   }
   else
   {
-    iDrawSetLineWidth(dc, line_width);
-    iDrawSetLineStyle(dc, style);
+    iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
 
     XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1, iupRound(a1 * 64), iupRound((a2 - a1) * 64));   /* angle = 1/64ths of a degree */
   }
 }
 
+IUP_SDK_API void iupdrvDrawEllipse(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Draw full ellipse using X11 arc with 360 degree span */
+  /* angle in X11 is 1/64ths of a degree, so 360*64 = 23040 */
+  if (style == IUP_DRAW_FILL)
+  {
+    XSetArcMode(iupmot_display, dc->pixmap_gc, ArcPieSlice);
+    XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1, 0, 23040);
+  }
+  else
+  {
+    iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
+    XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1, 0, 23040);
+  }
+}
+
 IUP_SDK_API void iupdrvDrawPolygon(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width)
 {
   int i;
-  XPoint* pnt = (XPoint*)malloc(count*sizeof(XPoint)); /* XPoint uses short for coordinates */
+  XPoint stack_pnt[256]; /* Stack buffer for small polygons - avoid malloc overhead */
+  XPoint* pnt;
+  int use_heap = 0;
+  int pnt_count;
 
+  /* Use stack buffer for small polygons, heap for large ones */
+  /* For stroked polygons, we need count+1 points to close the path */
+  pnt_count = (style == IUP_DRAW_FILL) ? count : count + 1;
+
+  if (pnt_count <= 256)
+    pnt = stack_pnt;
+  else
+  {
+    pnt = (XPoint*)malloc(pnt_count * sizeof(XPoint)); /* XPoint uses short for coordinates */
+    use_heap = 1;
+  }
+
   for (i = 0; i < count; i++)
   {
     pnt[i].x = (short)points[2*i];
@@ -213,6 +379,13 @@
     pnt[i].y = (short)points[2*i+1];
   }
 
+  /* For stroked polygons, close the path by adding first point at the end */
+  if (style != IUP_DRAW_FILL)
+  {
+    pnt[count].x = pnt[0].x;
+    pnt[count].y = pnt[0].y;
+  }
+
   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
 
   if (style==IUP_DRAW_FILL)
@@ -219,15 +392,82 @@
     XFillPolygon(iupmot_display, dc->pixmap, dc->pixmap_gc, pnt, count, Complex, CoordModeOrigin);
   else
   {
-    iDrawSetLineWidth(dc, line_width);
-    iDrawSetLineStyle(dc, style);
+    iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
 
-    XDrawLines(iupmot_display, dc->pixmap, dc->pixmap_gc, pnt, count, CoordModeOrigin);
+    XDrawLines(iupmot_display, dc->pixmap, dc->pixmap_gc, pnt, pnt_count, CoordModeOrigin);
   }
 
-  free(pnt);
+  if (use_heap)
+    free(pnt);
 }
 
+IUP_SDK_API void iupdrvDrawPixel(IdrawCanvas* dc, int x, int y, long color)
+{
+  XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+  XDrawPoint(iupmot_display, dc->pixmap, dc->pixmap_gc, x, y);
+}
+
+IUP_SDK_API void iupdrvDrawRoundedRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width)
+{
+  int diameter;
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Clamp radius to prevent oversized corners */
+  int max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2 : (y2 - y1) / 2;
+  if (corner_radius > max_radius)
+    corner_radius = max_radius;
+
+  diameter = corner_radius * 2;
+
+  XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+
+  if (style == IUP_DRAW_FILL)
+  {
+    /* Fill rounded rectangle by drawing filled arcs and rectangles */
+    /* Top-right arc */
+    XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y1, diameter, diameter, 0 * 64, 90 * 64);
+    /* Bottom-right arc */
+    XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y2 - diameter, diameter, diameter, 270 * 64, 90 * 64);
+    /* Bottom-left arc */
+    XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y2 - diameter, diameter, diameter, 180 * 64, 90 * 64);
+    /* Top-left arc */
+    XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, diameter, diameter, 90 * 64, 90 * 64);
+
+    /* Fill center rectangle */
+    XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x1 + corner_radius, y1, x2 - x1 - diameter + 1, y2 - y1 + 1);
+    /* Fill left rectangle */
+    XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1 + corner_radius, corner_radius, y2 - y1 - diameter + 1);
+    /* Fill right rectangle */
+    XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - corner_radius + 1, y1 + corner_radius, corner_radius, y2 - y1 - diameter + 1);
+  }
+  else
+  {
+    iDrawSetLineStyleAndWidth(dc, style, line_width);
+
+    /* Draw rounded rectangle by drawing arcs and lines */
+    /* Top-right arc */
+    XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y1, diameter, diameter, 0 * 64, 90 * 64);
+    /* Bottom-right arc */
+    XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y2 - diameter, diameter, diameter, 270 * 64, 90 * 64);
+    /* Bottom-left arc */
+    XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y2 - diameter, diameter, diameter, 180 * 64, 90 * 64);
+    /* Top-left arc */
+    XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, diameter, diameter, 90 * 64, 90 * 64);
+
+    /* Draw connecting lines */
+    /* Top line */
+    XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x1 + corner_radius, y1, x2 - corner_radius, y1);
+    /* Right line */
+    XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x2, y1 + corner_radius, x2, y2 - corner_radius);
+    /* Bottom line */
+    XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - corner_radius, y2, x1 + corner_radius, y2);
+    /* Left line */
+    XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y2 - corner_radius, x1, y1 + corner_radius);
+  }
+}
+
 IUP_SDK_API void iupdrvDrawGetClipRect(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2)
 {
   if (x1) *x1 = dc->clip_x1;
@@ -263,6 +503,81 @@
   dc->clip_y2 = y2;
 }
 
+IUP_SDK_API void iupdrvDrawSetClipRoundedRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius)
+{
+  Region region;
+  XPoint points[100];
+  int num_points = 0;
+  int i;
+  double angle, step;
+  int max_radius;
+  double pi = 3.14159265359;
+
+  if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
+  {
+    iupdrvDrawResetClip(dc);
+    return;
+  }
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Clamp radius to prevent oversized corners */
+  max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2 : (y2 - y1) / 2;
+  if (corner_radius > max_radius)
+    corner_radius = max_radius;
+
+  /* Create a polygon approximation going clockwise from top-left */
+  /* 8 points per corner arc */
+  step = 90.0 / 8.0;
+
+  /* Top-left corner arc: from top edge (270) to left edge (180) going clockwise */
+  for (i = 0; i <= 8; i++)
+  {
+    angle = (270.0 - i * step) * pi / 180.0;
+    points[num_points].x = (short)(x1 + corner_radius + (int)(corner_radius * cos(angle)));
+    points[num_points].y = (short)(y1 + corner_radius + (int)(corner_radius * sin(angle)));
+    num_points++;
+  }
+
+  /* Bottom-left corner arc: from left edge (180) to bottom edge (90) going clockwise */
+  for (i = 1; i <= 8; i++)
+  {
+    angle = (180.0 - i * step) * pi / 180.0;
+    points[num_points].x = (short)(x1 + corner_radius + (int)(corner_radius * cos(angle)));
+    points[num_points].y = (short)(y2 - corner_radius + (int)(corner_radius * sin(angle)));
+    num_points++;
+  }
+
+  /* Bottom-right corner arc: from bottom edge (90) to right edge (0) going clockwise */
+  for (i = 1; i <= 8; i++)
+  {
+    angle = (90.0 - i * step) * pi / 180.0;
+    points[num_points].x = (short)(x2 - corner_radius + (int)(corner_radius * cos(angle)));
+    points[num_points].y = (short)(y2 - corner_radius + (int)(corner_radius * sin(angle)));
+    num_points++;
+  }
+
+  /* Top-right corner arc: from right edge (0) to top edge (270 = -90) going clockwise */
+  for (i = 1; i <= 8; i++)
+  {
+    angle = (0.0 - i * step) * pi / 180.0;
+    points[num_points].x = (short)(x2 - corner_radius + (int)(corner_radius * cos(angle)));
+    points[num_points].y = (short)(y1 + corner_radius + (int)(corner_radius * sin(angle)));
+    num_points++;
+  }
+
+  /* Create X11 region from polygon */
+  region = XPolygonRegion(points, num_points, WindingRule);
+  XSetRegion(iupmot_display, dc->pixmap_gc, region);
+  XDestroyRegion(region);
+
+  dc->clip_x1 = x1;
+  dc->clip_y1 = y1;
+  dc->clip_x2 = x2;
+  dc->clip_y2 = y2;
+}
+
 IUP_SDK_API void iupdrvDrawResetClip(IdrawCanvas* dc)
 {
   XSetClipMask(iupmot_display, dc->pixmap_gc, None);
@@ -273,19 +588,123 @@
   dc->clip_y2 = 0;
 }
 
-IUP_SDK_API void iupdrvDrawText(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, const char* font, int flags, double text_orientation)
+#ifdef IUP_USE_XFT
+static void iDrawTextXft(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, XftFont* xftfont, int flags)
 {
-  int num_line, width, off_x;
-  XFontStruct* xfont = (XFontStruct*)iupmotGetFontStruct(font);
+  int num_line, off_x;
+  XftDraw* xftdraw;
+  XftColor xftcolor;
+  XRenderColor rendercolor;
+  XGlyphInfo extents;
 
-  /* IUP_DRAW_LAYOUTCENTER, IUP_DRAW_ELLIPSIS and IUP_DRAW_WRAP are not supported */
-  (void)text_orientation;  /* not supported */
+  rendercolor.red = (unsigned short)(iupDrawRed(color) << 8);
+  rendercolor.green = (unsigned short)(iupDrawGreen(color) << 8);
+  rendercolor.blue = (unsigned short)(iupDrawBlue(color) << 8);
+  rendercolor.alpha = 0xFFFF;
+  XftColorAllocValue(iupmot_display, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen), &rendercolor, &xftcolor);
 
-  XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
-  XSetFont(iupmot_display, dc->pixmap_gc, xfont->fid);
+  xftdraw = XftDrawCreate(iupmot_display, dc->pixmap, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen));
+  if (!xftdraw)
+  {
+    XftColorFree(iupmot_display, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen), &xftcolor);
+    return;
+  }
 
+  if (flags & IUP_DRAW_CLIP)
+  {
+    XRectangle rect;
+    rect.x = (short)x;
+    rect.y = (short)y;
+    rect.width = (unsigned short)w;
+    rect.height = (unsigned short)h;
+    XftDrawSetClipRectangles(xftdraw, 0, 0, &rect, 1);
+  }
+
   num_line = iupStrLineCount(text, len);
 
+  if (num_line == 1)
+  {
+    off_x = 0;
+    if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
+    {
+      XftTextExtentsUtf8(iupmot_display, xftfont, (FcChar8*)text, len, &extents);
+      if (flags & IUP_DRAW_RIGHT)
+      {
+        off_x = w - extents.xOff;
+        if (off_x < 0) off_x = 0;
+      }
+      else
+      {
+        off_x = (w - extents.xOff) / 2;
+        if (off_x < 0) off_x = 0;
+      }
+    }
+
+    XftDrawStringUtf8(xftdraw, &xftcolor, xftfont, x + off_x, y + xftfont->ascent, (FcChar8*)text, len);
+  }
+  else
+  {
+    int i, line_height, l_len, sum_len = 0;
+    const char *p, *q;
+
+    line_height = xftfont->ascent + xftfont->descent;
+
+    p = text;
+    for (i = 0; i < num_line; i++)
+    {
+      q = strchr(p, '\n');
+      if (q)
+        l_len = (int)(q - p);
+      else
+        l_len = (int)strlen(p);
+
+      if (sum_len + l_len > len)
+        l_len = len - sum_len;
+
+      if (l_len)
+      {
+        off_x = 0;
+        if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
+        {
+          XftTextExtentsUtf8(iupmot_display, xftfont, (FcChar8*)p, l_len, &extents);
+          if (flags & IUP_DRAW_RIGHT)
+          {
+            off_x = w - extents.xOff;
+            if (off_x < 0) off_x = 0;
+          }
+          else
+          {
+            off_x = (w - extents.xOff) / 2;
+            if (off_x < 0) off_x = 0;
+          }
+        }
+
+        XftDrawStringUtf8(xftdraw, &xftcolor, xftfont, x + off_x, y + xftfont->ascent, (FcChar8*)p, l_len);
+      }
+
+      if (q)
+        p = q + 1;
+
+      sum_len += l_len;
+      if (sum_len == len)
+        break;
+
+      y += line_height;
+    }
+  }
+
+  XftDrawDestroy(xftdraw);
+  XftColorFree(iupmot_display, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen), &xftcolor);
+}
+#endif
+
+static void iDrawTextX11(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, XFontStruct* xfont, int flags)
+{
+  int num_line, width, off_x;
+
+  XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+  XSetFont(iupmot_display, dc->pixmap_gc, xfont->fid);
+
   if (flags & IUP_DRAW_CLIP)
   {
     XRectangle rect;
@@ -296,21 +715,25 @@
     XSetClipRectangles(iupmot_display, dc->pixmap_gc, 0, 0, &rect, 1, Unsorted);
   }
 
+  num_line = iupStrLineCount(text, len);
+
   if (num_line == 1)
   {
     off_x = 0;
-    if (flags & IUP_DRAW_RIGHT)
+    if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
     {
       width = XTextWidth(xfont, text, len);
-      off_x = w - width;
-      if (off_x < 0) off_x = 0;
+      if (flags & IUP_DRAW_RIGHT)
+      {
+        off_x = w - width;
+        if (off_x < 0) off_x = 0;
+      }
+      else
+      {
+        off_x = (w - width) / 2;
+        if (off_x < 0) off_x = 0;
+      }
     }
-    else if (flags & IUP_DRAW_CENTER)
-    {
-      width = XTextWidth(xfont, text, len);
-      off_x = (w - width) / 2;
-      if (off_x < 0) off_x = 0;
-    }
 
     XDrawString(iupmot_display, dc->pixmap, dc->pixmap_gc, x + off_x, y + xfont->ascent, text, len);
   }
@@ -326,9 +749,9 @@
     {
       q = strchr(p, '\n');
       if (q)
-        l_len = (int)(q - p);  /* Cut the string to contain only one line */
+        l_len = (int)(q - p);
       else
-        l_len = (int)strlen(p);  /* use the remaining characters */
+        l_len = (int)strlen(p);
 
       if (sum_len + l_len > len)
         l_len = len - sum_len;
@@ -336,24 +759,24 @@
       if (l_len)
       {
         off_x = 0;
-        if (flags & IUP_DRAW_RIGHT)
+        if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
         {
           width = XTextWidth(xfont, p, l_len);
-          off_x = w - width;
-          if (off_x < 0) off_x = 0;
+          if (flags & IUP_DRAW_RIGHT)
+          {
+            off_x = w - width;
+            if (off_x < 0) off_x = 0;
+          }
+          else
+          {
+            off_x = (w - width) / 2;
+            if (off_x < 0) off_x = 0;
+          }
         }
-        else if (flags & IUP_DRAW_CENTER)
-        {
-          width = XTextWidth(xfont, p, l_len);
-          off_x = (w - width) / 2;
-          if (off_x < 0) off_x = 0;
-        }
 
-        /* Draw the line */
         XDrawString(iupmot_display, dc->pixmap, dc->pixmap_gc, x + off_x, y + xfont->ascent, p, l_len);
       }
 
-      /* Advance the string */
       if (q)
         p = q + 1;
 
@@ -361,16 +784,36 @@
       if (sum_len == len)
         break;
 
-      /* Advance a line */
       y += line_height;
     }
   }
 
-  /* restore settings */
   if (flags & IUP_DRAW_CLIP)
     XSetClipMask(iupmot_display, dc->pixmap_gc, None);
 }
 
+IUP_SDK_API void iupdrvDrawText(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, const char* font, int flags, double text_orientation)
+{
+  (void)text_orientation;
+
+#ifdef IUP_USE_XFT
+  {
+    XftFont* xftfont = (XftFont*)iupmotGetXftFont(font);
+    if (xftfont)
+    {
+      iDrawTextXft(dc, text, len, x, y, w, h, color, xftfont, flags);
+      return;
+    }
+  }
+#endif
+
+  {
+    XFontStruct* xfont = (XFontStruct*)iupmotGetFontStruct(font);
+    if (xfont)
+      iDrawTextX11(dc, text, len, x, y, w, h, color, xfont, flags);
+  }
+}
+
 IUP_SDK_API void iupdrvDrawImage(IdrawCanvas* dc, const char* name, int make_inactive, const char* bgcolor, int x, int y, int w, int h)
 {
   int img_w, img_h;
@@ -382,11 +825,13 @@
   /* must use this info, since image can be a driver image loaded from resources */
   iupdrvImageGetInfo((void*)pixmap, &img_w, &img_h, &bpp);
 
-  XCopyArea(iupmot_display, pixmap, dc->pixmap, dc->pixmap_gc, 0, 0, img_w, img_h, x, y);
-
-  /* zoom not supported */
+  /* Image scaling not supported in X11 driver */
+  if (w == -1 || w == 0) w = img_w;
+  if (h == -1 || h == 0) h = img_h;
   (void)w;
   (void)h;
+
+  XCopyArea(iupmot_display, pixmap, dc->pixmap, dc->pixmap_gc, 0, 0, img_w, img_h, x, y);
 }
 
 IUP_SDK_API void iupdrvDrawSelectRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2)
@@ -410,3 +855,139 @@
 
   XmeDrawHighlight(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1, 1);
 }
+
+IUP_SDK_API void iupdrvDrawBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width)
+{
+  /* X11/Motif does not have native Bezier support - use line approximation */
+  XPoint points[21]; /* 20 segments should give smooth curve */
+  int i, num_segments = 20;
+
+  /* Set color and line properties */
+  XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+  XSetLineAttributes(iupmot_display, dc->pixmap_gc, line_width, LineSolid, CapRound, JoinRound);
+
+  /* Generate points along Bezier curve using parametric equation */
+  for (i = 0; i <= num_segments; i++)
+  {
+    double t = (double)i / num_segments;
+    double t1 = 1.0 - t;
+    double t1_3 = t1 * t1 * t1;
+    double t1_2_t = 3.0 * t1 * t1 * t;
+    double t1_t_2 = 3.0 * t1 * t * t;
+    double t_3 = t * t * t;
+
+    points[i].x = (short)(t1_3 * x1 + t1_2_t * x2 + t1_t_2 * x3 + t_3 * x4);
+    points[i].y = (short)(t1_3 * y1 + t1_2_t * y2 + t1_t_2 * y3 + t_3 * y4);
+  }
+
+  if (style == IUP_DRAW_FILL)
+  {
+    /* Fill as polygon */
+    XFillPolygon(iupmot_display, dc->pixmap, dc->pixmap_gc, points, num_segments + 1, Nonconvex, CoordModeOrigin);
+  }
+  else
+  {
+    /* Draw as polyline */
+    XDrawLines(iupmot_display, dc->pixmap, dc->pixmap_gc, points, num_segments + 1, CoordModeOrigin);
+  }
+}
+
+IUP_SDK_API void iupdrvDrawQuadraticBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width)
+{
+  /* Convert quadratic Bezier to cubic Bezier using the 2/3 formula */
+  int cx1, cy1, cx2, cy2;
+
+  cx1 = x1 + ((2 * (x2 - x1)) / 3);
+  cy1 = y1 + ((2 * (y2 - y1)) / 3);
+  cx2 = x3 + ((2 * (x2 - x3)) / 3);
+  cy2 = y3 + ((2 * (y2 - y3)) / 3);
+
+  iupdrvDrawBezier(dc, x1, y1, cx1, cy1, cx2, cy2, x3, y3, color, style, line_width);
+}
+
+static long x11InterpolateColor(long color1, long color2, float t)
+{
+  unsigned char r1 = iupDrawRed(color1), g1 = iupDrawGreen(color1), b1 = iupDrawBlue(color1), a1 = iupDrawAlpha(color1);
+  unsigned char r2 = iupDrawRed(color2), g2 = iupDrawGreen(color2), b2 = iupDrawBlue(color2), a2 = iupDrawAlpha(color2);
+  unsigned char r = (unsigned char)(r1 + t * (r2 - r1));
+  unsigned char g = (unsigned char)(g1 + t * (g2 - g1));
+  unsigned char b = (unsigned char)(b1 + t * (b2 - b1));
+  unsigned char a = (unsigned char)(a1 + t * (a2 - a1));
+  return iupDrawColor(r, g, b, a);
+}
+
+IUP_SDK_API void iupdrvDrawLinearGradient(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2)
+{
+  int i, steps;
+  float t, dx, dy, length;
+  int px1, py1, px2, py2;
+  unsigned long pixel;
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Calculate gradient direction */
+  float rad = angle * 3.14159265359f / 180.0f;
+  dx = (float)cos(rad);
+  dy = (float)sin(rad);
+
+  /* Number of steps for smooth gradient */
+  length = (float)sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
+  steps = (int)length;
+  if (steps < 2) steps = 2;
+  if (steps > 256) steps = 256;
+
+  /* Draw gradient strips */
+  for (i = 0; i < steps; i++)
+  {
+    t = (float)i / (float)(steps - 1);
+    long color = x11InterpolateColor(color1, color2, t);
+
+    pixel = iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color));
+    XSetForeground(iupmot_display, dc->pixmap_gc, pixel);
+
+    /* Calculate strip position */
+    if (fabs(dx) > fabs(dy))  /* More horizontal */
+    {
+      px1 = x1 + (int)(t * (x2 - x1));
+      px2 = x1 + (int)((t + 1.0f / steps) * (x2 - x1));
+      py1 = y1;
+      py2 = y2;
+    }
+    else  /* More vertical */
+    {
+      px1 = x1;
+      px2 = x2;
+      py1 = y1 + (int)(t * (y2 - y1));
+      py2 = y1 + (int)((t + 1.0f / steps) * (y2 - y1));
+    }
+
+    XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, px1, py1, px2 - px1 + 1, py2 - py1 + 1);
+  }
+}
+
+IUP_SDK_API void iupdrvDrawRadialGradient(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge)
+{
+  int i, steps;
+  float t, r;
+  unsigned long pixel;
+
+  /* Number of steps for smooth gradient */
+  steps = radius;
+  if (steps < 2) steps = 2;
+  if (steps > 256) steps = 256;
+
+  /* Draw from outside to inside */
+  for (i = steps - 1; i >= 0; i--)
+  {
+    t = (float)i / (float)(steps - 1);
+    long color = x11InterpolateColor(colorCenter, colorEdge, t);
+    r = (float)radius * t;
+
+    pixel = iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color));
+    XSetForeground(iupmot_display, dc->pixmap_gc, pixel);
+
+    XSetArcMode(iupmot_display, dc->pixmap_gc, ArcPieSlice);
+    XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, (int)(cx - r), (int)(cy - r), (int)(2 * r), (int)(2 * r), 0, 23040);
+  }
+}
Index: src/mot/iupmot_drv.h
===================================================================
--- src/mot/iupmot_drv.h	(revision 5971)
+++ src/mot/iupmot_drv.h	(working copy)
@@ -42,6 +42,10 @@
 char* iupmotFindFontList(XmFontList fontlist);
 char* iupmotGetFontStructAttrib(Ihandle *ih);
 char* iupmotGetFontIdAttrib(Ihandle *ih);
+#ifdef IUP_USE_XFT
+void* iupmotGetXftFontAttrib(Ihandle *ih);
+void* iupmotGetXftFont(const char* value);
+#endif
 
 /* tips */
 /* called from Enter/Leave events to check if a TIP is present. */
@@ -57,6 +61,15 @@
 void iupmotTextSetString(Widget w, const char *value);
 XmString iupmotStringCreate(const char *value);
 void iupmotSetTitle(Widget w, const char *value);
+void iupmotStrSetUTF8Mode(int utf8mode);
+void iupmotStrSetUTF8ModeFile(int utf8mode);
+int iupmotStrGetUTF8Mode(void);
+int iupmotStrGetUTF8ModeFile(void);
+char* iupmotStrConvertToSystem(const char* str);
+char* iupmotStrConvertFromSystem(const char* str);
+char* iupmotStrConvertToFilename(const char* str);
+char* iupmotStrConvertFromFilename(const char* str);
+void iupmotStrRelease(void);
 
 /* common */
 void iupmotPointerMotionEvent(Widget w, Ihandle *ih, XEvent *evt, Boolean *cont);
@@ -85,7 +98,17 @@
 int iupUnixIsDirectory(const char* name);
 int iupUnixMakeDirectory(const char* name);
 
+/* tray */
+int iupmotSetTrayAttrib(Ihandle* ih, const char* value);
+int iupmotSetTrayTipAttrib(Ihandle* ih, const char* value);
+int iupmotSetTrayImageAttrib(Ihandle* ih, const char* value);
+int iupmotSetTrayMenuAttrib(Ihandle* ih, const char* value);
+void iupmotTrayCleanup(Ihandle* ih);
 
+/* dark mode */
+int iupmotIsSystemDarkMode(void);
+
+
 #ifdef __cplusplus
 }
 #endif
Index: src/mot/iupmot_filedlg.c
===================================================================
--- src/mot/iupmot_filedlg.c	(revision 5971)
+++ src/mot/iupmot_filedlg.c	(working copy)
@@ -515,6 +515,7 @@
   iupAttribSet(ih, "PREVIEWDC", (char*)gc);
   iupAttribSet(ih, "WID", (char*)w);
 
+  iupAttribSet(ih, "DRAWABLE", (char*)XtWindow(w));
   iupAttribSet(ih, "XWINDOW", (char*)XtWindow(w));
   iupAttribSet(ih, "XDISPLAY", (char*)iupmot_display);
   motFileDlgUpdatePreviewGLCanvas(ih);
@@ -564,6 +565,18 @@
     cb(ih, filename, "OTHER");
 
   XtFree(filename);
+
+  if (iupAttribGetBoolean(ih, "SHOWPREVIEW"))
+  {
+    Widget preview_canvas = (Widget)iupAttribGet(ih, "WID");
+    if (preview_canvas)
+    {
+      Window wnd = XtWindow(preview_canvas);
+      if (wnd)
+        XClearArea(iupmot_display, wnd, 0, 0, 0, 0, True);
+    }
+  }
+
   (void)w;
 }
 
Index: src/mot/iupmot_font.c
===================================================================
--- src/mot/iupmot_font.c	(revision 5971)
+++ src/mot/iupmot_font.c	(working copy)
@@ -10,6 +10,10 @@
 #include <Xm/Xm.h>
 #include <Xm/XmP.h>
 
+#ifdef IUP_USE_XFT
+#include <X11/Xft/Xft.h>
+#endif
+
 #include "iup.h"
 
 #include "iup_str.h"
@@ -23,12 +27,17 @@
 #include "iupmot_drv.h"
 
 
-typedef struct _ImotFont 
+typedef struct _ImotFont
 {
   char font[1024];
   char xlfd[1024];  /* X-Windows Font Description */
   XmFontList fontlist;  /* same as XmRenderTable */
   XFontStruct *fontstruct;
+#ifdef IUP_USE_XFT
+  XftFont *xftfont;
+  char xft_pattern[1024];
+  int is_xft;
+#endif
   int charwidth, charheight;
 } ImotFont;
 
@@ -135,6 +144,45 @@
   return fontstruct;
 }
 
+#ifdef IUP_USE_XFT
+static XftFont* motLoadXftFont(const char* typeface, int size, int bold, int italic, char* pattern_out)
+{
+  XftFont* xftfont;
+  char font_name[1024];
+  int xft_size;
+
+  if (iupStrEqualNoCase(typeface, "System"))
+    typeface = "Sans";
+
+  if (iupStrEqualNoCase(typeface, "fixed"))
+    typeface = "Monospace";
+
+  if (size < 0)
+  {
+    double res = ((double)DisplayWidth(iupmot_display, iupmot_screen) / (double)DisplayWidthMM(iupmot_display, iupmot_screen));
+    xft_size = iupRound((-size / res)*2.83464567);
+  }
+  else
+    xft_size = size;
+
+  if (bold && italic)
+    sprintf(font_name, "%s:size=%d:weight=bold:slant=italic", typeface, xft_size);
+  else if (bold)
+    sprintf(font_name, "%s:size=%d:weight=bold", typeface, xft_size);
+  else if (italic)
+    sprintf(font_name, "%s:size=%d:slant=italic", typeface, xft_size);
+  else
+    sprintf(font_name, "%s:size=%d", typeface, xft_size);
+
+  xftfont = XftFontOpenName(iupmot_display, iupmot_screen, font_name);
+
+  if (xftfont && pattern_out)
+    strcpy(pattern_out, font_name);
+
+  return xftfont;
+}
+#endif
+
 static XmFontList motFontCreateRenderTable(XFontStruct* fontstruct, int is_underline, int is_strikeout)
 {
   XmFontList fontlist;
@@ -165,6 +213,103 @@
   return fontlist;
 }
 
+#ifdef IUP_USE_XFT
+static XmFontList motFontCreateXftRenderTable(const char* xft_pattern, int is_underline, int is_strikeout, XftFont* xftfont)
+{
+  XmFontList fontlist;
+  XmRendition rendition;
+  Arg args[20];
+  int num_args = 0;
+  char family[256];
+  int size = 0;
+  int weight = 0;  /* 0=normal, 1=bold */
+  int slant = 0;   /* 0=normal, 1=italic */
+
+  /* Parse the XFT pattern to extract family, size, weight, slant */
+  {
+    const char* p = xft_pattern;
+    char* f = family;
+
+    /* Extract family name (everything before first ':') */
+    while (*p && *p != ':' && (f - family) < 255)
+      *f++ = *p++;
+    *f = '\0';
+
+    /* Parse properties after ':' */
+    while (*p)
+    {
+      if (*p == ':')
+      {
+        p++;
+        if (strncmp(p, "size=", 5) == 0)
+        {
+          size = atoi(p + 5);
+          while (*p && *p != ':') p++;
+        }
+        else if (strncmp(p, "weight=bold", 11) == 0)
+        {
+          weight = 1;
+          while (*p && *p != ':') p++;
+        }
+        else if (strncmp(p, "slant=italic", 12) == 0)
+        {
+          slant = 1;
+          while (*p && *p != ':') p++;
+        }
+        else
+        {
+          /* Skip unknown property */
+          while (*p && *p != ':') p++;
+        }
+      }
+      else
+        p++;
+    }
+  }
+
+  /* Set Motif XFT rendition resources separately */
+  iupMOT_SETARG(args, num_args, XmNfontName, family);
+  iupMOT_SETARG(args, num_args, XmNfontType, XmFONT_IS_XFT);
+  if (size > 0)
+    iupMOT_SETARG(args, num_args, XmNfontSize, size);
+
+  /* Build style string for XmNfontStyle (e.g., "Bold Italic") */
+  if (weight || slant)
+  {
+    static char style[64];
+    style[0] = '\0';
+    if (weight)
+      strcat(style, "Bold");
+    if (slant)
+    {
+      if (weight) strcat(style, " ");
+      strcat(style, "Italic");
+    }
+    iupMOT_SETARG(args, num_args, XmNfontStyle, style);
+  }
+
+  iupMOT_SETARG(args, num_args, XmNloadModel, XmLOAD_IMMEDIATE);
+
+  if (is_underline)
+    iupMOT_SETARG(args, num_args, XmNunderlineType, XmSINGLE_LINE);
+  else
+    iupMOT_SETARG(args, num_args, XmNunderlineType, XmNO_LINE);
+
+  if (is_strikeout)
+    iupMOT_SETARG(args, num_args, XmNstrikethruType, XmSINGLE_LINE);
+  else
+    iupMOT_SETARG(args, num_args, XmNstrikethruType, XmNO_LINE);
+
+  rendition = XmRenditionCreate(iupmot_appshell, "", args, num_args);
+
+  fontlist = XmRenderTableAddRenditions(NULL, &rendition, 1, XmDUPLICATE);
+
+  XmRenditionFree(rendition);
+
+  return fontlist;
+}
+#endif
+
 static int motFontCalcCharWidth(XFontStruct *fontstruct)
 {
   if (fontstruct->per_char)
@@ -182,10 +327,30 @@
     return fontstruct->max_bounds.width;
 }
 
+#ifdef IUP_USE_XFT
+static int motFontCalcXftCharWidth(XftFont *xftfont)
+{
+  int i, all = 0;
+  XGlyphInfo extents;
+
+  for (i = 32; i <= 126; i++)
+  {
+    XftTextExtents8(iupmot_display, xftfont, (FcChar8*)&i, 1, &extents);
+    all += extents.xOff;
+  }
+  return all / (126 - 32 + 1);
+}
+#endif
+
 static ImotFont* motFindFont(const char* foundry, const char *font)
 {
   char xlfd[1024];
-  XFontStruct* fontstruct;
+  XFontStruct* fontstruct = NULL;
+  int try_xft = 0;
+#ifdef IUP_USE_XFT
+  XftFont* xftfont = NULL;
+  char xft_pattern[1024];
+#endif
   int i, count = iupArrayCount(mot_fonts);
   int is_underline = 0, is_strikeout = 0;
 
@@ -222,8 +387,14 @@
     if (mapped_name)
       strcpy(typeface, mapped_name);
 
+#ifdef IUP_USE_XFT
+    xftfont = motLoadXftFont(typeface, size, is_bold, is_italic, xft_pattern);
+    if (xftfont)
+      try_xft = 1;
+#endif
+
     fontstruct = motLoadFont(foundry, typeface, size, is_bold, is_italic, xlfd);
-    if (!fontstruct) 
+    if (!fontstruct && !try_xft)
       return NULL;
   }
 
@@ -231,12 +402,44 @@
   fonts = (ImotFont*)iupArrayInc(mot_fonts);
 
   strcpy(fonts[i].font, font);
-  strcpy(fonts[i].xlfd, xlfd);
-  fonts[i].fontstruct = fontstruct;
-  fonts[i].fontlist = motFontCreateRenderTable(fontstruct, is_underline, is_strikeout);
-  fonts[i].charwidth = motFontCalcCharWidth(fontstruct);
-  fonts[i].charheight = fontstruct->ascent + fontstruct->descent;
+#ifdef IUP_USE_XFT
+  if (try_xft && xftfont)
+  {
+    strcpy(fonts[i].xft_pattern, xft_pattern);
+    fonts[i].xftfont = xftfont;
+    fonts[i].is_xft = 1;
+    fonts[i].fontlist = motFontCreateXftRenderTable(xft_pattern, is_underline, is_strikeout, xftfont);
 
+    if (fontstruct)
+    {
+      strcpy(fonts[i].xlfd, xlfd);
+      fonts[i].fontstruct = fontstruct;
+      fonts[i].charwidth = motFontCalcCharWidth(fontstruct);
+      fonts[i].charheight = fontstruct->ascent + fontstruct->descent;
+    }
+    else
+    {
+      strcpy(fonts[i].xlfd, "");
+      fonts[i].fontstruct = NULL;
+      fonts[i].charwidth = motFontCalcXftCharWidth(xftfont);
+      fonts[i].charheight = xftfont->ascent + xftfont->descent;
+    }
+  }
+  else
+#endif
+  {
+    strcpy(fonts[i].xlfd, xlfd);
+    fonts[i].fontstruct = fontstruct;
+#ifdef IUP_USE_XFT
+    fonts[i].xftfont = NULL;
+    strcpy(fonts[i].xft_pattern, "");
+    fonts[i].is_xft = 0;
+#endif
+    fonts[i].fontlist = motFontCreateRenderTable(fontstruct, is_underline, is_strikeout);
+    fonts[i].charwidth = motFontCalcCharWidth(fontstruct);
+    fonts[i].charheight = fontstruct->ascent + fontstruct->descent;
+  }
+
   return &fonts[i];
 }
 
@@ -250,7 +453,11 @@
 
   if (!motfont)
   {
+#ifdef IUP_USE_XFT
+    font = "Sans, 12";
+#else
     font = "Fixed, 11";
+#endif
     motFindFont("misc", font);
   }
 
@@ -285,12 +492,24 @@
 XFontStruct* iupmotGetFontStruct(const char* value)
 {
   ImotFont *motfont = motFindFont(NULL, value);
-  if (!motfont) 
+  if (!motfont)
     return NULL;
   else
     return motfont->fontstruct;
 }
 
+#ifdef IUP_USE_XFT
+void* iupmotGetXftFont(const char* value)
+{
+  ImotFont *motfont = motFindFont(NULL, value);
+  if (!motfont)
+    return NULL;
+  if (motfont->is_xft)
+    return (void*)motfont->xftfont;
+  return NULL;
+}
+#endif
+
 static ImotFont* motFontCreateNativeFont(Ihandle* ih, const char* value)
 {
   ImotFont *motfont = motFindFont(iupAttribGet(ih, "FOUNDRY"), value);
@@ -340,23 +559,43 @@
   ImotFont* motfont = motGetFont(ih);
   if (!motfont)
     return NULL;
-  else
-    return (char*)motfont->fontstruct->fid;
+#ifdef IUP_USE_XFT
+  if (motfont->is_xft)
+    return NULL;
+#endif
+  if (!motfont->fontstruct)
+    return NULL;
+  return (char*)motfont->fontstruct->fid;
 }
 
+#ifdef IUP_USE_XFT
+void* iupmotGetXftFontAttrib(Ihandle *ih)
+{
+  ImotFont* motfont = motGetFont(ih);
+  if (!motfont)
+    return NULL;
+  if (motfont->is_xft)
+    return (void*)motfont->xftfont;
+  return NULL;
+}
+#endif
+
 IUP_SDK_API int iupdrvSetFontAttrib(Ihandle* ih, const char* value)
 {
   ImotFont *motfont = motFontCreateNativeFont(ih, value);
-  if (!motfont) 
+  if (!motfont)
     return 0;
 
   /* If FONT is changed, must update the SIZE attribute */
   iupBaseUpdateAttribFromFont(ih);
 
-  /* FONT attribute must be able to be set before mapping, 
+  /* FONT attribute must be able to be set before mapping,
     so the font is enable for size calculation. */
   if (ih->handle && (ih->iclass->nativetype != IUP_TYPEVOID))
+  {
     XtVaSetValues(ih->handle, XmNrenderTable, motfont->fontlist, NULL);
+    XtVaSetValues(ih->handle, XmNfontList, motfont->fontlist, NULL);
+  }
 
   return 1;
 }
@@ -363,7 +602,7 @@
 
 IUP_SDK_API int iupdrvFontGetStringWidth(Ihandle* ih, const char* str)
 {
-  XFontStruct* fontstruct;
+  ImotFont* motfont;
   int len;
   char* line_end;
 
@@ -370,8 +609,8 @@
   if (!str || str[0]==0)
     return 0;
 
-  fontstruct = (XFontStruct*)iupmotGetFontStructAttrib(ih);
-  if (!fontstruct)
+  motfont = motGetFont(ih);
+  if (!motfont)
     return 0;
 
   line_end = strchr(str, '\n');
@@ -380,7 +619,20 @@
   else
     len = (int)strlen(str);
 
-  return XTextWidth(fontstruct, str, len);
+#ifdef IUP_USE_XFT
+  if (motfont->is_xft && motfont->xftfont)
+  {
+    XGlyphInfo extents;
+    XftTextExtentsUtf8(iupmot_display, motfont->xftfont, (FcChar8*)str, len, &extents);
+    return extents.xOff;
+  }
+  else
+#endif
+  {
+    if (!motfont->fontstruct)
+      return 0;
+    return XTextWidth(motfont->fontstruct, str, len);
+  }
 }
 
 static void motFontGetTextSize(ImotFont* motfont, const char* str, int len, int *w, int *h)
@@ -400,7 +652,7 @@
     if (h) *h = motfont->charheight * 1;
     return;
   }
-  
+
   if (str[0])
   {
     int l_len, lw, sum_len = 0;
@@ -415,7 +667,21 @@
 
       if (l_len)
       {
-        lw = XTextWidth(motfont->fontstruct, curstr, l_len);
+#ifdef IUP_USE_XFT
+        if (motfont->is_xft && motfont->xftfont)
+        {
+          XGlyphInfo extents;
+          XftTextExtentsUtf8(iupmot_display, motfont->xftfont, (FcChar8*)curstr, l_len, &extents);
+          lw = extents.xOff;
+        }
+        else
+#endif
+        {
+          if (motfont->fontstruct)
+            lw = XTextWidth(motfont->fontstruct, curstr, l_len);
+          else
+            lw = 0;
+        }
         max_w = iupMAX(max_w, lw);
       }
 
@@ -453,10 +719,25 @@
   ImotFont *motfont = motFindFont(NULL, font);
   if (motfont)
   {
-    if (max_width) *max_width = motfont->fontstruct->max_bounds.width;
-    if (line_height) *line_height = motfont->fontstruct->ascent + motfont->fontstruct->descent;
-    if (ascent)    *ascent = motfont->fontstruct->ascent;
-    if (descent)   *descent = motfont->fontstruct->descent;
+#ifdef IUP_USE_XFT
+    if (motfont->is_xft && motfont->xftfont)
+    {
+      if (max_width) *max_width = motfont->xftfont->max_advance_width;
+      if (line_height) *line_height = motfont->xftfont->ascent + motfont->xftfont->descent;
+      if (ascent)    *ascent = motfont->xftfont->ascent;
+      if (descent)   *descent = motfont->xftfont->descent;
+    }
+    else
+#endif
+    {
+      if (motfont->fontstruct)
+      {
+        if (max_width) *max_width = motfont->fontstruct->max_bounds.width;
+        if (line_height) *line_height = motfont->fontstruct->ascent + motfont->fontstruct->descent;
+        if (ascent)    *ascent = motfont->fontstruct->ascent;
+        if (descent)   *descent = motfont->fontstruct->descent;
+      }
+    }
   }
 }
 
@@ -490,8 +771,21 @@
   {
     XmFontListFree(fonts[i].fontlist);
     fonts[i].fontlist = NULL;
-    XFreeFont(iupmot_display, fonts[i].fontstruct);
-    fonts[i].fontstruct = NULL;
+#ifdef IUP_USE_XFT
+    if (fonts[i].is_xft && fonts[i].xftfont)
+    {
+      XftFontClose(iupmot_display, fonts[i].xftfont);
+      fonts[i].xftfont = NULL;
+    }
+    else
+#endif
+    {
+      if (fonts[i].fontstruct)
+      {
+        XFreeFont(iupmot_display, fonts[i].fontstruct);
+        fonts[i].fontstruct = NULL;
+      }
+    }
   }
   iupArrayDestroy(mot_fonts);
 }
Index: src/mot/iupmot_globalattrib.c
===================================================================
--- src/mot/iupmot_globalattrib.c	(revision 5971)
+++ src/mot/iupmot_globalattrib.c	(working copy)
@@ -153,11 +153,26 @@
     XChangeKeyboardControl(iupmot_display, KBAutoRepeatMode, &values);
     return 0;
   }
+  if (iupStrEqual(name, "UTF8MODE"))
+  {
+    iupmotStrSetUTF8Mode(iupStrBoolean(value));
+    return 1;
+  }
+  if (iupStrEqual(name, "UTF8MODE_FILE"))
+  {
+    iupmotStrSetUTF8ModeFile(iupStrBoolean(value));
+    return 1;
+  }
   return 1;
 }
 
 IUP_SDK_API char* iupdrvGetGlobal(const char *name)
 {
-  (void)name;
+  if (iupStrEqual(name, "UTF8MODE"))
+    return iupStrReturnBoolean(iupmotStrGetUTF8Mode());
+  if (iupStrEqual(name, "UTF8MODE_FILE"))
+    return iupStrReturnBoolean(iupmotStrGetUTF8ModeFile());
+  if (iupStrEqual(name, "DARKMODE"))
+    return iupStrReturnBoolean(iupmotIsSystemDarkMode());
   return NULL;
 }
Index: src/mot/iupmot_image.c
===================================================================
--- src/mot/iupmot_image.c	(revision 5971)
+++ src/mot/iupmot_image.c	(working copy)
@@ -162,7 +162,8 @@
 
   bpp = iupAttribGetInt(ih, "BPP");
 
-  iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);
+  if (bgcolor)
+    iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);
 
   if (bpp == 8)
   {
@@ -175,11 +176,21 @@
     {
       if (colors[i].a == 0)
       {
-        colors[i].r = bg_r;
-        colors[i].g = bg_g;
-        colors[i].b = bg_b;
-        colors[i].a = 255;
-        bgcolor_depend = 1;
+        if (bgcolor)
+        {
+          colors[i].r = bg_r;
+          colors[i].g = bg_g;
+          colors[i].b = bg_b;
+          colors[i].a = 255;
+          bgcolor_depend = 1;
+        }
+        else
+        {
+          colors[i].r = 0;
+          colors[i].g = 0;
+          colors[i].b = 0;
+          colors[i].a = 0;
+        }
       }
 
       if (make_inactive)
@@ -214,9 +225,8 @@
         if (bpp == 32)
         {
           unsigned char a = *(pixel_data+3);
-          if (a != 255)
+          if (bgcolor && a != 255)
           {
-            /* flat alpha */
             r = iupALPHABLEND(r, bg_r, a);
             g = iupALPHABLEND(g, bg_g, a);
             b = iupALPHABLEND(b, bg_b, a);
@@ -322,7 +332,7 @@
 
 static Pixmap motImageCreateMask(Ihandle *ih)
 {
-  int bpp,y,x,
+  int bpp, y, x,
       width = ih->currentwidth,
       height = ih->currentheight,
       line_size = (width+7)/8,
@@ -330,34 +340,56 @@
   unsigned char *imgdata = (unsigned char*)iupAttribGetStr(ih, "WID");
   char *bits, *sb;
   Pixmap mask;
-  unsigned char colors[256];
 
   bpp = iupAttribGetInt(ih, "BPP");
-  if (bpp > 8)
-    return 0;
 
   bits = (char*)malloc(size_bytes);
   if (!bits) return 0;
   memset(bits, 0, size_bytes);
 
-  iupImageInitNonBgColors(ih, colors);
+  sb = bits;
 
-  sb = bits;
-  for (y=0; y<height; y++)
+  if (bpp == 8)
   {
-    for (x=0; x<width; x++)
+    unsigned char colors[256];
+    iupImageInitNonBgColors(ih, colors);
+
+    for (y=0; y<height; y++)
     {
-      int byte = x/8;
-      int bit = x%8;
-      int index = (int)imgdata[y*width+x];
-      if (colors[index])
-        sb[byte] = (char)(sb[byte] | (1<<bit));
+      for (x=0; x<width; x++)
+      {
+        int byte = x/8;
+        int bit = x%8;
+        int index = (int)imgdata[y*width+x];
+        if (colors[index])
+          sb[byte] = (char)(sb[byte] | (1<<bit));
+      }
+      sb += line_size;
     }
-
-    sb += line_size;
   }
+  else if (bpp == 32)
+  {
+    for (y=0; y<height; y++)
+    {
+      for (x=0; x<width; x++)
+      {
+        int byte = x/8;
+        int bit = x%8;
+        unsigned char *pixel_data = imgdata + (y*width + x)*4;
+        unsigned char a = *(pixel_data+3);
+        if (a > 127)
+          sb[byte] = (char)(sb[byte] | (1<<bit));
+      }
+      sb += line_size;
+    }
+  }
+  else
+  {
+    free(bits);
+    return 0;
+  }
 
-  mask = XCreateBitmapFromData(iupmot_display, 
+  mask = XCreateBitmapFromData(iupmot_display,
                                RootWindow(iupmot_display,iupmot_screen),
                                bits, width, height);
 
Index: src/mot/iupmot_label.c
===================================================================
--- src/mot/iupmot_label.c	(revision 5971)
+++ src/mot/iupmot_label.c	(working copy)
@@ -49,31 +49,43 @@
 
 static int motLabelSetBgColorAttrib(Ihandle* ih, const char* value)
 {
-  /* ignore given value, must use only from parent */
-  value = iupBaseNativeParentGetBgColor(ih);
+  unsigned char r, g, b;
 
+  /* Try to use provided value first */
+  if (!iupStrToRGB(value, &r, &g, &b))
+  {
+    /* Fall back to parent's background if no valid color provided */
+    value = iupBaseNativeParentGetBgColor(ih);
+  }
+
   if (iupdrvBaseSetBgColorAttrib(ih, value))
     return 1;
-  return 0; 
+  return 0;
 }
 
 static int motLabelSetBackgroundAttrib(Ihandle* ih, const char* value)
 {
-  /* ignore given value, must use only from parent */
-  value = iupAttribGetInheritNativeParent(ih, "BACKGROUND");
+  unsigned char r, g, b;
 
-  if (iupdrvBaseSetBgColorAttrib(ih, value))
-    return 1;
-  else
+  /* Try to use provided value first */
+  if (!value || !iupStrToRGB(value, &r, &g, &b))
   {
-    Pixmap pixmap = (Pixmap)iupImageGetImage(value, ih, 0, NULL);
+    /* Check if it's an image name */
+    Pixmap pixmap = value ? (Pixmap)iupImageGetImage(value, ih, 0, NULL) : 0;
     if (pixmap)
     {
       XtVaSetValues(ih->handle, XmNbackgroundPixmap, pixmap, NULL);
       return 1;
     }
+
+    /* Fall back to parent's background */
+    value = iupAttribGetInheritNativeParent(ih, "BACKGROUND");
   }
-  return 0; 
+
+  if (iupdrvBaseSetBgColorAttrib(ih, value))
+    return 1;
+
+  return 0;
 }
 
 static int motLabelSetAlignmentAttrib(Ihandle* ih, const char* value)
Index: src/mot/iupmot_list.c
===================================================================
--- src/mot/iupmot_list.c	(revision 5971)
+++ src/mot/iupmot_list.c	(working copy)
@@ -18,6 +18,7 @@
 #include <string.h>
 #include <memory.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <time.h>
 #include <limits.h>
 
@@ -41,6 +42,9 @@
 static void motListComboBoxSelectionCallback(Widget w, Ihandle* ih, XmComboBoxCallbackStruct* call_data);
 
 
+/* Motif XmList does not support per-item images.
+   IMAGE_CB callback is not supported for virtual mode.
+   Use IupFlatList for image support on Motif. */
 void* iupdrvListGetImageHandle(Ihandle* ih, int id)
 {
   (void)ih;
@@ -216,10 +220,51 @@
     XmListDeleteAllItems(ih->handle);
 }
 
+void iupdrvListSetItemCount(Ihandle* ih, int count)
+{
+  Widget list_widget;
+  int i;
+  XmString* items;
 
+  if (!ih->data->is_virtual)
+    return;
+
+  /* Get the list widget */
+  if (ih->data->is_dropdown || ih->data->has_editbox)
+    XtVaGetValues(ih->handle, XmNlist, &list_widget, NULL);
+  else
+    list_widget = ih->handle;
+
+  /* Delete all existing items */
+  XmListDeleteAllItems(list_widget);
+
+  if (count <= 0)
+    return;
+
+  /* Allocate array for all items */
+  items = (XmString*)malloc(count * sizeof(XmString));
+  if (!items)
+    return;
+
+  /* Build all XmStrings from VALUE_CB */
+  for (i = 0; i < count; i++)
+  {
+    char* text = iupListGetItemValueCb(ih, i + 1);
+    items[i] = XmStringCreateLocalized(text ? (char*)text : "");
+  }
+
+  /* Add all items in a single batch operation */
+  XmListAddItems(list_widget, items, count, 0);
+
+  /* Free all XmStrings */
+  for (i = 0; i < count; i++)
+    XmStringFree(items[i]);
+
+  free(items);
+}
+
 /*********************************************************************************/
 
-
 static char* motListGetIdValueAttrib(Ihandle* ih, int id)
 {
   int pos = iupListGetPosAttrib(ih, id);
@@ -950,7 +995,7 @@
 static void motListDragTransferProc(Widget drop_context, Ihandle* ih, Atom *seltype, Atom *type, XtPointer value, unsigned long *length, int format)
 {
   Atom atomListItem = XInternAtom(iupmot_display, "LIST_ITEM", False);
-  int idDrag = (int)value;  /* starts at 1 */
+  int idDrag = (int)(intptr_t)value;  /* starts at 1 */
   int idDrop = iupAttribGetInt(ih, "_IUPLIST_DROPITEM");  /* starts at 1 */
 
   if (idDrop==0)
@@ -1095,7 +1140,7 @@
 
   /* format the value for transfer */
   *type_return = atomTreeItem;
-  *value_return = (XtPointer)idDrag;  /* starts at 1 */
+  *value_return = (XtPointer)(intptr_t)idDrag;  /* starts at 1 */
   *length_return = 1;
   *format_return = 32;
   return True;
@@ -1584,18 +1629,17 @@
   else
     iupmotDisableDragSource(ih->handle);  /* Disable Drag Source */
 
-  if (IupGetGlobal("_IUP_RESET_TXTCOLORS"))
+  IupSetCallback(ih, "_IUP_XY2POS_CB", (Icallback)motListConvertXYToPos);
+
+  if (ih->data->is_virtual)
   {
-    iupmotSetGlobalColorAttrib(ih->handle, XmNbackground, "TXTBGCOLOR");
-    iupmotSetGlobalColorAttrib(ih->handle, XmNforeground, "TXTFGCOLOR");
-    iupmotSetGlobalColorAttrib(ih->handle, XmNhighlightColor, "TXTHLCOLOR");
-    IupSetGlobal("_IUP_RESET_TXTCOLORS", NULL);
+    /* Motif doesn't support true virtual mode, populate all items from VALUE_CB */
+    if (ih->data->item_count > 0)
+      iupdrvListSetItemCount(ih, ih->data->item_count);
   }
+  else
+    iupListSetInitialItems(ih);
 
-  IupSetCallback(ih, "_IUP_XY2POS_CB", (Icallback)motListConvertXYToPos);
-
-  iupListSetInitialItems(ih);
-
   return IUP_NOERROR;
 }
 
@@ -1638,6 +1682,8 @@
   /* Not Supported */
   iupClassRegisterAttributeId(ic, "IMAGE", NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "SHOWIMAGE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "FITIMAGE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "DROPEXPAND", NULL, NULL, IUPAF_SAMEASSYSTEM, "Yes", IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "AUTOREDRAW", NULL, NULL, IUPAF_SAMEASSYSTEM, "Yes", IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/mot/iupmot_menu.c
===================================================================
--- src/mot/iupmot_menu.c	(revision 5971)
+++ src/mot/iupmot_menu.c	(working copy)
@@ -15,6 +15,7 @@
 #include <string.h>
 #include <memory.h>
 #include <stdarg.h>
+#include <stdint.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -302,6 +303,131 @@
   return iupStrReturnChecked(XmIsToggleButton(ih->handle) && XmToggleButtonGetState(ih->handle));
 }
 
+/*******************************************************************************************/
+
+static void motRecentItemActivateCallback(Widget w, XtPointer client_data, XtPointer call_data)
+{
+  int index = (int)(intptr_t)client_data;
+  Ihandle* menu = NULL;
+  Icallback recent_cb;
+  Ihandle* config;
+  char attr_name[32];
+  const char* filename;
+
+  XtVaGetValues(w, XmNuserData, &menu, NULL);
+  if (!menu)
+    return;
+
+  recent_cb = (Icallback)iupAttribGet(menu, "_IUP_RECENT_CB");
+  config = (Ihandle*)iupAttribGet(menu, "_IUP_CONFIG");
+
+  if (!recent_cb || !config)
+    return;
+
+  sprintf(attr_name, "_IUP_RECENT_FILE%d", index);
+  filename = iupAttribGet(menu, attr_name);
+
+  if (filename)
+  {
+    IupSetStrAttribute(config, "RECENTFILENAME", filename);
+    IupSetStrAttribute(config, "TITLE", filename);
+    config->parent = menu;
+
+    if (recent_cb(config) == IUP_CLOSE)
+      IupExitLoop();
+
+    config->parent = NULL;
+    IupSetAttribute(config, "RECENTFILENAME", NULL);
+    IupSetAttribute(config, "TITLE", NULL);
+  }
+
+  (void)call_data;
+}
+
+int iupdrvRecentMenuInit(Ihandle* menu, int max_recent, Icallback recent_cb)
+{
+  iupAttribSetInt(menu, "_IUP_RECENT_MAX", max_recent);
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", 0);
+  return 0;
+}
+
+int iupdrvRecentMenuUpdate(Ihandle* menu, const char** filenames, int count, Icallback recent_cb)
+{
+  Widget menu_widget;
+  int max_recent, existing, i;
+
+  if (!menu || !menu->handle)
+    return -1;
+
+  menu_widget = (Widget)menu->handle;
+  max_recent = iupAttribGetInt(menu, "_IUP_RECENT_MAX");
+  existing = iupAttribGetInt(menu, "_IUP_RECENT_COUNT");
+
+  if (count > max_recent)
+    count = max_recent;
+
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+
+  for (i = 0; i < count; i++)
+  {
+    char attr_name[32];
+    Widget item;
+    XmString xm_title;
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
+    iupAttribSetStr(menu, attr_name, filenames[i]);
+
+    sprintf(attr_name, "_IUP_RECENT_ITEM%d", i);
+    item = (Widget)iupAttribGet(menu, attr_name);
+
+    xm_title = XmStringCreateLocalized((char*)filenames[i]);
+
+    if (item)
+    {
+      XtVaSetValues(item, XmNlabelString, xm_title, NULL);
+    }
+    else
+    {
+      item = XtVaCreateManagedWidget("recentitem",
+        xmCascadeButtonWidgetClass, menu_widget,
+        XmNlabelString, xm_title,
+        XmNuserData, menu,
+        XmNpositionIndex, i,
+        NULL);
+
+      XtAddCallback(item, XmNactivateCallback,
+        (XtCallbackProc)motRecentItemActivateCallback, (XtPointer)(intptr_t)i);
+
+      iupAttribSet(menu, attr_name, (char*)item);
+    }
+
+    XmStringFree(xm_title);
+  }
+
+  for (; i < existing; i++)
+  {
+    char attr_name[32];
+    Widget item;
+
+    sprintf(attr_name, "_IUP_RECENT_ITEM%d", i);
+    item = (Widget)iupAttribGet(menu, attr_name);
+    if (item)
+    {
+      XtDestroyWidget(item);
+      iupAttribSet(menu, attr_name, NULL);
+    }
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
+    iupAttribSet(menu, attr_name, NULL);
+  }
+
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", count);
+  return 0;
+}
+
+/*******************************************************************************************/
+
 static int motItemMapMethod(Ihandle* ih)
 {
   int pos;
@@ -372,32 +498,6 @@
   return IUP_NOERROR;
 }
 
-void iupdrvItemInitClass(Iclass* ic)
-{
-  /* Driver Dependent Class functions */
-  ic->Map = motItemMapMethod;
-  ic->UnMap = iupdrvBaseUnMapMethod;
-
-  /* Common */
-  iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
-
-  /* Visual */
-  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-
-  /* IupItem only */
-  iupClassRegisterAttribute(ic, "VALUE", motItemGetValueAttrib, motItemSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TITLEIMAGE", NULL, motItemSetTitleImageAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-
-  /* IupItem Gtk and Motif only */
-  iupClassRegisterAttribute(ic, "HIDEMARK", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED);
-}
-
-
-/*******************************************************************************************/
-
-
 static int motSubmenuMapMethod(Ihandle* ih)
 {
   int pos;
@@ -407,7 +507,7 @@
 
   ih->handle = XtVaCreateManagedWidget(
                  iupMenuGetChildIdStr(ih),
-                 xmCascadeButtonWidgetClass, 
+                 xmCascadeButtonWidgetClass,
                  ih->parent->handle,
                  NULL);
 
@@ -429,27 +529,6 @@
   return IUP_NOERROR;
 }
 
-void iupdrvSubmenuInitClass(Iclass* ic)
-{
-  /* Driver Dependent Class functions */
-  ic->Map = motSubmenuMapMethod;
-  ic->UnMap = iupdrvBaseUnMapMethod;
-
-  /* Common */
-  iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
-
-  /* Visual */
-  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
-
-  /* IupSubmenu only */
-  iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
-}
-
-
-/*******************************************************************************************/
-
-
 static int motSeparatorMapMethod(Ihandle* ih)
 {
   int pos;
@@ -459,7 +538,7 @@
 
   ih->handle = XtVaCreateManagedWidget(
                  iupMenuGetChildIdStr(ih),
-                 xmSeparatorWidgetClass, 
+                 xmSeparatorWidgetClass,
                  ih->parent->handle,
                  NULL);
 
@@ -474,6 +553,45 @@
   return IUP_NOERROR;
 }
 
+void iupdrvItemInitClass(Iclass* ic)
+{
+  /* Driver Dependent Class functions */
+  ic->Map = motItemMapMethod;
+  ic->UnMap = iupdrvBaseUnMapMethod;
+
+  /* Common */
+  iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
+
+  /* Visual */
+  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+
+  /* IupItem only */
+  iupClassRegisterAttribute(ic, "VALUE", motItemGetValueAttrib, motItemSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "TITLEIMAGE", NULL, motItemSetTitleImageAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+
+  /* IupItem Gtk and Motif only */
+  iupClassRegisterAttribute(ic, "HIDEMARK", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED);
+}
+
+void iupdrvSubmenuInitClass(Iclass* ic)
+{
+  /* Driver Dependent Class functions */
+  ic->Map = motSubmenuMapMethod;
+  ic->UnMap = iupdrvBaseUnMapMethod;
+
+  /* Common */
+  iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
+
+  /* Visual */
+  iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+
+  /* IupSubmenu only */
+  iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
+}
+
 void iupdrvSeparatorInitClass(Iclass* ic)
 {
   /* Driver Dependent Class functions */
Index: src/mot/iupmot_open.c
===================================================================
--- src/mot/iupmot_open.c	(revision 5971)
+++ src/mot/iupmot_open.c	(working copy)
@@ -4,10 +4,11 @@
  * See Copyright Notice in "iup.h"
  */
 
-#include <stdlib.h>    
-#include <stdio.h>    
+#include <stdlib.h>
+#include <stdio.h>
 #include <locale.h>
-#include <string.h>    
+#include <string.h>
+#include <stdint.h>    
 
 #include <Xm/Xm.h>
 
@@ -36,7 +37,7 @@
 
 void iupmotSetGlobalColorAttrib(Widget w, const char* xmname, const char* name)
 {
-  unsigned char r, g, b; 
+  unsigned char r, g, b;
   Pixel color;
 
   XtVaGetValues(w, xmname, &color, NULL);
@@ -45,17 +46,41 @@
   iupGlobalSetDefaultColorAttrib(name, r, g, b);
 }
 
+/* Set IUP global color from X resource database, with fallback to default */
+static void iupmotSetGlobalColorFromXrm(const char* resource_name, const char* resource_class, const char* iup_name,
+                                         unsigned char def_r, unsigned char def_g, unsigned char def_b)
+{
+  XrmDatabase db;
+  XrmValue value;
+  char* type = NULL;
+
+  db = XrmGetDatabase(iupmot_display);
+  if (db && XrmGetResource(db, resource_name, resource_class, &type, &value))
+  {
+    XColor xcolor;
+    Colormap colormap = DefaultColormap(iupmot_display, iupmot_screen);
+
+    if (XParseColor(iupmot_display, colormap, value.addr, &xcolor))
+    {
+      unsigned char r = xcolor.red >> 8;
+      unsigned char g = xcolor.green >> 8;
+      unsigned char b = xcolor.blue >> 8;
+      iupGlobalSetDefaultColorAttrib(iup_name, r, g, b);
+      return;
+    }
+  }
+
+  /* Fallback to default values */
+  iupGlobalSetDefaultColorAttrib(iup_name, def_r, def_g, def_b);
+}
+
 int iupdrvOpen(int *argc, char ***argv)
 {
   IupSetGlobal("DRIVER", "Motif");
+  IupSetGlobal("WINDOWING", "X11");
 
-  /* XtSetLanguageProc(NULL, NULL, NULL); 
-     Removed to avoid invalid locale in modern Linux that set LANG=en_US.UTF-8 */
+  setlocale(LC_ALL, "");
 
-  /* We do NOT use XtVaOpenApplication because it crashes when using internal dummy argc and argv.
-     iupmot_appshell = XtVaOpenApplication(&iupmot_appcontext, "Iup", NULL, 0, argc, *argv, NULL,
-                                           sessionShellWidgetClass, NULL); */
-
   XtToolkitInitialize();
 
   iupmot_appcontext = XtCreateApplicationContext();
@@ -80,7 +105,7 @@
   iupmot_screen  = XDefaultScreen(iupmot_display);
 
   IupSetGlobal("XDISPLAY", (char*)iupmot_display);
-  IupSetGlobal("XSCREEN", (char*)iupmot_screen);
+  IupSetGlobal("XSCREEN", (char*)(intptr_t)iupmot_screen);
 
   /* screen depth can be 8bpp, but canvas can be 24bpp */
   {
@@ -111,17 +136,20 @@
 
   iupmotColorInit();
 
-  /* dialog background color */
+  /* Set default colors from X resources, with fallbacks.
+   * These colors are read from the X resource database (e.g., .Xresources)
+   * allowing users to theme Motif applications via standard X mechanisms. */
   {
-    iupmotSetGlobalColorAttrib(iupmot_appshell, XmNbackground, "DLGBGCOLOR");
-    iupGlobalSetDefaultColorAttrib("DLGFGCOLOR", 0, 0, 0);
-    IupSetGlobal("_IUP_RESET_DLGBGCOLOR", "YES");  /* will update the DLGFGCOLOR when the first dialog is mapped */
+    /* Dialog colors - use *.background and *.foreground */
+    iupmotSetGlobalColorFromXrm("*background", "*Background", "DLGBGCOLOR", 192, 192, 192);
+    iupmotSetGlobalColorFromXrm("*foreground", "*Foreground", "DLGFGCOLOR", 0, 0, 0);
 
-    iupGlobalSetDefaultColorAttrib("TXTBGCOLOR", 255, 255, 255);
-    iupGlobalSetDefaultColorAttrib("TXTFGCOLOR", 0, 0, 0);
-    iupGlobalSetDefaultColorAttrib("TXTHLCOLOR", 128, 128, 128);
-    IupSetGlobal("_IUP_RESET_TXTCOLORS", "YES");   /* will update the TXTCOLORS when the first text or list is mapped */
+    /* Text widget colors - also use *.background and *.foreground for consistency */
+    iupmotSetGlobalColorFromXrm("*background", "*Background", "TXTBGCOLOR", 255, 255, 255);
+    iupmotSetGlobalColorFromXrm("*foreground", "*Foreground", "TXTFGCOLOR", 0, 0, 0);
+    iupmotSetGlobalColorFromXrm("*highlightColor", "*HighlightColor", "TXTHLCOLOR", 128, 128, 128);
 
+    /* Link color - typically blue, but can be themed */
     iupGlobalSetDefaultColorAttrib("LINKFGCOLOR", 0, 0, 238);
   }
 
@@ -134,10 +162,33 @@
   return IUP_NOERROR;
 }
 
+int iupdrvSetGlobalAppIDAttrib(const char* value)
+{
+  static int appid_set = 0;
+  if (appid_set || !value || !value[0])
+    return 0;
+
+  IupStoreGlobal("_IUP_APPID_INTERNAL", value);
+  appid_set = 1;
+  return 1;
+}
+
+int iupdrvSetGlobalAppNameAttrib(const char* value)
+{
+  static int appname_set = 0;
+  if (appname_set || !value || !value[0])
+    return 0;
+
+  IupStoreGlobal("_IUP_APPNAME_INTERNAL", value);
+  appname_set = 1;
+  return 1;
+}
+
 void iupdrvClose(void)
-{ 
+{
   iupmotColorFinish();
   iupmotTipsFinish();
+  iupmotStrRelease();
 
   if (iupmot_appshell)
     XtDestroyWidget(iupmot_appshell);
Index: src/mot/iupmot_progressbar.c
===================================================================
--- src/mot/iupmot_progressbar.c	(revision 5971)
+++ src/mot/iupmot_progressbar.c	(working copy)
@@ -29,6 +29,21 @@
 #include "iupmot_color.h"
 
 
+void iupdrvProgressBarGetMinSize(Ihandle* ih, int* w, int* h)
+{
+  /* Motif XmScale has no intrinsic size API */
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    *w = 15;
+    *h = 80;
+  }
+  else
+  {
+    *w = 100;
+    *h = 15;
+  }
+}
+
 static int motProgressBarTimeCb(Ihandle* timer)
 {
   Ihandle* ih = (Ihandle*)iupAttribGet(timer, "_IUP_PROGRESSBAR");
Index: src/mot/iupmot_str.c
===================================================================
--- src/mot/iupmot_str.c	(revision 5971)
+++ src/mot/iupmot_str.c	(working copy)
@@ -8,6 +8,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <locale.h>
+#include <langinfo.h>
 
 #include <Xm/Xm.h>
 #include <Xm/Text.h>
@@ -20,7 +22,257 @@
 
 #include "iupmot_drv.h"
 
+#ifdef IUP_USE_ICONV
+#include <iconv.h>
+#endif
 
+static int iupmot_utf8mode = 0;
+static int iupmot_utf8mode_file = 0;
+static int iupmot_utf8_supported = -1;
+static char* motLastConvertUTF8 = NULL;
+static char* mot_current_charset = NULL;
+
+static int motStrCheckUTF8Support(void)
+{
+  if (iupmot_utf8_supported != -1)
+    return iupmot_utf8_supported;
+
+  if (XmVERSION > 2 || (XmVERSION == 2 && XmREVISION >= 3))
+    iupmot_utf8_supported = 1;
+  else
+    iupmot_utf8_supported = 0;
+
+  return iupmot_utf8_supported;
+}
+
+static char* motStrGetCurrentCharset(void)
+{
+  if (!mot_current_charset)
+    mot_current_charset = nl_langinfo(CODESET);
+  return mot_current_charset;
+}
+
+static void motStrResetCharset(void)
+{
+  mot_current_charset = NULL;
+}
+
+static int motStrIsLocaleUTF8(void)
+{
+  char* charset = motStrGetCurrentCharset();
+  return (iupStrEqualNoCase(charset, "UTF-8") ||
+          iupStrEqualNoCase(charset, "UTF8"));
+}
+
+#ifdef IUP_USE_ICONV
+static char* motStrToUTF8(const char* str, int len, const char* charset)
+{
+  size_t ulen = (size_t)len;
+  size_t mlen = ulen * 4;
+  char* utf8_buffer;
+  char* utf8_ptr;
+  const char* str_ptr = str;
+  iconv_t cd_iconv;
+
+  if (!charset)
+    charset = "ISO-8859-1";
+
+  cd_iconv = iconv_open("UTF-8", charset);
+  if (cd_iconv == (iconv_t)-1)
+    return NULL;
+
+  utf8_buffer = malloc(mlen + 1);
+  utf8_ptr = utf8_buffer;
+
+  if (iconv(cd_iconv, (char**)&str_ptr, &ulen, &utf8_ptr, &mlen) == (size_t)-1)
+  {
+    free(utf8_buffer);
+    iconv_close(cd_iconv);
+    return NULL;
+  }
+
+  *utf8_ptr = 0;
+  iconv_close(cd_iconv);
+
+  return utf8_buffer;
+}
+
+static char* motStrFromUTF8(const char* str, const char* charset)
+{
+  size_t ulen = strlen(str);
+  size_t mlen = ulen * 4;
+  char* locale_buffer;
+  char* locale_ptr;
+  const char* str_ptr = str;
+  iconv_t cd_iconv;
+
+  if (!charset)
+    charset = "ISO-8859-1";
+
+  cd_iconv = iconv_open(charset, "UTF-8");
+  if (cd_iconv == (iconv_t)-1)
+    return NULL;
+
+  locale_buffer = malloc(mlen + 1);
+  locale_ptr = locale_buffer;
+
+  if (iconv(cd_iconv, (char**)&str_ptr, &ulen, &locale_ptr, &mlen) == (size_t)-1)
+  {
+    free(locale_buffer);
+    iconv_close(cd_iconv);
+    return NULL;
+  }
+
+  *locale_ptr = 0;
+  iconv_close(cd_iconv);
+
+  return locale_buffer;
+}
+#endif
+
+void iupmotStrSetUTF8Mode(int utf8mode)
+{
+  iupmot_utf8mode = utf8mode;
+  if (utf8mode && !motStrIsLocaleUTF8())
+  {
+    char* result;
+    result = setlocale(LC_CTYPE, "en_US.UTF-8");
+    if (!result)
+      result = setlocale(LC_CTYPE, "C.UTF-8");
+    if (!result)
+      result = setlocale(LC_CTYPE, "UTF-8");
+
+    if (result)
+      motStrResetCharset();
+  }
+}
+
+void iupmotStrSetUTF8ModeFile(int utf8mode)
+{
+  iupmot_utf8mode_file = utf8mode;
+}
+
+int iupmotStrGetUTF8Mode(void)
+{
+  return iupmot_utf8mode;
+}
+
+int iupmotStrGetUTF8ModeFile(void)
+{
+  return iupmot_utf8mode_file;
+}
+
+void iupmotStrRelease(void)
+{
+  if (motLastConvertUTF8)
+  {
+    free(motLastConvertUTF8);
+    motLastConvertUTF8 = NULL;
+  }
+}
+
+char* iupmotStrConvertToSystem(const char* str)
+{
+  const char* charset = NULL;
+
+  if (!str || *str == 0)
+    return (char*)str;
+
+  if (!iupmot_utf8mode)
+    return (char*)str;
+
+  if (motStrCheckUTF8Support())
+    return (char*)str;
+
+  if (motStrIsLocaleUTF8())
+    return (char*)str;
+
+  if (iupStrIsAscii(str))
+    return (char*)str;
+
+  charset = motStrGetCurrentCharset();
+  if (!charset)
+    charset = "ISO-8859-1";
+
+#ifdef IUP_USE_ICONV
+  if (motLastConvertUTF8)
+    free(motLastConvertUTF8);
+
+  motLastConvertUTF8 = motStrFromUTF8(str, charset);
+  if (!motLastConvertUTF8)
+    return (char*)str;
+
+  return motLastConvertUTF8;
+#else
+  return (char*)str;
+#endif
+}
+
+char* iupmotStrConvertFromSystem(const char* str)
+{
+  const char* charset = NULL;
+
+  if (!str || *str == 0)
+    return (char*)str;
+
+  if (!iupmot_utf8mode)
+    return (char*)str;
+
+  if (motStrCheckUTF8Support())
+    return (char*)str;
+
+  if (motStrIsLocaleUTF8())
+    return (char*)str;
+
+  if (iupStrIsAscii(str))
+    return (char*)str;
+
+  charset = motStrGetCurrentCharset();
+  if (!charset)
+    charset = "ISO-8859-1";
+
+#ifdef IUP_USE_ICONV
+  if (motLastConvertUTF8)
+    free(motLastConvertUTF8);
+
+  motLastConvertUTF8 = motStrToUTF8(str, strlen(str), charset);
+  if (!motLastConvertUTF8)
+    return (char*)str;
+
+  return motLastConvertUTF8;
+#else
+  return (char*)str;
+#endif
+}
+
+char* iupmotStrConvertToFilename(const char* str)
+{
+  int old_mode = iupmot_utf8mode;
+  char* result;
+
+  if (iupmot_utf8mode)
+    iupmot_utf8mode = iupmot_utf8mode_file;
+
+  result = iupmotStrConvertToSystem(str);
+
+  iupmot_utf8mode = old_mode;
+  return result;
+}
+
+char* iupmotStrConvertFromFilename(const char* str)
+{
+  int old_mode = iupmot_utf8mode;
+  char* result;
+
+  if (iupmot_utf8mode)
+    iupmot_utf8mode = iupmot_utf8mode_file;
+
+  result = iupmotStrConvertFromSystem(str);
+
+  iupmot_utf8mode = old_mode;
+  return result;
+}
+
 void iupmotSetMnemonicTitle(Ihandle *ih, Widget w, int pos, const char* value)
 {
   char c;
@@ -60,22 +312,73 @@
 
 char* iupmotGetXmString(XmString str)
 {
-  return (char*)XmStringUnparse(str, NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
+  char* text;
+
+  if (iupmot_utf8mode && motStrCheckUTF8Support())
+  {
+    text = (char*)XmStringUnparse(str, "UTF-8", XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
+  }
+  else
+  {
+    text = (char*)XmStringUnparse(str, NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
+    text = iupmotStrConvertFromSystem(text);
+  }
+
+  return text;
 }
 
 char* iupmotReturnXmString(XmString str)
 {
-  char* text = iupmotGetXmString(str);
-  char* ret = iupStrReturnStr(text);
-  XtFree(text);
+  char* text;
+  char* converted;
+  char* ret;
+
+  if (iupmot_utf8mode && motStrCheckUTF8Support())
+  {
+    text = (char*)XmStringUnparse(str, "UTF-8", XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
+    ret = iupStrReturnStr(text);
+    XtFree(text);
+  }
+  else
+  {
+    text = (char*)XmStringUnparse(str, NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
+    converted = iupmotStrConvertFromSystem(text);
+
+    if (converted != text)
+    {
+      ret = iupStrReturnStr(converted);
+      XtFree(text);
+    }
+    else
+    {
+      ret = iupStrReturnStr(text);
+      XtFree(text);
+    }
+  }
+
   return ret;
 }
 
-/* TODO: UTF8 support would start here... */
-
 XmString iupmotStringCreate(const char *value)
 {
-  return XmStringCreateLocalized((String)value);
+  int use_utf8 = 0;
+
+  if (iupmot_utf8mode)
+    use_utf8 = 1;
+#ifdef IUP_USE_XFT
+  else if (motStrIsLocaleUTF8())
+    use_utf8 = 1;
+#endif
+
+  if (use_utf8 && motStrCheckUTF8Support())
+  {
+    return XmStringGenerate((XtPointer)value, "UTF-8", XmCHARSET_TEXT, NULL);
+  }
+  else
+  {
+    value = iupmotStrConvertToSystem(value);
+    return XmStringCreateLocalized((String)value);
+  }
 }
 
 void iupmotSetTitle(Widget w, const char *value)
@@ -87,13 +390,10 @@
 
 void iupmotTextSetString(Widget w, const char *value)
 {
+  value = iupmotStrConvertToSystem(value);
   XmTextSetString(w, (char*)value);
 }
 
-#ifdef USE_ICONV
-#include <iconv.h>
-#endif
-
 static char* iupCheckUtf8Buffer(char* utf8_buffer, int *utf8_buffer_max, int len)
 {
   if (!utf8_buffer)
@@ -124,7 +424,7 @@
   if (utf8mode || iupStrIsAscii(str)) /* string is already utf8 or is ascii */
     return iupStrCopyToUtf8Buffer(str, len, utf8_buffer, utf8_buffer_max);
 
-#ifdef USE_ICONV
+#ifdef IUP_USE_ICONV
   {
     size_t ulen = (size_t)len;
     size_t mlen = ulen * 2;
Index: src/mot/iupmot_tabs.c
===================================================================
--- src/mot/iupmot_tabs.c	(revision 5971)
+++ src/mot/iupmot_tabs.c	(working copy)
@@ -9,6 +9,7 @@
 #include <Xm/BulletinB.h>
 #include <Xm/PushB.h>
 #include <Xm/Label.h>
+#include <Xm/Form.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -36,6 +37,48 @@
 #include "iupmot_color.h"
 
 
+#define ITABS_CLOSE_SIZE 12
+
+static Pixmap mot_tabs_close_pixmap = 0;
+
+static void motTabsInitializeClosePixmap(Widget parent)
+{
+  Pixel fg, bg;
+
+  if (mot_tabs_close_pixmap != 0)
+    return;
+
+  static unsigned char close_bits[] = {
+    0x00, 0x00,
+    0x00, 0x00,
+    0x0c, 0x03,
+    0x9c, 0x03,
+    0xf8, 0x01,
+    0xf0, 0x00,
+    0xf0, 0x00,
+    0xf8, 0x01,
+    0x9c, 0x03,
+    0x0c, 0x03,
+    0x00, 0x00,
+    0x00, 0x00
+  };
+
+  Display* dpy = XtDisplay(parent);
+  Window root = RootWindowOfScreen(XtScreen(parent));
+
+  XtVaGetValues(parent, XmNforeground, &fg, XmNbackground, &bg, NULL);
+
+  mot_tabs_close_pixmap = XCreatePixmapFromBitmapData(
+    dpy, root,
+    (char*)close_bits,
+    ITABS_CLOSE_SIZE, ITABS_CLOSE_SIZE,
+    fg,
+    bg,
+    DefaultDepthOfScreen(XtScreen(parent))
+  );
+}
+
+
 int iupdrvTabsExtraMargin(void)
 {
   return 0;
@@ -72,6 +115,52 @@
   return pos;
 }
 
+void iupdrvTabsGetTabSize(Ihandle* ih, const char* tab_title, const char* tab_image, int* tab_width, int* tab_height)
+{
+  int width = 0;
+  int height = 0;
+  int text_width = 0;
+  int text_height = 0;
+
+  /* Measure text dimensions */
+  if (tab_title)
+  {
+    text_width = iupdrvFontGetStringWidth(ih, tab_title);
+    iupdrvFontGetCharSize(ih, NULL, &text_height);
+    width = text_width;
+    height = text_height;
+  }
+
+  /* Add image dimensions */
+  if (tab_image)
+  {
+    void* img = iupImageGetImage(tab_image, ih, 0, NULL);
+    if (img)
+    {
+      int img_w, img_h;
+      iupdrvImageGetInfo(img, &img_w, &img_h, NULL);
+      width += img_w;
+      if (tab_title)
+        width += 3;  /* spacing between icon and text */
+      if (img_h > height)
+        height = img_h;
+    }
+  }
+
+  if (ih->data->horiz_padding > 0)
+    width += 2 * ih->data->horiz_padding;
+  else
+    width += 30;  /* Matches XmNotebook's actual tab rendering */
+
+  if (ih->data->vert_padding > 0)
+    height += 2 * ih->data->vert_padding;
+  else
+    height += 12;  /* Matches XmNotebook's actual tab rendering */
+
+  if (tab_width) *tab_width = width;
+  if (tab_height) *tab_height = height;
+}
+
 static void motTabsUpdatePageNumber(Ihandle* ih)
 {
   int pos, old_pos;
@@ -130,9 +219,18 @@
   Ihandle* child;
   for (child = ih->firstchild; child; child = child->brother)
   {
+    Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
     Widget tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
-    if (tab_button)
+
+    if (tab_label)
+    {
+      XtVaSetValues(tab_label, XmNforeground, color, NULL);
       XtVaSetValues(tab_button, XmNforeground, color, NULL);
+    }
+    else if (tab_button)
+    {
+      XtVaSetValues(tab_button, XmNforeground, color, NULL);
+    }
   }
 }
 
@@ -141,9 +239,18 @@
   Ihandle* child;
   for (child = ih->firstchild; child; child = child->brother)
   {
+    Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
     Widget tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
-    if (tab_button)
+
+    if (tab_label)
+    {
+      iupmotSetBgColor(tab_label, color);
       iupmotSetBgColor(tab_button, color);
+    }
+    else if (tab_button)
+    {
+      iupmotSetBgColor(tab_button, color);
+    }
   }
 }
 
@@ -152,10 +259,13 @@
   Ihandle* child;
   for (child = ih->firstchild; child; child = child->brother)
   {
+    Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
     Widget tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
-    if (tab_button)
-      XtVaSetValues(tab_button, XmNmarginHeight, ih->data->vert_padding,
-                                XmNmarginWidth, ih->data->horiz_padding, NULL);
+    Widget target = tab_label ? tab_label : tab_button;
+
+    if (target)
+      XtVaSetValues(target, XmNmarginHeight, ih->data->vert_padding,
+                            XmNmarginWidth, ih->data->horiz_padding, NULL);
   }
 }
 
@@ -166,9 +276,12 @@
 
   for (child = ih->firstchild; child; child = child->brother)
   {
+    Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
     Widget tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
-    if (tab_button)
-      XtVaSetValues(tab_button, XmNrenderTable, fontlist, NULL);
+    Widget target = tab_label ? tab_label : tab_button;
+
+    if (target)
+      XtVaSetValues(target, XmNrenderTable, fontlist, NULL);
   }
 }
 
@@ -297,8 +410,12 @@
 
   if (value)
   {
+    Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
     Widget tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
-    if (tab_button)
+
+    if (tab_label)
+      iupmotSetMnemonicTitle(ih, tab_label, pos, value);
+    else if (tab_button)
       iupmotSetMnemonicTitle(ih, tab_button, pos, value);
   }
 
@@ -307,22 +424,25 @@
 
 static int motTabsSetTabImageAttrib(Ihandle* ih, int pos, const char* value)
 {
-  Widget tab_button;
+  Widget target;
   Ihandle* child = IupGetChild(ih, pos);
   if (child)
     iupAttribSetStr(child, "TABIMAGE", value);
 
-  tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
-  if (tab_button)
+  Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
+  Widget tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
+  target = tab_label ? tab_label : tab_button;
+
+  if (target)
   {
     if (value)
     {
       Pixmap pixmap = (Pixmap)iupImageGetImage(value, ih, 0, NULL);
       if (pixmap)
-        XtVaSetValues(tab_button, XmNlabelPixmap, pixmap, NULL);
+        XtVaSetValues(target, XmNlabelPixmap, pixmap, NULL);
     }
     else
-      XtVaSetValues(tab_button, XmNlabelPixmap, NULL, NULL);
+      XtVaSetValues(target, XmNlabelPixmap, NULL, NULL);
   }
   return 1;
 }
@@ -400,17 +520,65 @@
 static void motTabsButtonPressEvent(Widget w, Ihandle* child, XButtonEvent* evt, Boolean* cont)
 {
   Ihandle* ih = IupGetParent(child);
-  IFni cb = (IFni)IupGetCallback(ih, "RIGHTCLICK_CB");
+  int pos = iupAttribGetInt(child, "_IUPMOT_TABNUMBER");
   (void)w;
   (void)cont;
 
-  if (evt->type==ButtonPress && evt->button==Button3 && cb)  /* right button clicked on tab */
+  if (evt->type==ButtonPress && evt->button==Button1)
   {
-    int pos = iupAttribGetInt(child, "_IUPMOT_TABNUMBER");
-    cb(ih, pos);
+    Widget tab_close = (Widget)iupAttribGet(child, "_IUPMOT_TABCLOSE");
+    if (tab_close)
+    {
+      Window child_window;
+      int x_rel, y_rel;
+      XTranslateCoordinates(iupmot_display, evt->window, XtWindow(tab_close),
+                            evt->x, evt->y, &x_rel, &y_rel, &child_window);
+
+      Dimension width, height;
+      XtVaGetValues(tab_close, XmNwidth, &width, XmNheight, &height, NULL);
+      if (child_window == XtWindow(tab_close) ||
+          (x_rel >= 0 && x_rel < width && y_rel >= 0 && y_rel < height))
+      {
+        return;
+      }
+
+      iupdrvTabsSetCurrentTab(ih, pos);
+    }
   }
+  else if (evt->type==ButtonPress && evt->button==Button3)
+  {
+    IFni cb = (IFni)IupGetCallback(ih, "RIGHTCLICK_CB");
+    if (cb)
+      cb(ih, pos);
+  }
 }
 
+static void motTabsCloseButtonActivate(Widget w, XtPointer client_data, XtPointer call_data)
+{
+  Ihandle* child = (Ihandle*)client_data;
+  Ihandle* ih = IupGetParent(child);
+  int pos = iupAttribGetInt(child, "_IUPMOT_TABNUMBER");
+  IFni cb;
+  int ret = IUP_DEFAULT;
+
+  (void)w;
+  (void)call_data;
+
+  cb = (IFni)IupGetCallback(ih, "TABCLOSE_CB");
+  if (cb)
+    ret = cb(ih, pos);
+
+  if (ret == IUP_CONTINUE)
+  {
+    IupDestroy(child);
+    IupRefreshChildren(ih);
+  }
+  else if (ret == IUP_DEFAULT)
+  {
+    IupSetAttributeId(ih, "TABVISIBLE", pos, "NO");
+  }
+}
+
 static void motTabsConfigureNotify(Widget w, XEvent *evt, String* s, Cardinal *card)
 {
   /* Motif does not process the changed of position and/or size of children outside the parent's client area. 
@@ -496,38 +664,121 @@
       tabtitle = "     ";
 
     /* Create tabs */
-    /* Label */
-    iupMOT_SETARG(args, num_args, XmNlabelType, tabtitle? XmSTRING: XmPIXMAP);
-    iupMOT_SETARG(args, num_args, XmNmarginHeight, 0);
-    iupMOT_SETARG(args, num_args, XmNmarginWidth, 0);
-    /* Notebook Constraint */
-    iupMOT_SETARG(args, num_args, XmNnotebookChildType, XmMAJOR_TAB);
-    iupMOT_SETARG(args, num_args, XmNpageNumber, pos);
-    tab_button = XtCreateManagedWidget("tab_button", xmPushButtonWidgetClass, ih->handle, args, num_args);
+    if (ih->data->show_close)
+    {
+      Widget tab_form;
+      Widget tab_label_widget;
+      Widget close_button;
 
-    /* Disable Drag Source */
-    iupmotDisableDragSource(tab_button);
+      num_args = 0;
+      iupMOT_SETARG(args, num_args, XmNmarginHeight, 0);
+      iupMOT_SETARG(args, num_args, XmNmarginWidth, 0);
+      iupMOT_SETARG(args, num_args, XmNborderWidth, 0);
+      iupMOT_SETARG(args, num_args, XmNshadowThickness, 0);
+      iupMOT_SETARG(args, num_args, XmNnotebookChildType, XmMAJOR_TAB);
+      iupMOT_SETARG(args, num_args, XmNpageNumber, pos);
+      tab_form = XtCreateManagedWidget("tab_form", xmFormWidgetClass, ih->handle, args, num_args);
 
-    XtAddEventHandler(tab_button, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
-    XtAddEventHandler(tab_button, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
-    XtAddEventHandler(tab_button, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
-    XtAddEventHandler(tab_button, KeyPressMask,    False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
+      tab_label_widget = XtVaCreateManagedWidget(
+        "tab_label",
+        xmLabelWidgetClass,
+        tab_form,
+        XmNlabelType, tabtitle ? XmSTRING : XmPIXMAP,
+        XmNmarginHeight, ih->data->vert_padding,
+        XmNmarginWidth, ih->data->horiz_padding,
+        XmNtopAttachment, XmATTACH_FORM,
+        XmNbottomAttachment, XmATTACH_FORM,
+        XmNleftAttachment, XmATTACH_FORM,
+        NULL
+      );
 
-    XtAddEventHandler(tab_button, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
+      motTabsInitializeClosePixmap(ih->handle);
+      close_button = XtVaCreateManagedWidget(
+        "close_btn",
+        xmPushButtonWidgetClass,
+        tab_form,
+        XmNlabelType, XmPIXMAP,
+        XmNlabelPixmap, mot_tabs_close_pixmap,
+        XmNmarginHeight, 0,
+        XmNmarginWidth, 0,
+        XmNwidth, ITABS_CLOSE_SIZE + 6,
+        XmNheight, ITABS_CLOSE_SIZE + 6,
+        XmNshadowThickness, 1,
+        XmNhighlightThickness, 0,
+        XmNrecomputeSize, False,
+        XmNtopAttachment, XmATTACH_FORM,
+        XmNbottomAttachment, XmATTACH_FORM,
+        XmNrightAttachment, XmATTACH_FORM,
+        XmNleftAttachment, XmATTACH_WIDGET,
+        XmNleftWidget, tab_label_widget,
+        XmNleftOffset, 4,
+        NULL
+      );
 
-    if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
-    {
-      XtAddEventHandler(tab_button, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
-      XtAddEventHandler(child_manager, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
+      iupmotDisableDragSource(close_button);
+      XtAddCallback(close_button, XmNactivateCallback,
+                    (XtCallbackProc)motTabsCloseButtonActivate, (XtPointer)child);
+
+      tab_button = tab_form;
+
+      XtAddEventHandler(tab_form, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_form, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_form, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_form, KeyPressMask,    False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_form, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
+
+      XtAddEventHandler(tab_label_widget, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
+
+      if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
+      {
+        XtAddEventHandler(tab_form, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
+        XtAddEventHandler(child_manager, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
+      }
+
+      if (tabtitle)
+        iupmotSetMnemonicTitle(ih, tab_label_widget, pos, tabtitle);
+      else
+      {
+        Pixmap pixmap = (Pixmap)iupImageGetImage(tabimage, ih, 0, NULL);
+        if (pixmap)
+          XtVaSetValues(tab_label_widget, XmNlabelPixmap, pixmap, NULL);
+      }
+
+      iupAttribSet(child, "_IUPMOT_TABLABEL", (char*)tab_label_widget);
+      iupAttribSet(child, "_IUPMOT_TABCLOSE", (char*)close_button);
     }
-
-    if (tabtitle)
-      iupmotSetMnemonicTitle(ih, tab_button, pos, tabtitle);
     else
     {
-      Pixmap pixmap = (Pixmap)iupImageGetImage(tabimage, ih, 0, NULL);
-      if (pixmap)
-        XtVaSetValues(tab_button, XmNlabelPixmap, pixmap, NULL);
+      num_args = 0;
+      iupMOT_SETARG(args, num_args, XmNlabelType, tabtitle? XmSTRING: XmPIXMAP);
+      iupMOT_SETARG(args, num_args, XmNmarginHeight, ih->data->vert_padding);
+      iupMOT_SETARG(args, num_args, XmNmarginWidth, ih->data->horiz_padding);
+      iupMOT_SETARG(args, num_args, XmNnotebookChildType, XmMAJOR_TAB);
+      iupMOT_SETARG(args, num_args, XmNpageNumber, pos);
+      tab_button = XtCreateManagedWidget("tab_button", xmPushButtonWidgetClass, ih->handle, args, num_args);
+
+      iupmotDisableDragSource(tab_button);
+
+      XtAddEventHandler(tab_button, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_button, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_button, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_button, KeyPressMask,    False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
+      XtAddEventHandler(tab_button, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
+
+      if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
+      {
+        XtAddEventHandler(tab_button, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
+        XtAddEventHandler(child_manager, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
+      }
+
+      if (tabtitle)
+        iupmotSetMnemonicTitle(ih, tab_button, pos, tabtitle);
+      else
+      {
+        Pixmap pixmap = (Pixmap)iupImageGetImage(tabimage, ih, 0, NULL);
+        if (pixmap)
+          XtVaSetValues(tab_button, XmNlabelPixmap, pixmap, NULL);
+      }
     }
 
     background = iupBaseNativeParentGetBgColorAttrib(ih);
@@ -580,11 +831,12 @@
       XtDestroyWidget(tab_button);
       XtDestroyWidget(child_manager);
 
-      /* compact the tab number usage */
       motTabsUpdatePageNumber(ih);
 
       iupAttribSet(child, "_IUPTAB_CONTAINER", NULL);
       iupAttribSet(child, "_IUPMOT_TABBUTTON", NULL);
+      iupAttribSet(child, "_IUPMOT_TABLABEL", NULL);
+      iupAttribSet(child, "_IUPMOT_TABCLOSE", NULL);
       iupAttribSet(child, "_IUPMOT_TABNUMBER", NULL);
 
       iupAttribSet(ih, "_IUPMOT_IGNORE_PAGECHANGE", NULL);
@@ -681,6 +933,9 @@
     XtAppAddActions(iupmot_appcontext, &rec, 1);
   }
 
+  /* Register TABCLOSE_CB callback */
+  iupClassRegisterCallback(ic, "TABCLOSE_CB", "i");
+
   /* Driver Dependent Attribute functions */
 
   /* Common */
Index: src/mot/iupmot_text.c
===================================================================
--- src/mot/iupmot_text.c	(revision 5971)
+++ src/mot/iupmot_text.c	(working copy)
@@ -76,6 +76,13 @@
   (void)ih;
 }
 
+void iupdrvTextAddExtraPadding(Ihandle* ih, int *w, int *h)
+{
+  (void)ih;
+  (void)w;
+  (void)h;
+}
+
 static void motTextGetLinColFromPosition(const char *str, int pos, int *lin, int *col )
 {
   int i;
@@ -258,6 +265,11 @@
   }
 	if (value)
     XmTextInsert(ih->handle, pos, (char*)value);
+
+  /* Scroll to the end to make the appended text visible */
+  pos = XmTextGetLastPosition(ih->handle);
+  XmTextShowPosition(ih->handle, pos);
+
   ih->data->disable_callbacks = 0;
   return 0;
 }
@@ -731,8 +743,20 @@
 static char* motTextGetValueAttrib(Ihandle* ih)
 {
   char* value = XmTextGetString(ih->handle);
-  char* str = iupStrReturnStr(value);
-  XtFree(value);
+  char* converted = iupmotStrConvertFromSystem(value);
+  char* str;
+
+  if (converted != value)
+  {
+    str = iupStrReturnStr(converted);
+    XtFree(value);
+  }
+  else
+  {
+    str = iupStrReturnStr(value);
+    XtFree(value);
+  }
+
   return str;
 }
                        
@@ -1195,14 +1219,6 @@
   else
     XtRealizeWidget(ih->handle);
 
-  if (IupGetGlobal("_IUP_RESET_TXTCOLORS"))
-  {
-    iupmotSetGlobalColorAttrib(ih->handle, XmNbackground, "TXTBGCOLOR");
-    iupmotSetGlobalColorAttrib(ih->handle, XmNforeground, "TXTFGCOLOR");
-    iupmotSetGlobalColorAttrib(ih->handle, XmNhighlightColor, "TXTHLCOLOR");
-    IupSetGlobal("_IUP_RESET_TXTCOLORS", NULL);
-  }
-
   IupSetCallback(ih, "_IUP_XY2POS_CB", (Icallback)motTextConvertXYToPos);
 
   return IUP_NOERROR;
@@ -1254,4 +1270,5 @@
   iupClassRegisterAttribute(ic, "FORMATTING", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "OVERWRITE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TABSIZE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/mot/iupmot_toggle.c
===================================================================
--- src/mot/iupmot_toggle.c	(revision 5971)
+++ src/mot/iupmot_toggle.c	(working copy)
@@ -6,6 +6,7 @@
 
 #include <Xm/Xm.h>
 #include <Xm/ToggleB.h>
+#include <Xm/DrawingA.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -25,34 +26,185 @@
 #include "iup_drv.h"
 #include "iup_image.h"
 #include "iup_key.h"
+#include "iup_drvdraw.h"
+#include "iup_draw.h"
 
 #include "iupmot_drv.h"
 #include "iupmot_color.h"
 
+#define SWITCH_TRACK_WIDTH  40
+#define SWITCH_TRACK_HEIGHT 20
+#define SWITCH_THUMB_SIZE   14
+#define SWITCH_THUMB_MARGIN 3
 
+typedef struct _IupMotSwitchData
+{
+  Ihandle* ih;
+  int checked_state;
+  Widget drawing_area;
+} IupMotSwitchData;
+
+
 void iupdrvToggleAddBorders(Ihandle* ih, int *x, int *y)
 {
   iupdrvButtonAddBorders(ih, x, y);
 }
 
+void iupdrvToggleAddSwitch(Ihandle* ih, int *x, int *y, const char* str)
+{
+  (void)ih;
+
+  (*x) += 2 + SWITCH_TRACK_WIDTH + 2;
+  if ((*y) < 2 + SWITCH_TRACK_HEIGHT + 2)
+    (*y) = 2 + SWITCH_TRACK_HEIGHT + 2;
+  else
+    (*y) += 2 + 2;
+
+  if (str && str[0])
+    (*x) += 8;
+}
+
 void iupdrvToggleAddCheckBox(Ihandle* ih, int *x, int *y, const char* str)
 {
-  int check_box = 15;  /* See XmNindicatorSize */
+  int check_box = 15;
   (void)ih;
 
-  /* has margins too */
   (*x) += 3 + check_box + 3;
-  if ((*y) < 3 + check_box + 3) (*y) = 3 + check_box + 3; /* minimum height */
-  else (*y) += 3+3;
+#ifdef IUP_USE_XFT
+  if ((*y) < 3 + check_box + 9) (*y) = 3 + check_box + 9;
+  else (*y) += 3+9;
+#else
+  if ((*y) < 3 + check_box + 5) (*y) = 3 + check_box + 5;
+  else (*y) += 3+5;
+#endif
 
-  if (str && str[0]) /* add spacing between check box and text */
+  if (str && str[0])
     (*x) += 4;
 }
 
+/*********************************************************************************/
+/* SWITCH Control                                                               */
+/*********************************************************************************/
 
+static void motSwitchDraw(Ihandle* ih, IupMotSwitchData* switch_data, IdrawCanvas* dc)
+{
+  int width, height;
+  long track_color, thumb_color, shadow_dark, shadow_light;
+  int is_checked = switch_data->checked_state;
+  int is_active = iupdrvIsActive(ih);
+  int thumb_x, thumb_y;
+  Pixel bg_pixel, fg_pixel;
+  unsigned char bg_r, bg_g, bg_b, fg_r, fg_g, fg_b;
+
+  iupdrvDrawGetSize(dc, &width, &height);
+
+  XtVaGetValues(ih->handle, XmNbackground, &bg_pixel, XmNforeground, &fg_pixel, NULL);
+  iupmotColorGetRGB(bg_pixel, &bg_r, &bg_g, &bg_b);
+  iupmotColorGetRGB(fg_pixel, &fg_r, &fg_g, &fg_b);
+
+  if (!is_active)
+  {
+    track_color = iupDrawColor(bg_r * 0.85, bg_g * 0.85, bg_b * 0.85, 255);
+    thumb_color = iupDrawColor(bg_r * 0.95, bg_g * 0.95, bg_b * 0.95, 255);
+  }
+  else if (is_checked)
+  {
+    track_color = iupDrawColor(bg_r * 0.75, bg_g * 0.75, bg_b * 0.75, 255);
+    thumb_color = iupDrawColor(bg_r * 1.05, bg_g * 1.05, bg_b * 1.05, 255);
+  }
+  else
+  {
+    track_color = iupDrawColor(bg_r * 0.90, bg_g * 0.90, bg_b * 0.90, 255);
+    thumb_color = iupDrawColor(bg_r * 1.05, bg_g * 1.05, bg_b * 1.05, 255);
+  }
+
+  iupdrvDrawRectangle(dc, 0, 0, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1, track_color, IUP_DRAW_FILL, 1);
+
+  shadow_dark = iupDrawColor(fg_r * 0.4, fg_g * 0.4, fg_b * 0.4, 255);
+  shadow_light = iupDrawColor(bg_r * 1.1, bg_g * 1.1, bg_b * 1.1, 255);
+
+  iupdrvDrawLine(dc, 0, 0, SWITCH_TRACK_WIDTH - 1, 0, shadow_dark, IUP_DRAW_STROKE, 1);
+  iupdrvDrawLine(dc, 0, 0, 0, SWITCH_TRACK_HEIGHT - 1, shadow_dark, IUP_DRAW_STROKE, 1);
+
+  iupdrvDrawLine(dc, SWITCH_TRACK_WIDTH - 1, 1, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1, shadow_light, IUP_DRAW_STROKE, 1);
+  iupdrvDrawLine(dc, 1, SWITCH_TRACK_HEIGHT - 1, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1, shadow_light, IUP_DRAW_STROKE, 1);
+
+  if (is_checked)
+    thumb_x = SWITCH_TRACK_WIDTH - SWITCH_THUMB_SIZE - SWITCH_THUMB_MARGIN;
+  else
+    thumb_x = SWITCH_THUMB_MARGIN;
+
+  thumb_y = (SWITCH_TRACK_HEIGHT - SWITCH_THUMB_SIZE) / 2;
+
+  iupdrvDrawRectangle(dc, thumb_x, thumb_y, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + SWITCH_THUMB_SIZE - 1, thumb_color, IUP_DRAW_FILL, 1);
+
+  iupdrvDrawLine(dc, thumb_x, thumb_y, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y, shadow_light, IUP_DRAW_STROKE, 1);
+  iupdrvDrawLine(dc, thumb_x, thumb_y, thumb_x, thumb_y + SWITCH_THUMB_SIZE - 1, shadow_light, IUP_DRAW_STROKE, 1);
+
+  iupdrvDrawLine(dc, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + 1, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + SWITCH_THUMB_SIZE - 1, shadow_dark, IUP_DRAW_STROKE, 1);
+  iupdrvDrawLine(dc, thumb_x + 1, thumb_y + SWITCH_THUMB_SIZE - 1, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + SWITCH_THUMB_SIZE - 1, shadow_dark, IUP_DRAW_STROKE, 1);
+}
+
+static void motSwitchExposeCallback(Widget w, IupMotSwitchData* switch_data, XEvent* evt, Boolean* cont)
+{
+  Ihandle* ih = switch_data->ih;
+  IdrawCanvas* dc;
+  Window win;
+
+  (void)w;
+  (void)evt;
+  (void)cont;
+
+  win = XtWindow(switch_data->drawing_area);
+  if (!win)
+    return;
+
+  if (!iupAttribGet(ih, "DRAWABLE"))
+    iupAttribSet(ih, "DRAWABLE", (char*)win);
+
+  dc = iupdrvDrawCreateCanvas(ih);
+  if (!dc)
+    return;
+
+  iupDrawParentBackground(dc, ih);
+
+  motSwitchDraw(ih, switch_data, dc);
+
+  iupdrvDrawFlush(dc);
+
+  iupdrvDrawKillCanvas(dc);
+}
+
+static void motSwitchButtonPressCallback(Widget w, Ihandle* ih, XButtonPressedEvent* evt, Boolean* cont)
+{
+  IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
+  IFni cb;
+  int new_check;
+
+  (void)w;
+  (void)evt;
+  (void)cont;
+
+  if (!switch_data)
+    return;
+
+  iupmotTipLeaveNotify();
+
+  new_check = switch_data->checked_state ? 0 : 1;
+  switch_data->checked_state = new_check;
+
+  XClearArea(iupmot_display, XtWindow(switch_data->drawing_area), 0, 0, 0, 0, True);
+
+  cb = (IFni)IupGetCallback(ih, "ACTION");
+  if (cb && cb(ih, new_check) == IUP_CLOSE)
+    IupExitLoop();
+
+  if (iupObjectCheck(ih))
+    iupBaseCallValueChangedCb(ih);
+}
+
 /*********************************************************************************/
 
-
 static int motToggleSetBgColorAttrib(Ihandle* ih, const char* value)
 {
   if (ih->data->type == IUP_TOGGLE_TEXT)
@@ -151,6 +303,9 @@
 
 static int motToggleSetTitleAttrib(Ihandle* ih, const char* value)
 {
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+    return 0;
+
   if (ih->data->type == IUP_TOGGLE_TEXT)
   {
     iupmotSetMnemonicTitle(ih, NULL, 0, value);
@@ -226,6 +381,27 @@
   Ihandle *radio;
   unsigned char check;
 
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
+    int new_check;
+
+    if (!switch_data)
+      return 0;
+
+    if (iupStrEqualNoCase(value, "TOGGLE"))
+      new_check = !switch_data->checked_state;
+    else
+      new_check = iupStrBoolean(value);
+
+    switch_data->checked_state = new_check;
+
+    if (ih->handle)
+      XClearArea(iupmot_display, XtWindow(switch_data->drawing_area), 0, 0, 0, 0, True);
+
+    return 0;
+  }
+
   if (iupStrEqualNoCase(value,"TOGGLE"))
     check = (unsigned char)-1;
   else if (iupStrEqualNoCase(value,"NOTDEF"))
@@ -281,12 +457,22 @@
 
 static char* motToggleGetValueAttrib(Ihandle* ih)
 {
-  int check;
-  unsigned char set = 0;
-  XtVaGetValues (ih->handle, XmNset, &set, NULL);
-  check = set;
-  if (check == XmINDETERMINATE) check = -1;
-  return iupStrReturnChecked(check);
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
+    if (switch_data)
+      return iupStrReturnChecked(switch_data->checked_state);
+    return iupStrReturnChecked(0);
+  }
+
+  {
+    int check;
+    unsigned char set = 0;
+    XtVaGetValues (ih->handle, XmNset, &set, NULL);
+    check = set;
+    if (check == XmINDETERMINATE) check = -1;
+    return iupStrReturnChecked(check);
+  }
 }
 
 static int motToggleSetPaddingAttrib(Ihandle* ih, const char* value)
@@ -417,6 +603,76 @@
   if (radio)
     ih->data->is_radio = 1;
 
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupMotSwitchData* switch_data;
+
+    if (ih->data->is_radio)
+    {
+      iupAttribSet(ih, "SWITCH", "NO");
+      goto regular_toggle;
+    }
+
+    ih->data->type = IUP_TOGGLE_TEXT;
+
+    switch_data = (IupMotSwitchData*)calloc(1, sizeof(IupMotSwitchData));
+    switch_data->ih = ih;
+    iupAttribSet(ih, "_IUPMOT_SWITCHDATA", (char*)switch_data);
+
+    iupMOT_SETARG(args, num_args, XmNmappedWhenManaged, False);
+    iupMOT_SETARG(args, num_args, XmNx, 0);
+    iupMOT_SETARG(args, num_args, XmNy, 0);
+    iupMOT_SETARG(args, num_args, XmNwidth, SWITCH_TRACK_WIDTH);
+    iupMOT_SETARG(args, num_args, XmNheight, SWITCH_TRACK_HEIGHT);
+    iupMOT_SETARG(args, num_args, XmNmarginHeight, 0);
+    iupMOT_SETARG(args, num_args, XmNmarginWidth, 0);
+    iupMOT_SETARG(args, num_args, XmNshadowThickness, 0);
+
+    if (iupAttribGetBoolean(ih, "CANFOCUS"))
+      iupMOT_SETARG(args, num_args, XmNtraversalOn, True);
+    else
+      iupMOT_SETARG(args, num_args, XmNtraversalOn, False);
+
+    switch_data->drawing_area = XtCreateManagedWidget(
+      iupDialogGetChildIdStr(ih),
+      xmDrawingAreaWidgetClass,
+      iupChildTreeGetNativeParentHandle(ih),
+      args, num_args);
+
+    if (!switch_data->drawing_area)
+    {
+      free(switch_data);
+      return IUP_ERROR;
+    }
+
+    ih->handle = switch_data->drawing_area;
+    ih->serial = iupDialogGetChildId(ih);
+
+    XtAddCallback(ih->handle, XmNexposeCallback, (XtCallbackProc)motSwitchExposeCallback, (XtPointer)switch_data);
+    XtAddEventHandler(ih->handle, ButtonPressMask, False, (XtEventHandler)motSwitchButtonPressCallback, (XtPointer)ih);
+    XtAddEventHandler(ih->handle, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
+    XtAddEventHandler(ih->handle, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
+    XtAddEventHandler(ih->handle, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
+    XtAddEventHandler(ih->handle, KeyPressMask, False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
+    XtAddCallback(ih->handle, XmNhelpCallback, (XtCallbackProc)iupmotHelpCallback, (XtPointer)ih);
+
+    value = iupAttribGet(ih, "VALUE");
+    if (value && iupStrBoolean(value))
+      switch_data->checked_state = 1;
+    else
+      switch_data->checked_state = 0;
+
+    XtVaSetValues(ih->handle, XmNbackground, iupmotColorGetPixelStr(iupBaseNativeParentGetBgColor(ih)), NULL);
+
+    XtRealizeWidget(ih->handle);
+
+    iupAttribSet(ih, "DRAWABLE", (char*)XtWindow(ih->handle));
+
+    return IUP_NOERROR;
+  }
+
+regular_toggle:
+
   value = iupAttribGet(ih, "IMAGE");
   if (value)
   {
@@ -545,10 +801,26 @@
   return IUP_NOERROR;
 }
 
+static void motToggleUnMapMethod(Ihandle* ih)
+{
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
+    if (switch_data)
+    {
+      free(switch_data);
+      iupAttribSet(ih, "_IUPMOT_SWITCHDATA", NULL);
+    }
+  }
+
+  iupdrvBaseUnMapMethod(ih);
+}
+
 void iupdrvToggleInitClass(Iclass* ic)
 {
   /* Driver Dependent Class functions */
   ic->Map = motToggleMapMethod;
+  ic->UnMap = motToggleUnMapMethod;
 
   /* Driver Dependent Attribute functions */
 
Index: src/mot/iupmot_tree.c
===================================================================
--- src/mot/iupmot_tree.c	(revision 5971)
+++ src/mot/iupmot_tree.c	(working copy)
@@ -633,6 +633,7 @@
   XmString itemTitle;
   motTreeItemData *itemData;
   Pixel bgcolor, fgcolor;
+  XmFontList fontlist;
   int kindPrev = 0, num_args = 0;
   Arg args[30];
 
@@ -653,9 +654,10 @@
 
   itemTitle = iupmotStringCreate(title);
 
-  /* Get default colors */
+  /* Get default colors and font */
   XtVaGetValues(ih->handle, XmNforeground, &fgcolor, NULL);
   XtVaGetValues(ih->handle, XmNbackground, &bgcolor, NULL);
+  fontlist = (XmFontList)iupmotGetFontListAttrib(ih);
 
   if (wItemPrev)
   {
@@ -695,6 +697,12 @@
   iupMOT_SETARG(args, num_args, XmNshadowThickness, 0);
   iupMOT_SETARG(args, num_args, XmNlabelString, itemTitle);
 
+  if (fontlist)
+  {
+    iupMOT_SETARG(args, num_args, XmNrenderTable, fontlist);
+    iupMOT_SETARG(args, num_args, XmNfontList, fontlist);
+  }
+
   iupMOT_SETARG(args, num_args, XmNviewType, XmSMALL_ICON);
 
   if (kind == ITREE_BRANCH)
@@ -1486,7 +1494,7 @@
   if (value)
     fontlist = iupmotGetFontList(iupAttribGetId(ih, "TITLEFOUNDRY", id), value);
 
-  XtVaSetValues(wItem, XmNrenderTable, fontlist, NULL);
+  XtVaSetValues(wItem, XmNrenderTable, fontlist, XmNfontList, fontlist, NULL);
 
   return 0;
 }
@@ -2079,6 +2087,7 @@
   iupMOT_SETARG(args, num_args, XmNmarginWidth, 0);
   iupMOT_SETARG(args, num_args, XmNforeground, color);
   iupMOT_SETARG(args, num_args, XmNrenderTable, fontlist);
+  iupMOT_SETARG(args, num_args, XmNfontList, fontlist);
   iupMOT_SETARG(args, num_args, XmNvalue, value);
   iupMOT_SETARG(args, num_args, XmNtraversalOn, True);
 
@@ -2823,6 +2832,16 @@
   iupMOT_SETARG(args, num_args, XmNselectionPolicy, XmSINGLE_SELECT);
   iupMOT_SETARG(args, num_args, XmNoutlineIndentation, 20);
 
+  /* Set the font for the tree widget */
+  {
+    XmFontList fontlist = (XmFontList)iupmotGetFontListAttrib(ih);
+    if (fontlist)
+    {
+      iupMOT_SETARG(args, num_args, XmNrenderTable, fontlist);
+      iupMOT_SETARG(args, num_args, XmNfontList, fontlist);
+    }
+  }
+
   if (iupAttribGetBoolean(ih, "HIDELINES"))
     iupMOT_SETARG(args, num_args, XmNoutlineLineStyle,  XmNO_LINE);
   else
@@ -2842,6 +2861,15 @@
   if (!ih->handle)
     return IUP_ERROR;
 
+  /* Force font to be applied AFTER widget creation */
+  {
+    char* font_value = iupAttribGetStr(ih, "FONT");
+    if (!font_value)
+      font_value = IupGetGlobal("DEFAULTFONT");
+    if (font_value)
+      iupdrvSetFontAttrib(ih, font_value);
+  }
+
   ih->serial = iupDialogGetChildId(ih); /* must be after using the string */
 
   iupAttribSet(ih, "_IUP_EXTRAPARENT", (char*)parent);
@@ -2994,4 +3022,5 @@
   /* not supported in Motif */
   iupClassRegisterAttributeId(ic, "TOGGLEVALUE", NULL, NULL, IUPAF_NOT_SUPPORTED);
   iupClassRegisterAttributeId(ic, "SHOWTOGGLE", NULL, NULL, IUPAF_NOT_SUPPORTED);
+  iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
 }
Index: src/mot/iupunix_help.c
===================================================================
--- src/mot/iupunix_help.c	(revision 5971)
+++ src/mot/iupunix_help.c	(working copy)
@@ -62,9 +62,9 @@
     char* system = IupGetGlobal("SYSTEM"); 
     if (iupStrEqualNoCase(system, "Linux") ||
         iupStrEqualNoCase(system, "FreeBSD"))
-      browser = "firefox";
+      browser = "xdg-open";
     else if (iupStrEqualNoCase(system, "MacOS"))
-      browser = "safari";
+      browser = "open";
     else if (iupStrEqualPartial(system, "CYGWIN"))
       browser = "iexplore";
     else  
Index: src/mot/iupunix_info.c
===================================================================
--- src/mot/iupunix_info.c	(revision 5971)
+++ src/mot/iupunix_info.c	(working copy)
@@ -81,27 +81,8 @@
   return NULL;
 }
 
-IUP_SDK_API int iupdrvGetPreferencePath(char *filename, int use_system)
-{
-  char* home = getenv("HOME");
-  if (home)
-  {
-    (void)use_system; /* unused */
-    /* UNIX format */
-    strcpy(filename, home);
-    strcat(filename, "/");
-    return 1;
-  }
-  else
-  {
-    filename[0] = '\0';
-    return 0;
-  }
-}
-
 /**************************************************************************/
 
-
 int iupUnixIsFile(const char* name)
 {
   struct stat status;
@@ -122,11 +103,10 @@
   return 0;
 }            
 
-int iupUnixMakeDirectory(const char* name) 
+int iupUnixMakeDirectory(const char* name)
 {
   mode_t oldmask = umask((mode_t)0);
-  int fail =  mkdir(name, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP |
-                          S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH);
+  int fail =  mkdir(name, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH);
   umask (oldmask);
   if (fail)
     return 0;
@@ -133,10 +113,78 @@
   return 1;
 }
 
+static int iupUnixMakeDirectoryIfNeeded(const char* path)
+{
+  struct stat st;
+  if (stat(path, &st) == 0)
+  {
+    if (S_ISDIR(st.st_mode))
+      return 1;
+    return 0;
+  }
+  return iupUnixMakeDirectory(path);
+}
 
+IUP_SDK_API int iupdrvGetPreferencePath(char *filename, const char *app_name, int use_system)
+{
+  char* home;
+
+  if (!app_name || !app_name[0])
+  {
+    filename[0] = '\0';
+    return 0;
+  }
+
+  if (use_system)
+  {
+    /* XDG Base Directory Specification: ~/.config/appname/config */
+    char* xdg_config = getenv("XDG_CONFIG_HOME");
+    if (xdg_config && xdg_config[0])
+    {
+      strcpy(filename, xdg_config);
+    }
+    else
+    {
+      home = getenv("HOME");
+      if (!home)
+      {
+        filename[0] = '\0';
+        return 0;
+      }
+      strcpy(filename, home);
+      strcat(filename, "/.config");
+    }
+
+    /* Ensure base config directory exists */
+    iupUnixMakeDirectoryIfNeeded(filename);
+
+    /* Add app directory */
+    strcat(filename, "/");
+    strcat(filename, app_name);
+    iupUnixMakeDirectoryIfNeeded(filename);
+
+    /* Add config filename */
+    strcat(filename, "/config");
+    return 1;
+  }
+  else
+  {
+    /* Legacy format: ~/.appname */
+    home = getenv("HOME");
+    if (!home)
+    {
+      filename[0] = '\0';
+      return 0;
+    }
+    strcpy(filename, home);
+    strcat(filename, "/.");
+    strcat(filename, app_name);
+    return 1;
+  }
+}
+
 /**************************************************************************/
 
-
 IUP_API void IupLogV(const char* type, const char* format, va_list arglist)
 {
   int options = LOG_CONS | LOG_PID;
Index: src/win/iupwin_button.c
===================================================================
--- src/win/iupwin_button.c	(revision 5971)
+++ src/win/iupwin_button.c	(working copy)
@@ -40,9 +40,33 @@
 {
   /* LAYOUT_DECORATION_ESTIMATE */
   int border_size = winButtonGetBorder() * 2;
-  (void)ih;
-  (*x) += border_size;
-  (*y) += border_size;
+
+  int has_image = 0;
+  int has_text = 0;
+  int has_bgcolor = 0;
+
+  if (ih)
+  {
+    char* image = iupAttribGet(ih, "IMAGE");
+    char* title = iupAttribGet(ih, "TITLE");
+    char* bgcolor = iupAttribGet(ih, "BGCOLOR");
+    has_image = (image != NULL);
+    has_text = (title != NULL && *title != 0);
+    has_bgcolor = (!has_image && !has_text && bgcolor != NULL);
+  }
+
+  if (has_bgcolor)
+  {
+    int charwidth, charheight;
+    iupdrvFontGetCharSize(ih, &charwidth, &charheight);
+    (*x) += charwidth * 4 + border_size;
+    (*y) += charheight + border_size;
+  }
+  else
+  {
+    (*x) += border_size;
+    (*y) += border_size;
+  }
 }
 
 /****************************************************************/
@@ -302,11 +326,13 @@
     if (bgcolor)
     {
       RECT rect;
-      unsigned char r=0, g=0, b=0;
-      iupStrToRGB(bgcolor, &r, &g, &b);
-      SetDCBrushColor(hDC, RGB(r,g,b));
-      SetRect(&rect, xpad, ypad, rect_width - xpad, rect_height - ypad);
-      FillRect(hDC, &rect, (HBRUSH)GetStockObject(DC_BRUSH));
+      unsigned char r, g, b;
+      if (iupStrToRGB(bgcolor, &r, &g, &b))
+      {
+        SetDCBrushColor(hDC, RGB(r, g, b));
+        SetRect(&rect, xpad, ypad, rect_width - xpad, rect_height - ypad);
+        FillRect(hDC, &rect, (HBRUSH)GetStockObject(DC_BRUSH));
+      }
     }
   }
 }
@@ -586,8 +612,12 @@
         if (!iupAttribGetBoolean(ih, "CANFOCUS"))
         {
           Icallback cb = IupGetCallback(ih, "ACTION");
-          if (cb && cb(ih) == IUP_CLOSE)
-            IupExitLoop();
+          if (cb)
+          {
+            int ret = cb(ih);
+            if (ret == IUP_CLOSE)
+              IupExitLoop();
+          }
         }
       }
 
Index: src/win/iupwin_canvas.c
===================================================================
--- src/win/iupwin_canvas.c	(revision 5971)
+++ src/win/iupwin_canvas.c	(working copy)
@@ -446,7 +446,7 @@
     return 1; 
   case WM_PAINT:
     {
-      IFnff cb = (IFnff)IupGetCallback(ih, "ACTION");
+      IFn cb = (IFn)IupGetCallback(ih, "ACTION");
       if (cb && !(ih->data->inside_resize))
       {
         PAINTSTRUCT ps;
@@ -454,7 +454,7 @@
         iupAttribSet(ih, "HDC_WMPAINT", (char*)hdc);
         iupAttribSetStrf(ih, "CLIPRECT", "%d %d %d %d", ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right-ps.rcPaint.left, ps.rcPaint.bottom-ps.rcPaint.top);
 
-        cb(ih, (float)ih->data->posx, (float)ih->data->posy);
+        cb(ih);
 
         iupAttribSet(ih, "CLIPRECT", NULL);
         iupAttribSet(ih, "HDC_WMPAINT", NULL);
@@ -837,7 +837,6 @@
   iupClassRegisterAttribute(ic, "HWND", iupBaseGetWidAttrib, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "HDC_WMPAINT", NULL, NULL, NULL, NULL, IUPAF_NO_STRING|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "HTTRANSPARENT", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "DRAWUSEDIRECT2D", NULL, NULL, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "DRAWANTIALIAS", NULL, NULL, IUPAF_SAMEASSYSTEM, "YES", IUPAF_NO_INHERIT);
 
   iupClassRegisterAttribute(ic, "SCROLLVISIBLE", iupwinGetScrollVisibleAttrib, NULL, NULL, NULL, IUPAF_READONLY | IUPAF_NO_INHERIT);
Index: src/win/iupwin_common.c
===================================================================
--- src/win/iupwin_common.c	(revision 5971)
+++ src/win/iupwin_common.c	(working copy)
@@ -6,9 +6,10 @@
 #include <windows.h>
 #include <commctrl.h>
 
-#include <stdio.h>              
+#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>             
+#include <string.h>
+#include <stdint.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -1082,7 +1083,7 @@
     10,                           /* horizontal size - set this to avoid initial size problems */
     10,                           /* vertical size */
     hParent,                      /* window parent */
-    (HMENU)serial,                /* child identifier */
+    (HMENU)(intptr_t)serial,      /* child identifier */
     iupwin_hinstance,             /* instance of app. */
     clientdata);
 }
@@ -1297,6 +1298,45 @@
   DrawFocusRect(hDC, &rect);
 }
 
+void iupwinTitleBarThemeColor(HWND hwnd)
+{
+  typedef HRESULT(STDAPICALLTYPE *PtrDwmSetWindowAttribute)(HWND, DWORD, LPCVOID, DWORD);
+  static PtrDwmSetWindowAttribute dwmSetWindowAttribute = NULL;
+  static int initialized = 0;
+
+  if (!iupwinIsWin10OrNew())
+    return;
+
+  if (!initialized)
+  {
+    HMODULE dwmLibrary = LoadLibrary(TEXT("dwmapi.dll"));
+    if (dwmLibrary)
+      dwmSetWindowAttribute = (PtrDwmSetWindowAttribute)GetProcAddress(dwmLibrary, "DwmSetWindowAttribute");
+    initialized = 1;
+  }
+
+  if (dwmSetWindowAttribute)
+  {
+    int dark_mode = iupwinIsSystemDarkMode();
+    BOOL value = dark_mode ? TRUE : FALSE;
+    DWORD attribute = 20;
+
+    if (iupwinCheckWindowsVersion(10, 0))
+    {
+      DWORD build = 0;
+      OSVERSIONINFOEX osvi;
+      osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
+      if (GetVersionEx((OSVERSIONINFO*)&osvi))
+        build = osvi.dwBuildNumber;
+
+      if (build >= 18985)
+        attribute = 19;
+    }
+
+    dwmSetWindowAttribute(hwnd, attribute, &value, sizeof(value));
+  }
+}
+
 /* Unused in Windows */
 IUP_SDK_API int iupdrvBaseSetBgColorAttrib(Ihandle* ih, const char* value)
 {
Index: src/win/iupwin_dialog.c
===================================================================
--- src/win/iupwin_dialog.c	(revision 5971)
+++ src/win/iupwin_dialog.c	(working copy)
@@ -14,6 +14,7 @@
 #include <string.h>
 #include <memory.h>
 #include <stdarg.h>
+#include <stdint.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -47,12 +48,9 @@
 #endif
 
 
-#define IUPWIN_TRAY_NOTIFICATION 102
-
 static int WM_HELPMSG;
 
 static int winDialogSetBgColorAttrib(Ihandle* ih, const char* value);
-static int winDialogSetTrayAttrib(Ihandle *ih, const char *value);
 
 /****************************************************************
                      ITaskbarList3 resources
@@ -807,58 +805,6 @@
       else
         break;
     }
-  case WM_USER+IUPWIN_TRAY_NOTIFICATION:
-    {
-      int dclick  = 0;
-      int button  = 0;
-      int pressed = 0;
-
-      switch (lp)
-      {
-      case WM_LBUTTONDOWN:
-        pressed = 1;
-        button  = 1;
-        break;
-      case WM_MBUTTONDOWN:
-        pressed = 1;
-        button  = 2;
-        break;
-      case WM_RBUTTONDOWN:
-        pressed = 1;
-        button  = 3;
-        break;
-      case WM_LBUTTONDBLCLK:
-        dclick = 1;
-        button = 1;
-        break;
-      case WM_MBUTTONDBLCLK:
-        dclick = 1;
-        button = 2;
-        break;
-      case WM_RBUTTONDBLCLK:
-        dclick = 1;
-        button = 3;
-        break;
-      case WM_LBUTTONUP:
-        button = 1;
-        break;
-      case WM_MBUTTONUP:
-        button = 2;
-        break;
-      case WM_RBUTTONUP:
-        button = 3;
-        break;
-      }
-
-      if (button != 0)
-      {
-        IFniii cb = (IFniii)IupGetCallback(ih, "TRAYCLICK_CB");
-        if (cb && cb(ih, button, pressed, dclick) == IUP_CLOSE)
-          IupExitLoop();
-      }
-
-      break;
-    }
   case WM_CLOSE:
     {
       Icallback cb = IupGetCallback(ih, "CLOSE_CB");
@@ -982,6 +928,26 @@
       IupRefresh(ih);
       break;
     }
+  case WM_SETTINGCHANGE:
+    {
+      if (wp == 0 && lp != 0)
+      {
+        LPCTSTR area = (LPCTSTR)lp;
+        if (lstrcmp(area, TEXT("ImmersiveColorSet")) == 0)
+        {
+          iupwinTitleBarThemeColor(ih->handle);
+
+          iupwinSetGlobalColors();
+
+          int dark_mode = iupwinIsSystemDarkMode();
+
+          IFni cb = (IFni)IupGetCallback(ih, "THEMECHANGED_CB");
+          if (cb)
+            cb(ih, dark_mode);
+        }
+      }
+      break;
+    }
   }
 
   if (msg == (UINT)WM_HELPMSG)
@@ -1387,6 +1353,8 @@
   if (!ih->handle)
     return IUP_ERROR;
 
+  iupwinTitleBarThemeColor(ih->handle);
+
   /* associate HWND with Ihandle*, all Win32 controls must call this. */
   iupwinHandleAdd(ih, ih->handle);
 
@@ -1427,9 +1395,6 @@
   }
 #endif
 
-  if (iupAttribGet(ih, "_IUPDLG_HASTRAY"))
-    winDialogSetTrayAttrib(ih, NULL);
-
   iupwinTipsDestroy(ih);
   iupwinDestroyDragDrop(ih);
 
@@ -1783,128 +1748,6 @@
   return iupStrReturnBoolean(IsIconic(ih->handle));
 }
 
-static void winDialogTrayMessage(HWND hWnd, DWORD dwMessage, HICON hIcon, const char* value)
-{
-  NOTIFYICONDATA tnd;
-  memset(&tnd, 0, sizeof(NOTIFYICONDATA));
-
-  tnd.cbSize  = sizeof(NOTIFYICONDATA);
-  tnd.hWnd    = hWnd;
-  tnd.uID     = 1000;
-
-  if (dwMessage == NIM_ADD)
-  {
-    tnd.uFlags = NIF_MESSAGE;
-    tnd.uCallbackMessage = WM_USER+IUPWIN_TRAY_NOTIFICATION;
-  }
-  else if (dwMessage == NIM_MODIFY)
-  {
-    if (hIcon)  
-    {
-      tnd.uFlags |= NIF_ICON;
-      tnd.hIcon = hIcon;
-    }
-
-    if (value) 
-    {
-      tnd.uFlags |= NIF_TIP;
-      iupwinStrCopy(tnd.szTip, value, sizeof(tnd.szTip));
-    }
-  }
-
-  Shell_NotifyIcon(dwMessage, &tnd);
-}
-
-static void winDialogTrayBalloonMessage(Ihandle *ih, const char* value)
-{
-  NOTIFYICONDATA tnd;
-  memset(&tnd, 0, sizeof(NOTIFYICONDATA));
-
-  tnd.cbSize  = sizeof(NOTIFYICONDATA);
-  tnd.hWnd    = ih->handle;
-  tnd.uID     = 1000;
-  tnd.uFlags |= NIF_INFO;
-
-  /* set to NULL to remove the tooltip */
-  if (value) 
-  {
-    char* balloon_title;
-
-    iupwinStrCopy(tnd.szInfo, value, sizeof(tnd.szInfo));
-
-    tnd.uTimeout = IupGetInt(ih, "TRAYTIPBALLOONDELAY"); /* must use IupGetInt to use inheritance */
-
-    balloon_title = IupGetAttribute(ih, "TRAYTIPBALLOONTITLE");
-    if (balloon_title)
-      iupwinStrCopy(tnd.szInfoTitle, balloon_title, sizeof(tnd.szInfoTitle));
-
-    tnd.dwInfoFlags = IupGetInt(ih, "TRAYTIPBALLOONTITLEICON");
-  }
-
-  Shell_NotifyIcon(NIM_MODIFY, &tnd);
-}
-
-static int winDialogCheckTray(Ihandle *ih)
-{
-  if (iupAttribGet(ih, "_IUPDLG_HASTRAY"))
-    return 1;
-
-  if (iupAttribGetBoolean(ih, "TRAY"))
-  {
-    winDialogTrayMessage(ih->handle, NIM_ADD, NULL, NULL);
-    iupAttribSet(ih, "_IUPDLG_HASTRAY", "YES");
-    return 1;
-  }
-
-  return 0;
-}
-
-static int winDialogSetTrayAttrib(Ihandle *ih, const char *value)
-{
-  int tray = iupStrBoolean(value);
-  if (iupAttribGet(ih, "_IUPDLG_HASTRAY"))
-  {
-    if (!tray)
-    {
-      winDialogTrayMessage(ih->handle, NIM_DELETE, NULL, NULL);
-      iupAttribSet(ih, "_IUPDLG_HASTRAY", NULL);
-    }
-  }
-  else
-  {
-    if (tray)
-    {
-      winDialogTrayMessage(ih->handle, NIM_ADD, NULL, NULL);
-      iupAttribSet(ih, "_IUPDLG_HASTRAY", "YES");
-    }
-  }
-  return 1;
-}
-
-static int winDialogSetTrayTipAttrib(Ihandle *ih, const char *value)
-{
-  if (winDialogCheckTray(ih))
-  {
-    int balloon = IupGetInt(ih, "TRAYTIPBALLOON");  /* must use IupGetInt to use inheritance */
-    if (balloon)
-      winDialogTrayBalloonMessage(ih, value);
-    else
-      winDialogTrayMessage(ih->handle, NIM_MODIFY, NULL, value);
-  }
-  return 1;
-}
-
-static int winDialogSetTrayImageAttrib(Ihandle *ih, const char *value)
-{
-  if (winDialogCheckTray(ih))
-  {
-    HICON hIcon = (HICON)iupImageGetIcon(value);
-    if (hIcon)
-      winDialogTrayMessage(ih->handle, NIM_MODIFY, hIcon, NULL);
-  }
-  return 1;
-}
-
 static int winDialogSetBringFrontAttrib(Ihandle *ih, const char *value)
 {
   if (iupStrBoolean(value))
@@ -1990,7 +1833,7 @@
       off_style = WS_BORDER | WS_THICKFRAME | WS_CAPTION | 
                   WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SYSMENU;
       new_style = GetWindowLong(ih->handle, GWL_STYLE);
-      iupAttribSet(ih, "_IUPWIN_FS_STYLE", (char*)new_style);
+      iupAttribSet(ih, "_IUPWIN_FS_STYLE", (char*)(intptr_t)new_style);
       new_style &= (~off_style);
       SetWindowLong(ih->handle, GWL_STYLE, new_style);
 
@@ -2027,7 +1870,7 @@
   }
   else
   {
-    LONG style = (LONG)iupAttribGet(ih, "_IUPWIN_FS_STYLE");
+    LONG style = (LONG)(intptr_t)iupAttribGet(ih, "_IUPWIN_FS_STYLE");
     if (style)
     {
       BOOL visible = ShowWindow(ih->handle, SW_HIDE);
@@ -2096,9 +1939,6 @@
   iupClassRegisterCallback(ic, "CUSTOMFRAMEDRAW_CB", "");
   iupClassRegisterCallback(ic, "CUSTOMFRAMEACTIVATE_CB", "i");
 
-  /* Callback Windows and GTK Only */
-  iupClassRegisterCallback(ic, "TRAYCLICK_CB", "iii");
-
   /* Driver Dependent Attribute functions */
 
   /* Visual */
@@ -2153,16 +1993,9 @@
   iupClassRegisterAttribute(ic, "ACTIVEWINDOW", winDialogGetActiveWindowAttrib, NULL, NULL, NULL, IUPAF_READONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TOPMOST", NULL, winDialogSetTopMostAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TOPMOST", NULL, winDialogSetTopMostAttrib, NULL, NULL, IUPAF_WRITEONLY|IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAY", NULL, winDialogSetTrayAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYIMAGE", NULL, winDialogSetTrayImageAttrib, NULL, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYTIP", NULL, winDialogSetTrayTipAttrib, NULL, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "CUSTOMFRAME", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
 
   /* IupDialog Windows Only */
-  iupClassRegisterAttribute(ic, "TRAYTIPDELAY", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYTIPBALLOON", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYTIPBALLOONTITLE", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
-  iupClassRegisterAttribute(ic, "TRAYTIPBALLOONTITLEICON", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TASKBARBUTTON", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
 
   iupClassRegisterAttribute(ic, "CUSTOMFRAMEDRAW", NULL, NULL, IUPAF_SAMEASSYSTEM, NULL, IUPAF_NO_INHERIT);
Index: src/win/iupwin_draw.c
===================================================================
--- src/win/iupwin_draw.c	(revision 5971)
+++ src/win/iupwin_draw.c	(working copy)
@@ -7,10 +7,10 @@
 #include <windows.h>
 #include <uxtheme.h>
 
-#if (_MSC_VER >= 1700)  /* Visual C++ 11.0 ( Visual Studio 2012) */
+#if defined(_MSC_VER) && (_MSC_VER < 1700)  /* Visual C++ before 11.0 (Visual Studio 2012) */
+#include <tmschema.h>
+#else
 #include <vssym32.h>
-#else
-#include <tmschema.h>
 #endif
 
 
Index: src/win/iupwin_draw_gdi.c
===================================================================
--- src/win/iupwin_draw_gdi.c	(revision 5971)
+++ src/win/iupwin_draw_gdi.c	(working copy)
@@ -39,14 +39,22 @@
 void iupdrvDrawLineWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width);
 void iupdrvDrawRectangleWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width);
 void iupdrvDrawArcWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, double a1, double a2, long color, int style, int line_width);
+void iupdrvDrawEllipseWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width);
 void iupdrvDrawPolygonWDL(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width);
+void iupdrvDrawPixelWDL(IdrawCanvas* dc, int x, int y, long color);
+void iupdrvDrawRoundedRectangleWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width);
 void iupdrvDrawTextWDL(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, const char* font, int flags, double text_orientation);
 void iupdrvDrawImageWDL(IdrawCanvas* dc, const char* name, int make_inactive, const char* bgcolor, int x, int y, int w, int h);
 void iupdrvDrawSetClipRectWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2);
+void iupdrvDrawSetClipRoundedRectWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius);
 void iupdrvDrawResetClipWDL(IdrawCanvas* dc);
 void iupdrvDrawGetClipRectWDL(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2);
 void iupdrvDrawSelectRectWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2);
 void iupdrvDrawFocusRectWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2);
+void iupdrvDrawBezierWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width);
+void iupdrvDrawQuadraticBezierWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width);
+void iupdrvDrawLinearGradientWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2);
+void iupdrvDrawRadialGradientWDL(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge);
 
 struct _IdrawCanvas{
   Ihandle* ih;
@@ -62,6 +70,9 @@
   int sim_aa;
 
   IdrawCanvas* wdl_gc;
+
+  /* GDI+ antialiasing cache */
+  dummy_GpGraphics* cached_graphics;
 };
 
 void iupwinDrawInit(void)
@@ -85,12 +96,12 @@
 
   dc->ih = ih;
 
-  if (iupAttribGetBoolean(ih, "DRAWUSEDIRECT2D") || IupGetInt(NULL, "DRAWUSEDIRECT2D"))
-  {
-    dc->wdl_gc = iupdrvDrawCreateCanvasWDL(ih);
+  /* Try WDL first (Direct2D with automatic GDI+ fallback), if that fails use GDI */
+  dc->wdl_gc = iupdrvDrawCreateCanvasWDL(ih);
+  if (dc->wdl_gc)
     return dc;
-  }
 
+  /* WDL not available, fallback to GDI */
   dc->hWnd = (HWND)IupGetAttribute(ih, "HWND");  /* Use the attribute, so it can work with FileDlg preview area */
 
   /* valid only inside the ACTION callback of an IupCanvas */
@@ -129,6 +140,10 @@
     return;
   }
 
+  /* Cleanup GDI+ graphics cache */
+  if (dc->cached_graphics)
+    gdix_vtable->fn_DeleteGraphics(dc->cached_graphics);
+
   SelectObject(dc->hBitmapDC, dc->hOldBitmap);
   DeleteObject(dc->hBitmap);
   DeleteDC(dc->hBitmapDC);  /* to match CreateCompatibleDC */
@@ -158,6 +173,13 @@
     dc->w = w;
     dc->h = h;
 
+    /* Invalidate GDI+ graphics cache (HDC changed) */
+    if (dc->cached_graphics)
+    {
+      gdix_vtable->fn_DeleteGraphics(dc->cached_graphics);
+      dc->cached_graphics = NULL;
+    }
+
     SelectObject(dc->hBitmapDC, dc->hOldBitmap);
     DeleteObject(dc->hBitmap);
     DeleteDC(dc->hBitmapDC);  /* to match CreateCompatibleDC */
@@ -272,13 +294,22 @@
   return iupDrawAlpha(color) != 255;
 }
 
+/* Cached GDI+ graphics getter - reuses graphics object for antialiasing */
+static dummy_GpGraphics* iGetCachedGraphicsSimAA(IdrawCanvas* dc)
+{
+  if (!dc->cached_graphics)
+  {
+    gdix_vtable->fn_CreateFromHDC(dc->hBitmapDC, &dc->cached_graphics);
+    gdix_vtable->fn_SetSmoothingMode(dc->cached_graphics, dummy_SmoothingModeAntiAlias);
+  }
+
+  return dc->cached_graphics;
+}
+
 static void iwinDrawRectangleSimAA(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
 {
-  dummy_GpGraphics* graphics;
+  dummy_GpGraphics* graphics = iGetCachedGraphicsSimAA(dc);
 
-  gdix_vtable->fn_CreateFromHDC(dc->hBitmapDC, &graphics);
-  gdix_vtable->fn_SetSmoothingMode(graphics, dummy_SmoothingModeAntiAlias);
-
   iupDrawCheckSwapCoord(x1, x2);
   iupDrawCheckSwapCoord(y1, y2);
 
@@ -301,8 +332,6 @@
 
     gdix_vtable->fn_DeletePen(pen);
   }
-
-  gdix_vtable->fn_DeleteGraphics(graphics);
 }
 
 IUP_SDK_API void iupdrvDrawRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
@@ -359,12 +388,9 @@
 
 static void iwinDrawLineSimAA(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
 {
-  dummy_GpGraphics* graphics;
+  dummy_GpGraphics* graphics = iGetCachedGraphicsSimAA(dc);
   dummy_GpPen* pen;
 
-  gdix_vtable->fn_CreateFromHDC(dc->hBitmapDC, &graphics);
-  gdix_vtable->fn_SetSmoothingMode(graphics, dummy_SmoothingModeAntiAlias);
-
   gdix_vtable->fn_CreatePen1(iupColor2ARGB(color), (float)line_width, dummy_UnitPixel, &pen);
   iwinDrawSetLineStyleSimAA(style, pen);
 
@@ -371,8 +397,6 @@
   gdix_vtable->fn_DrawLine(graphics, pen, (float)x1, (float)y1, (float)x2, (float)y2);
 
   gdix_vtable->fn_DeletePen(pen);
-
-  gdix_vtable->fn_DeleteGraphics(graphics);
 }
 
 IUP_SDK_API void iupdrvDrawLine(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
@@ -419,11 +443,8 @@
 {
   float xc, yc, rx, ry, dx, dy;
   float baseAngle, sweepAngle;
-  dummy_GpGraphics* graphics;
+  dummy_GpGraphics* graphics = iGetCachedGraphicsSimAA(dc);
 
-  gdix_vtable->fn_CreateFromHDC(dc->hBitmapDC, &graphics);
-  gdix_vtable->fn_SetSmoothingMode(graphics, dummy_SmoothingModeAntiAlias);
-
   iupDrawCheckSwapCoord(x1, x2);
   iupDrawCheckSwapCoord(y1, y2);
 
@@ -464,8 +485,6 @@
 
     gdix_vtable->fn_DeletePen(pen);
   }
-
-  gdix_vtable->fn_DeleteGraphics(graphics);
 }
 
 IUP_SDK_API void iupdrvDrawArc(IdrawCanvas* dc, int x1, int y1, int x2, int y2, double a1, double a2, long color, int style, int line_width)
@@ -513,15 +532,49 @@
   }
 }
 
+IUP_SDK_API void iupdrvDrawEllipse(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  if (dc->wdl_gc)
+  {
+    iupdrvDrawEllipseWDL(dc->wdl_gc, x1, y1, x2, y2, color, style, line_width);
+    return;
+  }
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  if (style == IUP_DRAW_FILL)
+  {
+    HBRUSH hBrush = CreateSolidBrush(RGB(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+    HBRUSH hBrushOld = SelectObject(dc->hBitmapDC, hBrush);
+    HPEN hPen = CreatePen(PS_NULL, 0, 0);
+    HPEN hPenOld = SelectObject(dc->hBitmapDC, hPen);
+    Ellipse(dc->hBitmapDC, x1, y1, x2 + 1, y2 + 1);
+    SelectObject(dc->hBitmapDC, hPenOld);
+    SelectObject(dc->hBitmapDC, hBrushOld);
+    DeleteObject(hPen);
+    DeleteObject(hBrush);
+  }
+  else
+  {
+    HPEN hPen = iDrawCreatePen(color, style, line_width);
+    HPEN hPenOld = SelectObject(dc->hBitmapDC, hPen);
+    HBRUSH hBrush = (HBRUSH)GetStockObject(NULL_BRUSH);
+    HBRUSH hBrushOld = SelectObject(dc->hBitmapDC, hBrush);
+    Ellipse(dc->hBitmapDC, x1, y1, x2 + 1, y2 + 1);
+    SelectObject(dc->hBitmapDC, hBrushOld);
+    SelectObject(dc->hBitmapDC, hPenOld);
+    DeleteObject(hPen);
+  }
+}
+
 static void iwinDrawPolygonSimAA(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width)
 {
   int i;
-  dummy_GpGraphics* graphics;
+  dummy_GpGraphics* graphics = iGetCachedGraphicsSimAA(dc);
   dummy_GpPath* path;
 
-  gdix_vtable->fn_CreateFromHDC(dc->hBitmapDC, &graphics);
   gdix_vtable->fn_CreatePath(dummy_FillModeAlternate, &path);
-  gdix_vtable->fn_SetSmoothingMode(graphics, dummy_SmoothingModeAntiAlias);
 
   for (i = 0; i < count - 1; i++)
   {
@@ -551,7 +604,6 @@
   }
 
   gdix_vtable->fn_DeletePath(path);
-  gdix_vtable->fn_DeleteGraphics(graphics);
 }
 
 IUP_SDK_API void iupdrvDrawPolygon(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width)
@@ -572,7 +624,7 @@
   {
     HBRUSH hBrush = CreateSolidBrush(RGB(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
     HBRUSH hBrushOld = SelectObject(dc->hBitmapDC, hBrush);
-    BeginPath(dc->hBitmapDC); 
+    BeginPath(dc->hBitmapDC);
     Polygon(dc->hBitmapDC, (POINT*)points, count);
     EndPath(dc->hBitmapDC);
     FillPath(dc->hBitmapDC);
@@ -581,14 +633,169 @@
   }
   else
   {
+    /* For stroked polygons, need to close the path by adding first point at the end */
+    POINT* closed_points;
+    int use_heap = 0;
+    POINT stack_points[256];
+
+    if (count + 1 <= 256)
+      closed_points = stack_points;
+    else
+    {
+      closed_points = (POINT*)malloc((count + 1) * sizeof(POINT));
+      use_heap = 1;
+    }
+
+    /* Copy all points */
+    memcpy(closed_points, points, count * sizeof(POINT));
+    /* Add first point at the end to close the polygon */
+    closed_points[count] = closed_points[0];
+
     HPEN hPen = iDrawCreatePen(color, style, line_width);
     HPEN hPenOld = SelectObject(dc->hBitmapDC, hPen);
-    Polyline(dc->hBitmapDC, (POINT*)points, count);
+    Polyline(dc->hBitmapDC, closed_points, count + 1);
     SelectObject(dc->hBitmapDC, hPenOld);
     DeleteObject(hPen);
+
+    if (use_heap)
+      free(closed_points);
   }
 }
 
+IUP_SDK_API void iupdrvDrawPixel(IdrawCanvas* dc, int x, int y, long color)
+{
+  if (dc->wdl_gc)
+  {
+    iupdrvDrawPixelWDL(dc->wdl_gc, x, y, color);
+    return;
+  }
+
+  /* Basic GDI fallback - just set pixel */
+  SetPixel(dc->hBitmapDC, x, y, RGB(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+}
+
+IUP_SDK_API void iupdrvDrawRoundedRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width)
+{
+  if (dc->wdl_gc)
+  {
+    iupdrvDrawRoundedRectangleWDL(dc->wdl_gc, x1, y1, x2, y2, corner_radius, color, style, line_width);
+    return;
+  }
+
+  /* Basic GDI fallback - use RoundRect */
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  if (style == IUP_DRAW_FILL)
+  {
+    HBRUSH hBrush = CreateSolidBrush(RGB(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+    HBRUSH hBrushOld = SelectObject(dc->hBitmapDC, hBrush);
+    HPEN hPen = CreatePen(PS_NULL, 0, 0);
+    HPEN hPenOld = SelectObject(dc->hBitmapDC, hPen);
+    RoundRect(dc->hBitmapDC, x1, y1, x2 + 1, y2 + 1, corner_radius * 2, corner_radius * 2);
+    SelectObject(dc->hBitmapDC, hPenOld);
+    SelectObject(dc->hBitmapDC, hBrushOld);
+    DeleteObject(hPen);
+    DeleteObject(hBrush);
+  }
+  else
+  {
+    HPEN hPen = iDrawCreatePen(color, style, line_width);
+    HPEN hPenOld = SelectObject(dc->hBitmapDC, hPen);
+    HBRUSH hBrush = (HBRUSH)GetStockObject(NULL_BRUSH);
+    HBRUSH hBrushOld = SelectObject(dc->hBitmapDC, hBrush);
+    RoundRect(dc->hBitmapDC, x1, y1, x2 + 1, y2 + 1, corner_radius * 2, corner_radius * 2);
+    SelectObject(dc->hBitmapDC, hBrushOld);
+    SelectObject(dc->hBitmapDC, hPenOld);
+    DeleteObject(hPen);
+  }
+}
+
+IUP_SDK_API void iupdrvDrawBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width)
+{
+  if (dc->wdl_gc)
+  {
+    iupdrvDrawBezierWDL(dc->wdl_gc, x1, y1, x2, y2, x3, y3, x4, y4, color, style, line_width);
+    return;
+  }
+
+  /* GDI fallback using PolyBezier */
+  if (style == IUP_DRAW_FILL)
+  {
+    /* GDI PolyBezier doesn't support fill - use polygon approximation for filled Bezier */
+    POINT points[21]; /* 20 segments should give smooth curve */
+    int i, num_segments = 20;
+    HBRUSH hBrush = CreateSolidBrush(RGB(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+    HBRUSH hBrushOld = SelectObject(dc->hBitmapDC, hBrush);
+    HPEN hPen = CreatePen(PS_NULL, 0, 0);
+    HPEN hPenOld = SelectObject(dc->hBitmapDC, hPen);
+
+    /* Generate points along Bezier curve using parametric equation */
+    for (i = 0; i <= num_segments; i++)
+    {
+      double t = (double)i / num_segments;
+      double t1 = 1.0 - t;
+      double t1_3 = t1 * t1 * t1;
+      double t1_2_t = 3.0 * t1 * t1 * t;
+      double t1_t_2 = 3.0 * t1 * t * t;
+      double t_3 = t * t * t;
+
+      points[i].x = (LONG)(t1_3 * x1 + t1_2_t * x2 + t1_t_2 * x3 + t_3 * x4);
+      points[i].y = (LONG)(t1_3 * y1 + t1_2_t * y2 + t1_t_2 * y3 + t_3 * y4);
+    }
+
+    Polygon(dc->hBitmapDC, points, num_segments + 1);
+    SelectObject(dc->hBitmapDC, hPenOld);
+    SelectObject(dc->hBitmapDC, hBrushOld);
+    DeleteObject(hPen);
+    DeleteObject(hBrush);
+  }
+  else
+  {
+    /* Use native GDI PolyBezier for stroke */
+    POINT points[4];
+    HPEN hPen = iDrawCreatePen(color, style, line_width);
+    HPEN hPenOld = SelectObject(dc->hBitmapDC, hPen);
+
+    points[0].x = x1;
+    points[0].y = y1;
+    points[1].x = x2;
+    points[1].y = y2;
+    points[2].x = x3;
+    points[2].y = y3;
+    points[3].x = x4;
+    points[3].y = y4;
+
+    PolyBezier(dc->hBitmapDC, points, 4);
+
+    SelectObject(dc->hBitmapDC, hPenOld);
+    DeleteObject(hPen);
+  }
+}
+
+IUP_SDK_API void iupdrvDrawQuadraticBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width)
+{
+  /* Convert quadratic Bezier to cubic Bezier using the 2/3 formula:
+   * Given quadratic: Q(t) with control points q0, q1, q2
+   * Convert to cubic: C(t) with control points c0, c1, c2, c3
+   *
+   * c0 = q0                        (start point)
+   * c1 = q0 + (2/3) * (q1 - q0)   (first control point)
+   * c2 = q2 + (2/3) * (q1 - q2)   (second control point)
+   * c3 = q2                        (end point)
+   */
+  int cx1, cy1, cx2, cy2;
+
+  /* Calculate cubic control points from quadratic */
+  cx1 = x1 + ((2 * (x2 - x1)) / 3);
+  cy1 = y1 + ((2 * (y2 - y1)) / 3);
+  cx2 = x3 + ((2 * (x2 - x3)) / 3);
+  cy2 = y3 + ((2 * (y2 - y3)) / 3);
+
+  /* Draw as cubic Bezier */
+  iupdrvDrawBezier(dc, x1, y1, cx1, cy1, cx2, cy2, x3, y3, color, style, line_width);
+}
+
 IUP_SDK_API void iupdrvDrawGetClipRect(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2)
 {
   if (dc->wdl_gc)
@@ -649,6 +856,42 @@
   dc->clip_y2 = y2;
 }
 
+IUP_SDK_API void iupdrvDrawSetClipRoundedRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius)
+{
+  HRGN clip_hrgn;
+
+  if (dc->wdl_gc)
+  {
+    iupdrvDrawSetClipRoundedRectWDL(dc->wdl_gc, x1, y1, x2, y2, corner_radius);
+    return;
+  }
+
+  if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
+  {
+    iupdrvDrawResetClip(dc);
+    return;
+  }
+
+  /* make it an empty region */
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Clamp radius to prevent oversized corners */
+  int max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2 : (y2 - y1) / 2;
+  if (corner_radius > max_radius)
+    corner_radius = max_radius;
+
+  /* Create rounded rectangle region for clipping */
+  clip_hrgn = CreateRoundRectRgn(x1, y1, x2 + 1, y2 + 1, corner_radius * 2, corner_radius * 2);
+  SelectClipRgn(dc->hBitmapDC, clip_hrgn);
+  DeleteObject(clip_hrgn);
+
+  dc->clip_x1 = x1;
+  dc->clip_y1 = y1;
+  dc->clip_x2 = x2;
+  dc->clip_y2 = y2;
+}
+
 static void gdiRotateWorld(HDC hDC, int xc, int yc, double angle)
 {
   XFORM xForm;
@@ -812,3 +1055,117 @@
 
   DrawFocusRect(dc->hBitmapDC, &rect);
 }
+
+static long gdiInterpolateColor(long color1, long color2, float t)
+{
+  unsigned char r1 = iupDrawRed(color1), g1 = iupDrawGreen(color1), b1 = iupDrawBlue(color1), a1 = iupDrawAlpha(color1);
+  unsigned char r2 = iupDrawRed(color2), g2 = iupDrawGreen(color2), b2 = iupDrawBlue(color2), a2 = iupDrawAlpha(color2);
+  unsigned char r = (unsigned char)(r1 + t * (r2 - r1));
+  unsigned char g = (unsigned char)(g1 + t * (g2 - g1));
+  unsigned char b = (unsigned char)(b1 + t * (b2 - b1));
+  unsigned char a = (unsigned char)(a1 + t * (a2 - a1));
+  return iupDrawColor(r, g, b, a);
+}
+
+IUP_SDK_API void iupdrvDrawLinearGradient(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2)
+{
+  if (dc->wdl_gc)
+  {
+    iupdrvDrawLinearGradientWDL(dc->wdl_gc, x1, y1, x2, y2, angle, color1, color2);
+    return;
+  }
+
+  /* GDI fallback - draw as series of filled rectangles */
+  {
+    int i, steps;
+    float t, dx, dy, length;
+    int px1, py1, px2, py2;
+    HBRUSH hBrush;
+    RECT rect;
+
+    iupDrawCheckSwapCoord(x1, x2);
+    iupDrawCheckSwapCoord(y1, y2);
+
+    /* Calculate gradient direction */
+    float rad = angle * 3.14159265359f / 180.0f;
+    dx = (float)cos(rad);
+    dy = (float)sin(rad);
+
+    /* Number of steps for smooth gradient */
+    length = (float)sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
+    steps = (int)length;
+    if (steps < 2) steps = 2;
+    if (steps > 256) steps = 256;
+
+    /* Draw gradient strips */
+    for (i = 0; i < steps; i++)
+    {
+      t = (float)i / (float)(steps - 1);
+      long color = gdiInterpolateColor(color1, color2, t);
+      hBrush = CreateSolidBrush(RGB(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+
+      /* Calculate strip position */
+      if (fabs(dx) > fabs(dy))  /* More horizontal */
+      {
+        px1 = x1 + (int)(t * (x2 - x1));
+        px2 = x1 + (int)((t + 1.0f / steps) * (x2 - x1));
+        py1 = y1;
+        py2 = y2;
+      }
+      else  /* More vertical */
+      {
+        px1 = x1;
+        px2 = x2;
+        py1 = y1 + (int)(t * (y2 - y1));
+        py2 = y1 + (int)((t + 1.0f / steps) * (y2 - y1));
+      }
+
+      rect.left = px1;
+      rect.top = py1;
+      rect.right = px2 + 1;
+      rect.bottom = py2 + 1;
+      FillRect(dc->hBitmapDC, &rect, hBrush);
+      DeleteObject(hBrush);
+    }
+  }
+}
+
+IUP_SDK_API void iupdrvDrawRadialGradient(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge)
+{
+  if (dc->wdl_gc)
+  {
+    iupdrvDrawRadialGradientWDL(dc->wdl_gc, cx, cy, radius, colorCenter, colorEdge);
+    return;
+  }
+
+  /* GDI fallback - draw as series of concentric circles */
+  {
+    int i, steps;
+    float t, r;
+    HBRUSH hBrush;
+    HPEN hPen;
+
+    /* Number of steps for smooth gradient */
+    steps = radius;
+    if (steps < 2) steps = 2;
+    if (steps > 256) steps = 256;
+
+    /* Draw from outside to inside */
+    for (i = steps - 1; i >= 0; i--)
+    {
+      t = (float)i / (float)(steps - 1);
+      long color = gdiInterpolateColor(colorCenter, colorEdge, t);
+      r = (float)radius * t;
+
+      hBrush = CreateSolidBrush(RGB(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+      hPen = CreatePen(PS_SOLID, 1, RGB(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
+      SelectObject(dc->hBitmapDC, hBrush);
+      SelectObject(dc->hBitmapDC, hPen);
+
+      Ellipse(dc->hBitmapDC, (int)(cx - r), (int)(cy - r), (int)(cx + r + 1), (int)(cy + r + 1));
+
+      DeleteObject(hBrush);
+      DeleteObject(hPen);
+    }
+  }
+}
Index: src/win/iupwin_draw_wdl.c
===================================================================
--- src/win/iupwin_draw_wdl.c	(revision 5971)
+++ src/win/iupwin_draw_wdl.c	(working copy)
@@ -41,6 +41,8 @@
   HDC hDC;
 
   int clip_x1, clip_y1, clip_x2, clip_y2;
+
+  int backend_type;  /* WD_BACKEND_D2D or WD_BACKEND_GDIPLUS */
 };
 
 /* must be the same in wdInitialize and wdTerminate */
@@ -65,6 +67,7 @@
 int iupwinDrawFinishWDL(void)
 {
   int ret = 0;
+
   if (wdBackend() == WD_BACKEND_D2D)
     ret = 1;
 
@@ -81,9 +84,16 @@
   char *rcPaint;
 
   dc->ih = ih;
+  dc->backend_type = wdBackend();  /* Cache backend type */
 
   dc->hWnd = (HWND)IupGetAttribute(ih, "HWND");  /* Use the attribute, so it can work with FileDlg preview area */
 
+  if (!dc->hWnd)
+  {
+    free(dc);
+    return NULL;
+  }
+
   GetClientRect(dc->hWnd, &rect);
   dc->w = rect.right - rect.left;
   dc->h = rect.bottom - rect.top;
@@ -90,6 +100,7 @@
 
   /* valid only inside the ACTION callback of an IupCanvas */
   rcPaint = iupAttribGetStr(ih, "CLIPRECT");
+
   if (rcPaint)
   {
     ps.hdc = (HDC)iupAttribGet(ih, "HDC_WMPAINT");
@@ -110,8 +121,22 @@
     ps.rcPaint.bottom = dc->h;
   }
 
+  if (!ps.hdc)
+  {
+    free(dc);
+    return NULL;
+  }
+
   dc->hCanvas = wdCreateCanvasWithPaintStruct(dc->hWnd, &ps, WD_CANVAS_DOUBLEBUFFER | WD_CANVAS_NOGDICOMPAT);
 
+  if (!dc->hCanvas)
+  {
+    if (dc->hDC)
+      ReleaseDC(dc->hWnd, dc->hDC);
+    free(dc);
+    return NULL;
+  }
+
   if (wdBackend() == WD_BACKEND_D2D)
     iupAttribSet(ih, "DRAWDRIVER", "D2D");
   else
@@ -163,42 +188,46 @@
   if (h) *h = dc->h;
 }
 
-static WD_HSTROKESTYLE iDrawSetLineStyle(int style)
+/* Helper macros */
+#define iupInt2Float(_x) ((float)_x)
+#define iupInt2FloatW(_x) ((float)_x)
+#define iupColor2ARGB(_c) WD_ARGB(iupDrawAlpha(_c), iupDrawRed(_c), iupDrawGreen(_c), iupDrawBlue(_c))
+
+/* Create stroke style - caller must destroy immediately after use */
+static WD_HSTROKESTYLE iCreateStrokeStyle(int style)
 {
-  if (style == IUP_DRAW_STROKE_DASH)
+  float dashes[6];
+  int dash_count;
+
+  if (style == IUP_DRAW_STROKE || style == IUP_DRAW_FILL)
+    return NULL;
+
+  switch(style)
   {
-    float dashes[2] = { 9.0f, 3.0f };
-    return wdCreateStrokeStyleCustom(dashes, 2, WD_LINECAP_FLAT, WD_LINEJOIN_MITER);
+    case IUP_DRAW_STROKE_DASH:
+      dashes[0] = 9.0f; dashes[1] = 3.0f;
+      dash_count = 2;
+      break;
+    case IUP_DRAW_STROKE_DOT:
+      dashes[0] = 1.0f; dashes[1] = 2.0f;
+      dash_count = 2;
+      break;
+    case IUP_DRAW_STROKE_DASH_DOT:
+      dashes[0] = 7.0f; dashes[1] = 3.0f; dashes[2] = 1.0f; dashes[3] = 3.0f;
+      dash_count = 4;
+      break;
+    case IUP_DRAW_STROKE_DASH_DOT_DOT:
+      dashes[0] = 7.0f; dashes[1] = 3.0f; dashes[2] = 1.0f;
+      dashes[3] = 3.0f; dashes[4] = 1.0f; dashes[5] = 3.0f;
+      dash_count = 6;
+      break;
+    default:
+      return NULL;
   }
-  else if (style == IUP_DRAW_STROKE_DOT)
-  {
-    float dashes[2] = { 1.0f, 2.0f };
-    return wdCreateStrokeStyleCustom(dashes, 2, WD_LINECAP_FLAT, WD_LINEJOIN_MITER);
-  }
-  else if (style == IUP_DRAW_STROKE_DASH_DOT)
-  {
-    float dashes[4] = { 7.0f, 3.0f, 1.0f, 3.0f };
-    return wdCreateStrokeStyleCustom(dashes, 4, WD_LINECAP_FLAT, WD_LINEJOIN_MITER);
-  }
-  else if (style == IUP_DRAW_STROKE_DASH_DOT_DOT)
-  {
-    float dashes[6] = { 7.0f, 3.0f, 1.0f, 3.0f, 1.0f, 3.0f };
-    return wdCreateStrokeStyleCustom(dashes, 6, WD_LINECAP_FLAT, WD_LINEJOIN_MITER);
-  }
-  else
-    return NULL;
-}
 
-static void iDrawRelaseStyle(WD_HSTROKESTYLE stroke_style)
-{
-  if (stroke_style)
-    wdDestroyStrokeStyle(stroke_style);
+  return wdCreateStrokeStyleCustom(dashes, dash_count, WD_LINECAP_FLAT, WD_LINEJOIN_MITER);
 }
 
-#define iupInt2Float(_x) ((float)_x)
-#define iupInt2FloatW(_x) ((float)_x)
-#define iupColor2ARGB(_c) WD_ARGB(iupDrawAlpha(_c), iupDrawRed(_c), iupDrawGreen(_c), iupDrawBlue(_c))
-
 void iupdrvDrawRectangleWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
 {
   WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
@@ -210,9 +239,10 @@
     wdFillRect(dc->hCanvas, brush, iupInt2Float(x1 - 0.5f), iupInt2Float(y1 - 0.5f), iupInt2Float(x2 + 0.5f), iupInt2Float(y2 + 0.5f));
   else
   {
-    WD_HSTROKESTYLE stroke_style = iDrawSetLineStyle(style);
+    WD_HSTROKESTYLE stroke_style = iCreateStrokeStyle(style);
     wdDrawRectStyled(dc->hCanvas, brush, iupInt2Float(x1), iupInt2Float(y1), iupInt2Float(x2), iupInt2Float(y2), iupInt2FloatW(line_width), stroke_style);
-    iDrawRelaseStyle(stroke_style);
+    if (stroke_style)
+      wdDestroyStrokeStyle(stroke_style);
   }
 
   wdDestroyBrush(brush);
@@ -220,12 +250,10 @@
 
 void iupdrvDrawLineWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
 {
-  WD_HBRUSH brush;
-  WD_HSTROKESTYLE stroke_style;
+  WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
+  WD_HSTROKESTYLE stroke_style = iCreateStrokeStyle(style);
 
-  brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
-  stroke_style = iDrawSetLineStyle(style);
-  if (wdBackend() == WD_BACKEND_D2D && line_width == 1)
+  if (dc->backend_type == WD_BACKEND_D2D && line_width == 1)
   {
     /* compensate Direct2D horizontal and vertical lines when line_width == 1 */
     if (x1 == x2)
@@ -237,7 +265,9 @@
   }
   else
     wdDrawLineStyled(dc->hCanvas, brush, iupInt2Float(x1), iupInt2Float(y1), iupInt2Float(x2), iupInt2Float(y2), iupInt2FloatW(line_width), stroke_style);
-  iDrawRelaseStyle(stroke_style);
+
+  if (stroke_style)
+    wdDestroyStrokeStyle(stroke_style);
   wdDestroyBrush(brush);
 }
 
@@ -245,11 +275,8 @@
 {
   float xc, yc, rx, ry;
   float baseAngle, sweepAngle;
-  WD_HBRUSH brush;
+  WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
 
-  brush = wdCreateSolidBrush(dc->hCanvas, 0);
-  wdSetSolidBrushColor(brush, iupColor2ARGB(color));
-
   iupDrawCheckSwapCoord(x1, x2);
   iupDrawCheckSwapCoord(y1, y2);
 
@@ -271,43 +298,169 @@
   }
   else
   {
-    WD_HSTROKESTYLE stroke_style = iDrawSetLineStyle(style);
+    WD_HSTROKESTYLE stroke_style = iCreateStrokeStyle(style);
     if (sweepAngle == 360.0f)
       wdDrawEllipseStyled(dc->hCanvas, brush, xc, yc, rx, ry, iupInt2FloatW(line_width), stroke_style);
     else
       wdDrawEllipseArcStyled(dc->hCanvas, brush, xc, yc, rx, ry, baseAngle, sweepAngle, iupInt2FloatW(line_width), stroke_style);
-    iDrawRelaseStyle(stroke_style);
+    if (stroke_style)
+      wdDestroyStrokeStyle(stroke_style);
   }
 
   wdDestroyBrush(brush);
 }
 
+void iupdrvDrawEllipseWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
+{
+  float xc, yc, rx, ry;
+  WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  rx = (x2 - x1) / 2.0f;
+  ry = (y2 - y1) / 2.0f;
+
+  xc = iupInt2Float(x1) + rx;
+  yc = iupInt2Float(y1) + ry;
+
+  if (style == IUP_DRAW_FILL)
+  {
+    wdFillEllipse(dc->hCanvas, brush, xc, yc, rx, ry);
+  }
+  else
+  {
+    WD_HSTROKESTYLE stroke_style = iCreateStrokeStyle(style);
+    wdDrawEllipseStyled(dc->hCanvas, brush, xc, yc, rx, ry, iupInt2FloatW(line_width), stroke_style);
+    if (stroke_style)
+      wdDestroyStrokeStyle(stroke_style);
+  }
+
+  wdDestroyBrush(brush);
+}
+
 void iupdrvDrawPolygonWDL(IdrawCanvas* dc, int* points, int count, long color, int style, int line_width)
 {
-  WD_HBRUSH brush;
+  WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
   WD_HPATH path;
   WD_PATHSINK sink;
   int i;
 
-  brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
-
   path = wdCreatePath(dc->hCanvas);
   wdOpenPathSink(&sink, path);
+
+  /* Begin at first point */
   wdBeginFigure(&sink, iupInt2Float(points[0]), iupInt2Float(points[1]));
 
+  /* Add lines to all other points (starting from point 1, which is at index 2 in the array) */
   for (i = 2; i < count * 2; i = i + 2)
     wdAddLine(&sink, iupInt2Float(points[i]), iupInt2Float(points[i + 1]));
 
+  /* Close the figure - this connects the last point back to the first */
+  wdEndFigure(&sink, TRUE);
+  wdClosePathSink(&sink);
+
+  if (style == IUP_DRAW_FILL)
+    wdFillPath(dc->hCanvas, brush, path);
+  else
+  {
+    WD_HSTROKESTYLE stroke_style = iCreateStrokeStyle(style);
+    wdDrawPathStyled(dc->hCanvas, brush, path, iupInt2FloatW(line_width), stroke_style);
+    if (stroke_style)
+      wdDestroyStrokeStyle(stroke_style);
+  }
+
+  wdDestroyPath(path);
+  wdDestroyBrush(brush);
+}
+
+void iupdrvDrawPixelWDL(IdrawCanvas* dc, int x, int y, long color)
+{
+  WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
+  wdFillRect(dc->hCanvas, brush, iupInt2Float(x), iupInt2Float(y), iupInt2Float(x + 1), iupInt2Float(y + 1));
+  wdDestroyBrush(brush);
+}
+
+void iupdrvDrawRoundedRectangleWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width)
+{
+  WD_HBRUSH brush;
+  int width, height;
+  float x0, y0, x1f, y1f, max_radius, radius;
+
+  brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
+
+  if (!brush)
+    return;
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  width = x2 - x1;
+  height = y2 - y1;
+
+  x0 = iupInt2Float(x1);
+  y0 = iupInt2Float(y1);
+  x1f = iupInt2Float(x2);
+  y1f = iupInt2Float(y2);
+
+  /* Calculate radius - clamp to half of smaller dimension */
+  max_radius = (width < height) ? (float)width / 2.0f : (float)height / 2.0f;
+  radius = (float)corner_radius;
+  if (radius > max_radius)
+    radius = max_radius;
+
+  /* Use native Direct2D rounded rectangle (optimized, no path allocation) */
+  if (style == IUP_DRAW_FILL)
+  {
+    wdFillRoundedRect(dc->hCanvas, brush, x0, y0, x1f, y1f, radius);
+  }
+  else
+  {
+    WD_HSTROKESTYLE stroke_style = iCreateStrokeStyle(style);
+    wdDrawRoundedRectStyled(dc->hCanvas, brush, x0, y0, x1f, y1f, radius, iupInt2FloatW(line_width), stroke_style);
+    if (stroke_style)
+      wdDestroyStrokeStyle(stroke_style);
+  }
+
+  wdDestroyBrush(brush);
+}
+
+void iupdrvDrawBezierWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width)
+{
+  WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
+  WD_HPATH path;
+  WD_PATHSINK sink;
+
+  if (!brush)
+    return;
+
+  /* Create path for Bezier curve */
+  path = wdCreatePath(dc->hCanvas);
+  wdOpenPathSink(&sink, path);
+
+  /* Start at first point */
+  wdBeginFigure(&sink, iupInt2Float(x1), iupInt2Float(y1));
+
+  /* Add cubic Bezier curve using native Direct2D/GDI+ */
+  wdAddBezier(&sink, iupInt2Float(x2), iupInt2Float(y2),
+              iupInt2Float(x3), iupInt2Float(y3),
+              iupInt2Float(x4), iupInt2Float(y4));
+
+  /* End figure without closing (open curve) */
   wdEndFigure(&sink, FALSE);
   wdClosePathSink(&sink);
 
+  /* Draw or fill the path */
   if (style == IUP_DRAW_FILL)
+  {
     wdFillPath(dc->hCanvas, brush, path);
+  }
   else
   {
-    WD_HSTROKESTYLE stroke_style = iDrawSetLineStyle(style);
+    WD_HSTROKESTYLE stroke_style = iCreateStrokeStyle(style);
     wdDrawPathStyled(dc->hCanvas, brush, path, iupInt2FloatW(line_width), stroke_style);
-    iDrawRelaseStyle(stroke_style);
+    if (stroke_style)
+      wdDestroyStrokeStyle(stroke_style);
   }
 
   wdDestroyPath(path);
@@ -314,6 +467,39 @@
   wdDestroyBrush(brush);
 }
 
+void iupdrvDrawQuadraticBezierWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width)
+{
+  /* Convert quadratic Bezier to cubic Bezier using the 2/3 formula:
+   * Given quadratic: Q(t) with control points q0, q1, q2
+   * Convert to cubic: C(t) with control points c0, c1, c2, c3
+   *
+   * c0 = q0                        (start point)
+   * c1 = q0 + (2/3) * (q1 - q0)   (first control point)
+   * c2 = q2 + (2/3) * (q1 - q2)   (second control point)
+   * c3 = q2                        (end point)
+   */
+  int cx1, cy1, cx2, cy2;
+
+  /* Calculate cubic control points from quadratic */
+  cx1 = x1 + ((2 * (x2 - x1)) / 3);
+  cy1 = y1 + ((2 * (y2 - y1)) / 3);
+  cx2 = x3 + ((2 * (x2 - x3)) / 3);
+  cy2 = y3 + ((2 * (y2 - y3)) / 3);
+
+  /* Draw as cubic Bezier */
+  iupdrvDrawBezierWDL(dc, x1, y1, cx1, cy1, cx2, cy2, x3, y3, color, style, line_width);
+}
+
+void iupdrvDrawResetClipWDL(IdrawCanvas* dc)
+{
+  wdSetClip(dc->hCanvas, NULL, NULL);
+
+  dc->clip_x1 = 0;
+  dc->clip_y1 = 0;
+  dc->clip_x2 = 0;
+  dc->clip_y2 = 0;
+}
+
 void iupdrvDrawGetClipRectWDL(IdrawCanvas* dc, int *x1, int *y1, int *x2, int *y2)
 {
   if (x1) *x1 = dc->clip_x1;
@@ -328,7 +514,7 @@
 
   if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
   {
-    iupdrvDrawResetClip(dc);
+    iupdrvDrawResetClipWDL(dc);
     return;
   }
 
@@ -359,14 +545,49 @@
   dc->clip_y2 = y2;
 }
 
-void iupdrvDrawResetClipWDL(IdrawCanvas* dc)
+void iupdrvDrawSetClipRoundedRectWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius)
 {
-  wdSetClip(dc->hCanvas, NULL, NULL);
+  WD_RECT rect;
+  WD_HPATH path;
+  int width, height;
+  float max_radius, radius;
 
-  dc->clip_x1 = 0;
-  dc->clip_y1 = 0;
-  dc->clip_x2 = 0;
-  dc->clip_y2 = 0;
+  if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
+  {
+    iupdrvDrawResetClipWDL(dc);
+    return;
+  }
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  width = x2 - x1;
+  height = y2 - y1;
+
+  /* Calculate radius - clamp to half of smaller dimension */
+  max_radius = (width < height) ? (float)width / 2.0f : (float)height / 2.0f;
+  radius = (float)corner_radius;
+  if (radius > max_radius)
+    radius = max_radius;
+
+  /* Set up rectangle for path */
+  rect.x0 = iupInt2Float(x1);
+  rect.y0 = iupInt2Float(y1);
+  rect.x1 = iupInt2Float(x2);
+  rect.y1 = iupInt2Float(y2);
+
+  /* Create rounded rectangle path and set as clip */
+  path = wdCreateRoundedRectPath(dc->hCanvas, &rect, radius);
+  if (path)
+  {
+    wdSetClip(dc->hCanvas, NULL, path);
+    wdDestroyPath(path);
+  }
+
+  dc->clip_x1 = x1;
+  dc->clip_y1 = y1;
+  dc->clip_x2 = x2;
+  dc->clip_y2 = y2;
 }
 
 static int iCompensatePosX(float font_height)
@@ -408,7 +629,7 @@
       dwFlags |= WD_STR_ENDELLIPSIS;
   }
 
-  if (wdBackend() == WD_BACKEND_GDIPLUS)
+  if (dc->backend_type == WD_BACKEND_GDIPLUS)
   {
     /* compensate GDI+ internal padding */
     WD_FONTMETRICS metrics;
@@ -432,12 +653,12 @@
 
   wdDrawString(dc->hCanvas, wdFont, &rect, wtext, len, brush, dwFlags);
 
-  wdDestroyBrush(brush);
-  wdDestroyFont(wdFont);
-
   /* restore settings */
   if (text_orientation)
     wdResetWorld(dc->hCanvas);
+
+  wdDestroyFont(wdFont);
+  wdDestroyBrush(brush);
 }
 
 void iupdrvDrawImageWDL(IdrawCanvas* dc, const char* name, int make_inactive, const char* bgcolor, int x, int y, int w, int h)
@@ -464,13 +685,13 @@
 
 void iupdrvDrawSelectRectWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2)
 {
-  WD_HBRUSH brush;
+  WD_HBRUSH brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(iupDrawColor(0, 0, 255, 153)));  /* R=0, G=0, B=255, A=153 (blue semi-transparent) */
 
   iupDrawCheckSwapCoord(x1, x2);
   iupDrawCheckSwapCoord(y1, y2);
 
-  brush = wdCreateSolidBrush(dc->hCanvas, WD_ARGB(153, 0, 0, 255));  /* R=0, G=0, B=255, A=153 (blue semi-transparent) */
   wdFillRect(dc->hCanvas, brush, iupInt2Float(x1 - 0.5f), iupInt2Float(y1 - 0.5f), iupInt2Float(x2 + 0.5f), iupInt2Float(y2 + 0.5f));
+
   wdDestroyBrush(brush);
 }
 
@@ -492,6 +713,132 @@
   DrawFocusRect(hDC, &rect);
   wdEndGdi(dc->hCanvas, hDC);
 #else
-  iupdrvDrawRectangle(dc, x1, y1, x2, y2, iupDrawColor(0, 0, 0, 224), IUP_DRAW_STROKE_DOT, 1);
+  iupdrvDrawRectangleWDL(dc, x1, y1, x2, y2, iupDrawColor(0, 0, 0, 224), IUP_DRAW_STROKE_DOT, 1);
 #endif
 }
+
+static long iWdlInterpolateColor(long color1, long color2, float t)
+{
+  unsigned char r1 = iupDrawRed(color1), g1 = iupDrawGreen(color1), b1 = iupDrawBlue(color1), a1 = iupDrawAlpha(color1);
+  unsigned char r2 = iupDrawRed(color2), g2 = iupDrawGreen(color2), b2 = iupDrawBlue(color2), a2 = iupDrawAlpha(color2);
+  unsigned char r = (unsigned char)(r1 + t * (r2 - r1));
+  unsigned char g = (unsigned char)(g1 + t * (g2 - g1));
+  unsigned char b = (unsigned char)(b1 + t * (b2 - b1));
+  unsigned char a = (unsigned char)(a1 + t * (a2 - a1));
+  return iupDrawColor(r, g, b, a);
+}
+
+void iupdrvDrawLinearGradientWDL(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2)
+{
+  WD_HBRUSH brush;
+  float rad, dx, dy, cx, cy, w, h;
+  float x0, y0, x3, y3;
+
+  iupDrawCheckSwapCoord(x1, x2);
+  iupDrawCheckSwapCoord(y1, y2);
+
+  /* Calculate gradient direction based on angle */
+  /* 0 = left to right, 90 = top to bottom, 180 = right to left, 270 = bottom to top */
+  rad = angle * 3.14159265359f / 180.0f;
+  dx = (float)cos(rad);
+  dy = (float)sin(rad);
+
+  /* Calculate gradient start and end points */
+  w = (float)(x2 - x1);
+  h = (float)(y2 - y1);
+  cx = (float)x1 + w / 2.0f;
+  cy = (float)y1 + h / 2.0f;
+
+  /* Calculate start point */
+  x0 = cx - (w * dx) / 2.0f;
+  y0 = cy - (h * dy) / 2.0f;
+
+  /* Calculate end point */
+  x3 = cx + (w * dx) / 2.0f;
+  y3 = cy + (h * dy) / 2.0f;
+
+  /* Try to create native gradient brush (only works with Direct2D backend) */
+  brush = wdCreateLinearGradientBrush(dc->hCanvas, x0, y0, x3, y3, iupColor2ARGB(color1), iupColor2ARGB(color2));
+  if (brush)
+  {
+    /* Native gradient - single fill operation */
+    wdFillRect(dc->hCanvas, brush, iupInt2Float(x1), iupInt2Float(y1), iupInt2Float(x2), iupInt2Float(y2));
+    wdDestroyBrush(brush);
+  }
+  else
+  {
+    /* Fallback for GDI+ backend - manual color interpolation */
+    int i, steps;
+    float t, length;
+    int px1, py1, px2, py2;
+
+    length = (float)sqrt(w * w + h * h);
+    steps = (int)length;
+    if (steps < 2) steps = 2;
+    if (steps > 256) steps = 256;
+
+    for (i = 0; i < steps; i++)
+    {
+      t = (float)i / (float)(steps - 1);
+      long color = iWdlInterpolateColor(color1, color2, t);
+      brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
+
+      if (fabs(dx) > fabs(dy))
+      {
+        px1 = x1 + (int)(t * w);
+        px2 = x1 + (int)((t + 1.0f / steps) * w);
+        py1 = y1;
+        py2 = y2;
+      }
+      else
+      {
+        px1 = x1;
+        px2 = x2;
+        py1 = y1 + (int)(t * h);
+        py2 = y1 + (int)((t + 1.0f / steps) * h);
+      }
+
+      wdFillRect(dc->hCanvas, brush, iupInt2Float(px1), iupInt2Float(py1), iupInt2Float(px2), iupInt2Float(py2));
+      wdDestroyBrush(brush);
+    }
+  }
+}
+
+void iupdrvDrawRadialGradientWDL(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge)
+{
+  WD_HBRUSH brush;
+
+  /* Try to create native gradient brush (only works with Direct2D backend) */
+  brush = wdCreateRadialGradientBrush(dc->hCanvas, iupInt2Float(cx), iupInt2Float(cy),
+                                       iupInt2Float(radius), iupInt2Float(radius),
+                                       iupColor2ARGB(colorCenter), iupColor2ARGB(colorEdge));
+  if (brush)
+  {
+    /* Native gradient - single fill operation */
+    wdFillEllipse(dc->hCanvas, brush, iupInt2Float(cx), iupInt2Float(cy),
+                   iupInt2Float(radius), iupInt2Float(radius));
+    wdDestroyBrush(brush);
+  }
+  else
+  {
+    /* Fallback for GDI+ backend - manual color interpolation */
+    int i, steps;
+    float t, r;
+
+    steps = radius;
+    if (steps < 2) steps = 2;
+    if (steps > 256) steps = 256;
+
+    /* Draw concentric circles from outside to inside */
+    for (i = steps - 1; i >= 0; i--)
+    {
+      t = (float)i / (float)(steps - 1);
+      long color = iWdlInterpolateColor(colorCenter, colorEdge, t);
+      brush = wdCreateSolidBrush(dc->hCanvas, iupColor2ARGB(color));
+
+      r = (float)radius * t;
+      wdFillEllipse(dc->hCanvas, brush, iupInt2Float(cx), iupInt2Float(cy), r, r);
+      wdDestroyBrush(brush);
+    }
+  }
+}
Index: src/win/iupwin_drv.h
===================================================================
--- src/win/iupwin_drv.h	(revision 5971)
+++ src/win/iupwin_drv.h	(working copy)
@@ -25,6 +25,7 @@
 /* open */
 IUP_DRV_API void iupwinShowLastError(void);
 IUP_DRV_API void iupwinSetInstance(HINSTANCE hInstance);
+void iupwinSetGlobalColors(void);
 
 /* focus */
 void iupwinWmSetFocus(Ihandle *ih);
@@ -132,6 +133,8 @@
 void iupwinMergeStyle(Ihandle* ih, DWORD old_mask, DWORD value);
 void iupwinSetStyle(Ihandle* ih, DWORD value, int set);
 
+void iupwinTitleBarThemeColor(HWND hwnd);
+
 int iupwinClassExist(const TCHAR* name);
 
 
Index: src/win/iupwin_filedlg.c
===================================================================
--- src/win/iupwin_filedlg.c	(revision 5971)
+++ src/win/iupwin_filedlg.c	(working copy)
@@ -621,6 +621,110 @@
   return 0;
 }
 
+static HGLOBAL winFileDlgCreatePreviewTemplate(void)
+{
+  /*
+   * Creates a dialog template in memory equivalent to:
+   *
+   * iupPreviewDlg DIALOG DISCARDABLE  0, 0, 250, 95
+   * STYLE WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | DS_3DLOOK | DS_CONTROL
+   * FONT 8, "MS Shell Dlg"
+   * BEGIN
+   *   CONTROL "", IUP_PREVIEWCANVAS, "STATIC", SS_OWNERDRAW, 70, 0, 120, 90, WS_EX_STATICEDGE
+   * END
+   */
+
+  HGLOBAL hGlobal;
+  BYTE* p;
+  WORD* pw;
+  int templateSize;
+
+  /* Calculate size: DLGTEMPLATE + menu(2) + class(2) + title(2) + font size(2) + font name */
+  /* Plus DLGITEMTEMPLATE + extra data for the static control */
+  templateSize = sizeof(DLGTEMPLATE) + 2 + 2 + 2 + 2 + 24 +  /* dialog header + "MS Shell Dlg" */
+                 sizeof(DLGITEMTEMPLATE) + 2 + 14 + 2 + 2;    /* item + "STATIC" class + creation data */
+  templateSize = (templateSize + 3) & ~3;  /* DWORD align */
+
+  hGlobal = GlobalAlloc(GMEM_ZEROINIT, templateSize);
+  if (!hGlobal)
+    return NULL;
+
+  p = (BYTE*)GlobalLock(hGlobal);
+  if (!p)
+  {
+    GlobalFree(hGlobal);
+    return NULL;
+  }
+
+  /* DLGTEMPLATE structure */
+  {
+    DLGTEMPLATE* pDlg = (DLGTEMPLATE*)p;
+    pDlg->style = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | DS_3DLOOK | DS_CONTROL | DS_SETFONT;
+    pDlg->dwExtendedStyle = 0;
+    pDlg->cdit = 1;  /* one control */
+    pDlg->x = 0;
+    pDlg->y = 0;
+    pDlg->cx = 250;
+    pDlg->cy = 95;
+    p += sizeof(DLGTEMPLATE);
+  }
+
+  /* Menu array */
+  pw = (WORD*)p;
+  *pw++ = 0;
+
+  /* Class array (use default) */
+  *pw++ = 0;
+
+  /* Title array */
+  *pw++ = 0;
+
+  /* Font size */
+  *pw++ = 8;
+
+  /* Font name */
+  {
+    WCHAR fontName[] = L"MS Shell Dlg";
+    memcpy(pw, fontName, sizeof(fontName));
+    pw += sizeof(fontName) / sizeof(WORD);
+  }
+
+  /* Align to DWORD for DLGITEMTEMPLATE */
+  p = (BYTE*)pw;
+  p = (BYTE*)(((ULONG_PTR)p + 3) & ~3);
+
+  /* DLGITEMTEMPLATE for the static control */
+  {
+    DLGITEMTEMPLATE* pItem = (DLGITEMTEMPLATE*)p;
+    pItem->style = WS_CHILD | WS_VISIBLE | SS_OWNERDRAW;
+    pItem->dwExtendedStyle = WS_EX_STATICEDGE;
+    pItem->x = 70;
+    pItem->y = 0;
+    pItem->cx = 120;
+    pItem->cy = 90;
+    pItem->id = IUP_PREVIEWCANVAS;
+    p += sizeof(DLGITEMTEMPLATE);
+  }
+
+  /* Class array for control */
+  pw = (WORD*)p;
+  {
+    WCHAR className[] = L"STATIC";
+    memcpy(pw, className, sizeof(className));
+    pw += sizeof(className) / sizeof(WORD);
+  }
+
+  /* Title array for control */
+  *pw++ = 0;
+
+  /* Creation data */
+  *pw++ = 0;
+
+  GlobalUnlock(hGlobal);
+
+  return hGlobal;
+}
+
 static TCHAR* winFileDlgStrReplaceSeparator(const TCHAR* name)
 {
   int i=0, len = lstrlen(name);
@@ -665,6 +769,7 @@
   int result, dialogtype;
   char *value, *initial_dir=NULL;
   TCHAR* extfilter = NULL;
+  HGLOBAL hPreviewTemplate = NULL;
 
   iupAttribSetInt(ih, "_IUPDLG_X", x);   /* used in iupDialogUpdatePosition */
   iupAttribSetInt(ih, "_IUPDLG_Y", y);
@@ -794,10 +899,13 @@
 
   if (iupAttribGetBoolean(ih, "SHOWPREVIEW") && IupGetCallback(ih, "FILE_CB"))
   {
-    openfilename.Flags |= OFN_ENABLETEMPLATE;
-    openfilename.hInstance = iupwin_dll_hinstance? iupwin_dll_hinstance: iupwin_hinstance;
-    openfilename.lpTemplateName = TEXT("iupPreviewDlg");
-    openfilename.lpfnHook = winFileDlgPreviewHook;
+    hPreviewTemplate = winFileDlgCreatePreviewTemplate();
+    if (hPreviewTemplate)
+    {
+      openfilename.Flags |= OFN_ENABLETEMPLATEHANDLE;
+      openfilename.hInstance = (HINSTANCE)hPreviewTemplate;
+      openfilename.lpfnHook = winFileDlgPreviewHook;
+    }
   }
 
   if (IupGetCallback(ih, "HELP_CB"))
@@ -920,6 +1028,7 @@
   if (extfilter) free(extfilter);
   if (initial_dir) free(initial_dir);
   if (openfilename.lpstrFile) free(openfilename.lpstrFile);
+  if (hPreviewTemplate) GlobalFree(hPreviewTemplate);
 
   return IUP_NOERROR;
 }
Index: src/win/iupwin_focus.c
===================================================================
--- src/win/iupwin_focus.c	(revision 5971)
+++ src/win/iupwin_focus.c	(working copy)
@@ -61,6 +61,13 @@
 void iupwinWmSetFocus(Ihandle *ih)
 {
   Ihandle* dialog = IupGetDialog(ih);
+  if (!dialog)
+  {
+    /* Element is not inside a dialog (e.g., inside a Popover).
+       Just call the focus callback without tracking last focus. */
+    iupCallGetFocusCb(ih);
+    return;
+  }
   if (ih != dialog)
     iupAttribSet(dialog, "_IUPWIN_LASTFOCUS", (char*)ih);  /* used by IupMenu and here. */
   else
Index: src/win/iupwin_globalattrib.c
===================================================================
--- src/win/iupwin_globalattrib.c	(revision 5971)
+++ src/win/iupwin_globalattrib.c	(working copy)
@@ -9,6 +9,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <stdint.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -21,6 +22,7 @@
 
 #include "iupwin_drv.h"
 #include "iupwin_str.h"
+#include "iupwin_info.h"
 
 
 /* old cygwin related hack */
@@ -54,7 +56,7 @@
     return 1;
   }
 
-  /* wasnt found, new one created therefore return FALSE */
+  /* wasn't found, new one created therefore return FALSE */
   return (win_singleintance == NULL);
 }
 
@@ -358,13 +360,13 @@
   if (iupStrEqual(name, "CLIENTAREAANIMATION"))
   {
     BOOL flag = iupStrBoolean(value);
-    SystemParametersInfoA(SPI_SETCLIENTAREAANIMATION, 0, (void*)flag, 0);
+    SystemParametersInfoA(SPI_SETCLIENTAREAANIMATION, 0, (void*)(intptr_t)flag, 0);
     return 1;
   }
   if (iupStrEqual(name, "HOTTRACKING"))
   {
     BOOL flag = iupStrBoolean(value);
-    SystemParametersInfoA(SPI_SETHOTTRACKING, 0, (void*)flag, 0);
+    SystemParametersInfoA(SPI_SETHOTTRACKING, 0, (void*)(intptr_t)flag, 0);
     return 1;
   }
   if (iupStrEqual(name, "PROCESSWINDOWSGHOSTING"))
@@ -497,6 +499,9 @@
     else
       return NULL;
   }
+  if (iupStrEqual(name, "DARKMODE"))
+  {
+    return iupStrReturnBoolean(iupwinIsSystemDarkMode());
+  }
   return NULL;
 }
-
Index: src/win/iupwin_image.c
===================================================================
--- src/win/iupwin_image.c	(revision 5971)
+++ src/win/iupwin_image.c	(working copy)
@@ -538,7 +538,7 @@
     }
 
     hDC = GetDC(NULL);
-    hBitmap = CreateDIBSection(hDC, (BITMAPINFO*)bmih, DIB_RGB_COLORS, &bits, NULL, 0x0);
+    hBitmap = CreateDIBSection(hDC, (BITMAPINFO*)bmih, DIB_RGB_COLORS, (void **)&bits, NULL, 0x0);
     ReleaseDC(NULL, hDC);
     free(bmih);
   }
Index: src/win/iupwin_info.c
===================================================================
--- src/win/iupwin_info.c	(revision 5971)
+++ src/win/iupwin_info.c	(working copy)
@@ -16,10 +16,8 @@
 #include "iup_drv.h"
 
 #include "iupwin_info.h"
-#include "iupwin_str.h"
 
 #include <windows.h>
-#include <ShlObj.h> /* for SHGetFolderPath */
 
 
 #ifdef _MSC_VER
@@ -306,6 +304,43 @@
     return 0;
 }
 
+int iupwinIsSystemDarkMode(void)
+{
+  typedef HRESULT(STDAPICALLTYPE *PtrDwmGetWindowAttribute)(HWND, DWORD, PVOID, DWORD);
+  static PtrDwmGetWindowAttribute dwmGetWindowAttribute = NULL;
+  static int initialized = 0;
+  static int dark_mode = 0;
+
+  if (!iupwinIsWin10OrNew())
+    return 0;
+
+  if (!initialized)
+  {
+    HMODULE dwmLibrary = LoadLibrary(TEXT("dwmapi.dll"));
+    if (dwmLibrary)
+      dwmGetWindowAttribute = (PtrDwmGetWindowAttribute)GetProcAddress(dwmLibrary, "DwmGetWindowAttribute");
+    initialized = 1;
+  }
+
+  if (dwmGetWindowAttribute)
+  {
+    HKEY hKey;
+    DWORD value = 0;
+    DWORD size = sizeof(DWORD);
+
+    if (RegOpenKeyExA(HKEY_CURRENT_USER,
+                      "Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize",
+                      0, KEY_READ, &hKey) == ERROR_SUCCESS)
+    {
+      if (RegQueryValueExA(hKey, "AppsUseLightTheme", NULL, NULL, (LPBYTE)&value, &size) == ERROR_SUCCESS)
+        dark_mode = (value == 0) ? 1 : 0;
+      RegCloseKey(hKey);
+    }
+  }
+
+  return dark_mode;
+}
+
 IUP_SDK_API void iupdrvGetScreenSize(int *width, int *height)
 {
   RECT area;
@@ -391,120 +426,36 @@
 IUP_SDK_API char *iupdrvGetComputerName(void)
 {
   DWORD size = MAX_COMPUTERNAME_LENGTH + 1;
-  TCHAR wstr[MAX_COMPUTERNAME_LENGTH + 1];
-  GetComputerName(wstr, &size);
-  return iupwinStrFromSystem(wstr);
+  char* str = iupStrGetMemory(size);
+  GetComputerNameA((LPSTR)str, &size);
+  return str;
 }
 
-#define UNLEN 256 /* from <Lmcons.h> */
-
 IUP_SDK_API char *iupdrvGetUserName(void)
 {
-  DWORD size = UNLEN+1;
-  TCHAR wstr[UNLEN+1];
-  GetUserName(wstr, &size);
-  return iupwinStrFromSystem(wstr);
+  DWORD size = 256;
+  char* str = iupStrGetMemory(size);
+  GetUserNameA((LPSTR)str, &size);
+  return str;
 }
 
 IUP_SDK_API int iupdrvSetCurrentDirectory(const char* path)
 {
-  return SetCurrentDirectory(iupwinStrToSystemFilename(path));
+  return SetCurrentDirectoryA(path);
 }
 
 IUP_SDK_API char* iupdrvGetCurrentDirectory(void)
 {
-  TCHAR* wcur_dir = NULL;
-  char* cur_dir;
+  char* cur_dir = NULL;
 
-  int len = GetCurrentDirectory(0, NULL);
+  int len = GetCurrentDirectoryA(0, NULL);
   if (len == 0) return NULL;
 
-  wcur_dir = (TCHAR*)malloc((len + 2)*sizeof(TCHAR));
-  GetCurrentDirectory(len + 1, wcur_dir);
-  wcur_dir[len] = '\\';
-  wcur_dir[len + 1] = 0;
+  cur_dir = iupStrGetMemory(len + 2);
+  GetCurrentDirectoryA(len + 1, cur_dir);
+  cur_dir[len] = '\\';
+  cur_dir[len + 1] = 0;
 
-  cur_dir = iupwinStrFromSystemFilename(wcur_dir);
-  free(wcur_dir);
   return cur_dir;
 }
 
-/*
-Windows 7 and 10
-PreferencePath(0)=C:\Users\Tecgraf\
-PreferencePath(1)=C:\Users\Tecgraf\AppData\Roaming\
-
-Windows XP
-PreferencePath(0)=C:\Documents and Settings\Tecgraf\
-PreferencePath(1)=C:\Documents and Settings\Tecgraf\Application Data\
-*/
-
-IUP_SDK_API int iupdrvGetPreferencePath(char *filename, int use_system)
-{
-  char* homedrive;
-  char* homepath;
-
-  if (use_system)
-  {
-    TCHAR wpath[MAX_PATH];
-    if (SHGetFolderPath(NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, wpath) == S_OK)
-    {
-      strcpy(filename, iupwinStrFromSystemFilename(wpath));
-      strcat(filename, "\\");
-      return 1;
-    }
-  }
-
-  homedrive = getenv("HOMEDRIVE");
-  homepath = getenv("HOMEPATH");
-  if (homedrive && homepath)
-  {
-    strcpy(filename, homedrive);
-    strcat(filename, homepath);
-    strcat(filename, "\\");
-    return 1;
-  }
-
-  filename[0] = '\0';
-  return 0;
-
-}
-
-IUP_API void IupLogV(const char* type, const char* format, va_list arglist)
-{
-  HANDLE EventSource;
-  WORD wtype = 0;
-
-  int size;
-  char* value = iupStrGetLargeMem(&size);
-  vsnprintf(value, size, format, arglist);
-
-  if (iupStrEqualNoCase(type, "DEBUG"))
-  {
-    OutputDebugString(iupwinStrToSystem(value));
-    return;
-  }
-  else if (iupStrEqualNoCase(type, "ERROR"))
-    wtype = EVENTLOG_ERROR_TYPE;
-  else if (iupStrEqualNoCase(type, "WARNING"))
-    wtype = EVENTLOG_WARNING_TYPE;
-  else if (iupStrEqualNoCase(type, "INFO"))
-    wtype = EVENTLOG_INFORMATION_TYPE;
-
-  EventSource = RegisterEventSource(NULL, TEXT("Application"));
-  if (EventSource)
-  {
-    TCHAR* wstr[1];
-    wstr[0] = iupwinStrToSystem(value);
-    ReportEvent(EventSource, wtype, 0, 0, NULL, 1, 0, wstr, NULL);
-    DeregisterEventSource(EventSource);
-  }
-}
-
-IUP_API void IupLog(const char* type, const char* format, ...)
-{
-  va_list arglist;
-  va_start(arglist, format);
-  IupLogV(type, format, arglist);
-  va_end(arglist);
-}
Index: src/win/iupwin_info.h
===================================================================
--- src/win/iupwin_info.h	(revision 5971)
+++ src/win/iupwin_info.h	(working copy)
@@ -14,7 +14,9 @@
 /* system */
 int   iupwinGetComCtl32Version(void);
 char* iupwinGetSystemLanguage(void);
+int   iupwinCheckWindowsVersion(DWORD major, DWORD minor);
 int   iupwinIsAppThemed(void);
+int   iupwinIsSystemDarkMode(void);
 int   iupwinIsVistaOrNew(void);
 int   iupwinIsWinXPOrNew(void);
 int   iupwinIsWin7OrNew(void);
Index: src/win/iupwin_label.c
===================================================================
--- src/win/iupwin_label.c	(revision 5971)
+++ src/win/iupwin_label.c	(working copy)
@@ -153,7 +153,25 @@
 
   hDC = iupwinDrawCreateBitmapDC(&bmpDC, drawitem->hDC, 0, 0, width, height);
 
-  iupwinDrawParentBackground(ih, hDC, &drawitem->rcItem);
+  char* bgcolor = iupAttribGet(ih, "BGCOLOR");
+  if (bgcolor)
+  {
+    unsigned char r, g, b;
+    if (iupStrToRGB(bgcolor, &r, &g, &b))
+    {
+      HBRUSH hBrush = CreateSolidBrush(RGB(r, g, b));
+      FillRect(hDC, &drawitem->rcItem, hBrush);
+      DeleteObject(hBrush);
+    }
+    else
+    {
+      iupwinDrawParentBackground(ih, hDC, &drawitem->rcItem);
+    }
+  }
+  else
+  {
+    iupwinDrawParentBackground(ih, hDC, &drawitem->rcItem);
+  }
 
   if (ih->data->type == IUP_LABEL_IMAGE)
     winLabelDrawImage(ih, hDC, width, height);
@@ -252,6 +270,17 @@
   return 1;
 }
 
+static int winLabelSetBgColorAttrib(Ihandle* ih, const char* value)
+{
+  int type = iupLabelGetTypeBeforeMap(ih);
+  if (type != IUP_LABEL_SEP_HORIZ && type != IUP_LABEL_SEP_VERT)
+  {
+    if (ih->handle)
+      iupdrvRedrawNow(ih);
+  }
+  return 1;
+}
+
 static int winLabelSetFgColorAttrib(Ihandle* ih, const char* value)
 {
   /* this method can be called before map */
@@ -406,8 +435,7 @@
   /* Driver Dependent Attribute functions */
 
   /* Visual */
-  /* the most important use of this is to provide the correct background for images */
-  iupClassRegisterAttribute(ic, "BGCOLOR", iupBaseNativeParentGetBgColorAttrib, NULL, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_NO_SAVE);  
+  iupClassRegisterAttribute(ic, "BGCOLOR", iupBaseNativeParentGetBgColorAttrib, winLabelSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);  
 
   /* Special */
   iupClassRegisterAttribute(ic, "FGCOLOR", NULL, winLabelSetFgColorAttrib, "DLGFGCOLOR", NULL, IUPAF_NOT_MAPPED);    /* force new default value */
Index: src/win/iupwin_list.c
===================================================================
--- src/win/iupwin_list.c	(revision 5971)
+++ src/win/iupwin_list.c	(working copy)
@@ -117,39 +117,53 @@
 
 static void winListUpdateShowImageItemHeight(Ihandle* ih, winListItemData* itemdata, int pos)
 {
-  int txt_h, height;
+  int txt_h, height, available_height;
   iupdrvFontGetCharSize(ih, NULL, &txt_h);
 
+  available_height = txt_h + 2 * ih->data->spacing;
   height = txt_h;
 
   if (itemdata->hBitmap)
   {
     int img_w, img_h;
+    int scaled_w, scaled_h;
     iupdrvImageGetInfo(itemdata->hBitmap, &img_w, &img_h, NULL);
 
-    if (img_h > txt_h)
+    /* Calculate scaled dimensions (same logic as drawing) */
+    if (ih->data->fit_image && img_h > available_height)
     {
-      height = img_h;
+      scaled_w = (img_w * available_height) / img_h;
+      scaled_h = available_height;
+    }
+    else
+    {
+      scaled_w = img_w;
+      scaled_h = img_h;
+    }
 
-      if (ih->data->is_dropdown && 
-          !ih->data->has_editbox && 
-          img_h >= ih->data->maximg_h)
+    if (scaled_h > txt_h)
+    {
+      height = scaled_h;
+
+      if (ih->data->is_dropdown &&
+          !ih->data->has_editbox &&
+          scaled_h >= ih->data->maximg_h)
       {
         /* set also for the selection box of the dropdown */
-        SendMessage(ih->handle, WIN_SETITEMHEIGHT(ih), (WPARAM)-1, img_h);  
+        SendMessage(ih->handle, WIN_SETITEMHEIGHT(ih), (WPARAM)-1, scaled_h);
       }
     }
 
-    if (img_w > ih->data->maximg_w)
-      ih->data->maximg_w = img_w;
-    if (img_h > ih->data->maximg_h)
-      ih->data->maximg_h = img_h;
+    if (scaled_w > ih->data->maximg_w)
+      ih->data->maximg_w = scaled_w;
+    if (scaled_h > ih->data->maximg_h)
+      ih->data->maximg_h = scaled_h;
   }
 
   if (!ih->data->is_dropdown)
     height += 2*ih->data->spacing;
 
-  /* According to this documentation, the maximum height is 255 pixels. 
+  /* According to this documentation, the maximum height is 255 pixels.
      http://msdn.microsoft.com/en-us/library/ms997541.aspx */
   if (height > 255)
     height = 255;
@@ -187,6 +201,8 @@
 
 int iupdrvListGetCount(Ihandle* ih)
 {
+  if (ih->data->is_virtual)
+    return (int)SendMessage(ih->handle, LVM_GETITEMCOUNT, 0, 0);
   return (int)SendMessage(ih->handle, WIN_GETCOUNT(ih), 0, 0);
 }
 
@@ -361,10 +377,16 @@
   return iupwinStrFromSystem(str);
 }
 
+void iupdrvListSetItemCount(Ihandle* ih, int count)
+{
+  if (!ih->data->is_virtual)
+    return;
 
+  ListView_SetItemCountEx(ih->handle, count, LVSICF_NOINVALIDATEALL);
+}
+
 /*********************************************************************************/
 
-
 static void winListUpdateItemWidth(Ihandle* ih)
 {
   int i, count = (int)SendMessage(ih->handle, WIN_GETCOUNT(ih), 0, 0);
@@ -401,7 +423,14 @@
 {
   int pos = iupListGetPosAttrib(ih, id);
   if (pos >= 0)
+  {
+    if (ih->data->is_virtual)
+    {
+      char* text = iupListGetItemValueCb(ih, pos + 1);  /* 1-based */
+      return text;
+    }
     return iupStrReturnStr(winListGetText(ih, pos));
+  }
   return NULL;
 }
 
@@ -423,8 +452,15 @@
         return "";
     }
   }
-  else 
+  else if (ih->data->is_virtual)
   {
+    int pos = (int)SendMessage(ih->handle, LVM_GETNEXTITEM, (WPARAM)-1, LVNI_SELECTED);
+    if (pos >= 0)
+      return iupStrReturnInt(pos + 1);  /* IUP starts at 1 */
+    return NULL;
+  }
+  else
+  {
     if (ih->data->is_dropdown || !ih->data->is_multiple)
     {
       int pos = (int)SendMessage(ih->handle, WIN_GETCURSEL(ih), 0, 0);
@@ -441,6 +477,7 @@
       for (i=0; i<sel_count; i++)
         str[pos[i]] = '+';
       str[count]=0;
+      free(pos);
       return str;
     }
   }
@@ -450,8 +487,25 @@
 {
   if (ih->data->has_editbox)
     iupwinSetTitleAttrib(ih, value);
-  else 
+  else if (ih->data->is_virtual)
   {
+    int pos;
+    /* Clear current selection */
+    int old_pos = (int)SendMessage(ih->handle, LVM_GETNEXTITEM, (WPARAM)-1, LVNI_SELECTED);
+    if (old_pos >= 0)
+      ListView_SetItemState(ih->handle, old_pos, 0, LVIS_SELECTED | LVIS_FOCUSED);
+
+    if (iupStrToInt(value, &pos) == 1)
+    {
+      ListView_SetItemState(ih->handle, pos - 1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
+      ListView_EnsureVisible(ih->handle, pos - 1, FALSE);
+      iupAttribSetInt(ih, "_IUPLIST_OLDVALUE", pos);
+    }
+    else
+      iupAttribSet(ih, "_IUPLIST_OLDVALUE", NULL);
+  }
+  else
+  {
     if (ih->data->is_dropdown || !ih->data->is_multiple)
     {
       int pos;
@@ -482,7 +536,7 @@
 
       count = (int)SendMessage(ih->handle, LB_GETCOUNT, 0, 0L);
       len = (int)strlen(value);
-      if (len < count) 
+      if (len < count)
         count = len;
 
       /* update selection list */
@@ -512,7 +566,12 @@
   {
     int pos = 1;
     if (iupStrToInt(value, &pos))
-      SendMessage(ih->handle, WIN_SETTOPINDEX(ih), pos-1, 0);  /* IUP starts at 1 */
+    {
+      if (ih->data->is_virtual)
+        ListView_EnsureVisible(ih->handle, pos - 1, FALSE);  /* IUP starts at 1 */
+      else
+        SendMessage(ih->handle, WIN_SETTOPINDEX(ih), pos-1, 0);  /* IUP starts at 1 */
+    }
   }
   return 0;
 }
@@ -1673,11 +1732,240 @@
   return iupwinBaseMsgProc(ih, msg, wp, lp, result);
 }
 
+static int winListVirtualNotifyCallback(Ihandle* ih, void* msg_info, int *result)
+{
+  NMHDR* nmhdr = (NMHDR*)msg_info;
+
+  switch (nmhdr->code)
+  {
+    case LVN_GETDISPINFO:
+    {
+      NMLVDISPINFO* plvdi = (NMLVDISPINFO*)msg_info;
+
+      if (plvdi->item.mask & LVIF_TEXT)
+      {
+        int pos = plvdi->item.iItem + 1;  /* Convert to 1-based */
+        char* text = iupListGetItemValueCb(ih, pos);
+
+        if (text && *text)
+        {
+          TCHAR* ttext = iupwinStrToSystem(text);
+          lstrcpyn(plvdi->item.pszText, ttext, plvdi->item.cchTextMax);
+        }
+        else
+        {
+          plvdi->item.pszText[0] = 0;
+        }
+      }
+      break;
+    }
+
+    case NM_CUSTOMDRAW:
+    {
+      if (ih->data->show_image)
+      {
+        NMLVCUSTOMDRAW* pnmcd = (NMLVCUSTOMDRAW*)msg_info;
+
+        switch (pnmcd->nmcd.dwDrawStage)
+        {
+          case CDDS_PREPAINT:
+            *result = CDRF_NOTIFYITEMDRAW;
+            return 1;
+
+          case CDDS_ITEMPREPAINT:
+          {
+            int pos = (int)pnmcd->nmcd.dwItemSpec + 1;  /* 1-based */
+            char* text = iupListGetItemValueCb(ih, pos);
+            char* image_name = iupListGetItemImageCb(ih, pos);
+            RECT rc;
+            int img_w = ih->data->maximg_w;
+            HFONT hFont = (HFONT)iupwinGetHFontAttrib(ih);
+            HFONT oldFont;
+            COLORREF fgcolor, bgcolor;
+            UINT itemState;
+            int isSelected, hasFocus;
+
+            /* Query actual item state from ListView */
+            itemState = ListView_GetItemState(ih->handle, pnmcd->nmcd.dwItemSpec, LVIS_SELECTED | LVIS_FOCUSED);
+            isSelected = (itemState & LVIS_SELECTED) != 0;
+            hasFocus = (itemState & LVIS_FOCUSED) != 0;
+
+            ListView_GetItemRect(ih->handle, pnmcd->nmcd.dwItemSpec, &rc, LVIR_BOUNDS);
+
+            /* Draw background */
+            if (isSelected)
+              bgcolor = GetSysColor(COLOR_HIGHLIGHT);
+            else if (!iupwinGetColorRef(ih, "BGCOLOR", &bgcolor))
+              bgcolor = GetSysColor(COLOR_WINDOW);
+            SetDCBrushColor(pnmcd->nmcd.hdc, bgcolor);
+            FillRect(pnmcd->nmcd.hdc, &rc, (HBRUSH)GetStockObject(DC_BRUSH));
+
+            /* Get text color */
+            if (iupdrvIsActive(ih))
+            {
+              if (isSelected)
+                fgcolor = GetSysColor(COLOR_HIGHLIGHTTEXT);
+              else if (!iupwinGetColorRef(ih, "FGCOLOR", &fgcolor))
+                fgcolor = GetSysColor(COLOR_WINDOWTEXT);
+            }
+            else
+              fgcolor = GetSysColor(COLOR_GRAYTEXT);
+
+            /* Draw image */
+            if (image_name)
+            {
+              HBITMAP hBitmap = iupImageGetImage(image_name, ih, 0, NULL);
+              if (hBitmap)
+              {
+                int bpp, bmp_w, bmp_h;
+                int x, y;
+                int draw_w, draw_h;
+                int charheight;
+                int available_height;
+
+                iupdrvImageGetInfo(hBitmap, &bmp_w, &bmp_h, &bpp);
+                iupdrvFontGetCharSize(ih, NULL, &charheight);
+                available_height = charheight + 2 * ih->data->spacing;
+
+                /* Scale image down if needed to fit item height */
+                if (ih->data->fit_image && bmp_h > available_height)
+                {
+                  draw_w = (bmp_w * available_height) / bmp_h;
+                  draw_h = available_height;
+                }
+                else
+                {
+                  draw_w = bmp_w;
+                  draw_h = bmp_h;
+                }
+
+                x = rc.left + 2;
+                y = rc.top + (rc.bottom - rc.top - draw_h) / 2;
+
+                iupwinDrawBitmap(pnmcd->nmcd.hdc, hBitmap, x, y, draw_w, draw_h, bmp_w, bmp_h, bpp);
+              }
+            }
+
+            /* Draw text with offset for image */
+            if (text && *text)
+            {
+              RECT textRc = rc;
+              textRc.left += img_w + 6;  /* offset for image + spacing */
+
+              SetBkMode(pnmcd->nmcd.hdc, TRANSPARENT);
+              SetTextColor(pnmcd->nmcd.hdc, fgcolor);
+              oldFont = (HFONT)SelectObject(pnmcd->nmcd.hdc, hFont);
+              DrawText(pnmcd->nmcd.hdc, iupwinStrToSystem(text), -1, &textRc, DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
+              SelectObject(pnmcd->nmcd.hdc, oldFont);
+            }
+
+            /* Draw focus rectangle */
+            if (hasFocus)
+              iupwinDrawFocusRect(pnmcd->nmcd.hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
+
+            *result = CDRF_SKIPDEFAULT;
+            return 1;
+          }
+        }
+      }
+      break;
+    }
+
+    case LVN_ITEMCHANGED:
+    {
+      LPNMLISTVIEW pnmv = (LPNMLISTVIEW)msg_info;
+
+      if ((pnmv->uChanged & LVIF_STATE) &&
+          (pnmv->uNewState & LVIS_SELECTED) &&
+          !(pnmv->uOldState & LVIS_SELECTED))
+      {
+        IFnsii cb = (IFnsii)IupGetCallback(ih, "ACTION");
+        if (cb)
+        {
+          int pos = pnmv->iItem + 1;  /* 1-based */
+          char* text = iupListGetItemValueCb(ih, pos);
+          iupListSingleCallActionCb(ih, cb, pos);
+        }
+        iupBaseCallValueChangedCb(ih);
+      }
+      break;
+    }
+
+    case NM_DBLCLK:
+    {
+      IFnis cb = (IFnis)IupGetCallback(ih, "DBLCLICK_CB");
+      if (cb)
+      {
+        int pos = (int)SendMessage(ih->handle, LVM_GETNEXTITEM, (WPARAM)-1, LVNI_SELECTED);
+        if (pos >= 0)
+        {
+          pos++;  /* 1-based */
+          iupListSingleCallDblClickCb(ih, cb, pos);
+        }
+      }
+      break;
+    }
+
+    case NM_SETFOCUS:
+      iupwinWmSetFocus(ih);
+      break;
+
+    case NM_KILLFOCUS:
+      iupCallKillFocusCb(ih);
+      break;
+  }
+
+  (void)result;
+  return 0;
+}
+
+static LRESULT CALLBACK winListVirtualWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+  LRESULT result = 0;
+  WNDPROC oldProc;
+  Ihandle *ih;
+
+  ih = iupwinHandleGet(hwnd);
+  if (!iupObjectCheck(ih))
+    return DefWindowProc(hwnd, msg, wp, lp);
+
+  oldProc = (WNDPROC)IupGetCallback(ih, "_IUPWIN_LISTVIEWOLDPROC_CB");
+
+  switch (msg)
+  {
+    case WM_CHAR:
+      if (GetKeyState(VK_CONTROL) & 0x8000)
+      {
+        return 0;
+      }
+      break;
+  }
+
+  if (iupwinBaseMsgProc(ih, msg, wp, lp, &result))
+    return result;
+
+  return CallWindowProc(oldProc, hwnd, msg, wp, lp);
+}
+
+static int winListVirtualConvertXYToPos(Ihandle* ih, int x, int y)
+{
+  LVHITTESTINFO ht;
+  ht.pt.x = x;
+  ht.pt.y = y;
+  int index = (int)SendMessage(ih->handle, LVM_HITTEST, 0, (LPARAM)&ht);
+  if (index >= 0)
+    return index + 1;  /* 1-based */
+  return -1;
+}
+
+/*********************************************************************************/
+
 static void winListDrawItem(Ihandle* ih, DRAWITEMSTRUCT *drawitem)
 {
   char* text;
   int txt_w, txt_h;
-  winListItemData* itemdata;
+  winListItemData* itemdata = NULL;
+  HBITMAP hBitmap = NULL;
   HFONT hFont = (HFONT)iupwinGetHFontAttrib(ih);
   iupwinBitmapDC bmpDC;
   HDC hDC;
@@ -1716,10 +2004,25 @@
     fgcolor = GetSysColor(COLOR_GRAYTEXT);
 
   /* Get the bitmap associated with the item */
-  itemdata = winListGetItemData(ih, drawitem->itemID);
+  if (ih->data->is_virtual)
+  {
+    /* Virtual mode: query IMAGE_CB for the image */
+    char* image_name = iupListGetItemImageCb(ih, drawitem->itemID + 1);  /* 1-based */
+    if (image_name)
+      hBitmap = iupImageGetImage(image_name, ih, 0, NULL);
+  }
+  else
+  {
+    itemdata = winListGetItemData(ih, drawitem->itemID);
+    if (itemdata)
+      hBitmap = itemdata->hBitmap;
+  }
 
   /* Get and draw the string associated with the item */
-  text = winListGetText(ih, drawitem->itemID);
+  if (ih->data->is_virtual)
+    text = iupListGetItemValueCb(ih, drawitem->itemID + 1);  /* 1-based */
+  else
+    text = winListGetText(ih, drawitem->itemID);
   iupdrvFontGetMultiLineStringSize(ih, text, &txt_w, &txt_h);
 
   x = ih->data->maximg_w + 3; /* align text + spacing between text and image */
@@ -1727,15 +2030,31 @@
   iupwinDrawText(hDC, text, x, y, txt_w, txt_h, hFont, fgcolor, 0);
 
   /* Draw the bitmap associated with the item */
-  if (itemdata->hBitmap)
+  if (hBitmap)
   {
     int bpp, img_w, img_h;
+    int draw_w, draw_h;
+    int charheight, available_height;
 
-    iupdrvImageGetInfo(itemdata->hBitmap, &img_w, &img_h, &bpp);
+    iupdrvImageGetInfo(hBitmap, &img_w, &img_h, &bpp);
+    iupdrvFontGetCharSize(ih, NULL, &charheight);
+    available_height = charheight + 2 * ih->data->spacing;
 
+    /* Scale image down if needed to fit item height */
+    if (ih->data->fit_image && img_h > available_height)
+    {
+      draw_w = (img_w * available_height) / img_h;
+      draw_h = available_height;
+    }
+    else
+    {
+      draw_w = img_w;
+      draw_h = img_h;
+    }
+
     x = 0;
-    y = (height - img_h)/2;  /* vertically centered */
-    iupwinDrawBitmap(hDC, itemdata->hBitmap, x, y, img_w, img_h, img_w, img_h, bpp);
+    y = (height - draw_h)/2;  /* vertically centered */
+    iupwinDrawBitmap(hDC, hBitmap, x, y, draw_w, draw_h, img_w, img_h, bpp);
   }
 
   /* If the item has the focus, draw the focus rectangle */
@@ -1768,12 +2087,20 @@
     win_w = rect.right-rect.left;
 
     if (ih->currentwidth != win_w || calc_h != win_h)
-      SetWindowPos(ih->handle, HWND_TOP, ih->x, ih->y, ih->currentwidth, calc_h, 
+      SetWindowPos(ih->handle, HWND_TOP, ih->x, ih->y, ih->currentwidth, calc_h,
                    SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOOWNERZORDER);
     else
-      SetWindowPos(ih->handle, HWND_TOP, ih->x, ih->y, 0, 0, 
+      SetWindowPos(ih->handle, HWND_TOP, ih->x, ih->y, 0, 0,
                    SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOOWNERZORDER);
-  }                
+  }
+  else if (ih->data->is_virtual)
+  {
+    iupdrvBaseLayoutUpdateMethod(ih);
+
+    RECT rect;
+    GetClientRect(ih->handle, &rect);
+    ListView_SetColumnWidth(ih->handle, 0, rect.right - rect.left);
+  }
   else
     iupdrvBaseLayoutUpdateMethod(ih);
 }
@@ -1803,7 +2130,6 @@
 
 static int winListMapMethod(Ihandle* ih)
 {
-  TCHAR* class_name;
   DWORD dwStyle = WS_CHILD|WS_CLIPSIBLINGS,
       dwExStyle = WS_EX_CLIENTEDGE;
 
@@ -1810,10 +2136,52 @@
   if (!ih->parent)
     return IUP_ERROR;
 
+  if (ih->data->is_virtual && !ih->data->is_dropdown && !ih->data->has_editbox)
+  {
+    LVCOLUMN lvc;
+
+    dwStyle |= LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER | LVS_OWNERDATA;
+
+    if (ih->data->is_multiple)
+      dwStyle &= ~LVS_SINGLESEL;
+
+    if (iupAttribGetBoolean(ih, "CANFOCUS"))
+      dwStyle |= WS_TABSTOP;
+
+    if (!iupwinCreateWindow(ih, WC_LISTVIEW, dwExStyle, dwStyle, NULL))
+      return IUP_ERROR;
+
+    /* Set extended styles */
+    ListView_SetExtendedListViewStyle(ih->handle, LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER);
+
+    /* Add single column to fill width */
+    ZeroMemory(&lvc, sizeof(LVCOLUMN));
+    lvc.mask = LVCF_WIDTH;
+    lvc.cx = 1000;
+    ListView_InsertColumn(ih->handle, 0, &lvc);
+
+    /* Register notify callback for WM_NOTIFY */
+    IupSetCallback(ih, "_IUPWIN_NOTIFY_CB", (Icallback)winListVirtualNotifyCallback);
+
+    /* Subclass for keyboard handling */
+    IupSetCallback(ih, "_IUPWIN_LISTVIEWOLDPROC_CB", (Icallback)GetWindowLongPtr(ih->handle, GWLP_WNDPROC));
+    SetWindowLongPtr(ih->handle, GWLP_WNDPROC, (LONG_PTR)winListVirtualWndProc);
+
+    IupSetCallback(ih, "_IUP_XY2POS_CB", (Icallback)winListVirtualConvertXYToPos);
+
+    /* Set item count */
+    if (ih->data->item_count > 0)
+      ListView_SetItemCountEx(ih->handle, ih->data->item_count, LVSICF_NOINVALIDATEALL);
+
+    /* configure for DROP of files */
+    if (IupGetCallback(ih, "DROPFILES_CB"))
+      iupAttribSet(ih, "DROPFILESTARGET", "YES");
+
+    return IUP_NOERROR;
+  }
+
   if (ih->data->is_dropdown || ih->data->has_editbox)
   {
-    class_name = TEXT("COMBOBOX");
-
     dwStyle |= CBS_NOINTEGRALHEIGHT;
 
     if (ih->data->show_image)
@@ -1843,11 +2211,15 @@
 
     if (iupAttribGetBoolean(ih, "SORT"))
       dwStyle |= CBS_SORT;
+
+    if (iupAttribGetBoolean(ih, "CANFOCUS"))
+      dwStyle |= WS_TABSTOP;
+
+    if (!iupwinCreateWindow(ih, TEXT("COMBOBOX"), dwExStyle, dwStyle, NULL))
+      return IUP_ERROR;
   }
   else
   {
-    class_name = TEXT("LISTBOX");
-
     dwStyle |= LBS_NOINTEGRALHEIGHT|LBS_NOTIFY;
 
     if (ih->data->is_multiple)
@@ -1866,13 +2238,13 @@
 
     if (iupAttribGetBoolean(ih, "SORT"))
       dwStyle |= LBS_SORT;
-  }
 
-  if (iupAttribGetBoolean(ih, "CANFOCUS"))
-    dwStyle |= WS_TABSTOP;
+    if (iupAttribGetBoolean(ih, "CANFOCUS"))
+      dwStyle |= WS_TABSTOP;
 
-  if (!iupwinCreateWindow(ih, class_name, dwExStyle, dwStyle, NULL))
-    return IUP_ERROR;
+    if (!iupwinCreateWindow(ih, TEXT("LISTBOX"), dwExStyle, dwStyle, NULL))
+      return IUP_ERROR;
+  }
 
   /* Custom Procedure */
   IupSetCallback(ih, "_IUPWIN_CTRLMSGPROC_CB", (Icallback)winListMsgProc);
@@ -1917,7 +2289,7 @@
   if(ih->data->show_dragdrop && !ih->data->is_dropdown && !ih->data->is_multiple)
     winListEnableDragDrop(ih);
 
-  if(ih->data->show_image)
+  if (ih->data->show_image)
     IupSetCallback(ih, "_IUPWIN_DRAWITEM_CB", (Icallback)winListDrawItem);  /* Process WM_DRAWITEM */
 
   /* configure for DROP of files */
Index: src/win/iupwin_menu.c
===================================================================
--- src/win/iupwin_menu.c	(revision 5971)
+++ src/win/iupwin_menu.c	(working copy)
@@ -58,6 +58,9 @@
   return GetSystemMetrics(SM_CYMENU);
 }
 
+static int iupwinMenuIsRecentItem(int menuId);
+static void iupwinMenuRecentItemProc(HMENU hMenu, int menuId);
+
 static void winMenuUpdateBar(Ihandle* ih)
 {
   if (iupMenuIsMenuBar(ih) && ih->parent->handle)
@@ -167,10 +170,16 @@
       int menuId = GetMenuItemID((HMENU)lp, (int)wp);
       Icallback cb;
       Ihandle* ih;
-        
+
       if (menuId >= IUP_MDI_FIRSTCHILD)
         break;
-        
+
+      if (iupwinMenuIsRecentItem(menuId))
+      {
+        iupwinMenuRecentItemProc((HMENU)lp, menuId);
+        break;
+      }
+
       ih  = iupwinMenuGetItemHandle((HMENU)lp, menuId);
       if (!ih)
         break;
@@ -724,3 +733,118 @@
   ic->Map = winSeparatorMapMethod;
   ic->UnMap = winMenuChildUnMapMethod;
 }
+
+/*******************************************************************************************/
+
+#define IUP_RECENT_FIRSTID 90000000
+
+static void winRecentItemActivate(Ihandle* menu, int index)
+{
+  Icallback recent_cb = (Icallback)iupAttribGet(menu, "_IUP_RECENT_CB");
+  Ihandle* config = (Ihandle*)iupAttribGet(menu, "_IUP_CONFIG");
+
+  if (recent_cb && config)
+  {
+    char attr_name[32];
+    const char* filename;
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", index);
+    filename = iupAttribGet(menu, attr_name);
+
+    if (filename)
+    {
+      IupSetStrAttribute(config, "RECENTFILENAME", filename);
+      IupSetStrAttribute(config, "TITLE", filename);
+      config->parent = menu;
+
+      if (recent_cb(config) == IUP_CLOSE)
+        IupExitLoop();
+
+      config->parent = NULL;
+      IupSetAttribute(config, "RECENTFILENAME", NULL);
+      IupSetAttribute(config, "TITLE", NULL);
+    }
+  }
+}
+
+static int iupwinMenuIsRecentItem(int menuId)
+{
+  return (menuId >= IUP_RECENT_FIRSTID && menuId < IUP_RECENT_FIRSTID + 100);
+}
+
+static void iupwinMenuRecentItemProc(HMENU hMenu, int menuId)
+{
+  int index = menuId - IUP_RECENT_FIRSTID;
+  Ihandle* menu = iupwinMenuGetHandle(hMenu);
+  if (menu)
+    winRecentItemActivate(menu, index);
+}
+
+int iupdrvRecentMenuInit(Ihandle* menu, int max_recent, Icallback recent_cb)
+{
+  iupAttribSetInt(menu, "_IUP_RECENT_MAX", max_recent);
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", 0);
+  return 0;
+}
+
+int iupdrvRecentMenuUpdate(Ihandle* menu, const char** filenames, int count, Icallback recent_cb)
+{
+  HMENU hMenu;
+  int max_recent, existing, i;
+
+  if (!menu || !menu->handle)
+    return -1;
+
+  hMenu = (HMENU)menu->handle;
+  max_recent = iupAttribGetInt(menu, "_IUP_RECENT_MAX");
+  existing = iupAttribGetInt(menu, "_IUP_RECENT_COUNT");
+
+  if (count > max_recent)
+    count = max_recent;
+
+  iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
+
+  for (i = 0; i < count; i++)
+  {
+    char attr_name[32];
+    MENUITEMINFOA mii;
+    UINT menuId = IUP_RECENT_FIRSTID + i;
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
+    iupAttribSetStr(menu, attr_name, filenames[i]);
+
+    memset(&mii, 0, sizeof(MENUITEMINFOA));
+    mii.cbSize = sizeof(MENUITEMINFOA);
+    mii.fMask = MIIM_ID | MIIM_STRING | MIIM_DATA;
+    mii.wID = menuId;
+    mii.dwTypeData = (LPSTR)filenames[i];
+    mii.cch = (UINT)strlen(filenames[i]);
+    mii.dwItemData = (ULONG_PTR)menu;
+
+    if (i < existing)
+    {
+      mii.fMask = MIIM_STRING;
+      SetMenuItemInfoA(hMenu, i, TRUE, &mii);
+    }
+    else
+    {
+      InsertMenuItemA(hMenu, i, TRUE, &mii);
+    }
+  }
+
+  for (i = count; i < existing; i++)
+  {
+    char attr_name[32];
+    RemoveMenu(hMenu, count, MF_BYPOSITION);
+
+    sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
+    iupAttribSet(menu, attr_name, NULL);
+  }
+
+  iupAttribSetInt(menu, "_IUP_RECENT_COUNT", count);
+
+  winMenuUpdateBar(menu);
+
+  return 0;
+}
Index: src/win/iupwin_messagedlg.c
===================================================================
--- src/win/iupwin_messagedlg.c	(revision 5971)
+++ src/win/iupwin_messagedlg.c	(working copy)
@@ -5,6 +5,7 @@
  */
 
 #include <windows.h>
+#include <commctrl.h>
 
 #include "iup.h"
 
@@ -16,6 +17,7 @@
 #include "iup_drv.h"
 #include "iupwin_drv.h"
 #include "iupwin_str.h"
+#include "iupwin_info.h"
 
 
 static void CALLBACK winMessageDlgHelpCallback(HELPINFO* HelpInfo)
@@ -24,7 +26,7 @@
   Icallback cb = (Icallback)IupGetCallback(ih, "HELP_CB");
   if (cb && cb(ih) == IUP_CLOSE)
   {
-    if (iupStrEqualNoCase(iupAttribGetStr(ih, "BUTTONS"), "OK")) /* only one button */
+    if (iupStrEqualNoCase(iupAttribGetStr(ih, "BUTTONS"), "OK"))
       EndDialog((HWND)HelpInfo->hItemHandle, IDOK);
     else
       EndDialog((HWND)HelpInfo->hItemHandle, IDCANCEL);
@@ -40,78 +42,214 @@
   return iupStrReturnBoolean(automodal);
 }
 
-static int winMessageDlgPopup(Ihandle* ih, int x, int y)
+static HRESULT CALLBACK winMessageDlgTaskDialogCallback(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp, LONG_PTR lpRefData)
 {
-  InativeHandle* parent = iupDialogGetNativeParent(ih);
-  MSGBOXPARAMS MsgBoxParams;
-  int result, button_def;
-  DWORD dwStyle = MB_TASKMODAL;
-  char *icon, *buttons;
-  (void)x;
-  (void)y;
+  (void)wp;
+  (void)lp;
 
-  /* MessageBox is the only Windows pre-defined dialog that has a modal control,
-     no need to force a parent dialog here. */
+  if (msg == TDN_CREATED)
+  {
+    iupwinTitleBarThemeColor(hwnd);
+    return S_OK;
+  }
 
-  icon = iupAttribGetStr(ih, "DIALOGTYPE");
+  if (msg == TDN_HYPERLINK_CLICKED)
+    return S_OK;
+
+  if (msg == TDN_HELP)
+  {
+    Ihandle* ih = (Ihandle*)lpRefData;
+    Icallback cb = (Icallback)IupGetCallback(ih, "HELP_CB");
+    if (cb && cb(ih) == IUP_CLOSE)
+      SendMessage(hwnd, TDM_CLICK_BUTTON, IDCANCEL, 0);
+    return S_OK;
+  }
+
+  return S_OK;
+}
+
+static int winMessageDlgPopupTaskDialog(Ihandle* ih, InativeHandle* parent, char* icon, char* buttons)
+{
+  typedef HRESULT (WINAPI *TaskDialogIndirectFunc)(const TASKDIALOGCONFIG*, int*, int*, BOOL*);
+  static TaskDialogIndirectFunc pTaskDialogIndirect = NULL;
+  static int initialized = 0;
+
+  TASKDIALOGCONFIG config;
+  int nButton = 0;
+  int button_def;
+  TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons = 0;
+  PCWSTR pszIcon = NULL;
+  HRESULT hr;
+  WCHAR* wszTitle = NULL;
+  WCHAR* wszContent = NULL;
+
+  if (!initialized)
+  {
+    HMODULE hComCtl = LoadLibrary(TEXT("comctl32.dll"));
+    if (hComCtl)
+      pTaskDialogIndirect = (TaskDialogIndirectFunc)GetProcAddress(hComCtl, "TaskDialogIndirect");
+    initialized = 1;
+  }
+
+  if (!pTaskDialogIndirect)
+    return 0;
+
+  wszTitle = iupwinStrChar2Wide(iupAttribGet(ih, "TITLE"));
+  wszContent = iupwinStrChar2Wide(iupAttribGet(ih, "VALUE"));
+
+  ZeroMemory(&config, sizeof(TASKDIALOGCONFIG));
+  config.cbSize = sizeof(TASKDIALOGCONFIG);
+  config.hwndParent = parent;
+  config.dwFlags = TDF_POSITION_RELATIVE_TO_WINDOW | TDF_ALLOW_DIALOG_CANCELLATION;
+  config.pszWindowTitle = wszTitle;
+  config.pszContent = wszContent;
+  config.pfCallback = winMessageDlgTaskDialogCallback;
+  config.lpCallbackData = (LONG_PTR)ih;
+
   if (iupStrEqualNoCase(icon, "ERROR"))
-    dwStyle |= MB_ICONERROR;
+    pszIcon = TD_ERROR_ICON;
   else if (iupStrEqualNoCase(icon, "WARNING"))
-    dwStyle |= MB_ICONWARNING;
+    pszIcon = TD_WARNING_ICON;
   else if (iupStrEqualNoCase(icon, "INFORMATION"))
-    dwStyle |= MB_ICONINFORMATION;
+    pszIcon = TD_INFORMATION_ICON;
   else if (iupStrEqualNoCase(icon, "QUESTION"))
-    dwStyle |= MB_ICONQUESTION;
+    pszIcon = TD_INFORMATION_ICON;
 
-  buttons = iupAttribGetStr(ih, "BUTTONS");
+  config.pszMainIcon = pszIcon;
+
   if (iupStrEqualNoCase(buttons, "OKCANCEL"))
-    dwStyle |= MB_OKCANCEL;
+    dwCommonButtons = TDCBF_OK_BUTTON | TDCBF_CANCEL_BUTTON;
   else if (iupStrEqualNoCase(buttons, "RETRYCANCEL"))
-    dwStyle |= MB_RETRYCANCEL;
+    dwCommonButtons = TDCBF_RETRY_BUTTON | TDCBF_CANCEL_BUTTON;
   else if (iupStrEqualNoCase(buttons, "YESNO"))
-    dwStyle |= MB_YESNO;
+    dwCommonButtons = TDCBF_YES_BUTTON | TDCBF_NO_BUTTON;
   else if (iupStrEqualNoCase(buttons, "YESNOCANCEL"))
-    dwStyle |= MB_YESNOCANCEL;
+    dwCommonButtons = TDCBF_YES_BUTTON | TDCBF_NO_BUTTON | TDCBF_CANCEL_BUTTON;
   else
-    dwStyle |= MB_OK;
+    dwCommonButtons = TDCBF_OK_BUTTON;
 
-  if (IupGetCallback(ih, "HELP_CB"))
-    dwStyle |= MB_HELP;
+  config.dwCommonButtons = dwCommonButtons;
 
   button_def = iupAttribGetInt(ih, "BUTTONDEFAULT");
-  if (button_def == 3)
-    dwStyle |= MB_DEFBUTTON3;
+  if (button_def == 1)
+  {
+    if (dwCommonButtons & TDCBF_OK_BUTTON)
+      config.nDefaultButton = IDOK;
+    else if (dwCommonButtons & TDCBF_YES_BUTTON)
+      config.nDefaultButton = IDYES;
+    else if (dwCommonButtons & TDCBF_RETRY_BUTTON)
+      config.nDefaultButton = IDRETRY;
+  }
   else if (button_def == 2)
-    dwStyle |= MB_DEFBUTTON2;
-  else
-    dwStyle |= MB_DEFBUTTON1;
+  {
+    if (dwCommonButtons & TDCBF_CANCEL_BUTTON)
+      config.nDefaultButton = IDCANCEL;
+    else if (dwCommonButtons & TDCBF_NO_BUTTON)
+      config.nDefaultButton = IDNO;
+  }
+  else if (button_def == 3)
+  {
+    if (dwCommonButtons & TDCBF_CANCEL_BUTTON)
+      config.nDefaultButton = IDCANCEL;
+  }
 
-  MsgBoxParams.cbSize = sizeof(MSGBOXPARAMS);
-  MsgBoxParams.hwndOwner = parent;
-  MsgBoxParams.hInstance = NULL;
-  MsgBoxParams.lpszText = iupwinStrToSystem(iupAttribGet(ih, "VALUE"));
-  MsgBoxParams.lpszCaption = iupwinStrToSystem(iupAttribGet(ih, "TITLE"));
-  MsgBoxParams.dwStyle = dwStyle;
-  MsgBoxParams.lpszIcon = NULL;
-  MsgBoxParams.dwContextHelpId = (DWORD_PTR)ih;
-  MsgBoxParams.lpfnMsgBoxCallback = (MSGBOXCALLBACK)winMessageDlgHelpCallback;
-  MsgBoxParams.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
+  hr = pTaskDialogIndirect(&config, &nButton, NULL, NULL);
 
-  result = MessageBoxIndirect(&MsgBoxParams);
+  if (wszTitle) free(wszTitle);
+  if (wszContent) free(wszContent);
 
-  if (result == 0)  /* memory error */
-  {
-    iupAttribSet(ih, "BUTTONRESPONSE", NULL);
-    return IUP_ERROR;
-  }
+  if (FAILED(hr))
+    return 0;
 
-  if (result == IDOK || result == IDYES || result == IDRETRY)
+  if (nButton == IDOK || nButton == IDYES || nButton == IDRETRY)
     iupAttribSet(ih, "BUTTONRESPONSE", "1");
-  else if (result == IDCANCEL && iupStrEqualNoCase(buttons, "YESNOCANCEL"))
+  else if (nButton == IDCANCEL && iupStrEqualNoCase(buttons, "YESNOCANCEL"))
     iupAttribSet(ih, "BUTTONRESPONSE", "3");
   else
     iupAttribSet(ih, "BUTTONRESPONSE", "2");
 
+  return 1;
+}
+
+static int winMessageDlgPopup(Ihandle* ih, int x, int y)
+{
+  InativeHandle* parent = iupDialogGetNativeParent(ih);
+  char *icon, *buttons;
+  (void)x;
+  (void)y;
+
+  icon = iupAttribGetStr(ih, "DIALOGTYPE");
+  buttons = iupAttribGetStr(ih, "BUTTONS");
+
+  if (iupwinIsSystemDarkMode() && iupwinIsVistaOrNew())
+  {
+    if (winMessageDlgPopupTaskDialog(ih, parent, icon, buttons))
+      return IUP_NOERROR;
+  }
+
+  {
+    MSGBOXPARAMS MsgBoxParams;
+    int result, button_def;
+    DWORD dwStyle = MB_TASKMODAL;
+
+    if (iupStrEqualNoCase(icon, "ERROR"))
+      dwStyle |= MB_ICONERROR;
+    else if (iupStrEqualNoCase(icon, "WARNING"))
+      dwStyle |= MB_ICONWARNING;
+    else if (iupStrEqualNoCase(icon, "INFORMATION"))
+      dwStyle |= MB_ICONINFORMATION;
+    else if (iupStrEqualNoCase(icon, "QUESTION"))
+      dwStyle |= MB_ICONQUESTION;
+
+    if (iupStrEqualNoCase(buttons, "OKCANCEL"))
+      dwStyle |= MB_OKCANCEL;
+    else if (iupStrEqualNoCase(buttons, "RETRYCANCEL"))
+      dwStyle |= MB_RETRYCANCEL;
+    else if (iupStrEqualNoCase(buttons, "YESNO"))
+      dwStyle |= MB_YESNO;
+    else if (iupStrEqualNoCase(buttons, "YESNOCANCEL"))
+      dwStyle |= MB_YESNOCANCEL;
+    else
+      dwStyle |= MB_OK;
+
+    if (IupGetCallback(ih, "HELP_CB"))
+      dwStyle |= MB_HELP;
+
+    button_def = iupAttribGetInt(ih, "BUTTONDEFAULT");
+    if (button_def == 3)
+      dwStyle |= MB_DEFBUTTON3;
+    else if (button_def == 2)
+      dwStyle |= MB_DEFBUTTON2;
+    else
+      dwStyle |= MB_DEFBUTTON1;
+
+    MsgBoxParams.cbSize = sizeof(MSGBOXPARAMS);
+    MsgBoxParams.hwndOwner = parent;
+    MsgBoxParams.hInstance = NULL;
+    MsgBoxParams.lpszText = iupwinStrToSystem(iupAttribGet(ih, "VALUE"));
+    MsgBoxParams.lpszCaption = iupwinStrToSystem(iupAttribGet(ih, "TITLE"));
+    MsgBoxParams.dwStyle = dwStyle;
+    MsgBoxParams.lpszIcon = NULL;
+    MsgBoxParams.dwContextHelpId = (DWORD_PTR)ih;
+    MsgBoxParams.lpfnMsgBoxCallback = (MSGBOXCALLBACK)winMessageDlgHelpCallback;
+    MsgBoxParams.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
+
+    result = MessageBoxIndirect(&MsgBoxParams);
+
+    if (result == 0)
+    {
+      iupAttribSet(ih, "BUTTONRESPONSE", NULL);
+      return IUP_ERROR;
+    }
+
+    if (result == IDOK || result == IDYES || result == IDRETRY)
+      iupAttribSet(ih, "BUTTONRESPONSE", "1");
+    else if (result == IDCANCEL && iupStrEqualNoCase(buttons, "YESNOCANCEL"))
+      iupAttribSet(ih, "BUTTONRESPONSE", "3");
+    else
+      iupAttribSet(ih, "BUTTONRESPONSE", "2");
+  }
+
   return IUP_NOERROR;
 }
 
Index: src/win/iupwin_open.c
===================================================================
--- src/win/iupwin_open.c	(revision 5971)
+++ src/win/iupwin_open.c	(working copy)
@@ -6,10 +6,11 @@
 #include <windows.h>
 #include <commctrl.h>
 #include <ole2.h>
+#include <shobjidl.h>
 
-#include <stdio.h>              
+#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>             
+#include <string.h>
 
 #include "iup.h"
 
@@ -77,11 +78,23 @@
 static void winSetGlobalColor(int index, const char* name)
 {
   COLORREF color = GetSysColor(index);
-  iupGlobalSetDefaultColorAttrib(name, (int)GetRValue(color), 
-                                       (int)GetGValue(color), 
+  iupGlobalSetDefaultColorAttrib(name, (int)GetRValue(color),
+                                       (int)GetGValue(color),
                                        (int)GetBValue(color));
 }
 
+void iupwinSetGlobalColors(void)
+{
+  winSetGlobalColor(COLOR_BTNFACE, "DLGBGCOLOR");
+  winSetGlobalColor(COLOR_BTNTEXT, "DLGFGCOLOR");
+  winSetGlobalColor(COLOR_WINDOW, "TXTBGCOLOR");
+  winSetGlobalColor(COLOR_WINDOWTEXT, "TXTFGCOLOR");
+  winSetGlobalColor(COLOR_HIGHLIGHT, "TXTHLCOLOR");
+  winSetGlobalColor(COLOR_HOTLIGHT, "LINKFGCOLOR");
+  winSetGlobalColor(COLOR_MENU, "MENUBGCOLOR");
+  winSetGlobalColor(COLOR_MENUTEXT, "MENUFGCOLOR");
+}
+
 int iupdrvOpen(int *argc, char ***argv)
 {
   (void)argc; /* unused in the Windows driver */
@@ -91,6 +104,7 @@
     return IUP_ERROR;
 
   IupSetGlobal("DRIVER",  "Win32");
+  IupSetGlobal("WINDOWING", "WIN32");
 
   if (!iupwin_hinstance)
   {
@@ -124,16 +138,7 @@
 #endif
   IupSetGlobal("SYSTEMLANGUAGE", iupwinGetSystemLanguage());
 
-  /* default colors */
-  winSetGlobalColor(COLOR_BTNFACE, "DLGBGCOLOR");
-  winSetGlobalColor(COLOR_BTNTEXT, "DLGFGCOLOR");
-  winSetGlobalColor(COLOR_WINDOW,     "TXTBGCOLOR");
-  winSetGlobalColor(COLOR_WINDOWTEXT, "TXTFGCOLOR");
-  winSetGlobalColor(COLOR_HIGHLIGHT,  "TXTHLCOLOR");
-  winSetGlobalColor(COLOR_HOTLIGHT, "LINKFGCOLOR");
-  /* only in Windows */
-  winSetGlobalColor(COLOR_MENU, "MENUBGCOLOR");
-  winSetGlobalColor(COLOR_MENUTEXT, "MENUFGCOLOR");
+  iupwinSetGlobalColors();
 
   iupwinHandleInit();
   iupwinBrushInit();
@@ -154,6 +159,35 @@
   return IUP_NOERROR;
 }
 
+int iupdrvSetGlobalAppIDAttrib(const char* value)
+{
+  static int appid_set = 0;
+  if (appid_set || !value || !value[0])
+    return 0;
+
+  IupStoreGlobal("_IUP_APPID_INTERNAL", value);
+  appid_set = 1;
+  return 1;
+}
+
+int iupdrvSetGlobalAppNameAttrib(const char* value)
+{
+  static int appname_set = 0;
+  if (appname_set || !value || !value[0])
+    return 0;
+
+  WCHAR wappname[129];
+  MultiByteToWideChar(CP_UTF8, 0, value, -1, wappname, 129);
+
+  HRESULT hr = SetCurrentProcessExplicitAppUserModelID(wappname);
+  if (SUCCEEDED(hr))
+  {
+    appname_set = 1;
+    return 1;
+  }
+  return 0;
+}
+
 void iupdrvClose(void)
 {
   iupwinHandleFinish();
@@ -162,7 +196,7 @@
   iupwinDrawFinish();
 
   if (IupGetGlobal("_IUPWIN_OLEINITIALIZE"))
-	  OleUninitialize();
+    OleUninitialize();
 
   CoUninitialize();
 }
Index: src/win/iupwin_progressbar.c
===================================================================
--- src/win/iupwin_progressbar.c	(revision 5971)
+++ src/win/iupwin_progressbar.c	(working copy)
@@ -25,6 +25,7 @@
 #include "iupwin_drv.h"
 #include "iupwin_handle.h"
 #include "iupwin_str.h"
+#include "iupwin_draw.h"
 
 
 /* Not defined in Cygwin and MingW */
@@ -36,6 +37,98 @@
 #define IUP_PB_MAX 32000
 
 
+void iupdrvProgressBarGetMinSize(Ihandle* ih, int* w, int* h)
+{
+  /* Windows progress bar has no intrinsic size API */
+  if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
+  {
+    *w = 16;
+    *h = 80;
+  }
+  else
+  {
+    *w = 100;
+    *h = 16;
+  }
+}
+
+static void winProgressBarDraw(Ihandle* ih, HDC hDC)
+{
+  RECT rect;
+  HBRUSH hBrush;
+  COLORREF bgcolor, fgcolor;
+  unsigned char r, g, b;
+  char* value;
+  int width, height;
+  int is_vertical = iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL");
+  int progress;
+  double factor;
+
+  GetClientRect(ih->handle, &rect);
+  width = rect.right - rect.left;
+  height = rect.bottom - rect.top;
+
+  value = iupAttribGetStr(ih, "BGCOLOR");
+  if (iupStrToRGB(value, &r, &g, &b))
+    bgcolor = RGB(r, g, b);
+  else
+    bgcolor = GetSysColor(COLOR_3DFACE);
+
+  value = iupAttribGetStr(ih, "FGCOLOR");
+  if (iupStrToRGB(value, &r, &g, &b))
+    fgcolor = RGB(r, g, b);
+  else
+    fgcolor = GetSysColor(COLOR_HIGHLIGHT);
+
+  hBrush = CreateSolidBrush(bgcolor);
+  FillRect(hDC, &rect, hBrush);
+  DeleteObject(hBrush);
+
+  if (!ih->data->marquee)
+  {
+    factor = (ih->data->value - ih->data->vmin) / (ih->data->vmax - ih->data->vmin);
+
+    if (is_vertical)
+    {
+      progress = (int)(height * factor);
+      SetRect(&rect, 0, height - progress, width, height);
+    }
+    else
+    {
+      progress = (int)(width * factor);
+      SetRect(&rect, 0, 0, progress, height);
+    }
+
+    if (progress > 0)
+    {
+      hBrush = CreateSolidBrush(fgcolor);
+      FillRect(hDC, &rect, hBrush);
+      DeleteObject(hBrush);
+    }
+  }
+}
+
+static int winProgressBarMsgProc(Ihandle* ih, UINT msg, WPARAM wp, LPARAM lp, LRESULT *result)
+{
+  if (msg == WM_PAINT)
+  {
+    PAINTSTRUCT ps;
+    HDC hDC = BeginPaint(ih->handle, &ps);
+    winProgressBarDraw(ih, hDC);
+    EndPaint(ih->handle, &ps);
+    *result = 0;
+    return 1;
+  }
+
+  if (msg == WM_ERASEBKGND)
+  {
+    *result = 1;
+    return 1;
+  }
+
+  return iupwinBaseMsgProc(ih, msg, wp, lp, result);
+}
+
 static int winProgressBarSetMarqueeAttrib(Ihandle* ih, const char* value)
 {
   /* MARQUEE only works when using XP Styles */
@@ -59,12 +152,18 @@
 
   iProgressBarCropValue(ih);
 
-  /* Shows when the marquee style is not set */
   if (!ih->data->marquee)
   {
-    double factor = (ih->data->value - ih->data->vmin) / (ih->data->vmax - ih->data->vmin);
-    int val = (int)(IUP_PB_MAX * factor);
-    SendMessage(ih->handle, PBM_SETPOS, (WPARAM)val, 0);
+    if (iupwin_comctl32ver6)
+    {
+      iupdrvRedrawNow(ih);
+    }
+    else
+    {
+      double factor = (ih->data->value - ih->data->vmin) / (ih->data->vmax - ih->data->vmin);
+      int val = (int)(IUP_PB_MAX * factor);
+      SendMessage(ih->handle, PBM_SETPOS, (WPARAM)val, 0);
+    }
   }
 
   return 0;
@@ -74,9 +173,11 @@
 {
   unsigned char r, g, b;
 
-  /* Only works when using Classic style */
   if (iupwin_comctl32ver6)
-    return 0;
+  {
+    iupdrvRedrawNow(ih);
+    return 1;
+  }
 
   if (iupStrToRGB(value, &r, &g, &b))
   {
@@ -92,9 +193,11 @@
 {
   unsigned char r, g, b;
 
-  /* Only works when using Classic style */
   if (iupwin_comctl32ver6)
-    return 0;
+  {
+    iupdrvRedrawNow(ih);
+    return 1;
+  }
 
   if (iupStrToRGB(value, &r, &g, &b))
   {
@@ -137,7 +240,12 @@
   if (!iupwinCreateWindow(ih, PROGRESS_CLASS, 0, dwStyle, NULL))
     return IUP_ERROR;
 
-  /* configure the native range */
+  if (iupwin_comctl32ver6 && !ih->data->marquee)
+  {
+    iupwinDrawRemoveTheme(ih->handle);
+    IupSetCallback(ih, "_IUPWIN_CTRLMSGPROC_CB", (Icallback)winProgressBarMsgProc);
+  }
+
   SendMessage(ih->handle, PBM_SETRANGE, 0, MAKELPARAM(0, IUP_PB_MAX));
 
   return IUP_NOERROR;
@@ -149,15 +257,9 @@
   ic->Map = winProgressBarMapMethod;
 
   /* Visual */
-  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, winProgressBarSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);  
+  iupClassRegisterAttribute(ic, "BGCOLOR", NULL, winProgressBarSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
+  iupClassRegisterAttribute(ic, "FGCOLOR", NULL, winProgressBarSetFgColorAttrib, NULL, NULL, IUPAF_NO_INHERIT);
 
-  /* Special */
-  /* Only works when using Classic style */
-  if (iupwin_comctl32ver6)
-    iupClassRegisterAttribute(ic, "FGCOLOR", NULL, winProgressBarSetFgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGFGCOLOR", IUPAF_DEFAULT);
-  else
-    iupClassRegisterAttribute(ic, "FGCOLOR", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED);
-
   /* IupProgressBar only */
   iupClassRegisterAttribute(ic, "VALUE",  iProgressBarGetValueAttrib,  winProgressBarSetValueAttrib,  NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "ORIENTATION", NULL, NULL, IUPAF_SAMEASSYSTEM, "HORIZONTAL", IUPAF_NO_INHERIT);
Index: src/win/iupwin_tabs.c
===================================================================
--- src/win/iupwin_tabs.c	(revision 5971)
+++ src/win/iupwin_tabs.c	(working copy)
@@ -340,6 +340,77 @@
   return winTabsPosFixFromWin(ih, (int)SendMessage(ih->handle, TCM_GETCURSEL, 0, 0));
 }
 
+void iupdrvTabsGetTabSize(Ihandle* ih, const char* tab_title, const char* tab_image, int* tab_width, int* tab_height)
+{
+  int width = 0;
+  int height = 0;
+  int text_width = 0;
+  int text_height = 0;
+  int is_vertical = (ih->data->orientation == ITABS_VERTICAL);
+
+  /* Measure text dimensions */
+  if (tab_title)
+  {
+    text_width = iupdrvFontGetStringWidth(ih, tab_title);
+    iupdrvFontGetCharSize(ih, NULL, &text_height);
+
+    /* LEFT/RIGHT tabs have vertical text (rotated 90 degrees) */
+    if (is_vertical)
+    {
+      width = text_height;   /* text rotated: tab width = text height */
+      height = text_width;   /* text rotated: tab height = text width */
+    }
+    else
+    {
+      width = text_width;    /* horizontal text */
+      height = text_height;
+    }
+  }
+
+  if (tab_image)
+  {
+    void* img = iupImageGetImage(tab_image, ih, 0, NULL);
+    if (img)
+    {
+      int img_w, img_h;
+      iupdrvImageGetInfo(img, &img_w, &img_h, NULL);
+
+      if (is_vertical)
+      {
+        /* For vertical tabs, image is above/below the vertical text */
+        height += img_h;
+        if (tab_title)
+          height += 3;  /* spacing between icon and text */
+        if (img_w > width)
+          width = img_w;
+      }
+      else
+      {
+        /* For horizontal tabs, image is left/right of the text */
+        width += img_w;
+        if (tab_title)
+          width += 3;  /* spacing between icon and text */
+        if (img_h > height)
+          height = img_h;
+      }
+    }
+  }
+
+  if (is_vertical)
+  {
+    width += 12;   /* padding around rotated text width */
+    height += 30;  /* padding around rotated text height (which is text width) */
+  }
+  else
+  {
+    width += 30;   /* padding around text width */
+    height += 12;  /* padding around text height */
+  }
+
+  if (tab_width) *tab_width = width;
+  if (tab_height) *tab_height = height;
+}
+
 static int winTabsGetImageIndex(Ihandle* ih, const char* name)
 {
   HIMAGELIST image_list;
@@ -390,30 +461,75 @@
 
 static void winTabGetPageWindowRect(Ihandle* ih, RECT *rect)
 {
-  /* Calculate the display rectangle, assuming the
-     tab control is the size of the client area. */
-#if 0
   GetClientRect(ih->handle, rect);
-  SendMessage(ih->handle, TCM_ADJUSTRECT, FALSE, (LPARAM)rect);
-#else
+
+  if (ih->data->type == ITABS_LEFT || ih->data->type == ITABS_RIGHT)
   {
-    int x, y, w, h;
-    IupGetIntInt(ih, "CLIENTOFFSET", &x, &y);
-    IupGetIntInt(ih, "CLIENTSIZE", &w, &h);
-    rect->left = x;
-    rect->right = x + w;
-    rect->top = y;
-    rect->bottom = y + h;
+    /* For vertical tabs, measure the actual tab strip width */
+    int tab_count = (int)SendMessage(ih->handle, TCM_GETITEMCOUNT, 0, 0);
+    int tab_width = 0;
+
+    if (tab_count > 0)
+    {
+      RECT tab_rect;
+      /* Get the rectangle of the first tab to measure tab strip width */
+      SendMessage(ih->handle, TCM_GETITEMRECT, 0, (LPARAM)&tab_rect);
+
+      if (ih->data->type == ITABS_LEFT)
+      {
+        /* Tabs on left: content starts after tab strip width */
+        tab_width = tab_rect.right - tab_rect.left;
+        rect->left = tab_width + 4;  /* 4px border */
+        rect->top = 4;
+        rect->right -= 4;
+        rect->bottom -= 4;
+      }
+      else  /* ITABS_RIGHT */
+      {
+        /* Content ends before tab strip */
+        tab_width = tab_rect.right - tab_rect.left;
+        rect->left = 4;
+        rect->top = 4;
+        rect->right -= (tab_width + 4);
+        rect->bottom -= 4;
+      }
+
+      if (rect->left >= rect->right || rect->top >= rect->bottom)
+      {
+        rect->left = 0;
+        rect->top = 0;
+        rect->right = 0;
+        rect->bottom = 0;
+      }
+    }
   }
-#endif
+  else
+  {
+    /* Horizontal tabs */
+    SendMessage(ih->handle, TCM_ADJUSTRECT, FALSE, (LPARAM)rect);
+  }
 }
 
 static void winTabSetPageWindowPos(HWND tab_container, RECT *rect)
-{ 
+{
+  if (rect->right <= 0 || rect->bottom <= 0 ||
+      rect->left >= rect->right || rect->top >= rect->bottom)
+    return;
+
+  /* Only position visible pages. Hidden pages should not be positioned at all. */
+  LONG style = GetWindowLong(tab_container, GWL_STYLE);
+  BOOL has_visible_style = (style & WS_VISIBLE) != 0;
+
+  if (!has_visible_style)
+  {
+    return;
+  }
+
+  /* Position the IupTabsPage window */
   SetWindowPos(tab_container, NULL,
-                rect->left, rect->top,  
-                rect->right - rect->left, rect->bottom - rect->top, 
-                SWP_NOACTIVATE|SWP_NOZORDER);
+                rect->left, rect->top,
+                rect->right - rect->left, rect->bottom - rect->top,
+                SWP_NOACTIVATE | SWP_NOZORDER);
 }
 
 static void winTabsPlacePageWindows(Ihandle* ih, RECT* rect)
@@ -422,7 +538,7 @@
 
   for (child = ih->firstchild; child; child = child->brother)
   {
-    HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_CONTAINER");
+    HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_PAGE");
     winTabSetPageWindowPos(tab_container, rect);
   }
 }
@@ -445,9 +561,11 @@
 }
 
 static LRESULT CALLBACK winTabsPageWndProc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)
-{   
+{
   switch (msg)
   {
+  case WM_PARENTNOTIFY:
+    break;
   case WM_ERASEBKGND:
     {
       Ihandle* ih = iupwinHandleGet(hWnd);
@@ -480,10 +598,10 @@
   return DefWindowProc(hWnd, msg, wp, lp);
 }
 
-static HWND winTabsCreatePageWindow(Ihandle* ih) 
-{ 
+static HWND winTabsCreatePageWindow(Ihandle* ih)
+{
   HWND hWnd;
-  DWORD dwStyle = WS_CHILD|WS_CLIPSIBLINGS, 
+  DWORD dwStyle = WS_CHILD|WS_CLIPSIBLINGS,
       dwExStyle = 0;
 
   iupwinGetNativeParentStyle(ih, &dwExStyle, &dwStyle);
@@ -547,6 +665,18 @@
   tie.lParam = (LPARAM)tab_container;
   SendMessage(ih->handle, TCM_INSERTITEM, p, (LPARAM)&tie);
 
+  if (old_num_tabs == 0)
+  {
+    /* First page - show it */
+    ShowWindow(tab_container, SW_SHOWNOACTIVATE);
+    SendMessage(ih->handle, TCM_SETCURSEL, 0, 0);
+  }
+  else
+  {
+    /* All other pages - hide */
+    ShowWindow(tab_container, SW_HIDE);
+  }
+
   winTabGetPageWindowRect(ih, &rect);
   winTabSetPageWindowPos(tab_container, &rect);
 
@@ -563,13 +693,6 @@
     iupdrvRedrawNow(ih);
   }
 
-  /* the first page of an empty tabs must be shown (set as current) */
-  if (old_num_tabs == 0)
-  {
-    ShowWindow(tab_container, SW_SHOW);
-    SendMessage(ih->handle, TCM_SETCURSEL, 0, 0);
-  }
-
 #if PRINT_VISIBLE_ARRAY
   winTabsPrintVisibleArray(ih);
 #endif
@@ -738,7 +861,7 @@
     {
       if (p < 0)  /* is invisible */
       {
-        HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_CONTAINER");
+        HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_PAGE");
 
         winTabsSetVisibleArrayItem(ih, pos, 1);  /* to visible */
 
@@ -749,7 +872,7 @@
     {
       if (p >= 0)  /* is visible */
       {
-        HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_CONTAINER");
+        HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_PAGE");
 
         iupTabsCheckCurrentTab(ih, pos, 0);
         winTabsSetVisibleArrayItem(ih, pos, 0);  /* to invisible */
@@ -788,6 +911,79 @@
   return 1;
 }
 
+static int winTabsSetAllowReorderAttrib(Ihandle* ih, const char* value)
+{
+  (void)value;
+  return 1;
+}
+
+static void winTabsReorderTab(Ihandle* ih, int source_index, int target_index)
+{
+  TCITEM source_item;
+  TCHAR text_buffer[256];
+  int insert_index, current_sel;
+  Ihandle* source_child;
+  Ihandle* target_child;
+
+  int source_p = winTabsPosFixToWin(ih, source_index);
+  int target_p = winTabsPosFixToWin(ih, target_index);
+
+  if (source_p < 0 || target_p < 0)
+    return;
+
+  source_item.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE;
+  source_item.pszText = text_buffer;
+  source_item.cchTextMax = 256;
+  SendMessage(ih->handle, TCM_GETITEM, source_p, (LPARAM)&source_item);
+
+  SendMessage(ih->handle, TCM_DELETEITEM, source_p, 0);
+
+  insert_index = target_p;
+
+  SendMessage(ih->handle, TCM_INSERTITEM, insert_index, (LPARAM)&source_item);
+
+  source_child = IupGetChild(ih, source_index);
+
+  if (source_child)
+  {
+    Ihandle* ref_child;
+
+    if (source_index < target_index)
+    {
+      ref_child = IupGetChild(ih, target_index + 1);
+      IupReparent(source_child, ih, ref_child);
+    }
+    else
+    {
+      ref_child = IupGetChild(ih, target_index);
+      IupReparent(source_child, ih, ref_child);
+    }
+  }
+
+  current_sel = (int)SendMessage(ih->handle, TCM_GETCURSEL, 0, 0);
+
+  /* Hide the previously active tab's container */
+  if (current_sel >= 0 && current_sel < (int)SendMessage(ih->handle, TCM_GETITEMCOUNT, 0, 0))
+  {
+    int prev_active_pos = winTabsPosFixFromWin(ih, current_sel);
+    HWND prev_tab_container = winTabsGetPageWindow(ih, prev_active_pos);
+    if (prev_tab_container)
+      ShowWindow(prev_tab_container, SW_HIDE);
+  }
+
+  /* Always activate the moved tab after reordering */
+  SendMessage(ih->handle, TCM_SETCURSEL, insert_index, 0);
+
+  /* Show the newly active (moved) tab's container */
+  {
+    HWND new_tab_container = winTabsGetPageWindow(ih, target_index);
+    if (new_tab_container)
+      ShowWindow(new_tab_container, SW_SHOW);
+  }
+
+  IupRefresh(ih);
+}
+
 static int winTabsIsInsideCloseButton(Ihandle* ih, int p)
 {
   RECT rect;
@@ -882,9 +1078,7 @@
     HWND tab_container = winTabsGetPageWindow(ih, pos);
     HWND prev_tab_container = winTabsGetPageWindow(ih, prev_pos);
 
-    if (tab_container) ShowWindow(tab_container, SW_SHOW);   /* show new page, if any */
-    if (prev_tab_container) ShowWindow(prev_tab_container, SW_HIDE); /* hide previous page, if any */
-
+    /* Call the callback first, before showing/hiding windows */
     if (cb)
     {
       Ihandle* child = IupGetChild(ih, pos);
@@ -902,6 +1096,34 @@
         cb2(ih, pos, prev_pos);
     }
 
+    /* Show the new page and position it, hide all others. */
+    RECT rect;
+    winTabGetPageWindowRect(ih, &rect);
+
+    Ihandle* child;
+    int i = 0;
+    for (child = ih->firstchild; child; child = child->brother, i++)
+    {
+      HWND page = (HWND)iupAttribGet(child, "_IUPTAB_PAGE");
+      if (page) {
+        if (i == pos) {
+          /* Position the page FIRST */
+          SetWindowPos(page, NULL,
+                        rect.left, rect.top,
+                        rect.right - rect.left, rect.bottom - rect.top,
+                        SWP_NOACTIVATE | SWP_NOZORDER);
+
+          /* Then show it */
+          ShowWindow(page, SW_SHOWNA);
+
+          /* Bring to front */
+          SetWindowPos(page, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
+        } else {
+          ShowWindow(page, SW_HIDE);
+        }
+      }
+    }
+
     return 0;
   }
 
@@ -946,6 +1168,49 @@
     *result = 0;
     return 1;
   }
+  case WM_PAINT:
+    if (iupAttribGetInt(ih, "_IUPTABS_DRAGGING"))
+    {
+      WNDPROC oldProc = (WNDPROC)IupGetCallback(ih, "_IUPWIN_OLDWNDPROC_CB");
+      CallWindowProc(oldProc, ih->handle, msg, wp, lp);
+
+      {
+        HDC hdc = GetDC(ih->handle);
+        int target = iupAttribGetInt(ih, "_IUPTABS_DRAG_TARGET");
+        int target_p = winTabsPosFixToWin(ih, target);
+        int source = iupAttribGetInt(ih, "_IUPTABS_DRAG_SOURCE");
+        int source_p = winTabsPosFixToWin(ih, source);
+
+        if (target_p >= 0 && source_p >= 0 && target != source)
+        {
+          RECT rc;
+          HPEN pen, old_pen;
+          int x;
+
+          SendMessage(ih->handle, TCM_GETITEMRECT, target_p, (LPARAM)&rc);
+
+          pen = CreatePen(PS_SOLID, 2, RGB(0, 120, 215));
+          old_pen = (HPEN)SelectObject(hdc, pen);
+
+          if (source < target)
+            x = rc.right;
+          else
+            x = rc.left;
+
+          MoveToEx(hdc, x, rc.top, NULL);
+          LineTo(hdc, x, rc.bottom);
+
+          SelectObject(hdc, old_pen);
+          DeleteObject(pen);
+        }
+
+        ReleaseDC(ih->handle, hdc);
+      }
+
+      *result = 0;
+      return 1;
+    }
+    break;
   case WM_MOUSELEAVE:
     if (ih->data->show_close)
     {
@@ -958,7 +1223,6 @@
     }
     break;
   case WM_MOUSEMOVE:
-    if (ih->data->show_close)
     {
       TCHITTESTINFO ht;
       int p, high_p, press_p;
@@ -967,37 +1231,51 @@
       ht.pt.y = GET_Y_LPARAM(lp);
       p = (int)SendMessage(ih->handle, TCM_HITTEST, 0, (LPARAM)&ht);
 
-      high_p = iupAttribGetInt(ih, "_IUPTABS_CLOSEHIGH");
-      if (winTabsIsInsideCloseButton(ih, p))
+      if (ih->data->show_close)
       {
-        if (high_p != p)
+        high_p = iupAttribGetInt(ih, "_IUPTABS_CLOSEHIGH");
+        if (winTabsIsInsideCloseButton(ih, p))
         {
-          /* must be called so WM_MOUSELEAVE will be called */
-          iupwinTrackMouseLeave(ih);
+          if (high_p != p)
+          {
+            iupwinTrackMouseLeave(ih);
+            iupAttribSetInt(ih, "_IUPTABS_CLOSEHIGH", p);
+            iupdrvRedrawNow(ih);
+          }
+        }
+        else
+        {
+          if (high_p != -1)
+          {
+            iupAttribSetInt(ih, "_IUPTABS_CLOSEHIGH", -1);
+            iupdrvRedrawNow(ih);
+          }
+        }
 
-          iupAttribSetInt(ih, "_IUPTABS_CLOSEHIGH", p);
+        press_p = iupAttribGetInt(ih, "_IUPTABS_CLOSEPRESS");
+        if (press_p != -1 && !winTabsIsInsideCloseButton(ih, press_p))
+        {
+          iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", -1);
           iupdrvRedrawNow(ih);
         }
       }
-      else
+
+      if (iupAttribGetInt(ih, "_IUPTABS_DRAGGING"))
       {
-        if (high_p != -1)
+        if (p >= 0)
         {
-          iupAttribSetInt(ih, "_IUPTABS_CLOSEHIGH", -1);
-          iupdrvRedrawNow(ih);
+          int pos = winTabsPosFixFromWin(ih, p);
+          int old_target = iupAttribGetInt(ih, "_IUPTABS_DRAG_TARGET");
+          if (pos != old_target)
+          {
+            iupAttribSetInt(ih, "_IUPTABS_DRAG_TARGET", pos);
+            InvalidateRect(ih->handle, NULL, FALSE);
+          }
         }
       }
-
-      press_p = iupAttribGetInt(ih, "_IUPTABS_CLOSEPRESS");
-      if (press_p != -1 && !winTabsIsInsideCloseButton(ih, press_p))
-      {
-        iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", -1);
-        iupdrvRedrawNow(ih);
-      }
     }
     break;
   case WM_LBUTTONDOWN:
-    if (ih->data->show_close)
     {
       TCHITTESTINFO ht;
       int p;
@@ -1006,59 +1284,94 @@
       ht.pt.y = GET_Y_LPARAM(lp);
       p = (int)SendMessage(ih->handle, TCM_HITTEST, 0, (LPARAM)&ht);
 
-      if (p >= 0 && winTabsIsInsideCloseButton(ih, p))
+      if (ih->data->show_close)
       {
-        iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", p);  /* used for press feedback */
-        iupdrvRedrawNow(ih);
+        if (p >= 0 && winTabsIsInsideCloseButton(ih, p))
+        {
+          iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", p);
+          iupdrvRedrawNow(ih);
 
-        *result = 0;
-        return 1;
+          *result = 0;
+          return 1;
+        }
+        else
+          iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", -1);
       }
-      else
-        iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", -1);
+
+      if (iupAttribGetBoolean(ih, "ALLOWREORDER") && p >= 0 && !winTabsIsInsideCloseButton(ih, p))
+      {
+        int pos = winTabsPosFixFromWin(ih, p);
+        iupAttribSetInt(ih, "_IUPTABS_DRAGGING", 1);
+        iupAttribSetInt(ih, "_IUPTABS_DRAG_SOURCE", pos);
+        iupAttribSetInt(ih, "_IUPTABS_DRAG_TARGET", pos);
+        iupAttribSetInt(ih, "_IUPTABS_DRAG_START_X", ht.pt.x);
+        iupAttribSetInt(ih, "_IUPTABS_DRAG_START_Y", ht.pt.y);
+        SetCapture(ih->handle);
+      }
     }
     break;
   case WM_LBUTTONUP:
-    if (ih->data->show_close)
     {
-      int press_p = iupAttribGetInt(ih, "_IUPTABS_CLOSEPRESS");
-      if (press_p != -1)
+      int is_dragging = iupAttribGetInt(ih, "_IUPTABS_DRAGGING");
+
+      if (is_dragging)
       {
-        if (winTabsIsInsideCloseButton(ih, press_p))
-        {
-          int pos = winTabsPosFixFromWin(ih, press_p);
-          Ihandle *child = IupGetChild(ih, pos);
-          HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_CONTAINER");
+        int source = iupAttribGetInt(ih, "_IUPTABS_DRAG_SOURCE");
+        int target = iupAttribGetInt(ih, "_IUPTABS_DRAG_TARGET");
 
-          iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", -1);
+        ReleaseCapture();
+        iupAttribSet(ih, "_IUPTABS_DRAGGING", NULL);
 
-          if (tab_container)
+        if (source != target)
+          winTabsReorderTab(ih, source, target);
+
+        InvalidateRect(ih->handle, NULL, TRUE);
+
+        *result = 0;
+        return 1;
+      }
+
+      if (ih->data->show_close)
+      {
+        int press_p = iupAttribGetInt(ih, "_IUPTABS_CLOSEPRESS");
+        if (press_p != -1)
+        {
+          if (winTabsIsInsideCloseButton(ih, press_p))
           {
-            int ret = IUP_DEFAULT;
-            IFni cb = (IFni)IupGetCallback(ih, "TABCLOSE_CB");
-            if (cb)
-              ret = cb(ih, pos);
+            int pos = winTabsPosFixFromWin(ih, press_p);
+            Ihandle *child = IupGetChild(ih, pos);
+            HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_PAGE");
 
-            if (ret == IUP_CONTINUE) /* destroy tab and children */
+            iupAttribSetInt(ih, "_IUPTABS_CLOSEPRESS", -1);
+
+            if (tab_container)
             {
-              IupDestroy(child);
-              IupRefreshChildren(ih);
+              int ret = IUP_DEFAULT;
+              IFni cb = (IFni)IupGetCallback(ih, "TABCLOSE_CB");
+              if (cb)
+                ret = cb(ih, pos);
+
+              if (ret == IUP_CONTINUE)
+              {
+                IupDestroy(child);
+                IupRefreshChildren(ih);
+              }
+              else if (ret == IUP_DEFAULT)
+              {
+                iupTabsCheckCurrentTab(ih, pos, 0);
+                winTabsSetVisibleArrayItem(ih, pos, 0);
+                winTabsDeleteItem(ih, press_p, tab_container);
+              }
+              else if (ret == IUP_IGNORE)
+              {
+                *result = 0;
+                return 1;
+              }
             }
-            else if (ret == IUP_DEFAULT) /* hide tab and children */
-            {
-              iupTabsCheckCurrentTab(ih, pos, 0);
-              winTabsSetVisibleArrayItem(ih, pos, 0);  /* to invisible */
-              winTabsDeleteItem(ih, press_p, tab_container);
-            }
-            else if (ret == IUP_IGNORE)
-            {
-              *result = 0;
-              return 1;
-            }
           }
+
+          iupdrvRedrawNow(ih);
         }
-
-        iupdrvRedrawNow(ih);
       }
     }
     break;
@@ -1291,8 +1604,9 @@
     HWND tab_container = winTabsCreatePageWindow(ih);
 
     iupAttribSet(child, "_IUPTAB_CONTAINER", (char*)tab_container);
+    iupAttribSet(child, "_IUPTAB_PAGE", (char*)tab_container);
 
-    winTabsInsertVisibleArrayItem(ih, pos);  /* add to the array and set to visible */
+    winTabsInsertVisibleArrayItem(ih, pos);
 
     winTabsInsertItem(ih, child, pos, tab_container);
   }
@@ -1302,7 +1616,7 @@
 {
   if (ih->handle)
   {
-    HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_CONTAINER");
+    HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_PAGE");
     if (tab_container)
     {
       int p = winTabsGetPageWindowPos(ih, tab_container);
@@ -1315,6 +1629,7 @@
       iupwinHandleRemove(tab_container);
       DestroyWindow(tab_container);
       iupAttribSet(child, "_IUPTAB_CONTAINER", NULL);
+      iupAttribSet(child, "_IUPTAB_PAGE", NULL);
     }
   }
 }
@@ -1410,6 +1725,23 @@
       /* current value is now given by the native system */
       iupAttribSet(ih, "_IUPTABS_VALUE_HANDLE", NULL);
     }
+
+    /* Hide all pages except the currently active one. */
+    int current_tab = iupdrvTabsGetCurrentTab(ih);
+
+    int pos = 0;
+    for (child = ih->firstchild; child; child = child->brother, pos++)
+    {
+      HWND tab_container = (HWND)iupAttribGet(child, "_IUPTAB_PAGE");
+      if (tab_container)
+      {
+        if (pos == current_tab) {
+          ShowWindow(tab_container, SW_SHOWNA);
+        } else {
+          ShowWindow(tab_container, SW_HIDE);
+        }
+      }
+    }
   }
 
   return IUP_NOERROR;
@@ -1443,15 +1775,16 @@
 static void winTabsRegisterClass(void)
 {
   WNDCLASS wndclass;
+
   ZeroMemory(&wndclass, sizeof(WNDCLASS));
-  
+
   wndclass.hInstance      = iupwin_hinstance;
   wndclass.lpszClassName  = TEXT("IupTabsPage");
   wndclass.lpfnWndProc    = (WNDPROC)winTabsPageWndProc;
   wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
   wndclass.style          = CS_PARENTDC;
+
   wndclass.hbrBackground  = NULL;  /* remove the background to optimize redraw */
-   
   RegisterClass(&wndclass);
 }
 
@@ -1493,6 +1826,7 @@
   iupClassRegisterAttributeId(ic, "TABIMAGE", NULL, winTabsSetTabImageAttrib, IUPAF_IHANDLENAME|IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
   iupClassRegisterAttributeId(ic, "TABVISIBLE", iupTabsGetTabVisibleAttrib, winTabsSetTabVisibleAttrib, IUPAF_NO_DEFAULTVALUE | IUPAF_NO_INHERIT);
   iupClassRegisterAttribute(ic, "TABPADDING", iupTabsGetTabPaddingAttrib, winTabsSetTabPaddingAttrib, IUPAF_SAMEASSYSTEM, "0x0", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
+  iupClassRegisterAttribute(ic, "ALLOWREORDER", NULL, winTabsSetAllowReorderAttrib, IUPAF_SAMEASSYSTEM, "NO", IUPAF_NOT_MAPPED|IUPAF_NO_INHERIT);
 
   /* necessary because transparent background does not work when not using visual styles */
   if (!iupwin_comctl32ver6)  /* Used by iupdrvImageCreateImage */
Index: src/win/iupwin_text.c
===================================================================
--- src/win/iupwin_text.c	(revision 5971)
+++ src/win/iupwin_text.c	(working copy)
@@ -93,9 +93,16 @@
   int border_size = 2 * 3;
   (*w) += border_size;
   (*h) += border_size;
-  (void)ih;  
+  (void)ih;
 }
 
+void iupdrvTextAddExtraPadding(Ihandle* ih, int *w, int *h)
+{
+  (void)ih;
+  (void)w;
+  (void)h;
+}
+
 static void winTextParseParagraphFormat(Ihandle* formattag, PARAFORMAT2 *paraformat, int convert2twips)
 {
   int val;
@@ -1976,7 +1983,7 @@
       {
         char* value;
         WNDPROC oldProc = (WNDPROC)IupGetCallback(ih, "_IUPWIN_OLDWNDPROC_CB");
-        CallWindowProc(oldProc, ih->handle, WM_UNDO, 0, 0); /* call the proc so we have the changed value for action, but this will trigger VALUECHANGED_CB */
+        CallWindowProc(oldProc, ih->handle, WM_UNDO, 0, 0);
 
         value = winTextGetValueAttrib(ih);
         cb(ih, 0, (char*)value);
@@ -2105,7 +2112,6 @@
       iupBaseCallValueChangedCb(ih);
       break;
     }
-
   }
 
   (void)lp;
Index: src/win/iupwin_timer.c
===================================================================
--- src/win/iupwin_timer.c	(revision 5971)
+++ src/win/iupwin_timer.c	(working copy)
@@ -5,9 +5,10 @@
  */
 
 #include <windows.h>
- 
+
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdint.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -71,7 +72,7 @@
     long long start;
 
     ih->serial = (int)SetTimer(NULL, 0, time_ms, winTimerFunc);  /* minimum is 10 ms */
-    iupTableSet(wintimer_id_table, (const char*)ih->serial, ih, IUPTABLE_POINTER);
+    iupTableSet(wintimer_id_table, (const char*)(intptr_t)ih->serial, ih, IUPTABLE_POINTER);
 
     start = winTimerGetTickCount();
     iupAttribSetStrf(ih, "STARTCOUNT", "%lld", start);
@@ -83,7 +84,7 @@
   if (ih->serial > 0)
   {
     KillTimer(NULL, ih->serial);
-    iupTableRemove(wintimer_id_table, (const char*)ih->serial);
+    iupTableRemove(wintimer_id_table, (const char*)(intptr_t)ih->serial);
     ih->serial = -1;
   }
 }
Index: src/win/iupwin_toggle.c
===================================================================
--- src/win/iupwin_toggle.c	(revision 5971)
+++ src/win/iupwin_toggle.c	(working copy)
@@ -28,24 +28,214 @@
 #include "iupwin_draw.h"
 #include "iupwin_str.h"
 
+#include "wdl.h"
 
+
+/* Windows 11 ToggleSwitch dimensions (matching ModernWpf/WinUI 3 specs) */
+#define SWITCH_TRACK_WIDTH  40
+#define SWITCH_TRACK_HEIGHT 20
+#define SWITCH_THUMB_SIZE   12  /* Normal state: 12x12, scales to 14x14 on hover */
+#define SWITCH_THUMB_MARGIN 4   /* (20 - 12) / 2 = 4px margin on each side */
+
+/* Animation parameters (matching Windows 11 ModernWpf specs) */
+#define SWITCH_ANIMATION_DURATION 367  /* milliseconds (0.367s reposition duration) */
+#define SWITCH_ANIMATION_FPS      60   /* frames per second */
+#define SWITCH_ANIMATION_INTERVAL (1000 / SWITCH_ANIMATION_FPS)  /* ~16ms */
+
+typedef struct _IupWinSwitchData
+{
+  double thumb_position;      /* 0.0 = left (off), 1.0 = right (on) */
+  double animation_start;     /* Animation start position */
+  double animation_end;       /* Animation end position */
+  DWORD animation_start_time; /* GetTickCount() when animation started */
+  UINT_PTR timer_id;          /* Timer ID for animation */
+  int is_animating;           /* 1 if animation in progress */
+  int checked_state;          /* Current checked state (BST_CHECKED or BST_UNCHECKED) */
+  int is_hovering;            /* 1 if mouse is over the control */
+} IupWinSwitchData;
+
+static double winSwitchEaseInOutQuad(double t)
+{
+  if (t < 0.5)
+    return 2.0 * t * t;
+  else
+    return 1.0 - 2.0 * (1.0 - t) * (1.0 - t);
+}
+
+static void winSwitchAnimationStep(Ihandle* ih, IupWinSwitchData* switch_data)
+{
+  DWORD current_time = GetTickCount();
+  DWORD elapsed = current_time - switch_data->animation_start_time;
+
+  if (elapsed >= SWITCH_ANIMATION_DURATION)
+  {
+    /* Animation complete */
+    switch_data->thumb_position = switch_data->animation_end;
+    switch_data->is_animating = 0;
+
+    if (switch_data->timer_id != 0)
+    {
+      KillTimer(ih->handle, switch_data->timer_id);
+      switch_data->timer_id = 0;
+    }
+  }
+  else
+  {
+    /* Interpolate with easing */
+    double t = (double)elapsed / (double)SWITCH_ANIMATION_DURATION;
+    double eased_t = winSwitchEaseInOutQuad(t);
+    switch_data->thumb_position = switch_data->animation_start +
+                                   (switch_data->animation_end - switch_data->animation_start) * eased_t;
+  }
+
+  /* Trigger repaint */
+  InvalidateRect(ih->handle, NULL, FALSE);
+}
+
+static VOID CALLBACK winSwitchTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
+{
+  Ihandle* ih;
+  IupWinSwitchData* switch_data;
+
+  (void)uMsg;
+  (void)dwTime;
+
+  ih = iupwinHandleGet(hwnd);
+  if (!ih)
+    return;
+
+  switch_data = (IupWinSwitchData*)iupAttribGet(ih, "_IUPWIN_SWITCHDATA");
+  if (!switch_data || switch_data->timer_id != idEvent)
+    return;
+
+  winSwitchAnimationStep(ih, switch_data);
+}
+
+static void winSwitchStartAnimation(Ihandle* ih, IupWinSwitchData* switch_data, int checked)
+{
+  switch_data->animation_start = switch_data->thumb_position;
+  switch_data->animation_end = checked ? 1.0 : 0.0;
+  switch_data->animation_start_time = GetTickCount();
+  switch_data->is_animating = 1;
+
+  if (switch_data->timer_id == 0)
+  {
+    /* Use a unique timer ID and callback function */
+    UINT_PTR timer_id = SetTimer(ih->handle, (UINT_PTR)ih->handle, SWITCH_ANIMATION_INTERVAL, winSwitchTimerProc);
+    switch_data->timer_id = timer_id;
+  }
+  else
+  {
+    /* Update animation parameters for new click */
+    switch_data->animation_start = switch_data->thumb_position;
+    switch_data->animation_end = checked ? 1.0 : 0.0;
+    switch_data->animation_start_time = GetTickCount();
+  }
+
+  /* Trigger immediate repaint for first frame */
+  InvalidateRect(ih->handle, NULL, FALSE);
+}
+
+static void winSwitchCustomDraw(Ihandle* ih, HDC hDC, RECT* rect, UINT itemState)
+{
+  IupWinSwitchData* switch_data = (IupWinSwitchData*)iupAttribGet(ih, "_IUPWIN_SWITCHDATA");
+  if (!switch_data)
+    return;
+
+  WD_HCANVAS canvas = wdCreateCanvasWithHDC(hDC, rect, WD_CANVAS_NOGDICOMPAT);
+  if (!canvas)
+  {
+    return;
+  }
+
+  wdBeginPaint(canvas);
+
+  int is_checked = (switch_data->checked_state == BST_CHECKED);
+  int is_disabled = (itemState & ODS_DISABLED) != 0;
+
+  /* Get theme colors - interpolate during animation for smooth transition */
+  COLORREF track_color_ref, thumb_color_ref;
+  COLORREF track_off_color = GetSysColor(COLOR_BTNSHADOW);
+  COLORREF track_on_color = GetSysColor(COLOR_HIGHLIGHT);
+
+  if (is_disabled)
+  {
+    /* Disabled: use consistent gray regardless of checked state */
+    track_color_ref = GetSysColor(COLOR_BTNSHADOW);
+    thumb_color_ref = GetSysColor(COLOR_BTNFACE);
+  }
+  else
+  {
+    /* Interpolate track color based on thumb position for smooth transition */
+    float pos = (float)switch_data->thumb_position;
+    track_color_ref = RGB(
+      (int)(GetRValue(track_off_color) * (1.0f - pos) + GetRValue(track_on_color) * pos),
+      (int)(GetGValue(track_off_color) * (1.0f - pos) + GetGValue(track_on_color) * pos),
+      (int)(GetBValue(track_off_color) * (1.0f - pos) + GetBValue(track_on_color) * pos)
+    );
+    thumb_color_ref = GetSysColor(COLOR_WINDOW);
+  }
+
+  WD_COLOR track_color = WD_COLOR_FROM_GDI(track_color_ref);
+  WD_COLOR thumb_color = WD_COLOR_FROM_GDI(thumb_color_ref);
+
+  WD_HBRUSH track_brush = wdCreateSolidBrush(canvas, track_color);
+  WD_HBRUSH thumb_brush = wdCreateSolidBrush(canvas, thumb_color);
+
+  /* Draw track using native Direct2D rounded rectangle (optimized, no path allocation) */
+  float radius = SWITCH_TRACK_HEIGHT / 2.0f;
+  wdFillRoundedRect(canvas, track_brush, 0.0f, 0.0f, (float)SWITCH_TRACK_WIDTH, (float)SWITCH_TRACK_HEIGHT, radius);
+
+  /* WinUI 3: Thumb expands from 12x12 to 14x14 on hover */
+  int thumb_size = switch_data->is_hovering ? 14 : SWITCH_THUMB_SIZE;
+  float thumb_x_min = (float)SWITCH_THUMB_MARGIN;
+  float thumb_x_max = (float)(SWITCH_TRACK_WIDTH - thumb_size - SWITCH_THUMB_MARGIN);
+  float thumb_x = thumb_x_min + (thumb_x_max - thumb_x_min) * (float)switch_data->thumb_position;
+  float thumb_y = (SWITCH_TRACK_HEIGHT - thumb_size) / 2.0f;
+  float thumb_radius = thumb_size / 2.0f;
+
+  wdFillCircle(canvas, thumb_brush, thumb_x + thumb_radius, thumb_y + thumb_radius, thumb_radius);
+
+  wdDestroyBrush(thumb_brush);
+  wdDestroyBrush(track_brush);
+
+  wdEndPaint(canvas);
+  wdDestroyCanvas(canvas);
+}
+
 void iupdrvToggleAddBorders(Ihandle* ih, int *x, int *y)
 {
   iupdrvButtonAddBorders(ih, x, y);
 }
 
+void iupdrvToggleAddSwitch(Ihandle* ih, int *x, int *y, const char* str)
+{
+  int switch_w = SWITCH_TRACK_WIDTH;
+  int switch_h = SWITCH_TRACK_HEIGHT;
+  (void)ih;
+
+  (*x) += 2 + switch_w + 2;
+  if ((*y) < 2 + switch_h + 8)
+    (*y) = 2 + switch_h + 8;
+  else
+    (*y) += 2 + 8;
+
+  if (str && str[0])
+    (*x) += 8;
+}
+
 void iupdrvToggleAddCheckBox(Ihandle* ih, int *x, int *y, const char* str)
 {
-  /* LAYOUT_DECORATION_ESTIMATE */
   int check_box = 16;
   (void)ih;
+
   if (iupwinGetScreenRes() > 120)
     check_box = 26;
 
   (*x) += check_box;
-  if ((*y) < check_box) (*y) = check_box; /* minimum height */
+  if ((*y) < check_box) (*y) = check_box;
 
-  if (str && str[0]) /* add spacing between check box and text */
+  if (str && str[0])
   {
     (*x) += 8;
 
@@ -352,7 +542,29 @@
   else
     check = BST_UNCHECKED;
 
-  /* This is necessary because Windows does not handle the radio state 
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupWinSwitchData* switch_data = (IupWinSwitchData*)iupAttribGet(ih, "_IUPWIN_SWITCHDATA");
+    int oldcheck = winToggleGetCheck(ih);
+
+    if (check == -1)
+    {
+      if (oldcheck)
+        check = BST_UNCHECKED;
+      else
+        check = BST_CHECKED;
+    }
+
+    winToggleSetCheck(ih, check);
+
+    /* Start animation if value changed */
+    if (switch_data && oldcheck != check)
+      winSwitchStartAnimation(ih, switch_data, check);
+
+    return 0;
+  }
+
+  /* This is necessary because Windows does not handle the radio state
      when a toggle is programmatically changed. */
   radio = iupRadioFindToggleParent(ih);
   if (radio)
@@ -578,6 +790,90 @@
   return iupwinBaseMsgProc(ih, msg, wp, lp, result);
 }
 
+static int winToggleSwitchMsgProc(Ihandle* ih, UINT msg, WPARAM wp, LPARAM lp, LRESULT *result)
+{
+  IupWinSwitchData* switch_data = (IupWinSwitchData*)iupAttribGet(ih, "_IUPWIN_SWITCHDATA");
+
+  switch (msg)
+  {
+  case WM_MOUSEMOVE:
+    /* Track mouse hover for thumb expansion */
+    if (switch_data && !switch_data->is_hovering)
+    {
+      /* Enable mouse leave tracking */
+      iupwinTrackMouseLeave(ih);
+
+      switch_data->is_hovering = 1;
+      InvalidateRect(ih->handle, NULL, FALSE);
+    }
+    break;
+  case WM_MOUSELEAVE:
+    /* Remove hover state */
+    if (switch_data && switch_data->is_hovering)
+    {
+      switch_data->is_hovering = 0;
+      InvalidateRect(ih->handle, NULL, FALSE);
+    }
+    break;
+  case WM_LBUTTONDOWN:
+    /* Capture mouse to ensure we get WM_LBUTTONUP */
+    SetCapture(ih->handle);
+    *result = 0;
+    return 0;
+  case WM_LBUTTONUP:
+    /* Release mouse capture */
+    ReleaseCapture();
+
+    {
+      IFni cb;
+      int check = switch_data->checked_state;
+      int new_check = (check == BST_CHECKED) ? BST_UNCHECKED : BST_CHECKED;
+
+      /* Store the new checked state */
+      switch_data->checked_state = new_check;
+
+      /* Update the underlying button state (but this doesn't affect custom drawing) */
+      SendMessage(ih->handle, BM_SETCHECK, new_check, 0L);
+
+      /* Start animation (this triggers InvalidateRect internally) */
+      if (switch_data)
+        winSwitchStartAnimation(ih, switch_data, new_check);
+
+      cb = (IFni)IupGetCallback(ih, "ACTION");
+      if (cb && cb(ih, new_check) == IUP_CLOSE)
+        IupExitLoop();
+
+      if (iupObjectCheck(ih))
+        iupBaseCallValueChangedCb(ih);
+    }
+    *result = 0;
+    return 1;
+  case WM_THEMECHANGED:
+  case WM_SYSCOLORCHANGE:
+    /* Redraw on theme change */
+    InvalidateRect(ih->handle, NULL, TRUE);
+    break;
+  }
+
+  return iupwinBaseMsgProc(ih, msg, wp, lp, result);
+}
+
+static void winToggleSwitchDrawItem(Ihandle* ih, DRAWITEMSTRUCT* dis)
+{
+  int width = dis->rcItem.right - dis->rcItem.left;
+  int height = dis->rcItem.bottom - dis->rcItem.top;
+  HDC hDC;
+  iupwinBitmapDC bmpDC;
+
+  hDC = iupwinDrawCreateBitmapDC(&bmpDC, dis->hDC, 0, 0, width, height);
+
+  iupwinDrawParentBackground(ih, hDC, &dis->rcItem);
+
+  winSwitchCustomDraw(ih, hDC, &dis->rcItem, dis->itemState);
+
+  iupwinDrawDestroyBitmapDC(&bmpDC);
+}
+
 static int winToggleWmCommand(Ihandle* ih, WPARAM wp, LPARAM lp)
 {
   (void)lp;
@@ -594,6 +890,31 @@
       IFni cb;
       int check = winToggleGetCheck(ih);
 
+      if (iupAttribGetBoolean(ih, "SWITCH"))
+      {
+        IupWinSwitchData* switch_data = (IupWinSwitchData*)iupAttribGet(ih, "_IUPWIN_SWITCHDATA");
+
+        /* Manually toggle the state (BS_OWNERDRAW doesn't auto-toggle) */
+        int new_check = (check == BST_CHECKED) ? BST_UNCHECKED : BST_CHECKED;
+        winToggleSetCheck(ih, new_check);
+
+        /* Start animation */
+        if (switch_data)
+          winSwitchStartAnimation(ih, switch_data, new_check);
+
+        cb = (IFni)IupGetCallback(ih, "ACTION");
+        if (cb && cb(ih, new_check) == IUP_CLOSE)
+          IupExitLoop();
+
+        if (iupObjectCheck(ih))
+          iupBaseCallValueChangedCb(ih);
+
+        /* Redraw immediately */
+        InvalidateRect(ih->handle, NULL, FALSE);
+
+        return 0;
+      }
+
       if (ih->data->type==IUP_TOGGLE_IMAGE && !iupwin_comctl32ver6 && !ih->data->flat)
       {
         int active = winToggleIsActive(ih);
@@ -605,11 +926,6 @@
       radio = iupRadioFindToggleParent(ih);
       if (radio)
       {
-        /* This is necessary because Windows does not send a message
-           when a toggle is unchecked in a Radio. 
-           Also if the toggle is already checked in a radio, 
-           a click will call the callback again. */
-
         Ihandle* last_tg = (Ihandle*)iupAttribGet(radio, "_IUPWIN_LASTTOGGLE");
         if (iupObjectCheck(last_tg) && last_tg != ih)
         {
@@ -664,6 +980,24 @@
   return 0; /* not used */
 }
 
+static void winToggleUnMapMethod(Ihandle* ih)
+{
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupWinSwitchData* switch_data = (IupWinSwitchData*)iupAttribGet(ih, "_IUPWIN_SWITCHDATA");
+    if (switch_data)
+    {
+      if (switch_data->timer_id)
+        KillTimer(ih->handle, switch_data->timer_id);
+
+      free(switch_data);
+      iupAttribSet(ih, "_IUPWIN_SWITCHDATA", NULL);
+    }
+  }
+
+  iupdrvBaseUnMapMethod(ih);
+}
+
 static int winToggleMapMethod(Ihandle* ih)
 {
   Ihandle* radio = iupRadioFindToggleParent(ih);
@@ -678,6 +1012,65 @@
   if (radio)
     ih->data->is_radio = 1;
 
+  if (iupAttribGetBoolean(ih, "SWITCH"))
+  {
+    IupWinSwitchData* switch_data;
+
+    /* SWITCH must be a checkbox (not radio) */
+    if (ih->data->is_radio)
+    {
+      iupAttribSet(ih, "SWITCH", "NO");
+      goto regular_toggle;
+    }
+
+    ih->data->type = IUP_TOGGLE_TEXT;
+    dwStyle |= BS_OWNERDRAW | BS_CHECKBOX;
+    ownerdraw = 1;
+
+    /* Add tabstop if can focus */
+    if (iupAttribGetBoolean(ih, "CANFOCUS"))
+      dwStyle |= WS_TABSTOP;
+
+    /* Allocate switch data */
+    switch_data = (IupWinSwitchData*)malloc(sizeof(IupWinSwitchData));
+    memset(switch_data, 0, sizeof(IupWinSwitchData));
+    iupAttribSet(ih, "_IUPWIN_SWITCHDATA", (char*)switch_data);
+
+    /* Create the window */
+    if (!iupwinCreateWindow(ih, WC_BUTTON, 0, dwStyle, NULL))
+    {
+      free(switch_data);
+      return IUP_ERROR;
+    }
+
+    /* Set up switch-specific callbacks */
+    IupSetCallback(ih, "_IUPWIN_COMMAND_CB", (Icallback)winToggleWmCommand);
+    IupSetCallback(ih, "_IUPWIN_CTLCOLOR_CB", (Icallback)winToggleCtlColor);
+    IupSetCallback(ih, "_IUPWIN_DRAWITEM_CB", (Icallback)winToggleSwitchDrawItem);
+    IupSetCallback(ih, "_IUPWIN_CTRLMSGPROC_CB", (Icallback)winToggleSwitchMsgProc);
+
+    /* Initialize thumb position and checked state based on initial value */
+    value = iupAttribGet(ih, "VALUE");
+    if (value && (iupStrEqualNoCase(value, "ON") || iupStrEqualNoCase(value, "YES") || iupStrEqual(value, "1")))
+    {
+      switch_data->thumb_position = 1.0;
+      switch_data->checked_state = BST_CHECKED;
+      winToggleSetCheck(ih, BST_CHECKED);
+    }
+    else
+    {
+      switch_data->thumb_position = 0.0;
+      switch_data->checked_state = BST_UNCHECKED;
+      winToggleSetCheck(ih, BST_UNCHECKED);
+    }
+
+    /* Force initial paint */
+    InvalidateRect(ih->handle, NULL, TRUE);
+
+    return IUP_NOERROR;
+  }
+
+regular_toggle:
   value = iupAttribGet(ih, "IMAGE");
   if (value)
   {
@@ -766,6 +1159,7 @@
 {
   /* Driver Dependent Class functions */
   ic->Map = winToggleMapMethod;
+  ic->UnMap = winToggleUnMapMethod;
 
   /* Driver Dependent Attribute functions */
 
Index: src/win/iupwin_tree.c
===================================================================
--- src/win/iupwin_tree.c	(revision 5971)
+++ src/win/iupwin_tree.c	(working copy)
@@ -12,6 +12,7 @@
 #include <string.h>
 #include <memory.h>
 #include <stdarg.h>
+#include <stdint.h>
 
 #include "iup.h"
 #include "iupcbs.h"
@@ -190,9 +191,9 @@
   iupwinGetColor(iupAttribGetStr(ih, "FGCOLOR"), &itemData->color);
 
   if (kind == ITREE_BRANCH)
-    item.iSelectedImage = item.iImage = (int)ih->data->def_image_collapsed;
+    item.iSelectedImage = item.iImage = (int)(intptr_t)ih->data->def_image_collapsed;
   else
-    item.iSelectedImage = item.iImage = (int)ih->data->def_image_leaf;
+    item.iSelectedImage = item.iImage = (int)(intptr_t)ih->data->def_image_leaf;
 
   /* Save the heading level in the node's application-defined data area */
   tvins.item = item;
@@ -300,9 +301,9 @@
   itemData = (winTreeItemData*)item.lParam;
 
   if (expand)
-    item.iSelectedImage = item.iImage = (itemData->image_expanded!=-1)? itemData->image_expanded: (int)ih->data->def_image_expanded;
+    item.iSelectedImage = item.iImage = (itemData->image_expanded!=-1)? itemData->image_expanded: (int)(intptr_t)ih->data->def_image_expanded;
   else
-    item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)ih->data->def_image_collapsed;
+    item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)(intptr_t)ih->data->def_image_collapsed;
 
   item.hItem = hItem;
   item.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
@@ -643,7 +644,7 @@
         if (mode == ITREE_UPDATEIMAGE_EXPANDED)
         {
           item.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
-          item.iSelectedImage = item.iImage = (itemData->image_expanded!=-1)? itemData->image_expanded: (int)ih->data->def_image_expanded;
+          item.iSelectedImage = item.iImage = (itemData->image_expanded!=-1)? itemData->image_expanded: (int)(intptr_t)ih->data->def_image_expanded;
           SendMessage(ih->handle, TVM_SETITEM, 0, (LPARAM)(LPTVITEM)&item);
         }
       }
@@ -652,7 +653,7 @@
         if (mode == ITREE_UPDATEIMAGE_COLLAPSED)
         {
           item.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
-          item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)ih->data->def_image_collapsed;
+          item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)(intptr_t)ih->data->def_image_collapsed;
           SendMessage(ih->handle, TVM_SETITEM, 0, (LPARAM)(LPTVITEM)&item);
         }
       }
@@ -662,7 +663,7 @@
       if (mode == ITREE_UPDATEIMAGE_LEAF)
       {
         item.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
-        item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)ih->data->def_image_leaf;
+        item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)(intptr_t)ih->data->def_image_leaf;
         SendMessage(ih->handle, TVM_SETITEM, 0, (LPARAM)(LPTVITEM)&item);
       }
     }
@@ -973,7 +974,7 @@
 
 static int winTreeSetImageBranchExpandedAttrib(Ihandle* ih, const char* value)
 {
-  ih->data->def_image_expanded = (void*)winTreeGetImageIndex(ih, value);
+  ih->data->def_image_expanded = (void*)(intptr_t)winTreeGetImageIndex(ih, value);
 
   /* Update all images */
   winTreeUpdateImages(ih, ITREE_UPDATEIMAGE_EXPANDED);
@@ -983,7 +984,7 @@
 
 static int winTreeSetImageBranchCollapsedAttrib(Ihandle* ih, const char* value)
 {
-  ih->data->def_image_collapsed = (void*)winTreeGetImageIndex(ih, value);
+  ih->data->def_image_collapsed = (void*)(intptr_t)winTreeGetImageIndex(ih, value);
 
   /* Update all images */
   winTreeUpdateImages(ih, ITREE_UPDATEIMAGE_COLLAPSED);
@@ -993,7 +994,7 @@
 
 static int winTreeSetImageLeafAttrib(Ihandle* ih, const char* value)
 {
-  ih->data->def_image_leaf = (void*)winTreeGetImageIndex(ih, value);
+  ih->data->def_image_leaf = (void*)(intptr_t)winTreeGetImageIndex(ih, value);
 
   /* Update all images */
   winTreeUpdateImages(ih, ITREE_UPDATEIMAGE_LEAF);
@@ -1018,7 +1019,7 @@
   if (itemData->kind == ITREE_BRANCH && item.state & TVIS_EXPANDED)
   {
     if (itemData->image_expanded == -1)
-      item.iSelectedImage = item.iImage = (int)ih->data->def_image_expanded;
+      item.iSelectedImage = item.iImage = (int)(intptr_t)ih->data->def_image_expanded;
     else
       item.iSelectedImage = item.iImage = itemData->image_expanded;
     item.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
@@ -1047,7 +1048,7 @@
     if (!(item.state & TVIS_EXPANDED))
     {
       if (itemData->image == -1)
-        item.iSelectedImage = item.iImage = (int)ih->data->def_image_collapsed;
+        item.iSelectedImage = item.iImage = (int)(intptr_t)ih->data->def_image_collapsed;
       else
         item.iSelectedImage = item.iImage = itemData->image;
 
@@ -1058,7 +1059,7 @@
   else
   {
     if (itemData->image == -1)
-      item.iSelectedImage = item.iImage = (int)ih->data->def_image_leaf;
+      item.iSelectedImage = item.iImage = (int)(intptr_t)ih->data->def_image_leaf;
     else
       item.iSelectedImage = item.iImage = itemData->image;
 
@@ -2872,9 +2873,9 @@
       winTreeItemData* itemData = (winTreeItemData*)tree_info->itemNew.lParam;
 
       if (tree_info->action == TVE_EXPAND)
-        item.iSelectedImage = item.iImage = (itemData->image_expanded!=-1)? itemData->image_expanded: (int)ih->data->def_image_expanded;
+        item.iSelectedImage = item.iImage = (itemData->image_expanded!=-1)? itemData->image_expanded: (int)(intptr_t)ih->data->def_image_expanded;
       else
-        item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)ih->data->def_image_collapsed;
+        item.iSelectedImage = item.iImage = (itemData->image!=-1)? itemData->image: (int)(intptr_t)ih->data->def_image_collapsed;
 
       item.hItem = hItem;
       item.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
@@ -3143,9 +3144,9 @@
   }
 
   /* Initialize the default images */
-  ih->data->def_image_leaf = (void*)winTreeGetImageIndex(ih, iupAttribGetStr(ih, "IMAGELEAF"));
-  ih->data->def_image_collapsed = (void*)winTreeGetImageIndex(ih, iupAttribGetStr(ih, "IMAGEBRANCHCOLLAPSED"));
-  ih->data->def_image_expanded = (void*)winTreeGetImageIndex(ih, iupAttribGetStr(ih, "IMAGEBRANCHEXPANDED"));
+  ih->data->def_image_leaf = (void*)(intptr_t)winTreeGetImageIndex(ih, iupAttribGetStr(ih, "IMAGELEAF"));
+  ih->data->def_image_collapsed = (void*)(intptr_t)winTreeGetImageIndex(ih, iupAttribGetStr(ih, "IMAGEBRANCHCOLLAPSED"));
+  ih->data->def_image_expanded = (void*)(intptr_t)winTreeGetImageIndex(ih, iupAttribGetStr(ih, "IMAGEBRANCHEXPANDED"));
 
   if (ih->data->show_toggle)
   {
Index: src/win/iupwindows_help.c
===================================================================
--- src/win/iupwindows_help.c	(revision 5971)
+++ src/win/iupwindows_help.c	(working copy)
@@ -11,7 +11,6 @@
 #include <stdio.h>
 
 #include "iup.h"
-#include "iupwin_str.h"
 
 #ifndef SEE_MASK_NOASYNC
 #define SEE_MASK_NOASYNC 0x00000100
@@ -19,7 +18,7 @@
 
 IUP_API int IupExecute(const char *filename, const char* parameters)
 {
-  int err = (int)ShellExecute(GetDesktopWindow(), TEXT("open"), iupwinStrToSystemFilename(filename), iupwinStrToSystemFilename(parameters), NULL, SW_SHOWNORMAL);
+  INT_PTR err = (INT_PTR)ShellExecuteA(GetDesktopWindow(), "open", filename, parameters, NULL, SW_SHOWNORMAL);
   if (err <= 32)
   {
     switch (err)
@@ -35,21 +34,21 @@
 }
 
 IUP_API int IupExecuteWait(const char *filename, const char* parameters)
-{                                          
-  SHELLEXECUTEINFO ExecInfo;
-  memset(&ExecInfo, 0, sizeof(SHELLEXECUTEINFO));
+{
+  SHELLEXECUTEINFOA ExecInfo;
+  memset(&ExecInfo, 0, sizeof(SHELLEXECUTEINFOA));
 
-  ExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);
+  ExecInfo.cbSize = sizeof(SHELLEXECUTEINFOA);
   ExecInfo.fMask = SEE_MASK_NOASYNC | SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_NO_UI | SEE_MASK_NO_CONSOLE;
   ExecInfo.hwnd = GetDesktopWindow();
-  ExecInfo.lpVerb = TEXT("open");
-  ExecInfo.lpFile = iupwinStrToSystemFilename(filename);
-  ExecInfo.lpParameters = iupwinStrToSystemFilename(parameters);
+  ExecInfo.lpVerb = "open";
+  ExecInfo.lpFile = filename;
+  ExecInfo.lpParameters = parameters;
   ExecInfo.nShow = SW_SHOWNORMAL;
 
-  if (!ShellExecuteEx(&ExecInfo))
+  if (!ShellExecuteExA(&ExecInfo))
   {
-    int err = (int)ExecInfo.hInstApp;
+    INT_PTR err = (INT_PTR)ExecInfo.hInstApp;
     switch (err)
     {
     case SE_ERR_FNF:
Index: src/win/iupwindows_info.c
===================================================================
--- src/win/iupwindows_info.c	(revision 5971)
+++ src/win/iupwindows_info.c	(working copy)
@@ -11,6 +11,7 @@
    and Windows system headers. */
 
 #include <windows.h>
+#include <shlobj.h>
 
 #include "iup_export.h"
 #include "iup_str.h"
@@ -104,3 +105,97 @@
   return str;
 }
 
+static int iupwinMakeDirectory(const char* path)
+{
+  DWORD attrib = GetFileAttributesA(path);
+  if (attrib != INVALID_FILE_ATTRIBUTES)
+  {
+    if (attrib & FILE_ATTRIBUTE_DIRECTORY)
+      return 1;
+    return 0;
+  }
+  return CreateDirectoryA(path, NULL) ? 1 : 0;
+}
+
+IUP_SDK_API int iupdrvGetPreferencePath(char *filename, const char *app_name, int use_system)
+{
+  char* homedrive;
+  char* homepath;
+
+  if (!app_name || !app_name[0])
+  {
+    filename[0] = '\0';
+    return 0;
+  }
+
+  if (use_system)
+  {
+    /* Windows Local AppData: %LOCALAPPDATA%\appname\config.cfg */
+    if (SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, filename) == S_OK)
+    {
+      /* Add app directory */
+      strcat(filename, "\\");
+      strcat(filename, app_name);
+      iupwinMakeDirectory(filename);
+
+      /* Add config filename */
+      strcat(filename, "\\config.cfg");
+      return 1;
+    }
+  }
+
+  /* Legacy: %HOMEDRIVE%%HOMEPATH%\appname.cfg */
+  homedrive = getenv("HOMEDRIVE");
+  homepath = getenv("HOMEPATH");
+  if (homedrive && homepath)
+  {
+    strcpy(filename, homedrive);
+    strcat(filename, homepath);
+    strcat(filename, "\\");
+    strcat(filename, app_name);
+    strcat(filename, ".cfg");
+    return 1;
+  }
+
+  filename[0] = '\0';
+  return 0;
+}
+
+IUP_API void IupLogV(const char* type, const char* format, va_list arglist)
+{
+  HANDLE EventSource;
+  WORD wtype = 0;
+
+  int size;
+  char* value = iupStrGetLargeMem(&size);
+  vsnprintf(value, size, format, arglist);
+
+  if (iupStrEqualNoCase(type, "DEBUG"))
+  {
+    OutputDebugStringA(value);
+    return;
+  }
+  else if (iupStrEqualNoCase(type, "ERROR"))
+    wtype = EVENTLOG_ERROR_TYPE;
+  else if (iupStrEqualNoCase(type, "WARNING"))
+    wtype = EVENTLOG_WARNING_TYPE;
+  else if (iupStrEqualNoCase(type, "INFO"))
+    wtype = EVENTLOG_INFORMATION_TYPE;
+
+  EventSource = RegisterEventSourceA(NULL, "Application");
+  if (EventSource)
+  {
+    const char* strings[1];
+    strings[0] = value;
+    ReportEventA(EventSource, wtype, 0, 0, NULL, 1, 0, strings, NULL);
+    DeregisterEventSource(EventSource);
+  }
+}
+
+IUP_API void IupLog(const char* type, const char* format, ...)
+{
+  va_list arglist;
+  va_start(arglist, format);
+  IupLogV(type, format, arglist);
+  va_end(arglist);
+}
Index: src/win/iupwindows_main.c
===================================================================
--- src/win/iupwindows_main.c	(revision 5971)
+++ src/win/iupwindows_main.c	(working copy)
@@ -54,10 +54,10 @@
     return IupMain(_argc, _argv);
   }              
 #else
-  {                        
+  {
     /* this seems to work for all the compilers we tested, except Watcom compilers */
     /* These are declared in <stdlib.h>, except for Cygwin. */
-#ifdef __GNUC__
+#ifdef __CYGWIN__
     extern int __argc;
     extern char** __argv;
 #endif
Index: src/win/wdl/backend-gdix.c
===================================================================
--- src/win/wdl/backend-gdix.c	(revision 5971)
+++ src/win/wdl/backend-gdix.c	(working copy)
@@ -139,6 +139,7 @@
     GPA(GetPathLastPoint, (dummy_GpPath*, dummy_GpPointF*));
     GPA(AddPathArc, (dummy_GpPath*, float, float, float, float, float, float));
     GPA(AddPathLine, (dummy_GpPath*, float, float, float, float));
+    GPA(AddPathBezier, (dummy_GpPath*, float, float, float, float, float, float, float, float));
     GPA(SetPenDashOffset, (dummy_GpPen*, float));
 
     /* Font functions */
Index: src/win/wdl/backend-gdix.h
===================================================================
--- src/win/wdl/backend-gdix.h	(revision 5971)
+++ src/win/wdl/backend-gdix.h	(working copy)
@@ -101,6 +101,7 @@
     int (WINAPI* fn_GetPathLastPoint)(dummy_GpPath*, dummy_GpPointF*);
     int (WINAPI* fn_AddPathArc)(dummy_GpPath*, float, float, float, float, float, float);
     int (WINAPI* fn_AddPathLine)(dummy_GpPath*, float, float, float, float);
+    int (WINAPI* fn_AddPathBezier)(dummy_GpPath*, float, float, float, float, float, float, float, float);
 
     /* Font functions */
     int (WINAPI* fn_CreateFontFromLogfontW)(HDC, const LOGFONTW*, dummy_GpFont**);
Index: src/win/wdl/brush.c
===================================================================
--- src/win/wdl/brush.c	(revision 5971)
+++ src/win/wdl/brush.c	(working copy)
@@ -82,3 +82,103 @@
         gdix_vtable->fn_SetSolidFillColor(b, (dummy_ARGB) color);
     }
 }
+
+WD_HBRUSH
+wdCreateLinearGradientBrush(WD_HCANVAS hCanvas, float x0, float y0, float x1, float y1, WD_COLOR color0, WD_COLOR color1)
+{
+    if(d2d_enabled()) {
+        d2d_canvas_t* c = (d2d_canvas_t*) hCanvas;
+        dummy_ID2D1LinearGradientBrush* b;
+        dummy_ID2D1GradientStopCollection* stopCollection;
+        dummy_D2D1_GRADIENT_STOP stops[2];
+        dummy_D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props;
+        HRESULT hr;
+
+        /* Create gradient stops */
+        stops[0].position = 0.0f;
+        d2d_init_color(&stops[0].color, color0);
+        stops[1].position = 1.0f;
+        d2d_init_color(&stops[1].color, color1);
+
+        /* Create gradient stop collection */
+        hr = dummy_ID2D1RenderTarget_CreateGradientStopCollection(c->target, stops, 2,
+                    0 /* D2D1_GAMMA_2_2 */, 0 /* D2D1_EXTEND_MODE_CLAMP */, &stopCollection);
+        if(FAILED(hr)) {
+            WD_TRACE_HR("wdCreateLinearGradientBrush: "
+                        "ID2D1RenderTarget::CreateGradientStopCollection() failed.");
+            return NULL;
+        }
+
+        /* Create linear gradient brush */
+        props.startPoint.x = x0;
+        props.startPoint.y = y0;
+        props.endPoint.x = x1;
+        props.endPoint.y = y1;
+
+        hr = dummy_ID2D1RenderTarget_CreateLinearGradientBrush(c->target, &props, NULL, stopCollection, &b);
+        dummy_ID2D1GradientStopCollection_Release(stopCollection);
+
+        if(FAILED(hr)) {
+            WD_TRACE_HR("wdCreateLinearGradientBrush: "
+                        "ID2D1RenderTarget::CreateLinearGradientBrush() failed.");
+            return NULL;
+        }
+
+        return (WD_HBRUSH) b;
+    } else {
+        /* GDI+ backend doesn't support gradient brushes in WDL vtable */
+        /* Return NULL - caller will fall back to manual gradient */
+        return NULL;
+    }
+}
+
+WD_HBRUSH
+wdCreateRadialGradientBrush(WD_HCANVAS hCanvas, float cx, float cy, float rx, float ry, WD_COLOR colorCenter, WD_COLOR colorEdge)
+{
+    if(d2d_enabled()) {
+        d2d_canvas_t* c = (d2d_canvas_t*) hCanvas;
+        dummy_ID2D1RadialGradientBrush* b;
+        dummy_ID2D1GradientStopCollection* stopCollection;
+        dummy_D2D1_GRADIENT_STOP stops[2];
+        dummy_D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props;
+        HRESULT hr;
+
+        /* Create gradient stops */
+        stops[0].position = 0.0f;
+        d2d_init_color(&stops[0].color, colorCenter);
+        stops[1].position = 1.0f;
+        d2d_init_color(&stops[1].color, colorEdge);
+
+        /* Create gradient stop collection */
+        hr = dummy_ID2D1RenderTarget_CreateGradientStopCollection(c->target, stops, 2,
+                    0 /* D2D1_GAMMA_2_2 */, 0 /* D2D1_EXTEND_MODE_CLAMP */, &stopCollection);
+        if(FAILED(hr)) {
+            WD_TRACE_HR("wdCreateRadialGradientBrush: "
+                        "ID2D1RenderTarget::CreateGradientStopCollection() failed.");
+            return NULL;
+        }
+
+        /* Create radial gradient brush */
+        props.center.x = cx;
+        props.center.y = cy;
+        props.gradientOriginOffset.x = 0.0f;
+        props.gradientOriginOffset.y = 0.0f;
+        props.radiusX = rx;
+        props.radiusY = ry;
+
+        hr = dummy_ID2D1RenderTarget_CreateRadialGradientBrush(c->target, &props, NULL, stopCollection, &b);
+        dummy_ID2D1GradientStopCollection_Release(stopCollection);
+
+        if(FAILED(hr)) {
+            WD_TRACE_HR("wdCreateRadialGradientBrush: "
+                        "ID2D1RenderTarget::CreateRadialGradientBrush() failed.");
+            return NULL;
+        }
+
+        return (WD_HBRUSH) b;
+    } else {
+        /* GDI+ backend doesn't support gradient brushes in WDL vtable */
+        /* Return NULL - caller will fall back to manual gradient */
+        return NULL;
+    }
+}
Index: src/win/wdl/draw.c
===================================================================
--- src/win/wdl/draw.c	(revision 5971)
+++ src/win/wdl/draw.c	(working copy)
@@ -187,3 +187,38 @@
         gdix_vtable->fn_DrawRectangle(c->graphics, c->pen, x0, y0, x1 - x0, y1 - y0);
     }
 }
+
+void
+wdDrawRoundedRectStyled(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
+                        float x0, float y0, float x1, float y1, float r, float fStrokeWidth, WD_HSTROKESTYLE hStrokeStyle)
+{
+    if(d2d_enabled()) {
+        d2d_canvas_t* c = (d2d_canvas_t*) hCanvas;
+        dummy_ID2D1Brush* b = (dummy_ID2D1Brush*) hBrush;
+        dummy_ID2D1StrokeStyle* s = (dummy_ID2D1StrokeStyle*)hStrokeStyle;
+        dummy_D2D1_ROUNDED_RECT rr;
+
+        rr.rect.left = x0;
+        rr.rect.top = y0;
+        rr.rect.right = x1;
+        rr.rect.bottom = y1;
+        rr.radiusX = r;
+        rr.radiusY = r;
+
+        dummy_ID2D1RenderTarget_DrawRoundedRectangle(c->target, &rr, b, fStrokeWidth, s);
+    } else {
+        /* GDI+ doesn't have native rounded rectangle, use path */
+        gdix_canvas_t* c = (gdix_canvas_t*) hCanvas;
+        gdix_strokestyle_t* s = (gdix_strokestyle_t*)hStrokeStyle;
+        dummy_GpBrush* b = (dummy_GpBrush*)hBrush;
+        WD_RECT rect = { x0, y0, x1, y1 };
+        WD_HPATH path;
+
+        path = wdCreateRoundedRectPath(hCanvas, &rect, r);
+        if(path != NULL) {
+            gdix_setpen(c->pen, b, fStrokeWidth, s);
+            gdix_vtable->fn_DrawPath(c->graphics, (void*)c->pen, (void*)path);
+            wdDestroyPath(path);
+        }
+    }
+}
Index: src/win/wdl/dummy/d2d1.h
===================================================================
--- src/win/wdl/dummy/d2d1.h	(revision 5971)
+++ src/win/wdl/dummy/d2d1.h	(working copy)
@@ -62,6 +62,9 @@
 typedef struct dummy_ID2D1PathGeometry_tag              dummy_ID2D1PathGeometry;
 typedef struct dummy_ID2D1RenderTarget_tag              dummy_ID2D1RenderTarget;
 typedef struct dummy_ID2D1SolidColorBrush_tag           dummy_ID2D1SolidColorBrush;
+typedef struct dummy_ID2D1GradientStopCollection_tag    dummy_ID2D1GradientStopCollection;
+typedef struct dummy_ID2D1LinearGradientBrush_tag       dummy_ID2D1LinearGradientBrush;
+typedef struct dummy_ID2D1RadialGradientBrush_tag       dummy_ID2D1RadialGradientBrush;
 
 
 /*****************************
@@ -203,6 +206,13 @@
     dummy_D2D1_ARC_SIZE arcSize;
 };
 
+typedef struct dummy_D2D1_BEZIER_SEGMENT_tag dummy_D2D1_BEZIER_SEGMENT;
+struct dummy_D2D1_BEZIER_SEGMENT_tag {
+    dummy_D2D1_POINT_2F point1;  /* First control point */
+    dummy_D2D1_POINT_2F point2;  /* Second control point */
+    dummy_D2D1_POINT_2F point3;  /* End point */
+};
+
 typedef struct dummy_D2D1_ELLIPSE_tag dummy_D2D1_ELLIPSE;
 struct dummy_D2D1_ELLIPSE_tag {
     dummy_D2D1_POINT_2F point;
@@ -210,6 +220,33 @@
     FLOAT radiusY;
 };
 
+typedef struct dummy_D2D1_ROUNDED_RECT_tag dummy_D2D1_ROUNDED_RECT;
+struct dummy_D2D1_ROUNDED_RECT_tag {
+    dummy_D2D1_RECT_F rect;
+    FLOAT radiusX;
+    FLOAT radiusY;
+};
+
+typedef struct dummy_D2D1_GRADIENT_STOP_tag dummy_D2D1_GRADIENT_STOP;
+struct dummy_D2D1_GRADIENT_STOP_tag {
+    FLOAT position;
+    dummy_D2D1_COLOR_F color;
+};
+
+typedef struct dummy_D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES_tag dummy_D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES;
+struct dummy_D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES_tag {
+    dummy_D2D1_POINT_2F startPoint;
+    dummy_D2D1_POINT_2F endPoint;
+};
+
+typedef struct dummy_D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES_tag dummy_D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES;
+struct dummy_D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES_tag {
+    dummy_D2D1_POINT_2F center;
+    dummy_D2D1_POINT_2F gradientOriginOffset;
+    FLOAT radiusX;
+    FLOAT radiusY;
+};
+
 typedef struct dummy_D2D1_FACTORY_OPTIONS_tag dummy_D2D1_FACTORY_OPTIONS;
 struct dummy_D2D1_FACTORY_OPTIONS_tag {
     dummy_D2D1_DEBUG_LEVEL debugLevel;
@@ -740,7 +777,7 @@
 
     /* ID2D1GeometrySink methods */
     STDMETHOD_(void, AddLine)(dummy_ID2D1GeometrySink*, dummy_D2D1_POINT_2F point);
-    STDMETHOD(dummy_AddBezier)(void);
+    STDMETHOD_(void, AddBezier)(dummy_ID2D1GeometrySink*, const dummy_D2D1_BEZIER_SEGMENT*);
     STDMETHOD(dummy_AddQuadraticBezier)(void);
     STDMETHOD(dummy_AddQuadraticBeziers)(void);
     STDMETHOD_(void, AddArc)(dummy_ID2D1GeometrySink*, const dummy_D2D1_ARC_SEGMENT*);
@@ -757,6 +794,7 @@
 #define dummy_ID2D1GeometrySink_EndFigure(self,a)           (self)->vtbl->EndFigure(self,a)
 #define dummy_ID2D1GeometrySink_Close(self)                 (self)->vtbl->Close(self)
 #define dummy_ID2D1GeometrySink_AddLine(self,a)             (self)->vtbl->AddLine(self,a)
+#define dummy_ID2D1GeometrySink_AddBezier(self,a)           (self)->vtbl->AddBezier(self,a)
 #define dummy_ID2D1GeometrySink_AddArc(self,a)              (self)->vtbl->AddArc(self,a)
 
 
@@ -938,9 +976,9 @@
     STDMETHOD(dummy_CreateSharedBitmap)(void);
     STDMETHOD(dummy_CreateBitmapBrush)(void);
     STDMETHOD(CreateSolidColorBrush)(dummy_ID2D1RenderTarget*, const dummy_D2D1_COLOR_F*, const void*, dummy_ID2D1SolidColorBrush**);
-    STDMETHOD(dummy_CreateGradientStopCollection)(void);
-    STDMETHOD(dummy_CreateLinearGradientBrush)(void);
-    STDMETHOD(dummy_CreateRadialGradientBrush)(void);
+    STDMETHOD(CreateGradientStopCollection)(dummy_ID2D1RenderTarget*, const dummy_D2D1_GRADIENT_STOP*, UINT, unsigned, unsigned, dummy_ID2D1GradientStopCollection**);
+    STDMETHOD(CreateLinearGradientBrush)(dummy_ID2D1RenderTarget*, const dummy_D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES*, const void*, dummy_ID2D1GradientStopCollection*, dummy_ID2D1LinearGradientBrush**);
+    STDMETHOD(CreateRadialGradientBrush)(dummy_ID2D1RenderTarget*, const dummy_D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES*, const void*, dummy_ID2D1GradientStopCollection*, dummy_ID2D1RadialGradientBrush**);
     STDMETHOD(dummy_CreateCompatibleRenderTarget)(void);
     STDMETHOD(CreateLayer)(dummy_ID2D1RenderTarget*, const dummy_D2D1_SIZE_F*, dummy_ID2D1Layer**);
     STDMETHOD(dummy_CreateMesh)(void);
@@ -947,8 +985,8 @@
     STDMETHOD_(void, DrawLine)(dummy_ID2D1RenderTarget*, dummy_D2D1_POINT_2F, dummy_D2D1_POINT_2F, dummy_ID2D1Brush*, FLOAT, dummy_ID2D1StrokeStyle*);
     STDMETHOD_(void, DrawRectangle)(dummy_ID2D1RenderTarget*, const dummy_D2D1_RECT_F*, dummy_ID2D1Brush*, FLOAT, dummy_ID2D1StrokeStyle*);
     STDMETHOD_(void, FillRectangle)(dummy_ID2D1RenderTarget*, const dummy_D2D1_RECT_F*, dummy_ID2D1Brush*);
-    STDMETHOD(dummy_DrawRoundedRectangle)(void);
-    STDMETHOD(dummy_FillRoundedRectangle)(void);
+    STDMETHOD_(void, DrawRoundedRectangle)(dummy_ID2D1RenderTarget*, const dummy_D2D1_ROUNDED_RECT*, dummy_ID2D1Brush*, FLOAT, dummy_ID2D1StrokeStyle*);
+    STDMETHOD_(void, FillRoundedRectangle)(dummy_ID2D1RenderTarget*, const dummy_D2D1_ROUNDED_RECT*, dummy_ID2D1Brush*);
     STDMETHOD_(void, DrawEllipse)(dummy_ID2D1RenderTarget*, const dummy_D2D1_ELLIPSE*, dummy_ID2D1Brush*, FLOAT, dummy_ID2D1StrokeStyle*);
     STDMETHOD_(void, FillEllipse)(dummy_ID2D1RenderTarget*, const dummy_D2D1_ELLIPSE*, dummy_ID2D1Brush*);
     STDMETHOD_(void, DrawGeometry)(dummy_ID2D1RenderTarget*, dummy_ID2D1Geometry*, dummy_ID2D1Brush*, FLOAT, dummy_ID2D1StrokeStyle*);
@@ -998,10 +1036,15 @@
 #define dummy_ID2D1RenderTarget_Release(self)                           (self)->vtbl->Release(self)
 #define dummy_ID2D1RenderTarget_CreateBitmapFromWicBitmap(self,a,b,c)   (self)->vtbl->CreateBitmapFromWicBitmap(self,a,b,c)
 #define dummy_ID2D1RenderTarget_CreateSolidColorBrush(self,a,b,c)       (self)->vtbl->CreateSolidColorBrush(self,a,b,c)
+#define dummy_ID2D1RenderTarget_CreateGradientStopCollection(self,a,b,c,d,e)  (self)->vtbl->CreateGradientStopCollection(self,a,b,c,d,e)
+#define dummy_ID2D1RenderTarget_CreateLinearGradientBrush(self,a,b,c,d)  (self)->vtbl->CreateLinearGradientBrush(self,a,b,c,d)
+#define dummy_ID2D1RenderTarget_CreateRadialGradientBrush(self,a,b,c,d)  (self)->vtbl->CreateRadialGradientBrush(self,a,b,c,d)
 #define dummy_ID2D1RenderTarget_CreateLayer(self,a,b)                   (self)->vtbl->CreateLayer(self,a,b)
 #define dummy_ID2D1RenderTarget_DrawLine(self,a,b,c,d,e)                (self)->vtbl->DrawLine(self,a,b,c,d,e)
 #define dummy_ID2D1RenderTarget_DrawRectangle(self,a,b,c,d)             (self)->vtbl->DrawRectangle(self,a,b,c,d)
 #define dummy_ID2D1RenderTarget_FillRectangle(self,a,b)                 (self)->vtbl->FillRectangle(self,a,b)
+#define dummy_ID2D1RenderTarget_DrawRoundedRectangle(self,a,b,c,d)     (self)->vtbl->DrawRoundedRectangle(self,a,b,c,d)
+#define dummy_ID2D1RenderTarget_FillRoundedRectangle(self,a,b)         (self)->vtbl->FillRoundedRectangle(self,a,b)
 #define dummy_ID2D1RenderTarget_DrawEllipse(self,a,b,c,d)               (self)->vtbl->DrawEllipse(self,a,b,c,d)
 #define dummy_ID2D1RenderTarget_FillEllipse(self,a,b)                   (self)->vtbl->FillEllipse(self,a,b)
 #define dummy_ID2D1RenderTarget_DrawGeometry(self,a,b,c,d)              (self)->vtbl->DrawGeometry(self,a,b,c,d)
@@ -1056,4 +1099,118 @@
 #define dummy_ID2D1SolidColorBrush_SetColor(self,a)             (self)->vtbl->SetColor(self,a)
 
 
+/******************************************************
+ ***  Interface ID2D1GradientStopCollection  ***
+ ******************************************************/
+
+typedef struct dummy_ID2D1GradientStopCollectionVtbl_tag dummy_ID2D1GradientStopCollectionVtbl;
+struct dummy_ID2D1GradientStopCollectionVtbl_tag {
+    /* IUnknown methods */
+    STDMETHOD(QueryInterface)(dummy_ID2D1GradientStopCollection*, REFIID, void**);
+    STDMETHOD_(ULONG, AddRef)(dummy_ID2D1GradientStopCollection*);
+    STDMETHOD_(ULONG, Release)(dummy_ID2D1GradientStopCollection*);
+
+    /* ID2D1Resource methods */
+    STDMETHOD(dummy_GetFactory)(void);
+
+    /* ID2D1GradientStopCollection methods */
+    STDMETHOD(dummy_GetGradientStopCount)(void);
+    STDMETHOD(dummy_GetGradientStops)(void);
+    STDMETHOD(dummy_GetColorInterpolationGamma)(void);
+    STDMETHOD(dummy_GetExtendMode)(void);
+};
+
+struct dummy_ID2D1GradientStopCollection_tag {
+    dummy_ID2D1GradientStopCollectionVtbl* vtbl;
+};
+
+#define dummy_ID2D1GradientStopCollection_QueryInterface(self,a,b)  (self)->vtbl->QueryInterface(self,a,b)
+#define dummy_ID2D1GradientStopCollection_AddRef(self)              (self)->vtbl->AddRef(self)
+#define dummy_ID2D1GradientStopCollection_Release(self)             (self)->vtbl->Release(self)
+
+
+/**********************************************
+ ***  Interface ID2D1LinearGradientBrush  ***
+ **********************************************/
+
+typedef struct dummy_ID2D1LinearGradientBrushVtbl_tag dummy_ID2D1LinearGradientBrushVtbl;
+struct dummy_ID2D1LinearGradientBrushVtbl_tag {
+    /* IUnknown methods */
+    STDMETHOD(QueryInterface)(dummy_ID2D1LinearGradientBrush*, REFIID, void**);
+    STDMETHOD_(ULONG, AddRef)(dummy_ID2D1LinearGradientBrush*);
+    STDMETHOD_(ULONG, Release)(dummy_ID2D1LinearGradientBrush*);
+
+    /* ID2D1Resource methods */
+    STDMETHOD(dummy_GetFactory)(void);
+
+    /* ID2D1Brush methods */
+    STDMETHOD(dummy_SetOpacity)(void);
+    STDMETHOD(dummy_SetTransform)(void);
+    STDMETHOD(dummy_GetOpacity)(void);
+    STDMETHOD(dummy_GetTransform)(void);
+
+    /* ID2D1LinearGradientBrush methods */
+    STDMETHOD_(void, SetStartPoint)(dummy_ID2D1LinearGradientBrush*, dummy_D2D1_POINT_2F);
+    STDMETHOD_(void, SetEndPoint)(dummy_ID2D1LinearGradientBrush*, dummy_D2D1_POINT_2F);
+    STDMETHOD(dummy_GetStartPoint)(void);
+    STDMETHOD(dummy_GetEndPoint)(void);
+    STDMETHOD(dummy_GetGradientStopCollection)(void);
+};
+
+struct dummy_ID2D1LinearGradientBrush_tag {
+    dummy_ID2D1LinearGradientBrushVtbl* vtbl;
+};
+
+#define dummy_ID2D1LinearGradientBrush_QueryInterface(self,a,b)    (self)->vtbl->QueryInterface(self,a,b)
+#define dummy_ID2D1LinearGradientBrush_AddRef(self)                (self)->vtbl->AddRef(self)
+#define dummy_ID2D1LinearGradientBrush_Release(self)               (self)->vtbl->Release(self)
+#define dummy_ID2D1LinearGradientBrush_SetStartPoint(self,a)       (self)->vtbl->SetStartPoint(self,a)
+#define dummy_ID2D1LinearGradientBrush_SetEndPoint(self,a)         (self)->vtbl->SetEndPoint(self,a)
+
+
+/**********************************************
+ ***  Interface ID2D1RadialGradientBrush  ***
+ **********************************************/
+
+typedef struct dummy_ID2D1RadialGradientBrushVtbl_tag dummy_ID2D1RadialGradientBrushVtbl;
+struct dummy_ID2D1RadialGradientBrushVtbl_tag {
+    /* IUnknown methods */
+    STDMETHOD(QueryInterface)(dummy_ID2D1RadialGradientBrush*, REFIID, void**);
+    STDMETHOD_(ULONG, AddRef)(dummy_ID2D1RadialGradientBrush*);
+    STDMETHOD_(ULONG, Release)(dummy_ID2D1RadialGradientBrush*);
+
+    /* ID2D1Resource methods */
+    STDMETHOD(dummy_GetFactory)(void);
+
+    /* ID2D1Brush methods */
+    STDMETHOD(dummy_SetOpacity)(void);
+    STDMETHOD(dummy_SetTransform)(void);
+    STDMETHOD(dummy_GetOpacity)(void);
+    STDMETHOD(dummy_GetTransform)(void);
+
+    /* ID2D1RadialGradientBrush methods */
+    STDMETHOD_(void, SetCenter)(dummy_ID2D1RadialGradientBrush*, dummy_D2D1_POINT_2F);
+    STDMETHOD_(void, SetGradientOriginOffset)(dummy_ID2D1RadialGradientBrush*, dummy_D2D1_POINT_2F);
+    STDMETHOD_(void, SetRadiusX)(dummy_ID2D1RadialGradientBrush*, FLOAT);
+    STDMETHOD_(void, SetRadiusY)(dummy_ID2D1RadialGradientBrush*, FLOAT);
+    STDMETHOD(dummy_GetCenter)(void);
+    STDMETHOD(dummy_GetGradientOriginOffset)(void);
+    STDMETHOD(dummy_GetRadiusX)(void);
+    STDMETHOD(dummy_GetRadiusY)(void);
+    STDMETHOD(dummy_GetGradientStopCollection)(void);
+};
+
+struct dummy_ID2D1RadialGradientBrush_tag {
+    dummy_ID2D1RadialGradientBrushVtbl* vtbl;
+};
+
+#define dummy_ID2D1RadialGradientBrush_QueryInterface(self,a,b)            (self)->vtbl->QueryInterface(self,a,b)
+#define dummy_ID2D1RadialGradientBrush_AddRef(self)                        (self)->vtbl->AddRef(self)
+#define dummy_ID2D1RadialGradientBrush_Release(self)                       (self)->vtbl->Release(self)
+#define dummy_ID2D1RadialGradientBrush_SetCenter(self,a)                   (self)->vtbl->SetCenter(self,a)
+#define dummy_ID2D1RadialGradientBrush_SetGradientOriginOffset(self,a)     (self)->vtbl->SetGradientOriginOffset(self,a)
+#define dummy_ID2D1RadialGradientBrush_SetRadiusX(self,a)                  (self)->vtbl->SetRadiusX(self,a)
+#define dummy_ID2D1RadialGradientBrush_SetRadiusY(self,a)                  (self)->vtbl->SetRadiusY(self,a)
+
+
 #endif  /* DUMMY_D2D1_H */
Index: src/win/wdl/fill.c
===================================================================
--- src/win/wdl/fill.c	(revision 5971)
+++ src/win/wdl/fill.c	(working copy)
@@ -111,3 +111,34 @@
     }
 }
 
+void
+wdFillRoundedRect(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
+                  float x0, float y0, float x1, float y1, float r)
+{
+    if(d2d_enabled()) {
+        d2d_canvas_t* c = (d2d_canvas_t*) hCanvas;
+        dummy_ID2D1Brush* b = (dummy_ID2D1Brush*) hBrush;
+        dummy_D2D1_ROUNDED_RECT rr;
+
+        rr.rect.left = x0;
+        rr.rect.top = y0;
+        rr.rect.right = x1;
+        rr.rect.bottom = y1;
+        rr.radiusX = r;
+        rr.radiusY = r;
+
+        dummy_ID2D1RenderTarget_FillRoundedRectangle(c->target, &rr, b);
+    } else {
+        /* GDI+ doesn't have native rounded rectangle, use path */
+        gdix_canvas_t* c = (gdix_canvas_t*) hCanvas;
+        WD_RECT rect = { x0, y0, x1, y1 };
+        WD_HPATH path;
+
+        path = wdCreateRoundedRectPath(hCanvas, &rect, r);
+        if(path != NULL) {
+            gdix_vtable->fn_FillPath(c->graphics, (void*) hBrush, (void*) path);
+            wdDestroyPath(path);
+        }
+    }
+}
+
Index: src/win/wdl/path.c
===================================================================
--- src/win/wdl/path.c	(revision 5971)
+++ src/win/wdl/path.c	(working copy)
@@ -262,3 +262,31 @@
     }
 }
 
+void
+wdAddBezier(WD_PATHSINK* pSink, float x2, float y2, float x3, float y3, float x4, float y4)
+{
+    if(d2d_enabled()) {
+        dummy_ID2D1GeometrySink* s = (dummy_ID2D1GeometrySink*) pSink->pData;
+        dummy_D2D1_BEZIER_SEGMENT bezier_seg;
+
+        /* Set up Bezier segment with control points and end point */
+        bezier_seg.point1.x = x2;
+        bezier_seg.point1.y = y2;
+        bezier_seg.point2.x = x3;
+        bezier_seg.point2.y = y3;
+        bezier_seg.point3.x = x4;
+        bezier_seg.point3.y = y4;
+
+        dummy_ID2D1GeometrySink_AddBezier(s, &bezier_seg);
+    } else {
+        /* GDI+ requires all 8 coordinates (start + 3 points) */
+        gdix_vtable->fn_AddPathBezier(pSink->pData,
+                        pSink->ptEnd.x, pSink->ptEnd.y,  /* Current point as start */
+                        x2, y2, x3, y3, x4, y4);          /* Control points and end */
+    }
+
+    /* Update end point to the Bezier curve's end point */
+    pSink->ptEnd.x = x4;
+    pSink->ptEnd.y = y4;
+}
+
Index: src/win/wdl/wdl.h
===================================================================
--- src/win/wdl/wdl.h	(revision 5971)
+++ src/win/wdl/wdl.h	(working copy)
@@ -313,6 +313,8 @@
  * be used for the canvas it has been created for. */
 
 WD_HBRUSH wdCreateSolidBrush(WD_HCANVAS hCanvas, WD_COLOR color);
+WD_HBRUSH wdCreateLinearGradientBrush(WD_HCANVAS hCanvas, float x0, float y0, float x1, float y1, WD_COLOR color0, WD_COLOR color1);
+WD_HBRUSH wdCreateRadialGradientBrush(WD_HCANVAS hCanvas, float cx, float cy, float rx, float ry, WD_COLOR colorCenter, WD_COLOR colorEdge);
 void wdDestroyBrush(WD_HBRUSH hBrush);
 
 /* Can be only called for brushes created with wdCreateSolidBrush(). */
@@ -374,6 +376,7 @@
 
 void wdAddLine(WD_PATHSINK* pSink, float x, float y);
 void wdAddArc(WD_PATHSINK* pSink, float cx, float cy, float fSweepAngle);
+void wdAddBezier(WD_PATHSINK* pSink, float x2, float y2, float x3, float y3, float x4, float y4);
 
 
 /*************************
@@ -430,6 +433,9 @@
 void wdDrawRectStyled(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
                 float x0, float y0, float x1, float y1, float fStrokeWidth,
                 WD_HSTROKESTYLE hStrokeStyle);
+void wdDrawRoundedRectStyled(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
+                float x0, float y0, float x1, float y1, float r, float fStrokeWidth,
+                WD_HSTROKESTYLE hStrokeStyle);
 
 WD_INLINE void wdDrawArcStyled(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
                 float cx, float cy, float r,
@@ -532,6 +538,8 @@
 void wdFillPath(WD_HCANVAS hCanvas, WD_HBRUSH hBrush, const WD_HPATH hPath);
 void wdFillRect(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
                 float x0, float y0, float x1, float y1);
+void wdFillRoundedRect(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
+                float x0, float y0, float x1, float y1, float r);
 
 WD_INLINE void wdFillCircle(WD_HCANVAS hCanvas, WD_HBRUSH hBrush,
                 float cx, float cy, float r)
Index: srccd/config.mak
===================================================================
--- srccd/config.mak	(revision 5971)
+++ srccd/config.mak	(working copy)
@@ -5,6 +5,7 @@
 DEFINES = CD_NO_OLD_INTERFACE
 SRC = iup_cd.c iup_cdutil.c iup_draw_cd.c
 DEF_FILE = iupcd.def
+STDFLAGS = -Wincompatible-pointer-types
 
 USE_CD=YES
 # Can not use USE_IUP because Tecmake will include "iupcd" in linker
Index: srccd/iup_cd.c
===================================================================
--- srccd/iup_cd.c	(revision 5971)
+++ srccd/iup_cd.c	(working copy)
@@ -21,6 +21,7 @@
    So no need to rebuild IUPCD when cdCanvas is changed. */
 #include <cd_private.h>
 
+typedef void (*CanvasVoidPtrArgProc)(cdCanvas* canvas, void* data);
 
 static void (*cdcreatecanvasNATIVE)(cdCanvas* canvas, void* data) = NULL;
 
@@ -82,7 +83,7 @@
   cdcreatecanvasNATIVE = ctx->cxCreateCanvas;
 
   cdIupContext = *ctx;
-  cdIupContext.cxCreateCanvas = cdcreatecanvasIUP;
+  cdIupContext.cxCreateCanvas = (CanvasVoidPtrArgProc) cdcreatecanvasIUP;
 
   return &cdIupContext;
 }
@@ -123,7 +124,7 @@
   cdcreatecanvasDBUFFER = ctx->cxCreateCanvas;
 
   cdIupContextDBuffer = *ctx;
-  cdIupContextDBuffer.cxCreateCanvas = cdcreatecanvasIUP_DBUFFER;
+  cdIupContextDBuffer.cxCreateCanvas = (CanvasVoidPtrArgProc) cdcreatecanvasIUP_DBUFFER;
 
   return &cdIupContextDBuffer;
 }
@@ -164,7 +165,7 @@
   cdcreatecanvasDBUFFERRGB = ctx->cxCreateCanvas;
 
   cdIupContextDBufferRGB = *ctx;
-  cdIupContextDBufferRGB.cxCreateCanvas = cdcreatecanvasIUP_DBUFFERRGB;
+  cdIupContextDBufferRGB.cxCreateCanvas = (CanvasVoidPtrArgProc) cdcreatecanvasIUP_DBUFFERRGB;
 
   return &cdIupContextDBufferRGB;
 }
Index: srccd/iup_draw_cd.c
===================================================================
--- srccd/iup_draw_cd.c	(revision 5971)
+++ srccd/iup_draw_cd.c	(working copy)
@@ -18,6 +18,7 @@
 #include "iup_drvdraw.h"
 #include "iup_drvfont.h"
 
+typedef void (*CanvasVoidPtrArgProc)(cdCanvas* canvas, void* data);
 
 struct _cdCtxCanvas
 {
@@ -520,7 +521,7 @@
                  CD_CAP_LINECAP | CD_CAP_LINEJOIN | CD_CAP_PATH | CD_CAP_BEZIER |
                  CD_CAP_PALETTE | CD_CAP_CLIPPOLY | CD_CAP_REGION | CD_CAP_CHORD),
   CD_CTX_WINDOW,
-  cdcreatecanvas,
+  (CanvasVoidPtrArgProc) cdcreatecanvas,
   cdinittable,
   NULL,
   NULL,
Index: srcledc/y.tab.c
===================================================================
--- srcledc/y.tab.c	(revision 5971)
+++ srcledc/y.tab.c	(working copy)
@@ -17,6 +17,7 @@
 #include <errno.h>
 #include "ledc.h"
 
+extern int yylex(void);
 static int yyparse(void);
 
 #line 11 "ledc.y"
@@ -274,7 +275,8 @@
 
     yyssp = yyss;
     yyvsp = yyvs;
-    *yyssp = yystate = 0;
+    *yyssp = 0;
+    yystate = 0;
 
 yyloop:
     if (yyn = yydefred[yystate]) goto yyreduce;
Index: srclua5/ctrl/il_tuioclient.c
===================================================================
--- srclua5/ctrl/il_tuioclient.c	(revision 5971)
+++ srclua5/ctrl/il_tuioclient.c	(working copy)
@@ -1,60 +1,60 @@
-/******************************************************************************
- * Automatically generated file. Please don't change anything.                *
- *****************************************************************************/
-
-#include <stdlib.h>
-
-#include <lua.h>
-#include <lauxlib.h>
-
-#include "iup.h"
-#include "iuplua.h"
-#include "iuptuio.h"
-#include "il.h"
-
-
-static int TuioClient(lua_State *L)
-{
-  Ihandle *ih = IupTuioClient(luaL_optinteger(L, 1, 0));
-  iuplua_plugstate(L, ih);
-  iuplua_pushihandle_raw(L, ih);
-  return 1;
-}
-
-int iuptuioclientlua_open(lua_State * L)
-{
-  iuplua_register(L, TuioClient, "TuioClient");
-
-
-#ifdef IUPLUA_USELOH
-#include "tuioclient.loh"
-#else
-#ifdef IUPLUA_USELH
-#include "tuioclient.lh"
-#else
-  iuplua_dofile(L, "tuioclient.lua");
-#endif
-#endif
-
-  return 0;
-}
-
- 
-
-int iuptuiolua_open(lua_State* L)
-{
-  if (iuplua_opencall_internal(L))
-    IupTuioOpen();
-    
-  iuplua_get_env(L);
-  iuptuioclientlua_open(L);
-  
-  return 0;
-}
-
-/* obligatory to use require"iupluatuio" */
-int luaopen_iupluatuio(lua_State* L)
-{
-  return iuptuiolua_open(L);
-}
-
+/******************************************************************************
+ * Automatically generated file. Please don't change anything.                *
+ *****************************************************************************/
+
+#include <stdlib.h>
+
+#include <lua.h>
+#include <lauxlib.h>
+
+#include "iup.h"
+#include "iuplua.h"
+#include "iuptuio.h"
+#include "il.h"
+
+
+static int TuioClient(lua_State *L)
+{
+  Ihandle *ih = IupTuioClient(luaL_optinteger(L, 1, 0));
+  iuplua_plugstate(L, ih);
+  iuplua_pushihandle_raw(L, ih);
+  return 1;
+}
+
+int iuptuioclientlua_open(lua_State * L)
+{
+  iuplua_register(L, TuioClient, "TuioClient");
+
+
+#ifdef IUPLUA_USELOH
+#include "tuioclient.loh"
+#else
+#ifdef IUPLUA_USELH
+#include "tuioclient.lh"
+#else
+  iuplua_dofile(L, "tuioclient.lua");
+#endif
+#endif
+
+  return 0;
+}
+
+ 
+
+int iuptuiolua_open(lua_State* L)
+{
+  if (iuplua_opencall_internal(L))
+    IupTuioOpen();
+    
+  iuplua_get_env(L);
+  iuptuioclientlua_open(L);
+  
+  return 0;
+}
+
+/* obligatory to use require"iupluatuio" */
+int luaopen_iupluatuio(lua_State* L)
+{
+  return iuptuiolua_open(L);
+}
+
Index: srclua5/ctrl/iuplua_mglplot.c
===================================================================
--- srclua5/ctrl/iuplua_mglplot.c	(revision 5971)
+++ srclua5/ctrl/iuplua_mglplot.c	(working copy)
@@ -59,7 +59,7 @@
   int count = luaL_checkinteger(L, 6);
   px = iuplua_checkstring_array(L, 4, count);
   py = iuplua_checkdouble_array(L, 5, count);
-  IupMglPlotInsert1D(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), luaL_checkinteger(L,3), px, py, count);
+  IupMglPlotInsert1D(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), luaL_checkinteger(L,3), (const char **)px, py, count);
   free(px);
   free(py);
   return 0;
@@ -98,7 +98,7 @@
   int count = luaL_checkinteger(L, 5);
   px = iuplua_checkstring_array(L, 3, count);
   py = iuplua_checkdouble_array(L, 4, count);
-  IupMglPlotSet1D(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), px, py, count);
+  IupMglPlotSet1D(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), (const char **)px, py, count);
   free(px);
   free(py);
   return 0;
Index: srclua5/ctrl/iuplua_plot.c
===================================================================
--- srclua5/ctrl/iuplua_plot.c	(revision 5971)
+++ srclua5/ctrl/iuplua_plot.c	(working copy)
@@ -332,7 +332,7 @@
   int count = luaL_checkinteger(L, 6);
   px = iuplua_checkstring_array(L, 4, count);
   py = iuplua_checkdouble_array(L, 5, count);
-  IupPlotInsertStrSamples(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), luaL_checkinteger(L,3), px, py, count);
+  IupPlotInsertStrSamples(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), luaL_checkinteger(L,3), (const char **) px, py, count);
   free(px);
   free(py);
   return 0;
@@ -357,7 +357,7 @@
   int count = luaL_checkinteger(L, 5);
   px = iuplua_checkstring_array(L, 3, count);
   py = iuplua_checkdouble_array(L, 4, count);
-  IupPlotAddStrSamples(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), px, py, count);
+  IupPlotAddStrSamples(iuplua_checkihandle(L,1), luaL_checkinteger(L,2), (const char **) px, py, count);
   free(px);
   free(py);
   return 0;
Index: srclua5/elem/il_flattree.c
===================================================================
--- srclua5/elem/il_flattree.c	(revision 5971)
+++ srclua5/elem/il_flattree.c	(working copy)
@@ -1,40 +1,40 @@
-/******************************************************************************
- * Automatically generated file. Please don't change anything.                *
- *****************************************************************************/
-
-#include <stdlib.h>
-
-#include <lua.h>
-#include <lauxlib.h>
-
-#include "iup.h"
-#include "iuplua.h"
-#include "il.h"
-
-
-static int FlatTree(lua_State *L)
-{
-  Ihandle *ih = IupFlatTree();
-  iuplua_plugstate(L, ih);
-  iuplua_pushihandle_raw(L, ih);
-  return 1;
-}
-
-int iupflattreelua_open(lua_State * L)
-{
-  iuplua_register(L, FlatTree, "FlatTree");
-
-
-#ifdef IUPLUA_USELOH
-#include "flattree.loh"
-#else
-#ifdef IUPLUA_USELH
-#include "flattree.lh"
-#else
-  iuplua_dofile(L, "flattree.lua");
-#endif
-#endif
-
-  return 0;
-}
-
+/******************************************************************************
+ * Automatically generated file. Please don't change anything.                *
+ *****************************************************************************/
+
+#include <stdlib.h>
+
+#include <lua.h>
+#include <lauxlib.h>
+
+#include "iup.h"
+#include "iuplua.h"
+#include "il.h"
+
+
+static int FlatTree(lua_State *L)
+{
+  Ihandle *ih = IupFlatTree();
+  iuplua_plugstate(L, ih);
+  iuplua_pushihandle_raw(L, ih);
+  return 1;
+}
+
+int iupflattreelua_open(lua_State * L)
+{
+  iuplua_register(L, FlatTree, "FlatTree");
+
+
+#ifdef IUPLUA_USELOH
+#include "flattree.loh"
+#else
+#ifdef IUPLUA_USELH
+#include "flattree.lh"
+#else
+  iuplua_dofile(L, "flattree.lua");
+#endif
+#endif
+
+  return 0;
+}
+
Index: srclua5/elem/il_thread.c
===================================================================
--- srclua5/elem/il_thread.c	(revision 5971)
+++ srclua5/elem/il_thread.c	(working copy)
@@ -1,47 +1,47 @@
-/******************************************************************************
- * Automatically generated file. Please don't change anything.                *
- *****************************************************************************/
-
-#include <stdlib.h>
-
-#include <lua.h>
-#include <lauxlib.h>
-
-#include "iup.h"
-#include "iuplua.h"
-#include "il.h"
-
-
-static int thread_thread_cb(Ihandle *self)
-{
-  lua_State *L = iuplua_call_start(self, "thread_cb");
-  return iuplua_call(L, 0);
-}
-
-static int Thread(lua_State *L)
-{
-  Ihandle *ih = IupThread();
-  iuplua_plugstate(L, ih);
-  iuplua_pushihandle_raw(L, ih);
-  return 1;
-}
-
-int iupthreadlua_open(lua_State * L)
-{
-  iuplua_register(L, Thread, "Thread");
-
-  iuplua_register_cb(L, "THREAD_CB", (lua_CFunction)thread_thread_cb, NULL);
-
-#ifdef IUPLUA_USELOH
-#include "thread.loh"
-#else
-#ifdef IUPLUA_USELH
-#include "thread.lh"
-#else
-  iuplua_dofile(L, "thread.lua");
-#endif
-#endif
-
-  return 0;
-}
-
+/******************************************************************************
+ * Automatically generated file. Please don't change anything.                *
+ *****************************************************************************/
+
+#include <stdlib.h>
+
+#include <lua.h>
+#include <lauxlib.h>
+
+#include "iup.h"
+#include "iuplua.h"
+#include "il.h"
+
+
+static int thread_thread_cb(Ihandle *self)
+{
+  lua_State *L = iuplua_call_start(self, "thread_cb");
+  return iuplua_call(L, 0);
+}
+
+static int Thread(lua_State *L)
+{
+  Ihandle *ih = IupThread();
+  iuplua_plugstate(L, ih);
+  iuplua_pushihandle_raw(L, ih);
+  return 1;
+}
+
+int iupthreadlua_open(lua_State * L)
+{
+  iuplua_register(L, Thread, "Thread");
+
+  iuplua_register_cb(L, "THREAD_CB", (lua_CFunction)thread_thread_cb, NULL);
+
+#ifdef IUPLUA_USELOH
+#include "thread.loh"
+#else
+#ifdef IUPLUA_USELH
+#include "thread.lh"
+#else
+  iuplua_dofile(L, "thread.lua");
+#endif
+#endif
+
+  return 0;
+}
+
Index: srclua5/iuplua_api.c
===================================================================
--- srclua5/iuplua_api.c	(revision 5971)
+++ srclua5/iuplua_api.c	(working copy)
@@ -571,7 +571,7 @@
 
   ret = IupListDialog(type, luaL_checkstring(L, 2), 
                             size, 
-                            list, 
+                            (const char **)list, 
                             (int)luaL_checkinteger(L, 5), 
                             (int)luaL_checkinteger(L, 6),
                             (int)luaL_checkinteger(L, 7),
Index: srclua5/iuplua_im.c
===================================================================
--- srclua5/iuplua_im.c	(revision 5971)
+++ srclua5/iuplua_im.c	(working copy)
@@ -83,7 +83,7 @@
 {
   int file_count = (int)luaL_checkinteger(L, 2);
   char** filename_list = iuplua_checkstring_array(L, 1, file_count);
-  Ihandle* animation = IupLoadAnimationFrames(filename_list, file_count);
+  Ihandle* animation = IupLoadAnimationFrames((const char **)filename_list, file_count);
   iuplua_pushihandle(L, animation);
   return 1;
 }
Index: srclua5/lh/constants.lh
===================================================================
--- srclua5/lh/constants.lh	(revision 5971)
+++ srclua5/lh/constants.lh	(working copy)
@@ -1,176 +0,0 @@
-/* code automatically generated by bin2c -- DO NOT EDIT */
-{
-/* #include'ing this file in a C program is equivalent to calling
-  if (luaL_loadfile(L,"constants.lua")==0) lua_pcall(L, 0, 0, 0); 
-*/
-/* constants.lua */
-static const unsigned char B1[]={
- 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 45, 45,
- 32, 32, 67,111,109,109,111,110, 32,114,101,116,117,114,110, 32,118, 97,108,117,
-101,115, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 10, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,105,117,112, 46, 69, 82,
- 82, 79, 82, 32, 32, 32, 61, 32, 32, 49, 10,105,117,112, 46, 78, 79, 69, 82, 82,
- 79, 82, 32, 61, 32, 32, 48, 10,105,117,112, 46, 79, 80, 69, 78, 69, 68, 32, 32,
- 61, 32, 45, 49, 10,105,117,112, 46, 73, 78, 86, 65, 76, 73, 68, 32, 61, 32, 45,
- 49, 10,105,117,112, 46, 73, 78, 86, 65, 76, 73, 68, 95, 73, 68, 32, 61, 32, 45,
- 49, 48, 10, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 10, 45, 45, 32, 32, 67, 97,108,108, 98, 97, 99,107, 32,114,101,116,117,114,110,
- 32,118, 97,108,117,101,115, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
- 32, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,105,
-117,112, 46, 73, 71, 78, 79, 82, 69, 32, 32, 32, 61, 32, 45, 49, 10,105,117,112,
- 46, 68, 69, 70, 65, 85, 76, 84, 32, 32, 61, 32, 45, 50, 10,105,117,112, 46, 67,
- 76, 79, 83, 69, 32, 32, 32, 32, 61, 32, 45, 51, 10,105,117,112, 46, 67, 79, 78,
- 84, 73, 78, 85, 69, 32, 61, 32, 45, 52, 10, 10, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 10, 45, 45, 32, 32, 73,117,112, 80,111,112,117,
-112, 32,101, 32, 73,117,112, 83,104,111,119, 88, 89, 32, 32, 32, 32, 32, 32, 32,
- 32, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,105,
-117,112, 46, 67, 69, 78, 84, 69, 82, 32, 32, 32, 32, 32, 32, 32, 61, 32, 54, 53,
- 53, 51, 53, 10,105,117,112, 46, 76, 69, 70, 84, 32, 32, 32, 32, 32, 32, 32, 32,
- 32, 61, 32, 54, 53, 53, 51, 52, 10,105,117,112, 46, 82, 73, 71, 72, 84, 32, 32,
- 32, 32, 32, 32, 32, 32, 61, 32, 54, 53, 53, 51, 51, 10,105,117,112, 46, 77, 79,
- 85, 83, 69, 80, 79, 83, 32, 32, 32, 32, 32, 61, 32, 54, 53, 53, 51, 50, 10,105,
-117,112, 46, 67, 85, 82, 82, 69, 78, 84, 32, 32, 32, 32, 32, 32, 61, 32, 54, 53,
- 53, 51, 49, 10,105,117,112, 46, 67, 69, 78, 84, 69, 82, 80, 65, 82, 69, 78, 84,
- 32, 61, 32, 54, 53, 53, 51, 48, 10,105,117,112, 46, 76, 69, 70, 84, 80, 65, 82,
- 69, 78, 84, 32, 32, 32, 61, 32, 54, 53, 53, 50, 57, 10,105,117,112, 46, 82, 73,
- 71, 72, 84, 80, 65, 82, 69, 78, 84, 32, 32, 61, 32, 54, 53, 53, 50, 56, 10,105,
-117,112, 46, 84, 79, 80, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 61, 32,105,117,
-112, 46, 76, 69, 70, 84, 10,105,117,112, 46, 66, 79, 84, 84, 79, 77, 32, 32, 32,
- 32, 32, 32, 32, 61, 32,105,117,112, 46, 82, 73, 71, 72, 84, 10,105,117,112, 46,
- 84, 79, 80, 80, 65, 82, 69, 78, 84, 32, 32, 32, 32, 61, 32,105,117,112, 46, 76,
- 69, 70, 84, 80, 65, 82, 69, 78, 84, 10,105,117,112, 46, 66, 79, 84, 84, 79, 77,
- 80, 65, 82, 69, 78, 84, 32, 61, 32,105,117,112, 46, 82, 73, 71, 72, 84, 80, 65,
- 82, 69, 78, 84, 10, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 10, 45, 45, 32, 32, 83, 99,114,111,108,108, 98, 97,114, 10, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,105,117,112, 46, 83, 66,
- 85, 80, 32, 32, 32, 32, 32, 32, 61, 32, 48, 32, 32, 10,105,117,112, 46, 83, 66,
- 68, 78, 32, 32, 32, 32, 32, 32, 61, 32, 49, 32, 32, 10,105,117,112, 46, 83, 66,
- 80, 71, 85, 80, 32, 32, 32, 32, 61, 32, 50, 32, 32, 10,105,117,112, 46, 83, 66,
- 80, 71, 68, 78, 32, 32, 32, 32, 61, 32, 51, 32, 32, 10,105,117,112, 46, 83, 66,
- 80, 79, 83, 86, 32, 32, 32, 32, 61, 32, 52, 32, 32, 10,105,117,112, 46, 83, 66,
- 68, 82, 65, 71, 86, 32, 32, 32, 61, 32, 53, 32, 32, 10,105,117,112, 46, 83, 66,
- 76, 69, 70, 84, 32, 32, 32, 32, 61, 32, 54, 32, 32, 10,105,117,112, 46, 83, 66,
- 82, 73, 71, 72, 84, 32, 32, 32, 61, 32, 55, 32, 32, 10,105,117,112, 46, 83, 66,
- 80, 71, 76, 69, 70, 84, 32, 32, 61, 32, 56, 32, 32, 10,105,117,112, 46, 83, 66,
- 80, 71, 82, 73, 71, 72, 84, 32, 61, 32, 57, 32, 32, 10,105,117,112, 46, 83, 66,
- 80, 79, 83, 72, 32, 32, 32, 32, 61, 32, 49, 48, 32, 10,105,117,112, 46, 83, 66,
- 68, 82, 65, 71, 72, 32, 32, 32, 61, 32, 49, 49, 32, 10, 10, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 45, 45, 32, 32, 83, 72, 79, 87,
- 95, 67, 66, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
- 32, 32, 32, 32, 32, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 10,105,117,112, 46, 83, 72, 79, 87, 32, 32, 32, 32, 32, 61, 32, 48, 10,
-105,117,112, 46, 82, 69, 83, 84, 79, 82, 69, 32, 32, 61, 32, 49, 10,105,117,112,
- 46, 77, 73, 78, 73, 77, 73, 90, 69, 32, 61, 32, 50, 10,105,117,112, 46, 77, 65,
- 88, 73, 77, 73, 90, 69, 32, 61, 32, 51, 10,105,117,112, 46, 72, 73, 68, 69, 32,
- 32, 32, 32, 32, 61, 32, 52, 10, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 10, 45, 45, 32, 32, 66, 85, 84, 84, 79, 78, 95, 67, 66, 32,
- 32, 32, 32, 32, 32, 32, 32, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 10,105,117,112, 46, 66, 85, 84, 84, 79, 78, 49, 32, 61, 32,115,
-116,114,105,110,103, 46, 98,121,116,101, 40, 39, 49, 39, 41, 10,105,117,112, 46,
- 66, 85, 84, 84, 79, 78, 50, 32, 61, 32,115,116,114,105,110,103, 46, 98,121,116,
-101, 40, 39, 50, 39, 41, 10,105,117,112, 46, 66, 85, 84, 84, 79, 78, 51, 32, 61,
- 32,115,116,114,105,110,103, 46, 98,121,116,101, 40, 39, 51, 39, 41, 10,105,117,
-112, 46, 66, 85, 84, 84, 79, 78, 52, 32, 61, 32,115,116,114,105,110,103, 46, 98,
-121,116,101, 40, 39, 52, 39, 41, 10,105,117,112, 46, 66, 85, 84, 84, 79, 78, 53,
- 32, 61, 32,115,116,114,105,110,103, 46, 98,121,116,101, 40, 39, 53, 39, 41, 10,
- 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 45, 45,
- 32, 32, 82,101, 99,111,114,100, 32, 73,110,112,117,116, 10, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,105,117,112, 46, 82, 69, 67, 66,
- 73, 78, 65, 82, 89, 32, 61, 32, 48, 10,105,117,112, 46, 82, 69, 67, 84, 69, 88,
- 84, 32, 61, 32, 49, 10, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 10, 45, 45, 32, 32, 80,114,101, 45, 68,101,102,105,110,101,100, 32,
- 77, 97,115,107,115, 32, 32, 32, 32, 32, 32, 32, 32, 10, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,105,117,112, 46, 77, 65, 83, 75, 95,
- 70, 76, 79, 65, 84, 32, 32, 32, 32, 32, 32, 32, 61, 32, 34, 91, 43, 47, 45, 93,
- 63, 40, 47,100, 43, 47, 46, 63, 47,100, 42,124, 47, 46, 47,100, 43, 41, 34, 10,
-105,117,112, 46, 77, 65, 83, 75, 95, 85, 70, 76, 79, 65, 84, 32, 32, 32, 32, 32,
- 32, 61, 32, 32, 32, 32, 32, 32, 32, 34, 40, 47,100, 43, 47, 46, 63, 47,100, 42,
-124, 47, 46, 47,100, 43, 41, 34, 10,105,117,112, 46, 77, 65, 83, 75, 95, 69, 70,
- 76, 79, 65, 84, 32, 32, 32, 32, 32, 32, 61, 32, 34, 91, 43, 47, 45, 93, 63, 40,
- 47,100, 43, 47, 46, 63, 47,100, 42,124, 47, 46, 47,100, 43, 41, 40, 91,101, 69,
- 93, 91, 43, 47, 45, 93, 63, 47,100, 43, 41, 63, 34, 10,105,117,112, 46, 77, 65,
- 83, 75, 95, 70, 76, 79, 65, 84, 67, 79, 77, 77, 65, 32, 32, 61, 32, 34, 91, 43,
- 47, 45, 93, 63, 40, 47,100, 43, 47, 44, 63, 47,100, 42,124, 47, 44, 47,100, 43,
- 41, 34, 10,105,117,112, 46, 77, 65, 83, 75, 95, 85, 70, 76, 79, 65, 84, 67, 79,
- 77, 77, 65, 32, 61, 32, 32, 32, 32, 32, 32, 32, 34, 40, 47,100, 43, 47, 44, 63,
- 47,100, 42,124, 47, 44, 47,100, 43, 41, 34, 10,105,117,112, 46, 77, 65, 83, 75,
- 95, 73, 78, 84, 32, 32, 32, 32, 32, 32, 32, 32, 32, 61, 32, 32, 34, 91, 43, 47,
- 45, 93, 63, 47,100, 43, 34, 10,105,117,112, 46, 77, 65, 83, 75, 95, 85, 73, 78,
- 84, 32, 32, 32, 32, 32, 32, 32, 32, 61, 32, 32, 32, 32, 32, 32, 32, 32, 34, 47,
-100, 43, 34, 10, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 10, 45, 45, 32, 32, 73,117,112, 71,101,116, 80, 97,114, 97,109, 32, 67, 97,
-108,108, 98, 97, 99,107, 32,115,105,116,117, 97,116,105,111,110,115, 10, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,105,117,112, 46, 71,
- 69, 84, 80, 65, 82, 65, 77, 95, 66, 85, 84, 84, 79, 78, 49, 32, 61, 32, 45, 49,
- 10,105,117,112, 46, 71, 69, 84, 80, 65, 82, 65, 77, 95, 73, 78, 73, 84, 32, 32,
- 32, 32, 61, 32, 45, 50, 10,105,117,112, 46, 71, 69, 84, 80, 65, 82, 65, 77, 95,
- 66, 85, 84, 84, 79, 78, 50, 32, 61, 32, 45, 51, 10,105,117,112, 46, 71, 69, 84,
- 80, 65, 82, 65, 77, 95, 66, 85, 84, 84, 79, 78, 51, 32, 61, 32, 45, 52, 10,105,
-117,112, 46, 71, 69, 84, 80, 65, 82, 65, 77, 95, 67, 76, 79, 83, 69, 32, 32, 32,
- 61, 32, 45, 53, 10,105,117,112, 46, 71, 69, 84, 80, 65, 82, 65, 77, 95, 77, 65,
- 80, 32, 32, 32, 32, 32, 61, 32, 45, 54, 10,105,117,112, 46, 71, 69, 84, 80, 65,
- 82, 65, 77, 95, 79, 75, 32, 32, 32, 32, 32, 32, 61, 32,105,117,112, 46, 71, 69,
- 84, 80, 65, 82, 65, 77, 95, 66, 85, 84, 84, 79, 78, 49, 10,105,117,112, 46, 71,
- 69, 84, 80, 65, 82, 65, 77, 95, 67, 65, 78, 67, 69, 76, 32, 32, 61, 32,105,117,
-112, 46, 71, 69, 84, 80, 65, 82, 65, 77, 95, 66, 85, 84, 84, 79, 78, 50, 10,105,
-117,112, 46, 71, 69, 84, 80, 65, 82, 65, 77, 95, 72, 69, 76, 80, 32, 32, 32, 32,
- 61, 32,105,117,112, 46, 71, 69, 84, 80, 65, 82, 65, 77, 95, 66, 85, 84, 84, 79,
- 78, 51, 10,
-};
-
- iuplua_dobuffer(L,(const char*)B1,sizeof(B1),"=""constants.lua");
-}
Index: srclua5/lh/flattree.lh
===================================================================
--- srclua5/lh/flattree.lh	(revision 5971)
+++ srclua5/lh/flattree.lh	(working copy)
@@ -1,77 +1,77 @@
-/* code automatically generated by bin2c -- DO NOT EDIT */
-{
-/* #include'ing this file in a C program is equivalent to calling
-  if (luaL_loadfile(L,"elem/flattree.lua")==0) lua_pcall(L, 0, 0, 0); 
-*/
-/* elem/flattree.lua */
-static const unsigned char B1[]={
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 45,
- 45, 32, 84,114,101,101, 32, 99,108, 97,115,115, 32, 10, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,108,111, 99, 97,108, 32, 99,
-116,114,108, 32, 61, 32,123, 10, 32, 32,110,105, 99,107, 32, 61, 32, 34,102,108,
- 97,116,116,114,101,101, 34, 44, 10, 32, 32,112, 97,114,101,110,116, 32, 61, 32,
-105,117,112, 46, 87, 73, 68, 71, 69, 84, 44, 10, 32, 32,115,117, 98,100,105,114,
- 32, 61, 32, 34,101,108,101,109, 34, 44, 10, 32, 32,102,117,110, 99,110, 97,109,
-101, 32, 61, 32, 34, 70,108, 97,116, 84,114,101,101, 34, 44, 10, 32, 32, 99,114,
-101, 97,116,105,111,110, 32, 61, 32, 34, 34, 44, 10, 32, 32, 99, 97,108,108, 98,
- 97, 99,107, 32, 61, 32,123, 10, 45, 45, 32, 32, 32, 32,115,101,108,101, 99,116,
-105,111,110, 95, 99, 98, 32, 61, 32, 34,110,110, 34, 44, 10, 45, 45, 32, 32, 32,
- 32,109,117,108,116,105,115,101,108,101, 99,116,105,111,110, 95, 99, 98, 32, 61,
- 32, 34,110,110, 34, 44, 32, 32, 45, 45, 32,102, 97,107,101, 32,100,101,102,105,
-110,105,116,105,111,110, 32,116,111, 32, 98,101, 32,114,101,112,108, 97, 99,101,
-100, 32, 98,121, 32,116,114,101,101,102,117,110, 99,115, 32,109,111,100,117,108,
-101, 10, 45, 45, 32, 32, 32, 32,109,117,108,116,105,117,110,115,101,108,101, 99,
-116,105,111,110, 95, 99, 98, 32, 61, 32, 34,110,110, 34, 44, 32, 32, 45, 45, 32,
-102, 97,107,101, 32,100,101,102,105,110,105,116,105,111,110, 32,116,111, 32, 98,
-101, 32,114,101,112,108, 97, 99,101,100, 32, 98,121, 32,116,114,101,101,102,117,
-110, 99,115, 32,109,111,100,117,108,101, 10, 45, 45, 32, 32, 32, 32, 98,114, 97,
-110, 99,104,111,112,101,110, 95, 99, 98, 32, 61, 32, 34,110, 34, 44, 10, 45, 45,
- 32, 32, 32, 32, 98,114, 97,110, 99,104, 99,108,111,115,101, 95, 99, 98, 32, 61,
- 32, 34,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,101,120,101, 99,117,116,101,108,
-101, 97,102, 95, 99, 98, 32, 61, 32, 34,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,
-101,120,101, 99,117,116,101, 98,114, 97,110, 99,104, 95, 99, 98, 32, 61, 32, 34,
-110, 34, 44, 10, 45, 45, 32, 32, 32, 32,110,111,100,101,114,101,109,111,118,101,
-100, 95, 99, 98, 32, 61, 32, 34,115, 34, 44, 32, 32, 45, 45, 32,102, 97,107,101,
- 32,100,101,102,105,110,105,116,105,111,110, 32,116,111, 32, 98,101, 32,114,101,
-112,108, 97, 99,101,100, 32, 98,121, 32,116,114,101,101,102,117,110, 99,115, 32,
-109,111,100,117,108,101, 10, 45, 45, 32, 32, 32, 32,114,101,110, 97,109,101, 95,
- 99, 98, 32, 61, 32, 34,110,115, 34, 44, 10, 45, 45, 32, 32, 32, 32,115,104,111,
-119,114,101,110, 97,109,101, 95, 99, 98, 32, 61, 32, 34,110, 34, 44, 10, 45, 45,
- 32, 32, 32, 32,114,105,103,104,116, 99,108,105, 99,107, 95, 99, 98, 32, 61, 32,
- 34,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,100,114, 97,103,100,114,111,112, 95,
- 99, 98, 32, 61, 32, 34,110,110,110,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,116,
-111,103,103,108,101,118, 97,108,117,101, 95, 99, 98, 32, 61, 32, 34,110,110, 34,
- 44, 10, 32, 32,125, 44, 10, 45, 45, 32, 32,101,120,116,114, 97,102,117,110, 99,
-115, 32, 61, 32, 49, 44, 10,125, 10, 10, 99,116,114,108, 46, 83,101,116, 78,111,
-100,101, 65,116,116,114,105, 98,117,116,101,115, 32, 61, 32,105,117,112, 46, 84,
-114,101,101, 83,101,116, 78,111,100,101, 65,116,116,114,105, 98,117,116,101,115,
- 10, 99,116,114,108, 46, 83,101,116, 65,110, 99,101,115,116,111,114,115, 65,116,
-116,114,105, 98,117,116,101,115, 32, 61, 32,105,117,112, 46, 84,114,101,101, 83,
-101,116, 65,110, 99,101,115,116,111,114,115, 65,116,116,114,105, 98,117,116,101,
-115, 10, 99,116,114,108, 46, 83,101,116, 68,101,115, 99,101,110,100, 97,110,116,
-115, 65,116,116,114,105, 98,117,116,101,115, 32, 61, 32,105,117,112, 46, 84,114,
-101,101, 83,101,116, 68,101,115, 99,101,110,100, 97,110,116,115, 65,116,116,114,
-105, 98,117,116,101,115, 10, 99,116,114,108, 46, 65,100,100, 78,111,100,101,115,
- 32, 61, 32,105,117,112, 46, 84,114,101,101, 65,100,100, 78,111,100,101,115, 10,
- 99,116,114,108, 46, 71,101,116, 73,100, 32, 61, 32,105,117,112, 46, 84,114,101,
-101, 71,101,116, 73,100, 10, 99,116,114,108, 46, 71,101,116, 85,115,101,114, 73,
-100, 32, 61, 32,105,117,112, 46, 84,114,101,101, 71,101,116, 85,115,101,114, 73,
-100, 10, 99,116,114,108, 46, 83,101,116, 85,115,101,114, 73,100, 32, 61, 32,105,
-117,112, 46, 84,114,101,101, 83,101,116, 85,115,101,114, 73,100, 10, 10,102,117,
-110, 99,116,105,111,110, 32, 99,116,114,108, 46, 99,114,101, 97,116,101, 69,108,
-101,109,101,110,116, 40, 99,108, 97,115,115, 44, 32,112, 97,114, 97,109, 41, 10,
- 32, 32,114,101,116,117,114,110, 32,105,117,112, 46, 70,108, 97,116, 84,114,101,
-101, 40, 41, 10,101,110,100, 10, 10,105,117,112, 46, 82,101,103,105,115,116,101,
-114, 87,105,100,103,101,116, 40, 99,116,114,108, 41, 10,105,117,112, 46, 83,101,
-116, 67,108, 97,115,115, 40, 99,116,114,108, 44, 32, 34,105,117,112, 87,105,100,
-103,101,116, 34, 41, 10,
-};
-
- iuplua_dobuffer(L,(const char*)B1,sizeof(B1),"=""elem/flattree.lua");
-}
+/* code automatically generated by bin2c -- DO NOT EDIT */
+{
+/* #include'ing this file in a C program is equivalent to calling
+  if (luaL_loadfile(L,"elem/flattree.lua")==0) lua_pcall(L, 0, 0, 0); 
+*/
+/* elem/flattree.lua */
+static const unsigned char B1[]={
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 45,
+ 45, 32, 84,114,101,101, 32, 99,108, 97,115,115, 32, 10, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,108,111, 99, 97,108, 32, 99,
+116,114,108, 32, 61, 32,123, 10, 32, 32,110,105, 99,107, 32, 61, 32, 34,102,108,
+ 97,116,116,114,101,101, 34, 44, 10, 32, 32,112, 97,114,101,110,116, 32, 61, 32,
+105,117,112, 46, 87, 73, 68, 71, 69, 84, 44, 10, 32, 32,115,117, 98,100,105,114,
+ 32, 61, 32, 34,101,108,101,109, 34, 44, 10, 32, 32,102,117,110, 99,110, 97,109,
+101, 32, 61, 32, 34, 70,108, 97,116, 84,114,101,101, 34, 44, 10, 32, 32, 99,114,
+101, 97,116,105,111,110, 32, 61, 32, 34, 34, 44, 10, 32, 32, 99, 97,108,108, 98,
+ 97, 99,107, 32, 61, 32,123, 10, 45, 45, 32, 32, 32, 32,115,101,108,101, 99,116,
+105,111,110, 95, 99, 98, 32, 61, 32, 34,110,110, 34, 44, 10, 45, 45, 32, 32, 32,
+ 32,109,117,108,116,105,115,101,108,101, 99,116,105,111,110, 95, 99, 98, 32, 61,
+ 32, 34,110,110, 34, 44, 32, 32, 45, 45, 32,102, 97,107,101, 32,100,101,102,105,
+110,105,116,105,111,110, 32,116,111, 32, 98,101, 32,114,101,112,108, 97, 99,101,
+100, 32, 98,121, 32,116,114,101,101,102,117,110, 99,115, 32,109,111,100,117,108,
+101, 10, 45, 45, 32, 32, 32, 32,109,117,108,116,105,117,110,115,101,108,101, 99,
+116,105,111,110, 95, 99, 98, 32, 61, 32, 34,110,110, 34, 44, 32, 32, 45, 45, 32,
+102, 97,107,101, 32,100,101,102,105,110,105,116,105,111,110, 32,116,111, 32, 98,
+101, 32,114,101,112,108, 97, 99,101,100, 32, 98,121, 32,116,114,101,101,102,117,
+110, 99,115, 32,109,111,100,117,108,101, 10, 45, 45, 32, 32, 32, 32, 98,114, 97,
+110, 99,104,111,112,101,110, 95, 99, 98, 32, 61, 32, 34,110, 34, 44, 10, 45, 45,
+ 32, 32, 32, 32, 98,114, 97,110, 99,104, 99,108,111,115,101, 95, 99, 98, 32, 61,
+ 32, 34,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,101,120,101, 99,117,116,101,108,
+101, 97,102, 95, 99, 98, 32, 61, 32, 34,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,
+101,120,101, 99,117,116,101, 98,114, 97,110, 99,104, 95, 99, 98, 32, 61, 32, 34,
+110, 34, 44, 10, 45, 45, 32, 32, 32, 32,110,111,100,101,114,101,109,111,118,101,
+100, 95, 99, 98, 32, 61, 32, 34,115, 34, 44, 32, 32, 45, 45, 32,102, 97,107,101,
+ 32,100,101,102,105,110,105,116,105,111,110, 32,116,111, 32, 98,101, 32,114,101,
+112,108, 97, 99,101,100, 32, 98,121, 32,116,114,101,101,102,117,110, 99,115, 32,
+109,111,100,117,108,101, 10, 45, 45, 32, 32, 32, 32,114,101,110, 97,109,101, 95,
+ 99, 98, 32, 61, 32, 34,110,115, 34, 44, 10, 45, 45, 32, 32, 32, 32,115,104,111,
+119,114,101,110, 97,109,101, 95, 99, 98, 32, 61, 32, 34,110, 34, 44, 10, 45, 45,
+ 32, 32, 32, 32,114,105,103,104,116, 99,108,105, 99,107, 95, 99, 98, 32, 61, 32,
+ 34,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,100,114, 97,103,100,114,111,112, 95,
+ 99, 98, 32, 61, 32, 34,110,110,110,110, 34, 44, 10, 45, 45, 32, 32, 32, 32,116,
+111,103,103,108,101,118, 97,108,117,101, 95, 99, 98, 32, 61, 32, 34,110,110, 34,
+ 44, 10, 32, 32,125, 44, 10, 45, 45, 32, 32,101,120,116,114, 97,102,117,110, 99,
+115, 32, 61, 32, 49, 44, 10,125, 10, 10, 99,116,114,108, 46, 83,101,116, 78,111,
+100,101, 65,116,116,114,105, 98,117,116,101,115, 32, 61, 32,105,117,112, 46, 84,
+114,101,101, 83,101,116, 78,111,100,101, 65,116,116,114,105, 98,117,116,101,115,
+ 10, 99,116,114,108, 46, 83,101,116, 65,110, 99,101,115,116,111,114,115, 65,116,
+116,114,105, 98,117,116,101,115, 32, 61, 32,105,117,112, 46, 84,114,101,101, 83,
+101,116, 65,110, 99,101,115,116,111,114,115, 65,116,116,114,105, 98,117,116,101,
+115, 10, 99,116,114,108, 46, 83,101,116, 68,101,115, 99,101,110,100, 97,110,116,
+115, 65,116,116,114,105, 98,117,116,101,115, 32, 61, 32,105,117,112, 46, 84,114,
+101,101, 83,101,116, 68,101,115, 99,101,110,100, 97,110,116,115, 65,116,116,114,
+105, 98,117,116,101,115, 10, 99,116,114,108, 46, 65,100,100, 78,111,100,101,115,
+ 32, 61, 32,105,117,112, 46, 84,114,101,101, 65,100,100, 78,111,100,101,115, 10,
+ 99,116,114,108, 46, 71,101,116, 73,100, 32, 61, 32,105,117,112, 46, 84,114,101,
+101, 71,101,116, 73,100, 10, 99,116,114,108, 46, 71,101,116, 85,115,101,114, 73,
+100, 32, 61, 32,105,117,112, 46, 84,114,101,101, 71,101,116, 85,115,101,114, 73,
+100, 10, 99,116,114,108, 46, 83,101,116, 85,115,101,114, 73,100, 32, 61, 32,105,
+117,112, 46, 84,114,101,101, 83,101,116, 85,115,101,114, 73,100, 10, 10,102,117,
+110, 99,116,105,111,110, 32, 99,116,114,108, 46, 99,114,101, 97,116,101, 69,108,
+101,109,101,110,116, 40, 99,108, 97,115,115, 44, 32,112, 97,114, 97,109, 41, 10,
+ 32, 32,114,101,116,117,114,110, 32,105,117,112, 46, 70,108, 97,116, 84,114,101,
+101, 40, 41, 10,101,110,100, 10, 10,105,117,112, 46, 82,101,103,105,115,116,101,
+114, 87,105,100,103,101,116, 40, 99,116,114,108, 41, 10,105,117,112, 46, 83,101,
+116, 67,108, 97,115,115, 40, 99,116,114,108, 44, 32, 34,105,117,112, 87,105,100,
+103,101,116, 34, 41, 10,
+};
+
+ iuplua_dobuffer(L,(const char*)B1,sizeof(B1),"=""elem/flattree.lua");
+}
Index: srclua5/lh/thread.lh
===================================================================
--- srclua5/lh/thread.lh	(revision 5971)
+++ srclua5/lh/thread.lh	(working copy)
@@ -1,33 +1,33 @@
-/* code automatically generated by bin2c -- DO NOT EDIT */
-{
-/* #include'ing this file in a C program is equivalent to calling
-  if (luaL_loadfile(L,"elem/thread.lua")==0) lua_pcall(L, 0, 0, 0); 
-*/
-/* elem/thread.lua */
-static const unsigned char B1[]={
- 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,
- 45, 45, 32, 84,104,114,101, 97,100, 32, 99,108, 97,115,115, 32, 10, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,108,111, 99, 97,
-108, 32, 99,116,114,108, 32, 61, 32,123, 10, 32, 32,110,105, 99,107, 32, 61, 32,
- 34,116,104,114,101, 97,100, 34, 44, 10, 32, 32,112, 97,114,101,110,116, 32, 61,
- 32,105,117,112, 46, 87, 73, 68, 71, 69, 84, 44, 10, 32, 32,115,117, 98,100,105,
-114, 32, 61, 32, 34,101,108,101,109, 34, 44, 10, 32, 32, 99,114,101, 97,116,105,
-111,110, 32, 61, 32, 34, 34, 44, 10, 32, 32, 99, 97,108,108, 98, 97, 99,107, 32,
- 61, 32,123, 10, 32, 32, 32, 32,116,104,114,101, 97,100, 95, 99, 98, 32, 61, 32,
- 34, 34, 44, 32, 10, 32, 32,125, 10,125, 10, 10,102,117,110, 99,116,105,111,110,
- 32, 99,116,114,108, 46, 99,114,101, 97,116,101, 69,108,101,109,101,110,116, 40,
- 99,108, 97,115,115, 44, 32,112, 97,114, 97,109, 41, 10, 32, 32,114,101,116,117,
-114,110, 32,105,117,112, 46, 84,104,114,101, 97,100, 40, 41, 10,101,110,100, 10,
- 10,105,117,112, 46, 82,101,103,105,115,116,101,114, 87,105,100,103,101,116, 40,
- 99,116,114,108, 41, 10,105,117,112, 46, 83,101,116, 67,108, 97,115,115, 40, 99,
-116,114,108, 44, 32, 34,105,117,112, 87,105,100,103,101,116, 34, 41, 10,
-};
-
- iuplua_dobuffer(L,(const char*)B1,sizeof(B1),"=""elem/thread.lua");
-}
+/* code automatically generated by bin2c -- DO NOT EDIT */
+{
+/* #include'ing this file in a C program is equivalent to calling
+  if (luaL_loadfile(L,"elem/thread.lua")==0) lua_pcall(L, 0, 0, 0); 
+*/
+/* elem/thread.lua */
+static const unsigned char B1[]={
+ 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,
+ 45, 45, 32, 84,104,114,101, 97,100, 32, 99,108, 97,115,115, 32, 10, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,108,111, 99, 97,
+108, 32, 99,116,114,108, 32, 61, 32,123, 10, 32, 32,110,105, 99,107, 32, 61, 32,
+ 34,116,104,114,101, 97,100, 34, 44, 10, 32, 32,112, 97,114,101,110,116, 32, 61,
+ 32,105,117,112, 46, 87, 73, 68, 71, 69, 84, 44, 10, 32, 32,115,117, 98,100,105,
+114, 32, 61, 32, 34,101,108,101,109, 34, 44, 10, 32, 32, 99,114,101, 97,116,105,
+111,110, 32, 61, 32, 34, 34, 44, 10, 32, 32, 99, 97,108,108, 98, 97, 99,107, 32,
+ 61, 32,123, 10, 32, 32, 32, 32,116,104,114,101, 97,100, 95, 99, 98, 32, 61, 32,
+ 34, 34, 44, 32, 10, 32, 32,125, 10,125, 10, 10,102,117,110, 99,116,105,111,110,
+ 32, 99,116,114,108, 46, 99,114,101, 97,116,101, 69,108,101,109,101,110,116, 40,
+ 99,108, 97,115,115, 44, 32,112, 97,114, 97,109, 41, 10, 32, 32,114,101,116,117,
+114,110, 32,105,117,112, 46, 84,104,114,101, 97,100, 40, 41, 10,101,110,100, 10,
+ 10,105,117,112, 46, 82,101,103,105,115,116,101,114, 87,105,100,103,101,116, 40,
+ 99,116,114,108, 41, 10,105,117,112, 46, 83,101,116, 67,108, 97,115,115, 40, 99,
+116,114,108, 44, 32, 34,105,117,112, 87,105,100,103,101,116, 34, 41, 10,
+};
+
+ iuplua_dobuffer(L,(const char*)B1,sizeof(B1),"=""elem/thread.lua");
+}
Index: srclua5/lh/tuioclient.lh
===================================================================
--- srclua5/lh/tuioclient.lh	(revision 5971)
+++ srclua5/lh/tuioclient.lh	(working copy)
@@ -1,52 +1,52 @@
-/* code automatically generated by bin2c -- DO NOT EDIT */
-{
-/* #include'ing this file in a C program is equivalent to calling
-  if (luaL_loadfile(L,"ctrl/tuioclient.lua")==0) lua_pcall(L, 0, 0, 0); 
-*/
-/* ctrl/tuioclient.lua */
-static const unsigned char B1[]={
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 45,
- 45, 32, 84,117,105,111, 67,108,105,101,110,116, 32, 99,108, 97,115,115, 32, 10,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
- 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,108,
-111, 99, 97,108, 32, 99,116,114,108, 32, 61, 32,123, 10, 32, 32,110,105, 99,107,
- 32, 61, 32, 34,116,117,105,111, 99,108,105,101,110,116, 34, 44, 10, 32, 32,112,
- 97,114,101,110,116, 32, 61, 32,105,117,112, 46, 87, 73, 68, 71, 69, 84, 44, 10,
- 32, 32, 99,114,101, 97,116,105,111,110, 32, 61, 32, 34, 78, 34, 44, 32, 32, 45,
- 45, 32,111,112,116,105,111,110, 97,108, 32,105,110,116,101,103,101,114, 10, 32,
- 32,102,117,110, 99,110, 97,109,101, 32, 61, 32, 34, 84,117,105,111, 67,108,105,
-101,110,116, 34, 44, 10, 32, 32,115,117, 98,100,105,114, 32, 61, 32, 34, 99,116,
-114,108, 34, 44, 10, 32, 32, 99, 97,108,108, 98, 97, 99,107, 32, 61, 32,123, 10,
- 32, 32,125, 44, 10, 32, 32,105,110, 99,108,117,100,101, 32, 61, 32, 34,105,117,
-112,116,117,105,111, 46,104, 34, 44, 10, 32, 32,101,120,116,114, 97, 99,111,100,
-101, 32, 61, 32, 91, 91, 32, 10, 10,105,110,116, 32,105,117,112,116,117,105,111,
-108,117, 97, 95,111,112,101,110, 40,108,117, 97, 95, 83,116, 97,116,101, 42, 32,
- 76, 41, 10,123, 10, 32, 32,105,102, 32, 40,105,117,112,108,117, 97, 95,111,112,
-101,110, 99, 97,108,108, 95,105,110,116,101,114,110, 97,108, 40, 76, 41, 41, 10,
- 32, 32, 32, 32, 73,117,112, 84,117,105,111, 79,112,101,110, 40, 41, 59, 10, 32,
- 32, 32, 32, 10, 32, 32,105,117,112,108,117, 97, 95,103,101,116, 95,101,110,118,
- 40, 76, 41, 59, 10, 32, 32,105,117,112,116,117,105,111, 99,108,105,101,110,116,
-108,117, 97, 95,111,112,101,110, 40, 76, 41, 59, 10, 32, 32, 10, 32, 32,114,101,
-116,117,114,110, 32, 48, 59, 10,125, 10, 10, 47, 42, 32,111, 98,108,105,103, 97,
-116,111,114,121, 32,116,111, 32,117,115,101, 32,114,101,113,117,105,114,101, 34,
-105,117,112,108,117, 97,116,117,105,111, 34, 32, 42, 47, 10,105,110,116, 32,108,
-117, 97,111,112,101,110, 95,105,117,112,108,117, 97,116,117,105,111, 40,108,117,
- 97, 95, 83,116, 97,116,101, 42, 32, 76, 41, 10,123, 10, 32, 32,114,101,116,117,
-114,110, 32,105,117,112,116,117,105,111,108,117, 97, 95,111,112,101,110, 40, 76,
- 41, 59, 10,125, 10, 10, 93, 93, 10,125, 10, 10,102,117,110, 99,116,105,111,110,
- 32, 99,116,114,108, 46, 99,114,101, 97,116,101, 69,108,101,109,101,110,116, 40,
- 99,108, 97,115,115, 44, 32,112, 97,114, 97,109, 41, 10, 32, 32,114,101,116,117,
-114,110, 32,105,117,112, 46, 84,117,105,111, 67,108,105,101,110,116, 40,112, 97,
-114, 97,109, 91, 49, 93, 41, 10,101,110,100, 10, 10,105,117,112, 46, 82,101,103,
-105,115,116,101,114, 87,105,100,103,101,116, 40, 99,116,114,108, 41, 10,105,117,
-112, 46, 83,101,116, 67,108, 97,115,115, 40, 99,116,114,108, 44, 32, 34,105,117,
-112, 87,105,100,103,101,116, 34, 41, 10,
-};
-
- iuplua_dobuffer(L,(const char*)B1,sizeof(B1),"=""ctrl/tuioclient.lua");
-}
+/* code automatically generated by bin2c -- DO NOT EDIT */
+{
+/* #include'ing this file in a C program is equivalent to calling
+  if (luaL_loadfile(L,"ctrl/tuioclient.lua")==0) lua_pcall(L, 0, 0, 0); 
+*/
+/* ctrl/tuioclient.lua */
+static const unsigned char B1[]={
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 45,
+ 45, 32, 84,117,105,111, 67,108,105,101,110,116, 32, 99,108, 97,115,115, 32, 10,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
+ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10,108,
+111, 99, 97,108, 32, 99,116,114,108, 32, 61, 32,123, 10, 32, 32,110,105, 99,107,
+ 32, 61, 32, 34,116,117,105,111, 99,108,105,101,110,116, 34, 44, 10, 32, 32,112,
+ 97,114,101,110,116, 32, 61, 32,105,117,112, 46, 87, 73, 68, 71, 69, 84, 44, 10,
+ 32, 32, 99,114,101, 97,116,105,111,110, 32, 61, 32, 34, 78, 34, 44, 32, 32, 45,
+ 45, 32,111,112,116,105,111,110, 97,108, 32,105,110,116,101,103,101,114, 10, 32,
+ 32,102,117,110, 99,110, 97,109,101, 32, 61, 32, 34, 84,117,105,111, 67,108,105,
+101,110,116, 34, 44, 10, 32, 32,115,117, 98,100,105,114, 32, 61, 32, 34, 99,116,
+114,108, 34, 44, 10, 32, 32, 99, 97,108,108, 98, 97, 99,107, 32, 61, 32,123, 10,
+ 32, 32,125, 44, 10, 32, 32,105,110, 99,108,117,100,101, 32, 61, 32, 34,105,117,
+112,116,117,105,111, 46,104, 34, 44, 10, 32, 32,101,120,116,114, 97, 99,111,100,
+101, 32, 61, 32, 91, 91, 32, 10, 10,105,110,116, 32,105,117,112,116,117,105,111,
+108,117, 97, 95,111,112,101,110, 40,108,117, 97, 95, 83,116, 97,116,101, 42, 32,
+ 76, 41, 10,123, 10, 32, 32,105,102, 32, 40,105,117,112,108,117, 97, 95,111,112,
+101,110, 99, 97,108,108, 95,105,110,116,101,114,110, 97,108, 40, 76, 41, 41, 10,
+ 32, 32, 32, 32, 73,117,112, 84,117,105,111, 79,112,101,110, 40, 41, 59, 10, 32,
+ 32, 32, 32, 10, 32, 32,105,117,112,108,117, 97, 95,103,101,116, 95,101,110,118,
+ 40, 76, 41, 59, 10, 32, 32,105,117,112,116,117,105,111, 99,108,105,101,110,116,
+108,117, 97, 95,111,112,101,110, 40, 76, 41, 59, 10, 32, 32, 10, 32, 32,114,101,
+116,117,114,110, 32, 48, 59, 10,125, 10, 10, 47, 42, 32,111, 98,108,105,103, 97,
+116,111,114,121, 32,116,111, 32,117,115,101, 32,114,101,113,117,105,114,101, 34,
+105,117,112,108,117, 97,116,117,105,111, 34, 32, 42, 47, 10,105,110,116, 32,108,
+117, 97,111,112,101,110, 95,105,117,112,108,117, 97,116,117,105,111, 40,108,117,
+ 97, 95, 83,116, 97,116,101, 42, 32, 76, 41, 10,123, 10, 32, 32,114,101,116,117,
+114,110, 32,105,117,112,116,117,105,111,108,117, 97, 95,111,112,101,110, 40, 76,
+ 41, 59, 10,125, 10, 10, 93, 93, 10,125, 10, 10,102,117,110, 99,116,105,111,110,
+ 32, 99,116,114,108, 46, 99,114,101, 97,116,101, 69,108,101,109,101,110,116, 40,
+ 99,108, 97,115,115, 44, 32,112, 97,114, 97,109, 41, 10, 32, 32,114,101,116,117,
+114,110, 32,105,117,112, 46, 84,117,105,111, 67,108,105,101,110,116, 40,112, 97,
+114, 97,109, 91, 49, 93, 41, 10,101,110,100, 10, 10,105,117,112, 46, 82,101,103,
+105,115,116,101,114, 87,105,100,103,101,116, 40, 99,116,114,108, 41, 10,105,117,
+112, 46, 83,101,116, 67,108, 97,115,115, 40, 99,116,114,108, 44, 32, 34,105,117,
+112, 87,105,100,103,101,116, 34, 41, 10,
+};
+
+ iuplua_dobuffer(L,(const char*)B1,sizeof(B1),"=""ctrl/tuioclient.lua");
+}
Index: srcview/config.mak
===================================================================
--- srcview/config.mak	(revision 5971)
+++ srcview/config.mak	(working copy)
@@ -67,3 +67,6 @@
 endif
 
 INCLUDES = ../src
+
+STDINCS += /usr/include/dbus-1.0 /usr/lib/dbus-1.0/include
+LIBS += dbus-1
Index: srcview/iup_view.c
===================================================================
--- srcview/iup_view.c	(revision 5971)
+++ srcview/iup_view.c	(working copy)
@@ -202,7 +202,7 @@
   if (!all)
     count = 3;
 
-  ret = IupListDialog(1,"File Format",count,options,1,9,count+1,NULL);
+  ret = IupListDialog(1,"File Format",count,(const char **) options,1,9,count+1,NULL);
   if (ret == -1)
     return NULL;
   else
Index: srcvled/vled_image_editor.c
===================================================================
--- srcvled/vled_image_editor.c	(revision 5971)
+++ srcvled/vled_image_editor.c	(working copy)
@@ -1723,7 +1723,7 @@
 
     qsort(image_names, num_images, sizeof(Ihandle*), compare_names);
 
-    ret = IupListDialog(1, "Open Image", num_images, image_names, 1, 30, 10, NULL);
+    ret = IupListDialog(1, "Open Image", num_images, (const char **) image_names, 1, 30, 10, NULL);
     if (ret != -1)
     {
       char* name = image_names[ret];
Index: tecmake.mak
===================================================================
--- tecmake.mak	(revision 5971)
+++ tecmake.mak	(working copy)
@@ -1389,8 +1389,8 @@
   
   ifdef USE_PKGCONFIG
     # get compile/link flags via pkg-config
-    PKGINCS += $(shell pkg-config --cflags gtk+-$(GTKSFX).0 gdk-$(GTKSFX).0 gtk+-unix-print-$(GTKSFX).0)
-    PKGLIBS += $(shell pkg-config --libs gtk+-$(GTKSFX).0 gdk-$(GTKSFX).0 gtk+-unix-print-$(GTKSFX).0)
+    PKGINCS += $(shell pkg-config --cflags gtk+-$(GTKSFX).0 gdk-$(GTKSFX).0 gtk+-unix-print-$(GTKSFX).0 gmodule-2.0)
+    PKGLIBS += $(shell pkg-config --libs gtk+-$(GTKSFX).0 gdk-$(GTKSFX).0 gtk+-unix-print-$(GTKSFX).0 gmodule-2.0)
     GTK_BASE := $(shell pkg-config --variable=prefix gtk+-$(GTKSFX).0)
     GTK := $(GTK_BASE)    
   else
