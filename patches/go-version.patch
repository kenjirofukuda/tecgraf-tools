diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_button.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_button.c
42c42
<   if (ih->data->type == IUP_BUTTON_TEXT)
---
>   if (ih->data->type & IUP_BUTTON_TEXT)
71c71
<   if (ih->data->type == IUP_BUTTON_IMAGE)
---
>   if (ih->data->type & IUP_BUTTON_IMAGE)
77c77
<       /* if not active and IMINACTIVE is not defined 
---
>       /* if not active and IMINACTIVE is not defined
89c89
<   if (ih->data->type == IUP_BUTTON_IMAGE)
---
>   if (ih->data->type & IUP_BUTTON_IMAGE)
100c100
<   if (ih->data->type == IUP_BUTTON_IMAGE)
---
>   if (ih->data->type & IUP_BUTTON_IMAGE)
193a194
>   char* title;
197a199,200
>   title = iupAttribGet(ih, "TITLE");
> 
201c204,214
<     iupMOT_SETARG(args, num_args, XmNlabelType, XmPIXMAP);
---
> 
>     /* Check if we have both image and text */
>     if (title && *title != 0)
>     {
>       ih->data->type |= IUP_BUTTON_TEXT;  /* IUP_BUTTON_BOTH */
>       iupMOT_SETARG(args, num_args, XmNlabelType, XmPIXMAP_AND_STRING);
>     }
>     else
>     {
>       iupMOT_SETARG(args, num_args, XmNlabelType, XmPIXMAP);
>     }
289c302
<   if (ih->data->type == IUP_BUTTON_TEXT)
---
>   if (ih->data->type & IUP_BUTTON_TEXT)
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_canvas.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_canvas.c
17a18
> #include <stdint.h>
38c39
<   int op = (int)client_data, ipage, ipos;
---
>   int op = (int)(intptr_t)client_data, ipage, ipos;
73c74
<     IFnff action_cb = (IFnff)IupGetCallback(ih,"ACTION");
---
>     IFn action_cb = (IFn)IupGetCallback(ih,"ACTION");
172c173
<   IFnff cb;
---
>   IFn cb;
175c176
<   if (!XtWindow(w) || !ih) 
---
>   if (!XtWindow(w) || !ih)
178c179
<   cb = (IFnff)IupGetCallback(ih,"ACTION");
---
>   cb = (IFn)IupGetCallback(ih,"ACTION");
184c185,186
<     cb(ih, (float)ih->data->posx, (float)ih->data->posy);
---
>     iupAttribSet(ih, "DRAWABLE", (char*)XtWindow(w));
>     cb(ih);
492c494
<   return (char*)iupmot_screen;
---
>   return (char*)(intptr_t)iupmot_screen;
750a753
>   iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_common.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_common.c
55c55
<   /* Intrinsics and Motif do NOT support reparent. 
---
>   /* Intrinsics and Motif do NOT support reparent.
66a67
> 
69a71
> 
692a695,746
> }
> 
> int iupmotIsSystemDarkMode(void)
> {
>   unsigned char bg_r, bg_g, bg_b;
>   unsigned char fg_r, fg_g, fg_b;
>   double bg_lum, fg_lum;
>   XColor xcolor;
>   Colormap colormap;
>   XrmDatabase db;
>   XrmValue value;
>   char* type = NULL;
>   char* bg_str = NULL;
>   char* fg_str = NULL;
> 
>   db = XrmGetDatabase(iupmot_display);
>   if (!db)
>     return 0;
> 
>   /* Try to read background/foreground from X resource database */
>   if (XrmGetResource(db, "*background", "*Background", &type, &value))
>     bg_str = value.addr;
>   if (XrmGetResource(db, "*foreground", "*Foreground", &type, &value))
>     fg_str = value.addr;
> 
>   if (!bg_str || !fg_str)
>     return 0;  /* Can't determine, assume light mode */
> 
>   colormap = DefaultColormap(iupmot_display, iupmot_screen);
> 
>   /* Parse background color */
>   if (!XParseColor(iupmot_display, colormap, bg_str, &xcolor))
>     return 0;
> 
>   bg_r = xcolor.red >> 8;
>   bg_g = xcolor.green >> 8;
>   bg_b = xcolor.blue >> 8;
> 
>   /* Parse foreground color */
>   if (!XParseColor(iupmot_display, colormap, fg_str, &xcolor))
>     return 0;
> 
>   fg_r = xcolor.red >> 8;
>   fg_g = xcolor.green >> 8;
>   fg_b = xcolor.blue >> 8;
> 
>   /* Calculate relative luminance using standard formula (ITU-R BT.709) */
>   bg_lum = 0.2126 * bg_r + 0.7152 * bg_g + 0.0722 * bg_b;
>   fg_lum = 0.2126 * fg_r + 0.7152 * fg_g + 0.0722 * fg_b;
> 
>   /* Dark theme has lower background luminance than foreground */
>   return (bg_lum < fg_lum) ? 1 : 0;
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_dialog.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_dialog.c
746c746
<       XtVaSetValues(ih->handle, XmNiconMask, icon, NULL);
---
>       XtVaSetValues(ih->handle, XmNiconMask, icon_mask, NULL);
1006a1007,1029
>   /* Apply APPID and APPNAME if set */
>   {
>     const char* appid = IupGetGlobal("_IUP_APPID_INTERNAL");
>     const char* appname = IupGetGlobal("_IUP_APPNAME_INTERNAL");
>     Window window = XtWindow(ih->handle);
> 
>     if (appid || appname)
>     {
>       XClassHint class_hint;
>       class_hint.res_name = (char*)(appid ? appid : "iup");
>       class_hint.res_class = (char*)(appname ? appname : "Iup");
>       XSetClassHint(iupmot_display, window, &class_hint);
>     }
> 
>     if (appname)
>     {
>       XStoreName(iupmot_display, window, appname);
>       XChangeProperty(iupmot_display, window, XInternAtom(iupmot_display, "_NET_WM_NAME", False),
>                       XInternAtom(iupmot_display, "UTF8_STRING", False), 8, PropModeReplace,
>                       (unsigned char*)appname, strlen(appname));
>     }
>   }
> 
1017,1023d1039
<   if (IupGetGlobal("_IUP_RESET_DLGBGCOLOR"))
<   {
<     iupmotSetGlobalColorAttrib(dialog_manager, XmNbackground, "DLGBGCOLOR");
<     iupmotSetGlobalColorAttrib(dialog_manager, XmNforeground, "DLGFGCOLOR");
<     IupSetGlobal("_IUP_RESET_DLGBGCOLOR", NULL);
<   }
< 
1033c1049,1050
<   if (ih->data->menu) 
---
> 
>   if (ih->data->menu)
1036c1053
<     IupDestroy(ih->data->menu);  
---
>     IupDestroy(ih->data->menu);
1050c1067
<   
---
> 
1071,1078c1088,1098
<     XtVaSetValues(ih->handle,
<       XmNwidth, width,  /* client size */
<       XmNheight, height,
<       XmNminWidth, width, 
<       XmNminHeight, height, 
<       XmNmaxWidth, width, 
<       XmNmaxHeight, height, 
<       NULL);
---
>     if (width > 0 && height > 0)
>     {
>       XtVaSetValues(ih->handle,
>         XmNwidth, width,  /* client size */
>         XmNheight, height,
>         XmNminWidth, width,
>         XmNminHeight, height,
>         XmNmaxWidth, width,
>         XmNmaxHeight, height,
>         NULL);
>     }
1082,1085c1102,1110
<     XtVaSetValues(ih->handle,
<       XmNwidth, (XtArgVal)(ih->currentwidth - 2*border),     /* excluding the border */
<       XmNheight, (XtArgVal)(ih->currentheight - 2*border - caption),
<       NULL);
---
>     int width = ih->currentwidth - 2*border;
>     int height = ih->currentheight - 2*border - caption;
>     if (width > 0 && height > 0)
>     {
>       XtVaSetValues(ih->handle,
>         XmNwidth, (XtArgVal)width,     /* excluding the border */
>         XmNheight, (XtArgVal)height,
>         NULL);
>     }
1139,1141d1163
<   iupClassRegisterAttribute(ic, "TRAY", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
<   iupClassRegisterAttribute(ic, "TRAYIMAGE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
<   iupClassRegisterAttribute(ic, "TRAYTIP", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_draw_x11.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_draw_x11.c
10a11
> #include <math.h>
14a16,19
> #ifdef IUP_USE_XFT
> #include <X11/Xft/Xft.h>
> #endif
> 
40c45
< static void motDrawGetGeometry(Display *dpy, Drawable wnd, int *_w, int *_h, int *_d)
---
> static int motDrawGetGeometry(Display *dpy, Drawable wnd, int *_w, int *_h, int *_d)
44,48c49,61
<   unsigned int w, h, b, d;
<   XGetGeometry(dpy, wnd, &root, &x, &y, &w, &h, &b, &d);
<   *_w = w;
<   *_h = h;
<   *_d = d;
---
>   unsigned int w = 0, h = 0, b = 0, d = 0;
>   Status status = XGetGeometry(dpy, wnd, &root, &x, &y, &w, &h, &b, &d);
>   if (status == 0)
>   {
>     *_w = 0;
>     *_h = 0;
>     *_d = 0;
>     return 0;
>   }
>   *_w = (int)w;
>   *_h = (int)h;
>   *_d = (int)d;
>   return 1;
53c66
<   IdrawCanvas* dc = calloc(1, sizeof(IdrawCanvas));
---
>   IdrawCanvas* dc;
55a69,72
>   dc = calloc(1, sizeof(IdrawCanvas));
>   if (!dc)
>     return NULL;
> 
57a75,79
>   if (!dc->wnd)
>   {
>     free(dc);
>     return NULL;
>   }
59c81,85
<   dc->gc = XCreateGC(iupmot_display, dc->wnd, 0, NULL);
---
>   if (!motDrawGetGeometry(iupmot_display, dc->wnd, &dc->w, &dc->h, &depth))
>   {
>     free(dc);
>     return NULL;
>   }
61c87,88
<   motDrawGetGeometry(iupmot_display, dc->wnd, &dc->w, &dc->h, &depth);
---
>   if (dc->w <= 0) dc->w = 1;
>   if (dc->h <= 0) dc->h = 1;
63a91,96
>   if (!dc->pixmap)
>   {
>     free(dc);
>     return NULL;
>   }
> 
64a98,112
>   if (!dc->pixmap_gc)
>   {
>     XFreePixmap(iupmot_display, dc->pixmap);
>     free(dc);
>     return NULL;
>   }
> 
>   dc->gc = XCreateGC(iupmot_display, dc->wnd, 0, NULL);
>   if (!dc->gc)
>   {
>     XFreeGC(iupmot_display, dc->pixmap_gc);
>     XFreePixmap(iupmot_display, dc->pixmap);
>     free(dc);
>     return NULL;
>   }
73,75c121,129
<   XFreeGC(iupmot_display, dc->pixmap_gc);
<   XFreePixmap(iupmot_display, dc->pixmap);
<   XFreeGC(iupmot_display, dc->gc);
---
>   if (!dc)
>     return;
> 
>   if (dc->pixmap_gc)
>     XFreeGC(iupmot_display, dc->pixmap_gc);
>   if (dc->pixmap)
>     XFreePixmap(iupmot_display, dc->pixmap);
>   if (dc->gc)
>     XFreeGC(iupmot_display, dc->gc);
82c136
<   int w, h, depth;
---
>   int w = 0, h = 0, depth = 0;
84c138,145
<   motDrawGetGeometry(iupmot_display, dc->wnd, &w, &h, &depth);
---
>   if (!dc || !dc->wnd)
>     return;
> 
>   if (!motDrawGetGeometry(iupmot_display, dc->wnd, &w, &h, &depth))
>     return;
> 
>   if (w <= 0 || h <= 0)
>     return;
91,92c152,155
<     XFreeGC(iupmot_display, dc->pixmap_gc);
<     XFreePixmap(iupmot_display, dc->pixmap);
---
>     if (dc->pixmap_gc)
>       XFreeGC(iupmot_display, dc->pixmap_gc);
>     if (dc->pixmap)
>       XFreePixmap(iupmot_display, dc->pixmap);
94a158,165
>     if (!dc->pixmap)
>     {
>       dc->pixmap_gc = NULL;
>       dc->w = 0;
>       dc->h = 0;
>       return;
>     }
> 
95a167,174
>     if (!dc->pixmap_gc)
>     {
>       XFreePixmap(iupmot_display, dc->pixmap);
>       dc->pixmap = None;
>       dc->w = 0;
>       dc->h = 0;
>       return;
>     }
100a180,182
>   if (!dc || !dc->wnd || !dc->pixmap || !dc->gc)
>     return;
> 
105a188,194
>   if (!dc)
>   {
>     if (w) *w = 0;
>     if (h) *h = 0;
>     return;
>   }
> 
155a245,288
> /* Combined function to set both line style and width in one XChangeGC call */
> static void iDrawSetLineStyleAndWidth(IdrawCanvas* dc, int style, int line_width)
> {
>   XGCValues gcval;
> 
>   /* Set line width */
>   if (line_width == 1)
>     gcval.line_width = 0;
>   else
>     gcval.line_width = line_width;
> 
>   /* Set line style */
>   if (style == IUP_DRAW_STROKE || style == IUP_DRAW_FILL)
>     gcval.line_style = LineSolid;
>   else
>   {
>     if (style == IUP_DRAW_STROKE_DASH)
>     {
>       char dashes[2] = { 9, 3 };
>       XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 2);
>     }
>     else if (style == IUP_DRAW_STROKE_DOT)
>     {
>       char dashes[2] = { 1, 2 };
>       XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 2);
>     }
>     else if (style == IUP_DRAW_STROKE_DASH_DOT)
>     {
>       char dashes[4] = { 7, 3, 1, 3 };
>       XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 4);
>     }
>     else if (style == IUP_DRAW_STROKE_DASH_DOT_DOT)
>     {
>       char dashes[6] = { 7, 3, 1, 3, 1, 3 };
>       XSetDashes(iupmot_display, dc->pixmap_gc, 0, dashes, 6);
>     }
> 
>     gcval.line_style = LineOnOffDash;
>   }
> 
>   /* Batch update both line width and style in one call */
>   XChangeGC(iupmot_display, dc->pixmap_gc, GCLineWidth | GCLineStyle, &gcval);
> }
> 
167,168c300
<     iDrawSetLineWidth(dc, line_width);
<     iDrawSetLineStyle(dc, style);
---
>     iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
178,179c310
<   iDrawSetLineWidth(dc, line_width);
<   iDrawSetLineStyle(dc, style);
---
>   iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
198,199c329
<     iDrawSetLineWidth(dc, line_width);
<     iDrawSetLineStyle(dc, style);
---
>     iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
204a335,355
> IUP_SDK_API void iupdrvDrawEllipse(IdrawCanvas* dc, int x1, int y1, int x2, int y2, long color, int style, int line_width)
> {
>   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
> 
>   iupDrawCheckSwapCoord(x1, x2);
>   iupDrawCheckSwapCoord(y1, y2);
> 
>   /* Draw full ellipse using X11 arc with 360 degree span */
>   /* angle in X11 is 1/64ths of a degree, so 360*64 = 23040 */
>   if (style == IUP_DRAW_FILL)
>   {
>     XSetArcMode(iupmot_display, dc->pixmap_gc, ArcPieSlice);
>     XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1, 0, 23040);
>   }
>   else
>   {
>     iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
>     XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1, 0, 23040);
>   }
> }
> 
208c359,374
<   XPoint* pnt = (XPoint*)malloc(count*sizeof(XPoint)); /* XPoint uses short for coordinates */
---
>   XPoint stack_pnt[256]; /* Stack buffer for small polygons - avoid malloc overhead */
>   XPoint* pnt;
>   int use_heap = 0;
>   int pnt_count;
> 
>   /* Use stack buffer for small polygons, heap for large ones */
>   /* For stroked polygons, we need count+1 points to close the path */
>   pnt_count = (style == IUP_DRAW_FILL) ? count : count + 1;
> 
>   if (pnt_count <= 256)
>     pnt = stack_pnt;
>   else
>   {
>     pnt = (XPoint*)malloc(pnt_count * sizeof(XPoint)); /* XPoint uses short for coordinates */
>     use_heap = 1;
>   }
215a382,388
>   /* For stroked polygons, close the path by adding first point at the end */
>   if (style != IUP_DRAW_FILL)
>   {
>     pnt[count].x = pnt[0].x;
>     pnt[count].y = pnt[0].y;
>   }
> 
222,223c395
<     iDrawSetLineWidth(dc, line_width);
<     iDrawSetLineStyle(dc, style);
---
>     iDrawSetLineStyleAndWidth(dc, style, line_width);  /* Batch GC update */
225c397
<     XDrawLines(iupmot_display, dc->pixmap, dc->pixmap_gc, pnt, count, CoordModeOrigin);
---
>     XDrawLines(iupmot_display, dc->pixmap, dc->pixmap_gc, pnt, pnt_count, CoordModeOrigin);
228c400,468
<   free(pnt);
---
>   if (use_heap)
>     free(pnt);
> }
> 
> IUP_SDK_API void iupdrvDrawPixel(IdrawCanvas* dc, int x, int y, long color)
> {
>   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
>   XDrawPoint(iupmot_display, dc->pixmap, dc->pixmap_gc, x, y);
> }
> 
> IUP_SDK_API void iupdrvDrawRoundedRectangle(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius, long color, int style, int line_width)
> {
>   int diameter;
> 
>   iupDrawCheckSwapCoord(x1, x2);
>   iupDrawCheckSwapCoord(y1, y2);
> 
>   /* Clamp radius to prevent oversized corners */
>   int max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2 : (y2 - y1) / 2;
>   if (corner_radius > max_radius)
>     corner_radius = max_radius;
> 
>   diameter = corner_radius * 2;
> 
>   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
> 
>   if (style == IUP_DRAW_FILL)
>   {
>     /* Fill rounded rectangle by drawing filled arcs and rectangles */
>     /* Top-right arc */
>     XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y1, diameter, diameter, 0 * 64, 90 * 64);
>     /* Bottom-right arc */
>     XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y2 - diameter, diameter, diameter, 270 * 64, 90 * 64);
>     /* Bottom-left arc */
>     XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y2 - diameter, diameter, diameter, 180 * 64, 90 * 64);
>     /* Top-left arc */
>     XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, diameter, diameter, 90 * 64, 90 * 64);
> 
>     /* Fill center rectangle */
>     XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x1 + corner_radius, y1, x2 - x1 - diameter + 1, y2 - y1 + 1);
>     /* Fill left rectangle */
>     XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1 + corner_radius, corner_radius, y2 - y1 - diameter + 1);
>     /* Fill right rectangle */
>     XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - corner_radius + 1, y1 + corner_radius, corner_radius, y2 - y1 - diameter + 1);
>   }
>   else
>   {
>     iDrawSetLineStyleAndWidth(dc, style, line_width);
> 
>     /* Draw rounded rectangle by drawing arcs and lines */
>     /* Top-right arc */
>     XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y1, diameter, diameter, 0 * 64, 90 * 64);
>     /* Bottom-right arc */
>     XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - diameter, y2 - diameter, diameter, diameter, 270 * 64, 90 * 64);
>     /* Bottom-left arc */
>     XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y2 - diameter, diameter, diameter, 180 * 64, 90 * 64);
>     /* Top-left arc */
>     XDrawArc(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y1, diameter, diameter, 90 * 64, 90 * 64);
> 
>     /* Draw connecting lines */
>     /* Top line */
>     XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x1 + corner_radius, y1, x2 - corner_radius, y1);
>     /* Right line */
>     XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x2, y1 + corner_radius, x2, y2 - corner_radius);
>     /* Bottom line */
>     XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x2 - corner_radius, y2, x1 + corner_radius, y2);
>     /* Left line */
>     XDrawLine(iupmot_display, dc->pixmap, dc->pixmap_gc, x1, y2 - corner_radius, x1, y1 + corner_radius);
>   }
265a506,580
> IUP_SDK_API void iupdrvDrawSetClipRoundedRect(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int corner_radius)
> {
>   Region region;
>   XPoint points[100];
>   int num_points = 0;
>   int i;
>   double angle, step;
>   int max_radius;
>   double pi = 3.14159265359;
> 
>   if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)
>   {
>     iupdrvDrawResetClip(dc);
>     return;
>   }
> 
>   iupDrawCheckSwapCoord(x1, x2);
>   iupDrawCheckSwapCoord(y1, y2);
> 
>   /* Clamp radius to prevent oversized corners */
>   max_radius = ((x2 - x1) < (y2 - y1)) ? (x2 - x1) / 2 : (y2 - y1) / 2;
>   if (corner_radius > max_radius)
>     corner_radius = max_radius;
> 
>   /* Create a polygon approximation going clockwise from top-left */
>   /* 8 points per corner arc */
>   step = 90.0 / 8.0;
> 
>   /* Top-left corner arc: from top edge (270) to left edge (180) going clockwise */
>   for (i = 0; i <= 8; i++)
>   {
>     angle = (270.0 - i * step) * pi / 180.0;
>     points[num_points].x = (short)(x1 + corner_radius + (int)(corner_radius * cos(angle)));
>     points[num_points].y = (short)(y1 + corner_radius + (int)(corner_radius * sin(angle)));
>     num_points++;
>   }
> 
>   /* Bottom-left corner arc: from left edge (180) to bottom edge (90) going clockwise */
>   for (i = 1; i <= 8; i++)
>   {
>     angle = (180.0 - i * step) * pi / 180.0;
>     points[num_points].x = (short)(x1 + corner_radius + (int)(corner_radius * cos(angle)));
>     points[num_points].y = (short)(y2 - corner_radius + (int)(corner_radius * sin(angle)));
>     num_points++;
>   }
> 
>   /* Bottom-right corner arc: from bottom edge (90) to right edge (0) going clockwise */
>   for (i = 1; i <= 8; i++)
>   {
>     angle = (90.0 - i * step) * pi / 180.0;
>     points[num_points].x = (short)(x2 - corner_radius + (int)(corner_radius * cos(angle)));
>     points[num_points].y = (short)(y2 - corner_radius + (int)(corner_radius * sin(angle)));
>     num_points++;
>   }
> 
>   /* Top-right corner arc: from right edge (0) to top edge (270 = -90) going clockwise */
>   for (i = 1; i <= 8; i++)
>   {
>     angle = (0.0 - i * step) * pi / 180.0;
>     points[num_points].x = (short)(x2 - corner_radius + (int)(corner_radius * cos(angle)));
>     points[num_points].y = (short)(y1 + corner_radius + (int)(corner_radius * sin(angle)));
>     num_points++;
>   }
> 
>   /* Create X11 region from polygon */
>   region = XPolygonRegion(points, num_points, WindingRule);
>   XSetRegion(iupmot_display, dc->pixmap_gc, region);
>   XDestroyRegion(region);
> 
>   dc->clip_x1 = x1;
>   dc->clip_y1 = y1;
>   dc->clip_x2 = x2;
>   dc->clip_y2 = y2;
> }
> 
276c591,592
< IUP_SDK_API void iupdrvDrawText(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, const char* font, int flags, double text_orientation)
---
> #ifdef IUP_USE_XFT
> static void iDrawTextXft(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, XftFont* xftfont, int flags)
278,279c594,604
<   int num_line, width, off_x;
<   XFontStruct* xfont = (XFontStruct*)iupmotGetFontStruct(font);
---
>   int num_line, off_x;
>   XftDraw* xftdraw;
>   XftColor xftcolor;
>   XRenderColor rendercolor;
>   XGlyphInfo extents;
> 
>   rendercolor.red = (unsigned short)(iupDrawRed(color) << 8);
>   rendercolor.green = (unsigned short)(iupDrawGreen(color) << 8);
>   rendercolor.blue = (unsigned short)(iupDrawBlue(color) << 8);
>   rendercolor.alpha = 0xFFFF;
>   XftColorAllocValue(iupmot_display, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen), &rendercolor, &xftcolor);
281,282c606,611
<   /* IUP_DRAW_LAYOUTCENTER, IUP_DRAW_ELLIPSIS and IUP_DRAW_WRAP are not supported */
<   (void)text_orientation;  /* not supported */
---
>   xftdraw = XftDrawCreate(iupmot_display, dc->pixmap, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen));
>   if (!xftdraw)
>   {
>     XftColorFree(iupmot_display, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen), &xftcolor);
>     return;
>   }
284,285c613,621
<   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color),iupDrawGreen(color),iupDrawBlue(color)));
<   XSetFont(iupmot_display, dc->pixmap_gc, xfont->fid);
---
>   if (flags & IUP_DRAW_CLIP)
>   {
>     XRectangle rect;
>     rect.x = (short)x;
>     rect.y = (short)y;
>     rect.width = (unsigned short)w;
>     rect.height = (unsigned short)h;
>     XftDrawSetClipRectangles(xftdraw, 0, 0, &rect, 1);
>   }
288a625,707
>   if (num_line == 1)
>   {
>     off_x = 0;
>     if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
>     {
>       XftTextExtentsUtf8(iupmot_display, xftfont, (FcChar8*)text, len, &extents);
>       if (flags & IUP_DRAW_RIGHT)
>       {
>         off_x = w - extents.xOff;
>         if (off_x < 0) off_x = 0;
>       }
>       else
>       {
>         off_x = (w - extents.xOff) / 2;
>         if (off_x < 0) off_x = 0;
>       }
>     }
> 
>     XftDrawStringUtf8(xftdraw, &xftcolor, xftfont, x + off_x, y + xftfont->ascent, (FcChar8*)text, len);
>   }
>   else
>   {
>     int i, line_height, l_len, sum_len = 0;
>     const char *p, *q;
> 
>     line_height = xftfont->ascent + xftfont->descent;
> 
>     p = text;
>     for (i = 0; i < num_line; i++)
>     {
>       q = strchr(p, '\n');
>       if (q)
>         l_len = (int)(q - p);
>       else
>         l_len = (int)strlen(p);
> 
>       if (sum_len + l_len > len)
>         l_len = len - sum_len;
> 
>       if (l_len)
>       {
>         off_x = 0;
>         if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
>         {
>           XftTextExtentsUtf8(iupmot_display, xftfont, (FcChar8*)p, l_len, &extents);
>           if (flags & IUP_DRAW_RIGHT)
>           {
>             off_x = w - extents.xOff;
>             if (off_x < 0) off_x = 0;
>           }
>           else
>           {
>             off_x = (w - extents.xOff) / 2;
>             if (off_x < 0) off_x = 0;
>           }
>         }
> 
>         XftDrawStringUtf8(xftdraw, &xftcolor, xftfont, x + off_x, y + xftfont->ascent, (FcChar8*)p, l_len);
>       }
> 
>       if (q)
>         p = q + 1;
> 
>       sum_len += l_len;
>       if (sum_len == len)
>         break;
> 
>       y += line_height;
>     }
>   }
> 
>   XftDrawDestroy(xftdraw);
>   XftColorFree(iupmot_display, iupmot_visual, DefaultColormap(iupmot_display, iupmot_screen), &xftcolor);
> }
> #endif
> 
> static void iDrawTextX11(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, XFontStruct* xfont, int flags)
> {
>   int num_line, width, off_x;
> 
>   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
>   XSetFont(iupmot_display, dc->pixmap_gc, xfont->fid);
> 
298a718,719
>   num_line = iupStrLineCount(text, len);
> 
302c723
<     if (flags & IUP_DRAW_RIGHT)
---
>     if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
305,312c726,735
<       off_x = w - width;
<       if (off_x < 0) off_x = 0;
<     }
<     else if (flags & IUP_DRAW_CENTER)
<     {
<       width = XTextWidth(xfont, text, len);
<       off_x = (w - width) / 2;
<       if (off_x < 0) off_x = 0;
---
>       if (flags & IUP_DRAW_RIGHT)
>       {
>         off_x = w - width;
>         if (off_x < 0) off_x = 0;
>       }
>       else
>       {
>         off_x = (w - width) / 2;
>         if (off_x < 0) off_x = 0;
>       }
329c752
<         l_len = (int)(q - p);  /* Cut the string to contain only one line */
---
>         l_len = (int)(q - p);
331c754
<         l_len = (int)strlen(p);  /* use the remaining characters */
---
>         l_len = (int)strlen(p);
339c762
<         if (flags & IUP_DRAW_RIGHT)
---
>         if (flags & (IUP_DRAW_RIGHT | IUP_DRAW_CENTER))
342,349c765,774
<           off_x = w - width;
<           if (off_x < 0) off_x = 0;
<         }
<         else if (flags & IUP_DRAW_CENTER)
<         {
<           width = XTextWidth(xfont, p, l_len);
<           off_x = (w - width) / 2;
<           if (off_x < 0) off_x = 0;
---
>           if (flags & IUP_DRAW_RIGHT)
>           {
>             off_x = w - width;
>             if (off_x < 0) off_x = 0;
>           }
>           else
>           {
>             off_x = (w - width) / 2;
>             if (off_x < 0) off_x = 0;
>           }
352d776
<         /* Draw the line */
356d779
<       /* Advance the string */
364d786
<       /* Advance a line */
369d790
<   /* restore settings */
373a795,816
> IUP_SDK_API void iupdrvDrawText(IdrawCanvas* dc, const char* text, int len, int x, int y, int w, int h, long color, const char* font, int flags, double text_orientation)
> {
>   (void)text_orientation;
> 
> #ifdef IUP_USE_XFT
>   {
>     XftFont* xftfont = (XftFont*)iupmotGetXftFont(font);
>     if (xftfont)
>     {
>       iDrawTextXft(dc, text, len, x, y, w, h, color, xftfont, flags);
>       return;
>     }
>   }
> #endif
> 
>   {
>     XFontStruct* xfont = (XFontStruct*)iupmotGetFontStruct(font);
>     if (xfont)
>       iDrawTextX11(dc, text, len, x, y, w, h, color, xfont, flags);
>   }
> }
> 
385,387c828,830
<   XCopyArea(iupmot_display, pixmap, dc->pixmap, dc->pixmap_gc, 0, 0, img_w, img_h, x, y);
< 
<   /* zoom not supported */
---
>   /* Image scaling not supported in X11 driver */
>   if (w == -1 || w == 0) w = img_w;
>   if (h == -1 || h == 0) h = img_h;
389a833,834
> 
>   XCopyArea(iupmot_display, pixmap, dc->pixmap, dc->pixmap_gc, 0, 0, img_w, img_h, x, y);
411a857,992
> }
> 
> IUP_SDK_API void iupdrvDrawBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, long color, int style, int line_width)
> {
>   /* X11/Motif does not have native Bezier support - use line approximation */
>   XPoint points[21]; /* 20 segments should give smooth curve */
>   int i, num_segments = 20;
> 
>   /* Set color and line properties */
>   XSetForeground(iupmot_display, dc->pixmap_gc, iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color)));
>   XSetLineAttributes(iupmot_display, dc->pixmap_gc, line_width, LineSolid, CapRound, JoinRound);
> 
>   /* Generate points along Bezier curve using parametric equation */
>   for (i = 0; i <= num_segments; i++)
>   {
>     double t = (double)i / num_segments;
>     double t1 = 1.0 - t;
>     double t1_3 = t1 * t1 * t1;
>     double t1_2_t = 3.0 * t1 * t1 * t;
>     double t1_t_2 = 3.0 * t1 * t * t;
>     double t_3 = t * t * t;
> 
>     points[i].x = (short)(t1_3 * x1 + t1_2_t * x2 + t1_t_2 * x3 + t_3 * x4);
>     points[i].y = (short)(t1_3 * y1 + t1_2_t * y2 + t1_t_2 * y3 + t_3 * y4);
>   }
> 
>   if (style == IUP_DRAW_FILL)
>   {
>     /* Fill as polygon */
>     XFillPolygon(iupmot_display, dc->pixmap, dc->pixmap_gc, points, num_segments + 1, Nonconvex, CoordModeOrigin);
>   }
>   else
>   {
>     /* Draw as polyline */
>     XDrawLines(iupmot_display, dc->pixmap, dc->pixmap_gc, points, num_segments + 1, CoordModeOrigin);
>   }
> }
> 
> IUP_SDK_API void iupdrvDrawQuadraticBezier(IdrawCanvas* dc, int x1, int y1, int x2, int y2, int x3, int y3, long color, int style, int line_width)
> {
>   /* Convert quadratic Bezier to cubic Bezier using the 2/3 formula */
>   int cx1, cy1, cx2, cy2;
> 
>   cx1 = x1 + ((2 * (x2 - x1)) / 3);
>   cy1 = y1 + ((2 * (y2 - y1)) / 3);
>   cx2 = x3 + ((2 * (x2 - x3)) / 3);
>   cy2 = y3 + ((2 * (y2 - y3)) / 3);
> 
>   iupdrvDrawBezier(dc, x1, y1, cx1, cy1, cx2, cy2, x3, y3, color, style, line_width);
> }
> 
> static long x11InterpolateColor(long color1, long color2, float t)
> {
>   unsigned char r1 = iupDrawRed(color1), g1 = iupDrawGreen(color1), b1 = iupDrawBlue(color1), a1 = iupDrawAlpha(color1);
>   unsigned char r2 = iupDrawRed(color2), g2 = iupDrawGreen(color2), b2 = iupDrawBlue(color2), a2 = iupDrawAlpha(color2);
>   unsigned char r = (unsigned char)(r1 + t * (r2 - r1));
>   unsigned char g = (unsigned char)(g1 + t * (g2 - g1));
>   unsigned char b = (unsigned char)(b1 + t * (b2 - b1));
>   unsigned char a = (unsigned char)(a1 + t * (a2 - a1));
>   return iupDrawColor(r, g, b, a);
> }
> 
> IUP_SDK_API void iupdrvDrawLinearGradient(IdrawCanvas* dc, int x1, int y1, int x2, int y2, float angle, long color1, long color2)
> {
>   int i, steps;
>   float t, dx, dy, length;
>   int px1, py1, px2, py2;
>   unsigned long pixel;
> 
>   iupDrawCheckSwapCoord(x1, x2);
>   iupDrawCheckSwapCoord(y1, y2);
> 
>   /* Calculate gradient direction */
>   float rad = angle * 3.14159265359f / 180.0f;
>   dx = (float)cos(rad);
>   dy = (float)sin(rad);
> 
>   /* Number of steps for smooth gradient */
>   length = (float)sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
>   steps = (int)length;
>   if (steps < 2) steps = 2;
>   if (steps > 256) steps = 256;
> 
>   /* Draw gradient strips */
>   for (i = 0; i < steps; i++)
>   {
>     t = (float)i / (float)(steps - 1);
>     long color = x11InterpolateColor(color1, color2, t);
> 
>     pixel = iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color));
>     XSetForeground(iupmot_display, dc->pixmap_gc, pixel);
> 
>     /* Calculate strip position */
>     if (fabs(dx) > fabs(dy))  /* More horizontal */
>     {
>       px1 = x1 + (int)(t * (x2 - x1));
>       px2 = x1 + (int)((t + 1.0f / steps) * (x2 - x1));
>       py1 = y1;
>       py2 = y2;
>     }
>     else  /* More vertical */
>     {
>       px1 = x1;
>       px2 = x2;
>       py1 = y1 + (int)(t * (y2 - y1));
>       py2 = y1 + (int)((t + 1.0f / steps) * (y2 - y1));
>     }
> 
>     XFillRectangle(iupmot_display, dc->pixmap, dc->pixmap_gc, px1, py1, px2 - px1 + 1, py2 - py1 + 1);
>   }
> }
> 
> IUP_SDK_API void iupdrvDrawRadialGradient(IdrawCanvas* dc, int cx, int cy, int radius, long colorCenter, long colorEdge)
> {
>   int i, steps;
>   float t, r;
>   unsigned long pixel;
> 
>   /* Number of steps for smooth gradient */
>   steps = radius;
>   if (steps < 2) steps = 2;
>   if (steps > 256) steps = 256;
> 
>   /* Draw from outside to inside */
>   for (i = steps - 1; i >= 0; i--)
>   {
>     t = (float)i / (float)(steps - 1);
>     long color = x11InterpolateColor(colorCenter, colorEdge, t);
>     r = (float)radius * t;
> 
>     pixel = iupmotColorGetPixel(iupDrawRed(color), iupDrawGreen(color), iupDrawBlue(color));
>     XSetForeground(iupmot_display, dc->pixmap_gc, pixel);
> 
>     XSetArcMode(iupmot_display, dc->pixmap_gc, ArcPieSlice);
>     XFillArc(iupmot_display, dc->pixmap, dc->pixmap_gc, (int)(cx - r), (int)(cy - r), (int)(2 * r), (int)(2 * r), 0, 23040);
>   }
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_drv.h /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_drv.h
44a45,48
> #ifdef IUP_USE_XFT
> void* iupmotGetXftFontAttrib(Ihandle *ih);
> void* iupmotGetXftFont(const char* value);
> #endif
59a64,72
> void iupmotStrSetUTF8Mode(int utf8mode);
> void iupmotStrSetUTF8ModeFile(int utf8mode);
> int iupmotStrGetUTF8Mode(void);
> int iupmotStrGetUTF8ModeFile(void);
> char* iupmotStrConvertToSystem(const char* str);
> char* iupmotStrConvertFromSystem(const char* str);
> char* iupmotStrConvertToFilename(const char* str);
> char* iupmotStrConvertFromFilename(const char* str);
> void iupmotStrRelease(void);
86a100,109
> 
> /* tray */
> int iupmotSetTrayAttrib(Ihandle* ih, const char* value);
> int iupmotSetTrayTipAttrib(Ihandle* ih, const char* value);
> int iupmotSetTrayImageAttrib(Ihandle* ih, const char* value);
> int iupmotSetTrayMenuAttrib(Ihandle* ih, const char* value);
> void iupmotTrayCleanup(Ihandle* ih);
> 
> /* dark mode */
> int iupmotIsSystemDarkMode(void);
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_filedlg.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_filedlg.c
517a518
>   iupAttribSet(ih, "DRAWABLE", (char*)XtWindow(w));
566a568,579
> 
>   if (iupAttribGetBoolean(ih, "SHOWPREVIEW"))
>   {
>     Widget preview_canvas = (Widget)iupAttribGet(ih, "WID");
>     if (preview_canvas)
>     {
>       Window wnd = XtWindow(preview_canvas);
>       if (wnd)
>         XClearArea(iupmot_display, wnd, 0, 0, 0, 0, True);
>     }
>   }
> 
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_font.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_font.c
12a13,16
> #ifdef IUP_USE_XFT
> #include <X11/Xft/Xft.h>
> #endif
> 
26c30
< typedef struct _ImotFont 
---
> typedef struct _ImotFont
31a36,40
> #ifdef IUP_USE_XFT
>   XftFont *xftfont;
>   char xft_pattern[1024];
>   int is_xft;
> #endif
137a147,185
> #ifdef IUP_USE_XFT
> static XftFont* motLoadXftFont(const char* typeface, int size, int bold, int italic, char* pattern_out)
> {
>   XftFont* xftfont;
>   char font_name[1024];
>   int xft_size;
> 
>   if (iupStrEqualNoCase(typeface, "System"))
>     typeface = "Sans";
> 
>   if (iupStrEqualNoCase(typeface, "fixed"))
>     typeface = "Monospace";
> 
>   if (size < 0)
>   {
>     double res = ((double)DisplayWidth(iupmot_display, iupmot_screen) / (double)DisplayWidthMM(iupmot_display, iupmot_screen));
>     xft_size = iupRound((-size / res)*2.83464567);
>   }
>   else
>     xft_size = size;
> 
>   if (bold && italic)
>     sprintf(font_name, "%s:size=%d:weight=bold:slant=italic", typeface, xft_size);
>   else if (bold)
>     sprintf(font_name, "%s:size=%d:weight=bold", typeface, xft_size);
>   else if (italic)
>     sprintf(font_name, "%s:size=%d:slant=italic", typeface, xft_size);
>   else
>     sprintf(font_name, "%s:size=%d", typeface, xft_size);
> 
>   xftfont = XftFontOpenName(iupmot_display, iupmot_screen, font_name);
> 
>   if (xftfont && pattern_out)
>     strcpy(pattern_out, font_name);
> 
>   return xftfont;
> }
> #endif
> 
167a216,312
> #ifdef IUP_USE_XFT
> static XmFontList motFontCreateXftRenderTable(const char* xft_pattern, int is_underline, int is_strikeout, XftFont* xftfont)
> {
>   XmFontList fontlist;
>   XmRendition rendition;
>   Arg args[20];
>   int num_args = 0;
>   char family[256];
>   int size = 0;
>   int weight = 0;  /* 0=normal, 1=bold */
>   int slant = 0;   /* 0=normal, 1=italic */
> 
>   /* Parse the XFT pattern to extract family, size, weight, slant */
>   {
>     const char* p = xft_pattern;
>     char* f = family;
> 
>     /* Extract family name (everything before first ':') */
>     while (*p && *p != ':' && (f - family) < 255)
>       *f++ = *p++;
>     *f = '\0';
> 
>     /* Parse properties after ':' */
>     while (*p)
>     {
>       if (*p == ':')
>       {
>         p++;
>         if (strncmp(p, "size=", 5) == 0)
>         {
>           size = atoi(p + 5);
>           while (*p && *p != ':') p++;
>         }
>         else if (strncmp(p, "weight=bold", 11) == 0)
>         {
>           weight = 1;
>           while (*p && *p != ':') p++;
>         }
>         else if (strncmp(p, "slant=italic", 12) == 0)
>         {
>           slant = 1;
>           while (*p && *p != ':') p++;
>         }
>         else
>         {
>           /* Skip unknown property */
>           while (*p && *p != ':') p++;
>         }
>       }
>       else
>         p++;
>     }
>   }
> 
>   /* Set Motif XFT rendition resources separately */
>   iupMOT_SETARG(args, num_args, XmNfontName, family);
>   iupMOT_SETARG(args, num_args, XmNfontType, XmFONT_IS_XFT);
>   if (size > 0)
>     iupMOT_SETARG(args, num_args, XmNfontSize, size);
> 
>   /* Build style string for XmNfontStyle (e.g., "Bold Italic") */
>   if (weight || slant)
>   {
>     static char style[64];
>     style[0] = '\0';
>     if (weight)
>       strcat(style, "Bold");
>     if (slant)
>     {
>       if (weight) strcat(style, " ");
>       strcat(style, "Italic");
>     }
>     iupMOT_SETARG(args, num_args, XmNfontStyle, style);
>   }
> 
>   iupMOT_SETARG(args, num_args, XmNloadModel, XmLOAD_IMMEDIATE);
> 
>   if (is_underline)
>     iupMOT_SETARG(args, num_args, XmNunderlineType, XmSINGLE_LINE);
>   else
>     iupMOT_SETARG(args, num_args, XmNunderlineType, XmNO_LINE);
> 
>   if (is_strikeout)
>     iupMOT_SETARG(args, num_args, XmNstrikethruType, XmSINGLE_LINE);
>   else
>     iupMOT_SETARG(args, num_args, XmNstrikethruType, XmNO_LINE);
> 
>   rendition = XmRenditionCreate(iupmot_appshell, "", args, num_args);
> 
>   fontlist = XmRenderTableAddRenditions(NULL, &rendition, 1, XmDUPLICATE);
> 
>   XmRenditionFree(rendition);
> 
>   return fontlist;
> }
> #endif
> 
184a330,344
> #ifdef IUP_USE_XFT
> static int motFontCalcXftCharWidth(XftFont *xftfont)
> {
>   int i, all = 0;
>   XGlyphInfo extents;
> 
>   for (i = 32; i <= 126; i++)
>   {
>     XftTextExtents8(iupmot_display, xftfont, (FcChar8*)&i, 1, &extents);
>     all += extents.xOff;
>   }
>   return all / (126 - 32 + 1);
> }
> #endif
> 
188c348,353
<   XFontStruct* fontstruct;
---
>   XFontStruct* fontstruct = NULL;
>   int try_xft = 0;
> #ifdef IUP_USE_XFT
>   XftFont* xftfont = NULL;
>   char xft_pattern[1024];
> #endif
224a390,395
> #ifdef IUP_USE_XFT
>     xftfont = motLoadXftFont(typeface, size, is_bold, is_italic, xft_pattern);
>     if (xftfont)
>       try_xft = 1;
> #endif
> 
226c397
<     if (!fontstruct) 
---
>     if (!fontstruct && !try_xft)
234,238c405,441
<   strcpy(fonts[i].xlfd, xlfd);
<   fonts[i].fontstruct = fontstruct;
<   fonts[i].fontlist = motFontCreateRenderTable(fontstruct, is_underline, is_strikeout);
<   fonts[i].charwidth = motFontCalcCharWidth(fontstruct);
<   fonts[i].charheight = fontstruct->ascent + fontstruct->descent;
---
> #ifdef IUP_USE_XFT
>   if (try_xft && xftfont)
>   {
>     strcpy(fonts[i].xft_pattern, xft_pattern);
>     fonts[i].xftfont = xftfont;
>     fonts[i].is_xft = 1;
>     fonts[i].fontlist = motFontCreateXftRenderTable(xft_pattern, is_underline, is_strikeout, xftfont);
> 
>     if (fontstruct)
>     {
>       strcpy(fonts[i].xlfd, xlfd);
>       fonts[i].fontstruct = fontstruct;
>       fonts[i].charwidth = motFontCalcCharWidth(fontstruct);
>       fonts[i].charheight = fontstruct->ascent + fontstruct->descent;
>     }
>     else
>     {
>       strcpy(fonts[i].xlfd, "");
>       fonts[i].fontstruct = NULL;
>       fonts[i].charwidth = motFontCalcXftCharWidth(xftfont);
>       fonts[i].charheight = xftfont->ascent + xftfont->descent;
>     }
>   }
>   else
> #endif
>   {
>     strcpy(fonts[i].xlfd, xlfd);
>     fonts[i].fontstruct = fontstruct;
> #ifdef IUP_USE_XFT
>     fonts[i].xftfont = NULL;
>     strcpy(fonts[i].xft_pattern, "");
>     fonts[i].is_xft = 0;
> #endif
>     fonts[i].fontlist = motFontCreateRenderTable(fontstruct, is_underline, is_strikeout);
>     fonts[i].charwidth = motFontCalcCharWidth(fontstruct);
>     fonts[i].charheight = fontstruct->ascent + fontstruct->descent;
>   }
252a456,458
> #ifdef IUP_USE_XFT
>     font = "Sans, 12";
> #else
253a460
> #endif
288c495
<   if (!motfont) 
---
>   if (!motfont)
293a501,512
> #ifdef IUP_USE_XFT
> void* iupmotGetXftFont(const char* value)
> {
>   ImotFont *motfont = motFindFont(NULL, value);
>   if (!motfont)
>     return NULL;
>   if (motfont->is_xft)
>     return (void*)motfont->xftfont;
>   return NULL;
> }
> #endif
> 
343,344c562,568
<   else
<     return (char*)motfont->fontstruct->fid;
---
> #ifdef IUP_USE_XFT
>   if (motfont->is_xft)
>     return NULL;
> #endif
>   if (!motfont->fontstruct)
>     return NULL;
>   return (char*)motfont->fontstruct->fid;
346a571,582
> #ifdef IUP_USE_XFT
> void* iupmotGetXftFontAttrib(Ihandle *ih)
> {
>   ImotFont* motfont = motGetFont(ih);
>   if (!motfont)
>     return NULL;
>   if (motfont->is_xft)
>     return (void*)motfont->xftfont;
>   return NULL;
> }
> #endif
> 
350c586
<   if (!motfont) 
---
>   if (!motfont)
356c592
<   /* FONT attribute must be able to be set before mapping, 
---
>   /* FONT attribute must be able to be set before mapping,
358a595
>   {
359a597,598
>     XtVaSetValues(ih->handle, XmNfontList, motfont->fontlist, NULL);
>   }
366c605
<   XFontStruct* fontstruct;
---
>   ImotFont* motfont;
373,374c612,613
<   fontstruct = (XFontStruct*)iupmotGetFontStructAttrib(ih);
<   if (!fontstruct)
---
>   motfont = motGetFont(ih);
>   if (!motfont)
383c622,635
<   return XTextWidth(fontstruct, str, len);
---
> #ifdef IUP_USE_XFT
>   if (motfont->is_xft && motfont->xftfont)
>   {
>     XGlyphInfo extents;
>     XftTextExtentsUtf8(iupmot_display, motfont->xftfont, (FcChar8*)str, len, &extents);
>     return extents.xOff;
>   }
>   else
> #endif
>   {
>     if (!motfont->fontstruct)
>       return 0;
>     return XTextWidth(motfont->fontstruct, str, len);
>   }
403c655
<   
---
> 
418c670,684
<         lw = XTextWidth(motfont->fontstruct, curstr, l_len);
---
> #ifdef IUP_USE_XFT
>         if (motfont->is_xft && motfont->xftfont)
>         {
>           XGlyphInfo extents;
>           XftTextExtentsUtf8(iupmot_display, motfont->xftfont, (FcChar8*)curstr, l_len, &extents);
>           lw = extents.xOff;
>         }
>         else
> #endif
>         {
>           if (motfont->fontstruct)
>             lw = XTextWidth(motfont->fontstruct, curstr, l_len);
>           else
>             lw = 0;
>         }
456,459c722,740
<     if (max_width) *max_width = motfont->fontstruct->max_bounds.width;
<     if (line_height) *line_height = motfont->fontstruct->ascent + motfont->fontstruct->descent;
<     if (ascent)    *ascent = motfont->fontstruct->ascent;
<     if (descent)   *descent = motfont->fontstruct->descent;
---
> #ifdef IUP_USE_XFT
>     if (motfont->is_xft && motfont->xftfont)
>     {
>       if (max_width) *max_width = motfont->xftfont->max_advance_width;
>       if (line_height) *line_height = motfont->xftfont->ascent + motfont->xftfont->descent;
>       if (ascent)    *ascent = motfont->xftfont->ascent;
>       if (descent)   *descent = motfont->xftfont->descent;
>     }
>     else
> #endif
>     {
>       if (motfont->fontstruct)
>       {
>         if (max_width) *max_width = motfont->fontstruct->max_bounds.width;
>         if (line_height) *line_height = motfont->fontstruct->ascent + motfont->fontstruct->descent;
>         if (ascent)    *ascent = motfont->fontstruct->ascent;
>         if (descent)   *descent = motfont->fontstruct->descent;
>       }
>     }
493,494c774,788
<     XFreeFont(iupmot_display, fonts[i].fontstruct);
<     fonts[i].fontstruct = NULL;
---
> #ifdef IUP_USE_XFT
>     if (fonts[i].is_xft && fonts[i].xftfont)
>     {
>       XftFontClose(iupmot_display, fonts[i].xftfont);
>       fonts[i].xftfont = NULL;
>     }
>     else
> #endif
>     {
>       if (fonts[i].fontstruct)
>       {
>         XFreeFont(iupmot_display, fonts[i].fontstruct);
>         fonts[i].fontstruct = NULL;
>       }
>     }
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_globalattrib.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_globalattrib.c
155a156,165
>   if (iupStrEqual(name, "UTF8MODE"))
>   {
>     iupmotStrSetUTF8Mode(iupStrBoolean(value));
>     return 1;
>   }
>   if (iupStrEqual(name, "UTF8MODE_FILE"))
>   {
>     iupmotStrSetUTF8ModeFile(iupStrBoolean(value));
>     return 1;
>   }
161c171,176
<   (void)name;
---
>   if (iupStrEqual(name, "UTF8MODE"))
>     return iupStrReturnBoolean(iupmotStrGetUTF8Mode());
>   if (iupStrEqual(name, "UTF8MODE_FILE"))
>     return iupStrReturnBoolean(iupmotStrGetUTF8ModeFile());
>   if (iupStrEqual(name, "DARKMODE"))
>     return iupStrReturnBoolean(iupmotIsSystemDarkMode());
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_image.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_image.c
165c165,166
<   iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);
---
>   if (bgcolor)
>     iupStrToRGB(bgcolor, &bg_r, &bg_g, &bg_b);
178,182c179,193
<         colors[i].r = bg_r;
<         colors[i].g = bg_g;
<         colors[i].b = bg_b;
<         colors[i].a = 255;
<         bgcolor_depend = 1;
---
>         if (bgcolor)
>         {
>           colors[i].r = bg_r;
>           colors[i].g = bg_g;
>           colors[i].b = bg_b;
>           colors[i].a = 255;
>           bgcolor_depend = 1;
>         }
>         else
>         {
>           colors[i].r = 0;
>           colors[i].g = 0;
>           colors[i].b = 0;
>           colors[i].a = 0;
>         }
217c228
<           if (a != 255)
---
>           if (bgcolor && a != 255)
219d229
<             /* flat alpha */
325c335
<   int bpp,y,x,
---
>   int bpp, y, x,
333d342
<   unsigned char colors[256];
336,337d344
<   if (bpp > 8)
<     return 0;
343,344d349
<   iupImageInitNonBgColors(ih, colors);
< 
346c351,352
<   for (y=0; y<height; y++)
---
> 
>   if (bpp == 8)
348c354,357
<     for (x=0; x<width; x++)
---
>     unsigned char colors[256];
>     iupImageInitNonBgColors(ih, colors);
> 
>     for (y=0; y<height; y++)
350,354c359,367
<       int byte = x/8;
<       int bit = x%8;
<       int index = (int)imgdata[y*width+x];
<       if (colors[index])
<         sb[byte] = (char)(sb[byte] | (1<<bit));
---
>       for (x=0; x<width; x++)
>       {
>         int byte = x/8;
>         int bit = x%8;
>         int index = (int)imgdata[y*width+x];
>         if (colors[index])
>           sb[byte] = (char)(sb[byte] | (1<<bit));
>       }
>       sb += line_size;
356,357c369,389
< 
<     sb += line_size;
---
>   }
>   else if (bpp == 32)
>   {
>     for (y=0; y<height; y++)
>     {
>       for (x=0; x<width; x++)
>       {
>         int byte = x/8;
>         int bit = x%8;
>         unsigned char *pixel_data = imgdata + (y*width + x)*4;
>         unsigned char a = *(pixel_data+3);
>         if (a > 127)
>           sb[byte] = (char)(sb[byte] | (1<<bit));
>       }
>       sb += line_size;
>     }
>   }
>   else
>   {
>     free(bits);
>     return 0;
360c392
<   mask = XCreateBitmapFromData(iupmot_display, 
---
>   mask = XCreateBitmapFromData(iupmot_display,
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_label.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_label.c
52,53c52,59
<   /* ignore given value, must use only from parent */
<   value = iupBaseNativeParentGetBgColor(ih);
---
>   unsigned char r, g, b;
> 
>   /* Try to use provided value first */
>   if (!iupStrToRGB(value, &r, &g, &b))
>   {
>     /* Fall back to parent's background if no valid color provided */
>     value = iupBaseNativeParentGetBgColor(ih);
>   }
57c63
<   return 0; 
---
>   return 0;
62,63c68
<   /* ignore given value, must use only from parent */
<   value = iupAttribGetInheritNativeParent(ih, "BACKGROUND");
---
>   unsigned char r, g, b;
65,67c70,71
<   if (iupdrvBaseSetBgColorAttrib(ih, value))
<     return 1;
<   else
---
>   /* Try to use provided value first */
>   if (!value || !iupStrToRGB(value, &r, &g, &b))
69c73,74
<     Pixmap pixmap = (Pixmap)iupImageGetImage(value, ih, 0, NULL);
---
>     /* Check if it's an image name */
>     Pixmap pixmap = value ? (Pixmap)iupImageGetImage(value, ih, 0, NULL) : 0;
74a80,82
> 
>     /* Fall back to parent's background */
>     value = iupAttribGetInheritNativeParent(ih, "BACKGROUND");
76c84,88
<   return 0; 
---
> 
>   if (iupdrvBaseSetBgColorAttrib(ih, value))
>     return 1;
> 
>   return 0;
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_list.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_list.c
20a21
> #include <stdint.h>
43a45,47
> /* Motif XmList does not support per-item images.
>    IMAGE_CB callback is not supported for virtual mode.
>    Use IupFlatList for image support on Motif. */
218a223,227
> void iupdrvListSetItemCount(Ihandle* ih, int count)
> {
>   Widget list_widget;
>   int i;
>   XmString* items;
220c229,239
< /*********************************************************************************/
---
>   if (!ih->data->is_virtual)
>     return;
> 
>   /* Get the list widget */
>   if (ih->data->is_dropdown || ih->data->has_editbox)
>     XtVaGetValues(ih->handle, XmNlist, &list_widget, NULL);
>   else
>     list_widget = ih->handle;
> 
>   /* Delete all existing items */
>   XmListDeleteAllItems(list_widget);
221a241,266
>   if (count <= 0)
>     return;
> 
>   /* Allocate array for all items */
>   items = (XmString*)malloc(count * sizeof(XmString));
>   if (!items)
>     return;
> 
>   /* Build all XmStrings from VALUE_CB */
>   for (i = 0; i < count; i++)
>   {
>     char* text = iupListGetItemValueCb(ih, i + 1);
>     items[i] = XmStringCreateLocalized(text ? (char*)text : "");
>   }
> 
>   /* Add all items in a single batch operation */
>   XmListAddItems(list_widget, items, count, 0);
> 
>   /* Free all XmStrings */
>   for (i = 0; i < count; i++)
>     XmStringFree(items[i]);
> 
>   free(items);
> }
> 
> /*********************************************************************************/
953c998
<   int idDrag = (int)value;  /* starts at 1 */
---
>   int idDrag = (int)(intptr_t)value;  /* starts at 1 */
1098c1143
<   *value_return = (XtPointer)idDrag;  /* starts at 1 */
---
>   *value_return = (XtPointer)(intptr_t)idDrag;  /* starts at 1 */
1587,1594d1631
<   if (IupGetGlobal("_IUP_RESET_TXTCOLORS"))
<   {
<     iupmotSetGlobalColorAttrib(ih->handle, XmNbackground, "TXTBGCOLOR");
<     iupmotSetGlobalColorAttrib(ih->handle, XmNforeground, "TXTFGCOLOR");
<     iupmotSetGlobalColorAttrib(ih->handle, XmNhighlightColor, "TXTHLCOLOR");
<     IupSetGlobal("_IUP_RESET_TXTCOLORS", NULL);
<   }
< 
1597c1634,1641
<   iupListSetInitialItems(ih);
---
>   if (ih->data->is_virtual)
>   {
>     /* Motif doesn't support true virtual mode, populate all items from VALUE_CB */
>     if (ih->data->item_count > 0)
>       iupdrvListSetItemCount(ih, ih->data->item_count);
>   }
>   else
>     iupListSetInitialItems(ih);
1640a1685
>   iupClassRegisterAttribute(ic, "FITIMAGE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
1642a1688
>   iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_menu.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_menu.c
17a18
> #include <stdint.h>
304a306,430
> /*******************************************************************************************/
> 
> static void motRecentItemActivateCallback(Widget w, XtPointer client_data, XtPointer call_data)
> {
>   int index = (int)(intptr_t)client_data;
>   Ihandle* menu = NULL;
>   Icallback recent_cb;
>   Ihandle* config;
>   char attr_name[32];
>   const char* filename;
> 
>   XtVaGetValues(w, XmNuserData, &menu, NULL);
>   if (!menu)
>     return;
> 
>   recent_cb = (Icallback)iupAttribGet(menu, "_IUP_RECENT_CB");
>   config = (Ihandle*)iupAttribGet(menu, "_IUP_CONFIG");
> 
>   if (!recent_cb || !config)
>     return;
> 
>   sprintf(attr_name, "_IUP_RECENT_FILE%d", index);
>   filename = iupAttribGet(menu, attr_name);
> 
>   if (filename)
>   {
>     IupSetStrAttribute(config, "RECENTFILENAME", filename);
>     IupSetStrAttribute(config, "TITLE", filename);
>     config->parent = menu;
> 
>     if (recent_cb(config) == IUP_CLOSE)
>       IupExitLoop();
> 
>     config->parent = NULL;
>     IupSetAttribute(config, "RECENTFILENAME", NULL);
>     IupSetAttribute(config, "TITLE", NULL);
>   }
> 
>   (void)call_data;
> }
> 
> int iupdrvRecentMenuInit(Ihandle* menu, int max_recent, Icallback recent_cb)
> {
>   iupAttribSetInt(menu, "_IUP_RECENT_MAX", max_recent);
>   iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
>   iupAttribSetInt(menu, "_IUP_RECENT_COUNT", 0);
>   return 0;
> }
> 
> int iupdrvRecentMenuUpdate(Ihandle* menu, const char** filenames, int count, Icallback recent_cb)
> {
>   Widget menu_widget;
>   int max_recent, existing, i;
> 
>   if (!menu || !menu->handle)
>     return -1;
> 
>   menu_widget = (Widget)menu->handle;
>   max_recent = iupAttribGetInt(menu, "_IUP_RECENT_MAX");
>   existing = iupAttribGetInt(menu, "_IUP_RECENT_COUNT");
> 
>   if (count > max_recent)
>     count = max_recent;
> 
>   iupAttribSet(menu, "_IUP_RECENT_CB", (char*)recent_cb);
> 
>   for (i = 0; i < count; i++)
>   {
>     char attr_name[32];
>     Widget item;
>     XmString xm_title;
> 
>     sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
>     iupAttribSetStr(menu, attr_name, filenames[i]);
> 
>     sprintf(attr_name, "_IUP_RECENT_ITEM%d", i);
>     item = (Widget)iupAttribGet(menu, attr_name);
> 
>     xm_title = XmStringCreateLocalized((char*)filenames[i]);
> 
>     if (item)
>     {
>       XtVaSetValues(item, XmNlabelString, xm_title, NULL);
>     }
>     else
>     {
>       item = XtVaCreateManagedWidget("recentitem",
>         xmCascadeButtonWidgetClass, menu_widget,
>         XmNlabelString, xm_title,
>         XmNuserData, menu,
>         XmNpositionIndex, i,
>         NULL);
> 
>       XtAddCallback(item, XmNactivateCallback,
>         (XtCallbackProc)motRecentItemActivateCallback, (XtPointer)(intptr_t)i);
> 
>       iupAttribSet(menu, attr_name, (char*)item);
>     }
> 
>     XmStringFree(xm_title);
>   }
> 
>   for (; i < existing; i++)
>   {
>     char attr_name[32];
>     Widget item;
> 
>     sprintf(attr_name, "_IUP_RECENT_ITEM%d", i);
>     item = (Widget)iupAttribGet(menu, attr_name);
>     if (item)
>     {
>       XtDestroyWidget(item);
>       iupAttribSet(menu, attr_name, NULL);
>     }
> 
>     sprintf(attr_name, "_IUP_RECENT_FILE%d", i);
>     iupAttribSet(menu, attr_name, NULL);
>   }
> 
>   iupAttribSetInt(menu, "_IUP_RECENT_COUNT", count);
>   return 0;
> }
> 
> /*******************************************************************************************/
> 
375,400d500
< void iupdrvItemInitClass(Iclass* ic)
< {
<   /* Driver Dependent Class functions */
<   ic->Map = motItemMapMethod;
<   ic->UnMap = iupdrvBaseUnMapMethod;
< 
<   /* Common */
<   iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
< 
<   /* Visual */
<   iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
<   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
< 
<   /* IupItem only */
<   iupClassRegisterAttribute(ic, "VALUE", motItemGetValueAttrib, motItemSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
<   iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
<   iupClassRegisterAttribute(ic, "TITLEIMAGE", NULL, motItemSetTitleImageAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
< 
<   /* IupItem Gtk and Motif only */
<   iupClassRegisterAttribute(ic, "HIDEMARK", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED);
< }
< 
< 
< /*******************************************************************************************/
< 
< 
410c510
<                  xmCascadeButtonWidgetClass, 
---
>                  xmCascadeButtonWidgetClass,
432,452d531
< void iupdrvSubmenuInitClass(Iclass* ic)
< {
<   /* Driver Dependent Class functions */
<   ic->Map = motSubmenuMapMethod;
<   ic->UnMap = iupdrvBaseUnMapMethod;
< 
<   /* Common */
<   iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
< 
<   /* Visual */
<   iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
<   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
< 
<   /* IupSubmenu only */
<   iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
< }
< 
< 
< /*******************************************************************************************/
< 
< 
462c541
<                  xmSeparatorWidgetClass, 
---
>                  xmSeparatorWidgetClass,
474a554,592
> }
> 
> void iupdrvItemInitClass(Iclass* ic)
> {
>   /* Driver Dependent Class functions */
>   ic->Map = motItemMapMethod;
>   ic->UnMap = iupdrvBaseUnMapMethod;
> 
>   /* Common */
>   iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
> 
>   /* Visual */
>   iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
>   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
> 
>   /* IupItem only */
>   iupClassRegisterAttribute(ic, "VALUE", motItemGetValueAttrib, motItemSetValueAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
>   iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
>   iupClassRegisterAttribute(ic, "TITLEIMAGE", NULL, motItemSetTitleImageAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
> 
>   /* IupItem Gtk and Motif only */
>   iupClassRegisterAttribute(ic, "HIDEMARK", NULL, NULL, NULL, NULL, IUPAF_NOT_MAPPED);
> }
> 
> void iupdrvSubmenuInitClass(Iclass* ic)
> {
>   /* Driver Dependent Class functions */
>   ic->Map = motSubmenuMapMethod;
>   ic->UnMap = iupdrvBaseUnMapMethod;
> 
>   /* Common */
>   iupClassRegisterAttribute(ic, "FONT", NULL, iupdrvSetFontAttrib, IUPAF_SAMEASSYSTEM, "DEFAULTFONT", IUPAF_NOT_MAPPED);  /* inherited */
> 
>   /* Visual */
>   iupClassRegisterAttribute(ic, "ACTIVE", iupBaseGetActiveAttrib, iupBaseSetActiveAttrib, IUPAF_SAMEASSYSTEM, "YES", IUPAF_DEFAULT);
>   iupClassRegisterAttribute(ic, "BGCOLOR", NULL, iupdrvBaseSetBgColorAttrib, IUPAF_SAMEASSYSTEM, "DLGBGCOLOR", IUPAF_DEFAULT);
> 
>   /* IupSubmenu only */
>   iupClassRegisterAttribute(ic, "TITLE", NULL, motItemSetTitleAttrib, NULL, NULL, IUPAF_NO_DEFAULTVALUE|IUPAF_NO_INHERIT);
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_open.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_open.c
7,8c7,8
< #include <stdlib.h>    
< #include <stdio.h>    
---
> #include <stdlib.h>
> #include <stdio.h>
10c10,11
< #include <string.h>    
---
> #include <string.h>
> #include <stdint.h>    
39c40
<   unsigned char r, g, b; 
---
>   unsigned char r, g, b;
47a49,76
> /* Set IUP global color from X resource database, with fallback to default */
> static void iupmotSetGlobalColorFromXrm(const char* resource_name, const char* resource_class, const char* iup_name,
>                                          unsigned char def_r, unsigned char def_g, unsigned char def_b)
> {
>   XrmDatabase db;
>   XrmValue value;
>   char* type = NULL;
> 
>   db = XrmGetDatabase(iupmot_display);
>   if (db && XrmGetResource(db, resource_name, resource_class, &type, &value))
>   {
>     XColor xcolor;
>     Colormap colormap = DefaultColormap(iupmot_display, iupmot_screen);
> 
>     if (XParseColor(iupmot_display, colormap, value.addr, &xcolor))
>     {
>       unsigned char r = xcolor.red >> 8;
>       unsigned char g = xcolor.green >> 8;
>       unsigned char b = xcolor.blue >> 8;
>       iupGlobalSetDefaultColorAttrib(iup_name, r, g, b);
>       return;
>     }
>   }
> 
>   /* Fallback to default values */
>   iupGlobalSetDefaultColorAttrib(iup_name, def_r, def_g, def_b);
> }
> 
50a80
>   IupSetGlobal("WINDOWING", "X11");
52,57c82
<   /* XtSetLanguageProc(NULL, NULL, NULL); 
<      Removed to avoid invalid locale in modern Linux that set LANG=en_US.UTF-8 */
< 
<   /* We do NOT use XtVaOpenApplication because it crashes when using internal dummy argc and argv.
<      iupmot_appshell = XtVaOpenApplication(&iupmot_appcontext, "Iup", NULL, 0, argc, *argv, NULL,
<                                            sessionShellWidgetClass, NULL); */
---
>   setlocale(LC_ALL, "");
83c108
<   IupSetGlobal("XSCREEN", (char*)iupmot_screen);
---
>   IupSetGlobal("XSCREEN", (char*)(intptr_t)iupmot_screen);
114c139,141
<   /* dialog background color */
---
>   /* Set default colors from X resources, with fallbacks.
>    * These colors are read from the X resource database (e.g., .Xresources)
>    * allowing users to theme Motif applications via standard X mechanisms. */
116,123c143,150
<     iupmotSetGlobalColorAttrib(iupmot_appshell, XmNbackground, "DLGBGCOLOR");
<     iupGlobalSetDefaultColorAttrib("DLGFGCOLOR", 0, 0, 0);
<     IupSetGlobal("_IUP_RESET_DLGBGCOLOR", "YES");  /* will update the DLGFGCOLOR when the first dialog is mapped */
< 
<     iupGlobalSetDefaultColorAttrib("TXTBGCOLOR", 255, 255, 255);
<     iupGlobalSetDefaultColorAttrib("TXTFGCOLOR", 0, 0, 0);
<     iupGlobalSetDefaultColorAttrib("TXTHLCOLOR", 128, 128, 128);
<     IupSetGlobal("_IUP_RESET_TXTCOLORS", "YES");   /* will update the TXTCOLORS when the first text or list is mapped */
---
>     /* Dialog colors - use *.background and *.foreground */
>     iupmotSetGlobalColorFromXrm("*background", "*Background", "DLGBGCOLOR", 192, 192, 192);
>     iupmotSetGlobalColorFromXrm("*foreground", "*Foreground", "DLGFGCOLOR", 0, 0, 0);
> 
>     /* Text widget colors - also use *.background and *.foreground for consistency */
>     iupmotSetGlobalColorFromXrm("*background", "*Background", "TXTBGCOLOR", 255, 255, 255);
>     iupmotSetGlobalColorFromXrm("*foreground", "*Foreground", "TXTFGCOLOR", 0, 0, 0);
>     iupmotSetGlobalColorFromXrm("*highlightColor", "*HighlightColor", "TXTHLCOLOR", 128, 128, 128);
124a152
>     /* Link color - typically blue, but can be themed */
136a165,186
> int iupdrvSetGlobalAppIDAttrib(const char* value)
> {
>   static int appid_set = 0;
>   if (appid_set || !value || !value[0])
>     return 0;
> 
>   IupStoreGlobal("_IUP_APPID_INTERNAL", value);
>   appid_set = 1;
>   return 1;
> }
> 
> int iupdrvSetGlobalAppNameAttrib(const char* value)
> {
>   static int appname_set = 0;
>   if (appname_set || !value || !value[0])
>     return 0;
> 
>   IupStoreGlobal("_IUP_APPNAME_INTERNAL", value);
>   appname_set = 1;
>   return 1;
> }
> 
138c188
< { 
---
> {
140a191
>   iupmotStrRelease();
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: iupmot_popover.c
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_progressbar.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_progressbar.c
31a32,46
> void iupdrvProgressBarGetMinSize(Ihandle* ih, int* w, int* h)
> {
>   /* Motif XmScale has no intrinsic size API */
>   if (iupStrEqualNoCase(iupAttribGetStr(ih, "ORIENTATION"), "VERTICAL"))
>   {
>     *w = 15;
>     *h = 80;
>   }
>   else
>   {
>     *w = 100;
>     *h = 15;
>   }
> }
> 
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_str.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_str.c
10a11,12
> #include <locale.h>
> #include <langinfo.h>
22a25,274
> #ifdef IUP_USE_ICONV
> #include <iconv.h>
> #endif
> 
> static int iupmot_utf8mode = 0;
> static int iupmot_utf8mode_file = 0;
> static int iupmot_utf8_supported = -1;
> static char* motLastConvertUTF8 = NULL;
> static char* mot_current_charset = NULL;
> 
> static int motStrCheckUTF8Support(void)
> {
>   if (iupmot_utf8_supported != -1)
>     return iupmot_utf8_supported;
> 
>   if (XmVERSION > 2 || (XmVERSION == 2 && XmREVISION >= 3))
>     iupmot_utf8_supported = 1;
>   else
>     iupmot_utf8_supported = 0;
> 
>   return iupmot_utf8_supported;
> }
> 
> static char* motStrGetCurrentCharset(void)
> {
>   if (!mot_current_charset)
>     mot_current_charset = nl_langinfo(CODESET);
>   return mot_current_charset;
> }
> 
> static void motStrResetCharset(void)
> {
>   mot_current_charset = NULL;
> }
> 
> static int motStrIsLocaleUTF8(void)
> {
>   char* charset = motStrGetCurrentCharset();
>   return (iupStrEqualNoCase(charset, "UTF-8") ||
>           iupStrEqualNoCase(charset, "UTF8"));
> }
> 
> #ifdef IUP_USE_ICONV
> static char* motStrToUTF8(const char* str, int len, const char* charset)
> {
>   size_t ulen = (size_t)len;
>   size_t mlen = ulen * 4;
>   char* utf8_buffer;
>   char* utf8_ptr;
>   const char* str_ptr = str;
>   iconv_t cd_iconv;
> 
>   if (!charset)
>     charset = "ISO-8859-1";
> 
>   cd_iconv = iconv_open("UTF-8", charset);
>   if (cd_iconv == (iconv_t)-1)
>     return NULL;
> 
>   utf8_buffer = malloc(mlen + 1);
>   utf8_ptr = utf8_buffer;
> 
>   if (iconv(cd_iconv, (char**)&str_ptr, &ulen, &utf8_ptr, &mlen) == (size_t)-1)
>   {
>     free(utf8_buffer);
>     iconv_close(cd_iconv);
>     return NULL;
>   }
> 
>   *utf8_ptr = 0;
>   iconv_close(cd_iconv);
> 
>   return utf8_buffer;
> }
> 
> static char* motStrFromUTF8(const char* str, const char* charset)
> {
>   size_t ulen = strlen(str);
>   size_t mlen = ulen * 4;
>   char* locale_buffer;
>   char* locale_ptr;
>   const char* str_ptr = str;
>   iconv_t cd_iconv;
> 
>   if (!charset)
>     charset = "ISO-8859-1";
> 
>   cd_iconv = iconv_open(charset, "UTF-8");
>   if (cd_iconv == (iconv_t)-1)
>     return NULL;
> 
>   locale_buffer = malloc(mlen + 1);
>   locale_ptr = locale_buffer;
> 
>   if (iconv(cd_iconv, (char**)&str_ptr, &ulen, &locale_ptr, &mlen) == (size_t)-1)
>   {
>     free(locale_buffer);
>     iconv_close(cd_iconv);
>     return NULL;
>   }
> 
>   *locale_ptr = 0;
>   iconv_close(cd_iconv);
> 
>   return locale_buffer;
> }
> #endif
> 
> void iupmotStrSetUTF8Mode(int utf8mode)
> {
>   iupmot_utf8mode = utf8mode;
>   if (utf8mode && !motStrIsLocaleUTF8())
>   {
>     char* result;
>     result = setlocale(LC_CTYPE, "en_US.UTF-8");
>     if (!result)
>       result = setlocale(LC_CTYPE, "C.UTF-8");
>     if (!result)
>       result = setlocale(LC_CTYPE, "UTF-8");
> 
>     if (result)
>       motStrResetCharset();
>   }
> }
> 
> void iupmotStrSetUTF8ModeFile(int utf8mode)
> {
>   iupmot_utf8mode_file = utf8mode;
> }
> 
> int iupmotStrGetUTF8Mode(void)
> {
>   return iupmot_utf8mode;
> }
> 
> int iupmotStrGetUTF8ModeFile(void)
> {
>   return iupmot_utf8mode_file;
> }
> 
> void iupmotStrRelease(void)
> {
>   if (motLastConvertUTF8)
>   {
>     free(motLastConvertUTF8);
>     motLastConvertUTF8 = NULL;
>   }
> }
> 
> char* iupmotStrConvertToSystem(const char* str)
> {
>   const char* charset = NULL;
> 
>   if (!str || *str == 0)
>     return (char*)str;
> 
>   if (!iupmot_utf8mode)
>     return (char*)str;
> 
>   if (motStrCheckUTF8Support())
>     return (char*)str;
> 
>   if (motStrIsLocaleUTF8())
>     return (char*)str;
> 
>   if (iupStrIsAscii(str))
>     return (char*)str;
> 
>   charset = motStrGetCurrentCharset();
>   if (!charset)
>     charset = "ISO-8859-1";
> 
> #ifdef IUP_USE_ICONV
>   if (motLastConvertUTF8)
>     free(motLastConvertUTF8);
> 
>   motLastConvertUTF8 = motStrFromUTF8(str, charset);
>   if (!motLastConvertUTF8)
>     return (char*)str;
> 
>   return motLastConvertUTF8;
> #else
>   return (char*)str;
> #endif
> }
> 
> char* iupmotStrConvertFromSystem(const char* str)
> {
>   const char* charset = NULL;
> 
>   if (!str || *str == 0)
>     return (char*)str;
> 
>   if (!iupmot_utf8mode)
>     return (char*)str;
> 
>   if (motStrCheckUTF8Support())
>     return (char*)str;
> 
>   if (motStrIsLocaleUTF8())
>     return (char*)str;
> 
>   if (iupStrIsAscii(str))
>     return (char*)str;
> 
>   charset = motStrGetCurrentCharset();
>   if (!charset)
>     charset = "ISO-8859-1";
> 
> #ifdef IUP_USE_ICONV
>   if (motLastConvertUTF8)
>     free(motLastConvertUTF8);
> 
>   motLastConvertUTF8 = motStrToUTF8(str, strlen(str), charset);
>   if (!motLastConvertUTF8)
>     return (char*)str;
> 
>   return motLastConvertUTF8;
> #else
>   return (char*)str;
> #endif
> }
> 
> char* iupmotStrConvertToFilename(const char* str)
> {
>   int old_mode = iupmot_utf8mode;
>   char* result;
> 
>   if (iupmot_utf8mode)
>     iupmot_utf8mode = iupmot_utf8mode_file;
> 
>   result = iupmotStrConvertToSystem(str);
> 
>   iupmot_utf8mode = old_mode;
>   return result;
> }
> 
> char* iupmotStrConvertFromFilename(const char* str)
> {
>   int old_mode = iupmot_utf8mode;
>   char* result;
> 
>   if (iupmot_utf8mode)
>     iupmot_utf8mode = iupmot_utf8mode_file;
> 
>   result = iupmotStrConvertFromSystem(str);
> 
>   iupmot_utf8mode = old_mode;
>   return result;
> }
63c315,327
<   return (char*)XmStringUnparse(str, NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
---
>   char* text;
> 
>   if (iupmot_utf8mode && motStrCheckUTF8Support())
>   {
>     text = (char*)XmStringUnparse(str, "UTF-8", XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
>   }
>   else
>   {
>     text = (char*)XmStringUnparse(str, NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
>     text = iupmotStrConvertFromSystem(text);
>   }
> 
>   return text;
68,70c332,358
<   char* text = iupmotGetXmString(str);
<   char* ret = iupStrReturnStr(text);
<   XtFree(text);
---
>   char* text;
>   char* converted;
>   char* ret;
> 
>   if (iupmot_utf8mode && motStrCheckUTF8Support())
>   {
>     text = (char*)XmStringUnparse(str, "UTF-8", XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
>     ret = iupStrReturnStr(text);
>     XtFree(text);
>   }
>   else
>   {
>     text = (char*)XmStringUnparse(str, NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
>     converted = iupmotStrConvertFromSystem(text);
> 
>     if (converted != text)
>     {
>       ret = iupStrReturnStr(converted);
>       XtFree(text);
>     }
>     else
>     {
>       ret = iupStrReturnStr(text);
>       XtFree(text);
>     }
>   }
> 
74,75d361
< /* TODO: UTF8 support would start here... */
< 
78c364,381
<   return XmStringCreateLocalized((String)value);
---
>   int use_utf8 = 0;
> 
>   if (iupmot_utf8mode)
>     use_utf8 = 1;
> #ifdef IUP_USE_XFT
>   else if (motStrIsLocaleUTF8())
>     use_utf8 = 1;
> #endif
> 
>   if (use_utf8 && motStrCheckUTF8Support())
>   {
>     return XmStringGenerate((XtPointer)value, "UTF-8", XmCHARSET_TEXT, NULL);
>   }
>   else
>   {
>     value = iupmotStrConvertToSystem(value);
>     return XmStringCreateLocalized((String)value);
>   }
89a393
>   value = iupmotStrConvertToSystem(value);
93,96d396
< #ifdef USE_ICONV
< #include <iconv.h>
< #endif
< 
127c427
< #ifdef USE_ICONV
---
> #ifdef IUP_USE_ICONV
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: iupmot_table.c
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_tabs.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_tabs.c
11a12
> #include <Xm/Form.h>
38a40,81
> #define ITABS_CLOSE_SIZE 12
> 
> static Pixmap mot_tabs_close_pixmap = 0;
> 
> static void motTabsInitializeClosePixmap(Widget parent)
> {
>   Pixel fg, bg;
> 
>   if (mot_tabs_close_pixmap != 0)
>     return;
> 
>   static unsigned char close_bits[] = {
>     0x00, 0x00,
>     0x00, 0x00,
>     0x0c, 0x03,
>     0x9c, 0x03,
>     0xf8, 0x01,
>     0xf0, 0x00,
>     0xf0, 0x00,
>     0xf8, 0x01,
>     0x9c, 0x03,
>     0x0c, 0x03,
>     0x00, 0x00,
>     0x00, 0x00
>   };
> 
>   Display* dpy = XtDisplay(parent);
>   Window root = RootWindowOfScreen(XtScreen(parent));
> 
>   XtVaGetValues(parent, XmNforeground, &fg, XmNbackground, &bg, NULL);
> 
>   mot_tabs_close_pixmap = XCreatePixmapFromBitmapData(
>     dpy, root,
>     (char*)close_bits,
>     ITABS_CLOSE_SIZE, ITABS_CLOSE_SIZE,
>     fg,
>     bg,
>     DefaultDepthOfScreen(XtScreen(parent))
>   );
> }
> 
> 
74a118,163
> void iupdrvTabsGetTabSize(Ihandle* ih, const char* tab_title, const char* tab_image, int* tab_width, int* tab_height)
> {
>   int width = 0;
>   int height = 0;
>   int text_width = 0;
>   int text_height = 0;
> 
>   /* Measure text dimensions */
>   if (tab_title)
>   {
>     text_width = iupdrvFontGetStringWidth(ih, tab_title);
>     iupdrvFontGetCharSize(ih, NULL, &text_height);
>     width = text_width;
>     height = text_height;
>   }
> 
>   /* Add image dimensions */
>   if (tab_image)
>   {
>     void* img = iupImageGetImage(tab_image, ih, 0, NULL);
>     if (img)
>     {
>       int img_w, img_h;
>       iupdrvImageGetInfo(img, &img_w, &img_h, NULL);
>       width += img_w;
>       if (tab_title)
>         width += 3;  /* spacing between icon and text */
>       if (img_h > height)
>         height = img_h;
>     }
>   }
> 
>   if (ih->data->horiz_padding > 0)
>     width += 2 * ih->data->horiz_padding;
>   else
>     width += 30;  /* Matches XmNotebook's actual tab rendering */
> 
>   if (ih->data->vert_padding > 0)
>     height += 2 * ih->data->vert_padding;
>   else
>     height += 12;  /* Matches XmNotebook's actual tab rendering */
> 
>   if (tab_width) *tab_width = width;
>   if (tab_height) *tab_height = height;
> }
> 
132a222
>     Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
134c224,227
<     if (tab_button)
---
> 
>     if (tab_label)
>     {
>       XtVaSetValues(tab_label, XmNforeground, color, NULL);
135a229,233
>     }
>     else if (tab_button)
>     {
>       XtVaSetValues(tab_button, XmNforeground, color, NULL);
>     }
143a242
>     Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
145c244,247
<     if (tab_button)
---
> 
>     if (tab_label)
>     {
>       iupmotSetBgColor(tab_label, color);
146a249,253
>     }
>     else if (tab_button)
>     {
>       iupmotSetBgColor(tab_button, color);
>     }
154a262
>     Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
156,158c264,268
<     if (tab_button)
<       XtVaSetValues(tab_button, XmNmarginHeight, ih->data->vert_padding,
<                                 XmNmarginWidth, ih->data->horiz_padding, NULL);
---
>     Widget target = tab_label ? tab_label : tab_button;
> 
>     if (target)
>       XtVaSetValues(target, XmNmarginHeight, ih->data->vert_padding,
>                             XmNmarginWidth, ih->data->horiz_padding, NULL);
168a279
>     Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
170,171c281,284
<     if (tab_button)
<       XtVaSetValues(tab_button, XmNrenderTable, fontlist, NULL);
---
>     Widget target = tab_label ? tab_label : tab_button;
> 
>     if (target)
>       XtVaSetValues(target, XmNrenderTable, fontlist, NULL);
299a413
>     Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
301c415,418
<     if (tab_button)
---
> 
>     if (tab_label)
>       iupmotSetMnemonicTitle(ih, tab_label, pos, value);
>     else if (tab_button)
310c427
<   Widget tab_button;
---
>   Widget target;
315,316c432,436
<   tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
<   if (tab_button)
---
>   Widget tab_label = (Widget)iupAttribGet(child, "_IUPMOT_TABLABEL");
>   Widget tab_button = (Widget)iupAttribGet(child, "_IUPMOT_TABBUTTON");
>   target = tab_label ? tab_label : tab_button;
> 
>   if (target)
322c442
<         XtVaSetValues(tab_button, XmNlabelPixmap, pixmap, NULL);
---
>         XtVaSetValues(target, XmNlabelPixmap, pixmap, NULL);
325c445
<       XtVaSetValues(tab_button, XmNlabelPixmap, NULL, NULL);
---
>       XtVaSetValues(target, XmNlabelPixmap, NULL, NULL);
403c523
<   IFni cb = (IFni)IupGetCallback(ih, "RIGHTCLICK_CB");
---
>   int pos = iupAttribGetInt(child, "_IUPMOT_TABNUMBER");
407c527,571
<   if (evt->type==ButtonPress && evt->button==Button3 && cb)  /* right button clicked on tab */
---
>   if (evt->type==ButtonPress && evt->button==Button1)
>   {
>     Widget tab_close = (Widget)iupAttribGet(child, "_IUPMOT_TABCLOSE");
>     if (tab_close)
>     {
>       Window child_window;
>       int x_rel, y_rel;
>       XTranslateCoordinates(iupmot_display, evt->window, XtWindow(tab_close),
>                             evt->x, evt->y, &x_rel, &y_rel, &child_window);
> 
>       Dimension width, height;
>       XtVaGetValues(tab_close, XmNwidth, &width, XmNheight, &height, NULL);
>       if (child_window == XtWindow(tab_close) ||
>           (x_rel >= 0 && x_rel < width && y_rel >= 0 && y_rel < height))
>       {
>         return;
>       }
> 
>       iupdrvTabsSetCurrentTab(ih, pos);
>     }
>   }
>   else if (evt->type==ButtonPress && evt->button==Button3)
>   {
>     IFni cb = (IFni)IupGetCallback(ih, "RIGHTCLICK_CB");
>     if (cb)
>       cb(ih, pos);
>   }
> }
> 
> static void motTabsCloseButtonActivate(Widget w, XtPointer client_data, XtPointer call_data)
> {
>   Ihandle* child = (Ihandle*)client_data;
>   Ihandle* ih = IupGetParent(child);
>   int pos = iupAttribGetInt(child, "_IUPMOT_TABNUMBER");
>   IFni cb;
>   int ret = IUP_DEFAULT;
> 
>   (void)w;
>   (void)call_data;
> 
>   cb = (IFni)IupGetCallback(ih, "TABCLOSE_CB");
>   if (cb)
>     ret = cb(ih, pos);
> 
>   if (ret == IUP_CONTINUE)
409,410c573,578
<     int pos = iupAttribGetInt(child, "_IUPMOT_TABNUMBER");
<     cb(ih, pos);
---
>     IupDestroy(child);
>     IupRefreshChildren(ih);
>   }
>   else if (ret == IUP_DEFAULT)
>   {
>     IupSetAttributeId(ih, "TABVISIBLE", pos, "NO");
499,506c667,728
<     /* Label */
<     iupMOT_SETARG(args, num_args, XmNlabelType, tabtitle? XmSTRING: XmPIXMAP);
<     iupMOT_SETARG(args, num_args, XmNmarginHeight, 0);
<     iupMOT_SETARG(args, num_args, XmNmarginWidth, 0);
<     /* Notebook Constraint */
<     iupMOT_SETARG(args, num_args, XmNnotebookChildType, XmMAJOR_TAB);
<     iupMOT_SETARG(args, num_args, XmNpageNumber, pos);
<     tab_button = XtCreateManagedWidget("tab_button", xmPushButtonWidgetClass, ih->handle, args, num_args);
---
>     if (ih->data->show_close)
>     {
>       Widget tab_form;
>       Widget tab_label_widget;
>       Widget close_button;
> 
>       num_args = 0;
>       iupMOT_SETARG(args, num_args, XmNmarginHeight, 0);
>       iupMOT_SETARG(args, num_args, XmNmarginWidth, 0);
>       iupMOT_SETARG(args, num_args, XmNborderWidth, 0);
>       iupMOT_SETARG(args, num_args, XmNshadowThickness, 0);
>       iupMOT_SETARG(args, num_args, XmNnotebookChildType, XmMAJOR_TAB);
>       iupMOT_SETARG(args, num_args, XmNpageNumber, pos);
>       tab_form = XtCreateManagedWidget("tab_form", xmFormWidgetClass, ih->handle, args, num_args);
> 
>       tab_label_widget = XtVaCreateManagedWidget(
>         "tab_label",
>         xmLabelWidgetClass,
>         tab_form,
>         XmNlabelType, tabtitle ? XmSTRING : XmPIXMAP,
>         XmNmarginHeight, ih->data->vert_padding,
>         XmNmarginWidth, ih->data->horiz_padding,
>         XmNtopAttachment, XmATTACH_FORM,
>         XmNbottomAttachment, XmATTACH_FORM,
>         XmNleftAttachment, XmATTACH_FORM,
>         NULL
>       );
> 
>       motTabsInitializeClosePixmap(ih->handle);
>       close_button = XtVaCreateManagedWidget(
>         "close_btn",
>         xmPushButtonWidgetClass,
>         tab_form,
>         XmNlabelType, XmPIXMAP,
>         XmNlabelPixmap, mot_tabs_close_pixmap,
>         XmNmarginHeight, 0,
>         XmNmarginWidth, 0,
>         XmNwidth, ITABS_CLOSE_SIZE + 6,
>         XmNheight, ITABS_CLOSE_SIZE + 6,
>         XmNshadowThickness, 1,
>         XmNhighlightThickness, 0,
>         XmNrecomputeSize, False,
>         XmNtopAttachment, XmATTACH_FORM,
>         XmNbottomAttachment, XmATTACH_FORM,
>         XmNrightAttachment, XmATTACH_FORM,
>         XmNleftAttachment, XmATTACH_WIDGET,
>         XmNleftWidget, tab_label_widget,
>         XmNleftOffset, 4,
>         NULL
>       );
> 
>       iupmotDisableDragSource(close_button);
>       XtAddCallback(close_button, XmNactivateCallback,
>                     (XtCallbackProc)motTabsCloseButtonActivate, (XtPointer)child);
> 
>       tab_button = tab_form;
> 
>       XtAddEventHandler(tab_form, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_form, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_form, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_form, KeyPressMask,    False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_form, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
508,509c730
<     /* Disable Drag Source */
<     iupmotDisableDragSource(tab_button);
---
>       XtAddEventHandler(tab_label_widget, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
511,514c732,736
<     XtAddEventHandler(tab_button, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
<     XtAddEventHandler(tab_button, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
<     XtAddEventHandler(tab_button, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
<     XtAddEventHandler(tab_button, KeyPressMask,    False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
---
>       if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
>       {
>         XtAddEventHandler(tab_form, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
>         XtAddEventHandler(child_manager, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
>       }
516c738,745
<     XtAddEventHandler(tab_button, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
---
>       if (tabtitle)
>         iupmotSetMnemonicTitle(ih, tab_label_widget, pos, tabtitle);
>       else
>       {
>         Pixmap pixmap = (Pixmap)iupImageGetImage(tabimage, ih, 0, NULL);
>         if (pixmap)
>           XtVaSetValues(tab_label_widget, XmNlabelPixmap, pixmap, NULL);
>       }
518,521c747,748
<     if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
<     {
<       XtAddEventHandler(tab_button, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
<       XtAddEventHandler(child_manager, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
---
>       iupAttribSet(child, "_IUPMOT_TABLABEL", (char*)tab_label_widget);
>       iupAttribSet(child, "_IUPMOT_TABCLOSE", (char*)close_button);
523,525d749
< 
<     if (tabtitle)
<       iupmotSetMnemonicTitle(ih, tab_button, pos, tabtitle);
528,530c752,781
<       Pixmap pixmap = (Pixmap)iupImageGetImage(tabimage, ih, 0, NULL);
<       if (pixmap)
<         XtVaSetValues(tab_button, XmNlabelPixmap, pixmap, NULL);
---
>       num_args = 0;
>       iupMOT_SETARG(args, num_args, XmNlabelType, tabtitle? XmSTRING: XmPIXMAP);
>       iupMOT_SETARG(args, num_args, XmNmarginHeight, ih->data->vert_padding);
>       iupMOT_SETARG(args, num_args, XmNmarginWidth, ih->data->horiz_padding);
>       iupMOT_SETARG(args, num_args, XmNnotebookChildType, XmMAJOR_TAB);
>       iupMOT_SETARG(args, num_args, XmNpageNumber, pos);
>       tab_button = XtCreateManagedWidget("tab_button", xmPushButtonWidgetClass, ih->handle, args, num_args);
> 
>       iupmotDisableDragSource(tab_button);
> 
>       XtAddEventHandler(tab_button, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_button, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_button, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_button, KeyPressMask,    False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
>       XtAddEventHandler(tab_button, ButtonPressMask, False, (XtEventHandler)motTabsButtonPressEvent, (XtPointer)child);
> 
>       if (iupStrBoolean(IupGetGlobal("INPUTCALLBACKS")))
>       {
>         XtAddEventHandler(tab_button, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
>         XtAddEventHandler(child_manager, PointerMotionMask, False, (XtEventHandler)iupmotDummyPointerMotionEvent, NULL);
>       }
> 
>       if (tabtitle)
>         iupmotSetMnemonicTitle(ih, tab_button, pos, tabtitle);
>       else
>       {
>         Pixmap pixmap = (Pixmap)iupImageGetImage(tabimage, ih, 0, NULL);
>         if (pixmap)
>           XtVaSetValues(tab_button, XmNlabelPixmap, pixmap, NULL);
>       }
583d833
<       /* compact the tab number usage */
587a838,839
>       iupAttribSet(child, "_IUPMOT_TABLABEL", NULL);
>       iupAttribSet(child, "_IUPMOT_TABCLOSE", NULL);
682a935,937
> 
>   /* Register TABCLOSE_CB callback */
>   iupClassRegisterCallback(ic, "TABCLOSE_CB", "i");
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_text.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_text.c
78a79,85
> void iupdrvTextAddExtraPadding(Ihandle* ih, int *w, int *h)
> {
>   (void)ih;
>   (void)w;
>   (void)h;
> }
> 
260a268,272
> 
>   /* Scroll to the end to make the appended text visible */
>   pos = XmTextGetLastPosition(ih->handle);
>   XmTextShowPosition(ih->handle, pos);
> 
734,735c746,759
<   char* str = iupStrReturnStr(value);
<   XtFree(value);
---
>   char* converted = iupmotStrConvertFromSystem(value);
>   char* str;
> 
>   if (converted != value)
>   {
>     str = iupStrReturnStr(converted);
>     XtFree(value);
>   }
>   else
>   {
>     str = iupStrReturnStr(value);
>     XtFree(value);
>   }
> 
1198,1205d1221
<   if (IupGetGlobal("_IUP_RESET_TXTCOLORS"))
<   {
<     iupmotSetGlobalColorAttrib(ih->handle, XmNbackground, "TXTBGCOLOR");
<     iupmotSetGlobalColorAttrib(ih->handle, XmNforeground, "TXTFGCOLOR");
<     iupmotSetGlobalColorAttrib(ih->handle, XmNhighlightColor, "TXTHLCOLOR");
<     IupSetGlobal("_IUP_RESET_TXTCOLORS", NULL);
<   }
< 
1256a1273
>   iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_toggle.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_toggle.c
8a9
> #include <Xm/DrawingA.h>
27a29,30
> #include "iup_drvdraw.h"
> #include "iup_draw.h"
31a35,46
> #define SWITCH_TRACK_WIDTH  40
> #define SWITCH_TRACK_HEIGHT 20
> #define SWITCH_THUMB_SIZE   14
> #define SWITCH_THUMB_MARGIN 3
> 
> typedef struct _IupMotSwitchData
> {
>   Ihandle* ih;
>   int checked_state;
>   Widget drawing_area;
> } IupMotSwitchData;
> 
37a53,66
> void iupdrvToggleAddSwitch(Ihandle* ih, int *x, int *y, const char* str)
> {
>   (void)ih;
> 
>   (*x) += 2 + SWITCH_TRACK_WIDTH + 2;
>   if ((*y) < 2 + SWITCH_TRACK_HEIGHT + 2)
>     (*y) = 2 + SWITCH_TRACK_HEIGHT + 2;
>   else
>     (*y) += 2 + 2;
> 
>   if (str && str[0])
>     (*x) += 8;
> }
> 
40c69
<   int check_box = 15;  /* See XmNindicatorSize */
---
>   int check_box = 15;
43d71
<   /* has margins too */
45,46c73,79
<   if ((*y) < 3 + check_box + 3) (*y) = 3 + check_box + 3; /* minimum height */
<   else (*y) += 3+3;
---
> #ifdef IUP_USE_XFT
>   if ((*y) < 3 + check_box + 9) (*y) = 3 + check_box + 9;
>   else (*y) += 3+9;
> #else
>   if ((*y) < 3 + check_box + 5) (*y) = 3 + check_box + 5;
>   else (*y) += 3+5;
> #endif
48c81
<   if (str && str[0]) /* add spacing between check box and text */
---
>   if (str && str[0])
52d84
< 
53a86,135
> /* SWITCH Control                                                               */
> /*********************************************************************************/
> 
> static void motSwitchDraw(Ihandle* ih, IupMotSwitchData* switch_data, IdrawCanvas* dc)
> {
>   int width, height;
>   long track_color, thumb_color, shadow_dark, shadow_light;
>   int is_checked = switch_data->checked_state;
>   int is_active = iupdrvIsActive(ih);
>   int thumb_x, thumb_y;
>   Pixel bg_pixel, fg_pixel;
>   unsigned char bg_r, bg_g, bg_b, fg_r, fg_g, fg_b;
> 
>   iupdrvDrawGetSize(dc, &width, &height);
> 
>   XtVaGetValues(ih->handle, XmNbackground, &bg_pixel, XmNforeground, &fg_pixel, NULL);
>   iupmotColorGetRGB(bg_pixel, &bg_r, &bg_g, &bg_b);
>   iupmotColorGetRGB(fg_pixel, &fg_r, &fg_g, &fg_b);
> 
>   if (!is_active)
>   {
>     track_color = iupDrawColor(bg_r * 0.85, bg_g * 0.85, bg_b * 0.85, 255);
>     thumb_color = iupDrawColor(bg_r * 0.95, bg_g * 0.95, bg_b * 0.95, 255);
>   }
>   else if (is_checked)
>   {
>     track_color = iupDrawColor(bg_r * 0.75, bg_g * 0.75, bg_b * 0.75, 255);
>     thumb_color = iupDrawColor(bg_r * 1.05, bg_g * 1.05, bg_b * 1.05, 255);
>   }
>   else
>   {
>     track_color = iupDrawColor(bg_r * 0.90, bg_g * 0.90, bg_b * 0.90, 255);
>     thumb_color = iupDrawColor(bg_r * 1.05, bg_g * 1.05, bg_b * 1.05, 255);
>   }
> 
>   iupdrvDrawRectangle(dc, 0, 0, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1, track_color, IUP_DRAW_FILL, 1);
> 
>   shadow_dark = iupDrawColor(fg_r * 0.4, fg_g * 0.4, fg_b * 0.4, 255);
>   shadow_light = iupDrawColor(bg_r * 1.1, bg_g * 1.1, bg_b * 1.1, 255);
> 
>   iupdrvDrawLine(dc, 0, 0, SWITCH_TRACK_WIDTH - 1, 0, shadow_dark, IUP_DRAW_STROKE, 1);
>   iupdrvDrawLine(dc, 0, 0, 0, SWITCH_TRACK_HEIGHT - 1, shadow_dark, IUP_DRAW_STROKE, 1);
> 
>   iupdrvDrawLine(dc, SWITCH_TRACK_WIDTH - 1, 1, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1, shadow_light, IUP_DRAW_STROKE, 1);
>   iupdrvDrawLine(dc, 1, SWITCH_TRACK_HEIGHT - 1, SWITCH_TRACK_WIDTH - 1, SWITCH_TRACK_HEIGHT - 1, shadow_light, IUP_DRAW_STROKE, 1);
> 
>   if (is_checked)
>     thumb_x = SWITCH_TRACK_WIDTH - SWITCH_THUMB_SIZE - SWITCH_THUMB_MARGIN;
>   else
>     thumb_x = SWITCH_THUMB_MARGIN;
54a137,206
>   thumb_y = (SWITCH_TRACK_HEIGHT - SWITCH_THUMB_SIZE) / 2;
> 
>   iupdrvDrawRectangle(dc, thumb_x, thumb_y, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + SWITCH_THUMB_SIZE - 1, thumb_color, IUP_DRAW_FILL, 1);
> 
>   iupdrvDrawLine(dc, thumb_x, thumb_y, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y, shadow_light, IUP_DRAW_STROKE, 1);
>   iupdrvDrawLine(dc, thumb_x, thumb_y, thumb_x, thumb_y + SWITCH_THUMB_SIZE - 1, shadow_light, IUP_DRAW_STROKE, 1);
> 
>   iupdrvDrawLine(dc, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + 1, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + SWITCH_THUMB_SIZE - 1, shadow_dark, IUP_DRAW_STROKE, 1);
>   iupdrvDrawLine(dc, thumb_x + 1, thumb_y + SWITCH_THUMB_SIZE - 1, thumb_x + SWITCH_THUMB_SIZE - 1, thumb_y + SWITCH_THUMB_SIZE - 1, shadow_dark, IUP_DRAW_STROKE, 1);
> }
> 
> static void motSwitchExposeCallback(Widget w, IupMotSwitchData* switch_data, XEvent* evt, Boolean* cont)
> {
>   Ihandle* ih = switch_data->ih;
>   IdrawCanvas* dc;
>   Window win;
> 
>   (void)w;
>   (void)evt;
>   (void)cont;
> 
>   win = XtWindow(switch_data->drawing_area);
>   if (!win)
>     return;
> 
>   if (!iupAttribGet(ih, "DRAWABLE"))
>     iupAttribSet(ih, "DRAWABLE", (char*)win);
> 
>   dc = iupdrvDrawCreateCanvas(ih);
>   if (!dc)
>     return;
> 
>   iupDrawParentBackground(dc, ih);
> 
>   motSwitchDraw(ih, switch_data, dc);
> 
>   iupdrvDrawFlush(dc);
> 
>   iupdrvDrawKillCanvas(dc);
> }
> 
> static void motSwitchButtonPressCallback(Widget w, Ihandle* ih, XButtonPressedEvent* evt, Boolean* cont)
> {
>   IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
>   IFni cb;
>   int new_check;
> 
>   (void)w;
>   (void)evt;
>   (void)cont;
> 
>   if (!switch_data)
>     return;
> 
>   iupmotTipLeaveNotify();
> 
>   new_check = switch_data->checked_state ? 0 : 1;
>   switch_data->checked_state = new_check;
> 
>   XClearArea(iupmot_display, XtWindow(switch_data->drawing_area), 0, 0, 0, 0, True);
> 
>   cb = (IFni)IupGetCallback(ih, "ACTION");
>   if (cb && cb(ih, new_check) == IUP_CLOSE)
>     IupExitLoop();
> 
>   if (iupObjectCheck(ih))
>     iupBaseCallValueChangedCb(ih);
> }
> 
> /*********************************************************************************/
153a306,308
>   if (iupAttribGetBoolean(ih, "SWITCH"))
>     return 0;
> 
228a384,404
>   if (iupAttribGetBoolean(ih, "SWITCH"))
>   {
>     IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
>     int new_check;
> 
>     if (!switch_data)
>       return 0;
> 
>     if (iupStrEqualNoCase(value, "TOGGLE"))
>       new_check = !switch_data->checked_state;
>     else
>       new_check = iupStrBoolean(value);
> 
>     switch_data->checked_state = new_check;
> 
>     if (ih->handle)
>       XClearArea(iupmot_display, XtWindow(switch_data->drawing_area), 0, 0, 0, 0, True);
> 
>     return 0;
>   }
> 
284,289c460,475
<   int check;
<   unsigned char set = 0;
<   XtVaGetValues (ih->handle, XmNset, &set, NULL);
<   check = set;
<   if (check == XmINDETERMINATE) check = -1;
<   return iupStrReturnChecked(check);
---
>   if (iupAttribGetBoolean(ih, "SWITCH"))
>   {
>     IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
>     if (switch_data)
>       return iupStrReturnChecked(switch_data->checked_state);
>     return iupStrReturnChecked(0);
>   }
> 
>   {
>     int check;
>     unsigned char set = 0;
>     XtVaGetValues (ih->handle, XmNset, &set, NULL);
>     check = set;
>     if (check == XmINDETERMINATE) check = -1;
>     return iupStrReturnChecked(check);
>   }
419a606,675
>   if (iupAttribGetBoolean(ih, "SWITCH"))
>   {
>     IupMotSwitchData* switch_data;
> 
>     if (ih->data->is_radio)
>     {
>       iupAttribSet(ih, "SWITCH", "NO");
>       goto regular_toggle;
>     }
> 
>     ih->data->type = IUP_TOGGLE_TEXT;
> 
>     switch_data = (IupMotSwitchData*)calloc(1, sizeof(IupMotSwitchData));
>     switch_data->ih = ih;
>     iupAttribSet(ih, "_IUPMOT_SWITCHDATA", (char*)switch_data);
> 
>     iupMOT_SETARG(args, num_args, XmNmappedWhenManaged, False);
>     iupMOT_SETARG(args, num_args, XmNx, 0);
>     iupMOT_SETARG(args, num_args, XmNy, 0);
>     iupMOT_SETARG(args, num_args, XmNwidth, SWITCH_TRACK_WIDTH);
>     iupMOT_SETARG(args, num_args, XmNheight, SWITCH_TRACK_HEIGHT);
>     iupMOT_SETARG(args, num_args, XmNmarginHeight, 0);
>     iupMOT_SETARG(args, num_args, XmNmarginWidth, 0);
>     iupMOT_SETARG(args, num_args, XmNshadowThickness, 0);
> 
>     if (iupAttribGetBoolean(ih, "CANFOCUS"))
>       iupMOT_SETARG(args, num_args, XmNtraversalOn, True);
>     else
>       iupMOT_SETARG(args, num_args, XmNtraversalOn, False);
> 
>     switch_data->drawing_area = XtCreateManagedWidget(
>       iupDialogGetChildIdStr(ih),
>       xmDrawingAreaWidgetClass,
>       iupChildTreeGetNativeParentHandle(ih),
>       args, num_args);
> 
>     if (!switch_data->drawing_area)
>     {
>       free(switch_data);
>       return IUP_ERROR;
>     }
> 
>     ih->handle = switch_data->drawing_area;
>     ih->serial = iupDialogGetChildId(ih);
> 
>     XtAddCallback(ih->handle, XmNexposeCallback, (XtCallbackProc)motSwitchExposeCallback, (XtPointer)switch_data);
>     XtAddEventHandler(ih->handle, ButtonPressMask, False, (XtEventHandler)motSwitchButtonPressCallback, (XtPointer)ih);
>     XtAddEventHandler(ih->handle, EnterWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
>     XtAddEventHandler(ih->handle, LeaveWindowMask, False, (XtEventHandler)iupmotEnterLeaveWindowEvent, (XtPointer)ih);
>     XtAddEventHandler(ih->handle, FocusChangeMask, False, (XtEventHandler)iupmotFocusChangeEvent, (XtPointer)ih);
>     XtAddEventHandler(ih->handle, KeyPressMask, False, (XtEventHandler)iupmotKeyPressEvent, (XtPointer)ih);
>     XtAddCallback(ih->handle, XmNhelpCallback, (XtCallbackProc)iupmotHelpCallback, (XtPointer)ih);
> 
>     value = iupAttribGet(ih, "VALUE");
>     if (value && iupStrBoolean(value))
>       switch_data->checked_state = 1;
>     else
>       switch_data->checked_state = 0;
> 
>     XtVaSetValues(ih->handle, XmNbackground, iupmotColorGetPixelStr(iupBaseNativeParentGetBgColor(ih)), NULL);
> 
>     XtRealizeWidget(ih->handle);
> 
>     iupAttribSet(ih, "DRAWABLE", (char*)XtWindow(ih->handle));
> 
>     return IUP_NOERROR;
>   }
> 
> regular_toggle:
> 
547a804,818
> static void motToggleUnMapMethod(Ihandle* ih)
> {
>   if (iupAttribGetBoolean(ih, "SWITCH"))
>   {
>     IupMotSwitchData* switch_data = (IupMotSwitchData*)iupAttribGet(ih, "_IUPMOT_SWITCHDATA");
>     if (switch_data)
>     {
>       free(switch_data);
>       iupAttribSet(ih, "_IUPMOT_SWITCHDATA", NULL);
>     }
>   }
> 
>   iupdrvBaseUnMapMethod(ih);
> }
> 
551a823
>   ic->UnMap = motToggleUnMapMethod;
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: iupmot_tray_sni.c
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: iupmot_tray_xembed.c
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupmot_tree.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupmot_tree.c
635a636
>   XmFontList fontlist;
656c657
<   /* Get default colors */
---
>   /* Get default colors and font */
658a660
>   fontlist = (XmFontList)iupmotGetFontListAttrib(ih);
697a700,705
>   if (fontlist)
>   {
>     iupMOT_SETARG(args, num_args, XmNrenderTable, fontlist);
>     iupMOT_SETARG(args, num_args, XmNfontList, fontlist);
>   }
> 
1489c1497
<   XtVaSetValues(wItem, XmNrenderTable, fontlist, NULL);
---
>   XtVaSetValues(wItem, XmNrenderTable, fontlist, XmNfontList, fontlist, NULL);
2081a2090
>   iupMOT_SETARG(args, num_args, XmNfontList, fontlist);
2825a2835,2844
>   /* Set the font for the tree widget */
>   {
>     XmFontList fontlist = (XmFontList)iupmotGetFontListAttrib(ih);
>     if (fontlist)
>     {
>       iupMOT_SETARG(args, num_args, XmNrenderTable, fontlist);
>       iupMOT_SETARG(args, num_args, XmNfontList, fontlist);
>     }
>   }
> 
2844a2864,2872
>   /* Force font to be applied AFTER widget creation */
>   {
>     char* font_value = iupAttribGetStr(ih, "FONT");
>     if (!font_value)
>       font_value = IupGetGlobal("DEFAULTFONT");
>     if (font_value)
>       iupdrvSetFontAttrib(ih, font_value);
>   }
> 
2996a3025
>   iupClassRegisterAttribute(ic, "SCROLLVISIBLE", NULL, NULL, NULL, NULL, IUPAF_NOT_SUPPORTED|IUPAF_NO_INHERIT);
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: iupunix_dbus_dlopen.h
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupunix_help.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupunix_help.c
65c65
<       browser = "firefox";
---
>       browser = "xdg-open";
67c67
<       browser = "safari";
---
>       browser = "open";
diff /home/kenjiro/Nextcloud/tecgraf/repos/iup/src/mot/iupunix_info.c /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/iupunix_info.c
84,101d83
< IUP_SDK_API int iupdrvGetPreferencePath(char *filename, int use_system)
< {
<   char* home = getenv("HOME");
<   if (home)
<   {
<     (void)use_system; /* unused */
<     /* UNIX format */
<     strcpy(filename, home);
<     strcat(filename, "/");
<     return 1;
<   }
<   else
<   {
<     filename[0] = '\0';
<     return 0;
<   }
< }
< 
104d85
< 
125c106
< int iupUnixMakeDirectory(const char* name) 
---
> int iupUnixMakeDirectory(const char* name)
128,129c109
<   int fail =  mkdir(name, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP |
<                           S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH);
---
>   int fail =  mkdir(name, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH);
135a116,126
> static int iupUnixMakeDirectoryIfNeeded(const char* path)
> {
>   struct stat st;
>   if (stat(path, &st) == 0)
>   {
>     if (S_ISDIR(st.st_mode))
>       return 1;
>     return 0;
>   }
>   return iupUnixMakeDirectory(path);
> }
137c128,130
< /**************************************************************************/
---
> IUP_SDK_API int iupdrvGetPreferencePath(char *filename, const char *app_name, int use_system)
> {
>   char* home;
138a132,186
>   if (!app_name || !app_name[0])
>   {
>     filename[0] = '\0';
>     return 0;
>   }
> 
>   if (use_system)
>   {
>     /* XDG Base Directory Specification: ~/.config/appname/config */
>     char* xdg_config = getenv("XDG_CONFIG_HOME");
>     if (xdg_config && xdg_config[0])
>     {
>       strcpy(filename, xdg_config);
>     }
>     else
>     {
>       home = getenv("HOME");
>       if (!home)
>       {
>         filename[0] = '\0';
>         return 0;
>       }
>       strcpy(filename, home);
>       strcat(filename, "/.config");
>     }
> 
>     /* Ensure base config directory exists */
>     iupUnixMakeDirectoryIfNeeded(filename);
> 
>     /* Add app directory */
>     strcat(filename, "/");
>     strcat(filename, app_name);
>     iupUnixMakeDirectoryIfNeeded(filename);
> 
>     /* Add config filename */
>     strcat(filename, "/config");
>     return 1;
>   }
>   else
>   {
>     /* Legacy format: ~/.appname */
>     home = getenv("HOME");
>     if (!home)
>     {
>       filename[0] = '\0';
>       return 0;
>     }
>     strcpy(filename, home);
>     strcat(filename, "/.");
>     strcat(filename, app_name);
>     return 1;
>   }
> }
> 
> /**************************************************************************/
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: iupunix_notify.c
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: iupunix_sni.c
Only in /home/kenjiro/Documents/github/gen2brain/iup-go/iup/external/src/mot/: vendor.go
